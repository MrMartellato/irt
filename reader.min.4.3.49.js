/*!
 * HTML reader 4.3.49
 */
/*
 RequireJS 2.1.9 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
var requirejs,require,define;
(function(Z){function H(b){return"[object Function]"===L.call(b)}function I(b){return"[object Array]"===L.call(b)}function y(b,c){if(b){var e;for(e=0;e<b.length&&(!b[e]||!c(b[e],e,b));e+=1);}}function M(b,c){if(b){var e;for(e=b.length-1;-1<e&&(!b[e]||!c(b[e],e,b));e-=1);}}function t(b,c){return ga.call(b,c)}function l(b,c){return t(b,c)&&b[c]}function F(b,c){for(var e in b)if(t(b,e)&&c(b[e],e))break}function Q(b,c,e,h){c&&F(c,function(c,j){if(e||!t(b,j))h&&"string"!==typeof c?(b[j]||(b[j]={}),Q(b[j],
c,e,h)):b[j]=c});return b}function u(b,c){return function(){return c.apply(b,arguments)}}function aa(b){throw b;}function ba(b){if(!b)return b;var c=Z;y(b.split("."),function(b){c=c[b]});return c}function A(b,c,e,h){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=h;e&&(c.originalError=e);return c}function ha(b){function c(a,f,b){var d,m,c,g,e,h,j,i=f&&f.split("/");d=i;var n=k.map,p=n&&n["*"];if(a&&"."===a.charAt(0))if(f){d=l(k.pkgs,f)?i=[f]:i.slice(0,i.length-
1);f=a=d.concat(a.split("/"));for(d=0;f[d];d+=1)if(m=f[d],"."===m)f.splice(d,1),d-=1;else if(".."===m)if(1===d&&(".."===f[2]||".."===f[0]))break;else 0<d&&(f.splice(d-1,2),d-=2);d=l(k.pkgs,f=a[0]);a=a.join("/");d&&a===f+"/"+d.main&&(a=f)}else 0===a.indexOf("./")&&(a=a.substring(2));if(b&&n&&(i||p)){f=a.split("/");for(d=f.length;0<d;d-=1){c=f.slice(0,d).join("/");if(i)for(m=i.length;0<m;m-=1)if(b=l(n,i.slice(0,m).join("/")))if(b=l(b,c)){g=b;e=d;break}if(g)break;!h&&(p&&l(p,c))&&(h=l(p,c),j=d)}!g&&
h&&(g=h,e=j);g&&(f.splice(0,e,g),a=f.join("/"))}return a}function e(a){z&&y(document.getElementsByTagName("script"),function(f){if(f.getAttribute("data-requiremodule")===a&&f.getAttribute("data-requirecontext")===i.contextName)return f.parentNode.removeChild(f),!0})}function h(a){var f=l(k.paths,a);if(f&&I(f)&&1<f.length)return f.shift(),i.require.undef(a),i.require([a]),!0}function $(a){var f,b=a?a.indexOf("!"):-1;-1<b&&(f=a.substring(0,b),a=a.substring(b+1,a.length));return[f,a]}function n(a,f,
b,d){var m,B,g=null,e=f?f.name:null,h=a,j=!0,k="";a||(j=!1,a="_@r"+(L+=1));a=$(a);g=a[0];a=a[1];g&&(g=c(g,e,d),B=l(r,g));a&&(g?k=B&&B.normalize?B.normalize(a,function(a){return c(a,e,d)}):c(a,e,d):(k=c(a,e,d),a=$(k),g=a[0],k=a[1],b=!0,m=i.nameToUrl(k)));b=g&&!B&&!b?"_unnormalized"+(M+=1):"";return{prefix:g,name:k,parentMap:f,unnormalized:!!b,url:m,originalName:h,isDefine:j,id:(g?g+"!"+k:k)+b}}function q(a){var f=a.id,b=l(p,f);b||(b=p[f]=new i.Module(a));return b}function s(a,f,b){var d=a.id,m=l(p,
d);if(t(r,d)&&(!m||m.defineEmitComplete))"defined"===f&&b(r[d]);else if(m=q(a),m.error&&"error"===f)b(m.error);else m.on(f,b)}function v(a,f){var b=a.requireModules,d=!1;if(f)f(a);else if(y(b,function(f){if(f=l(p,f))f.error=a,f.events.error&&(d=!0,f.emit("error",a))}),!d)j.onError(a)}function w(){R.length&&(ia.apply(G,[G.length-1,0].concat(R)),R=[])}function x(a){delete p[a];delete T[a]}function E(a,f,b){var d=a.map.id;a.error?a.emit("error",a.error):(f[d]=!0,y(a.depMaps,function(d,c){var g=d.id,
e=l(p,g);e&&(!a.depMatched[c]&&!b[g])&&(l(f,g)?(a.defineDep(c,r[g]),a.check()):E(e,f,b))}),b[d]=!0)}function C(){var a,f,b,d,m=(b=1E3*k.waitSeconds)&&i.startTime+b<(new Date).getTime(),c=[],g=[],j=!1,l=!0;if(!U){U=!0;F(T,function(b){a=b.map;f=a.id;if(b.enabled&&(a.isDefine||g.push(b),!b.error))if(!b.inited&&m)h(f)?j=d=!0:(c.push(f),e(f));else if(!b.inited&&(b.fetched&&a.isDefine)&&(j=!0,!a.prefix))return l=!1});if(m&&c.length)return b=A("timeout","Load timeout for modules: "+c,null,c),b.contextName=
i.contextName,v(b);l&&y(g,function(a){E(a,{},{})});if((!m||d)&&j)if((z||da)&&!V)V=setTimeout(function(){V=0;C()},50);U=!1}}function D(a){t(r,a[0])||q(n(a[0],null,!0)).init(a[1],a[2])}function J(a){var a=a.currentTarget||a.srcElement,b=i.onScriptLoad;a.detachEvent&&!W?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=i.onScriptError;(!a.detachEvent||W)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function K(){var a;for(w();G.length;){a=
G.shift();if(null===a[0])return v(A("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));D(a)}}var U,X,i,N,V,k={waitSeconds:7,baseUrl:"./",paths:{},pkgs:{},shim:{},config:{}},p={},T={},Y={},G=[],r={},S={},L=1,M=1;N={require:function(a){return a.require?a.require:a.require=i.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?a.exports:a.exports=r[a.map.id]={}},module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){var b=
l(k.pkgs,a.map.id);return(b?l(k.config,a.map.id+"/"+b.main):l(k.config,a.map.id))||{}},exports:r[a.map.id]}}};X=function(a){this.events=l(Y,a.id)||{};this.map=a;this.shim=l(k.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};X.prototype={init:function(a,b,c,d){d=d||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=u(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=c;this.inited=!0;
this.ignore=d.ignore;d.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;i.startTime=(new Date).getTime();var a=this.map;if(this.shim)i.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],u(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=
this.map.url;S[a]||(S[a]=!0,i.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var d=this.exports,m=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(H(m)){if(this.events.error&&this.map.isDefine||j.onError!==aa)try{d=i.execCb(c,m,b,d)}catch(e){a=e}else d=i.execCb(c,m,b,d);this.map.isDefine&&((b=this.module)&&void 0!==b.exports&&b.exports!==
this.exports?d=b.exports:void 0===d&&this.usingExports&&(d=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",v(this.error=a)}else d=m;this.exports=d;if(this.map.isDefine&&!this.ignore&&(r[c]=d,j.onResourceLoad))j.onResourceLoad(i,this.map,this.depMaps);x(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=
!0)}}else this.fetch()}},callPlugin:function(){var a=this.map,b=a.id,e=n(a.prefix);this.depMaps.push(e);s(e,"defined",u(this,function(d){var m,e;e=this.map.name;var g=this.map.parentMap?this.map.parentMap.name:null,h=i.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(d.normalize&&(e=d.normalize(e,function(a){return c(a,g,!0)})||""),d=n(a.prefix+"!"+e,this.map.parentMap),s(d,"defined",u(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),
e=l(p,d.id)){this.depMaps.push(d);if(this.events.error)e.on("error",u(this,function(a){this.emit("error",a)}));e.enable()}}else m=u(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),m.error=u(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];F(p,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&x(a.map.id)});v(a)}),m.fromText=u(this,function(d,c){var e=a.name,g=n(e),B=O;c&&(d=c);B&&(O=!1);q(g);t(k.config,b)&&(k.config[e]=k.config[b]);try{j.exec(d)}catch(ca){return v(A("fromtexteval",
"fromText eval for "+b+" failed: "+ca,ca,[b]))}B&&(O=!0);this.depMaps.push(g);i.completeLoad(e);h([e],m)}),d.load(a.name,h,m,k)}));i.enable(e,this);this.pluginMaps[e.id]=e},enable:function(){T[this.map.id]=this;this.enabling=this.enabled=!0;y(this.depMaps,u(this,function(a,b){var c,d;if("string"===typeof a){a=n(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=l(N,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;s(a,"defined",u(this,function(a){this.defineDep(b,
a);this.check()}));this.errback&&s(a,"error",u(this,this.errback))}c=a.id;d=p[c];!t(N,c)&&(d&&!d.enabled)&&i.enable(a,this)}));F(this.pluginMaps,u(this,function(a){var b=l(p,a.id);b&&!b.enabled&&i.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){y(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};i={config:k,contextName:b,registry:p,defined:r,urlFetched:S,defQueue:G,Module:X,makeModuleMap:n,
nextTick:j.nextTick,onError:v,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=k.pkgs,c=k.shim,d={paths:!0,config:!0,map:!0};F(a,function(a,b){d[b]?"map"===b?(k.map||(k.map={}),Q(k[b],a,!0,!0)):Q(k[b],a,!0):k[b]=a});a.shim&&(F(a.shim,function(a,b){I(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=i.makeShimExports(a);c[b]=a}),k.shim=c);a.packages&&(y(a.packages,function(a){a="string"===typeof a?{name:a}:a;b[a.name]={name:a.name,
location:a.location||a.name,main:(a.main||"main").replace(ja,"").replace(ea,"")}}),k.pkgs=b);F(p,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=n(b))});if(a.deps||a.callback)i.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(Z,arguments));return b||a.exports&&ba(a.exports)}},makeRequire:function(a,f){function h(d,c,e){var g,k;f.enableBuildCallback&&(c&&H(c))&&(c.__requireJsBuild=!0);if("string"===typeof d){if(H(c))return v(A("requireargs",
"Invalid require call"),e);if(a&&t(N,d))return N[d](p[a.id]);if(j.get)return j.get(i,d,a,h);g=n(d,a,!1,!0);g=g.id;return!t(r,g)?v(A("notloaded",'Module name "'+g+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):r[g]}K();i.nextTick(function(){K();k=q(n(null,a));k.skipMap=f.skipMap;k.init(d,c,e,{enabled:!0});C()});return h}f=f||{};Q(h,{isBrowser:z,toUrl:function(b){var f,e=b.lastIndexOf("."),g=b.split("/")[0];if(-1!==e&&(!("."===g||".."===g)||1<e))f=b.substring(e,b.length),b=
b.substring(0,e);return i.nameToUrl(c(b,a&&a.id,!0),f,!0)},defined:function(b){return t(r,n(b,a,!1,!0).id)},specified:function(b){b=n(b,a,!1,!0).id;return t(r,b)||t(p,b)}});a||(h.undef=function(b){w();var c=n(b,a,!0),f=l(p,b);e(b);delete r[b];delete S[c.url];delete Y[b];f&&(f.events.defined&&(Y[b]=f.events),x(b))});return h},enable:function(a){l(p,a.id)&&q(a).enable()},completeLoad:function(a){var b,c,d=l(k.shim,a)||{},e=d.exports;for(w();G.length;){c=G.shift();if(null===c[0]){c[0]=a;if(b)break;b=
!0}else c[0]===a&&(b=!0);D(c)}c=l(p,a);if(!b&&!t(r,a)&&c&&!c.inited){if(k.enforceDefine&&(!e||!ba(e)))return h(a)?void 0:v(A("nodefine","No define call for "+a,null,[a]));D([a,d.deps||[],d.exportsFn])}C()},nameToUrl:function(a,b,c){var d,e,h,g,i,n;if(j.jsExtRegExp.test(a))g=a+(b||"");else{d=k.paths;e=k.pkgs;g=a.split("/");for(i=g.length;0<i;i-=1)if(n=g.slice(0,i).join("/"),h=l(e,n),n=l(d,n)){I(n)&&(n=n[0]);g.splice(0,i,n);break}else if(h){a=a===h.name?h.location+"/"+h.main:h.location;g.splice(0,i,
a);break}g=g.join("/");g+=b||(/^data\:|\?/.test(g)||c?"":".js");g=("/"===g.charAt(0)||g.match(/^[\w\+\.\-]+:/)?"":k.baseUrl)+g}return k.urlArgs?g+((-1===g.indexOf("?")?"?":"&")+k.urlArgs):g},load:function(a,b){j.load(i,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||ka.test((a.currentTarget||a.srcElement).readyState))P=null,a=J(a),i.completeLoad(a.id)},onScriptError:function(a){var b=J(a);if(!h(b.id))return v(A("scripterror","Script error for: "+b.id,
a,[b.id]))}};i.require=i.makeRequire();return i}var j,w,x,C,J,D,P,K,q,fa,la=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,ma=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,ea=/\.js$/,ja=/^\.\//;w=Object.prototype;var L=w.toString,ga=w.hasOwnProperty,ia=Array.prototype.splice,z=!!("undefined"!==typeof window&&"undefined"!==typeof navigator&&window.document),da=!z&&"undefined"!==typeof importScripts,ka=z&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,W="undefined"!==typeof opera&&
"[object Opera]"===opera.toString(),E={},s={},R=[],O=!1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(H(requirejs))return;s=requirejs;requirejs=void 0}"undefined"!==typeof require&&!H(require)&&(s=require,require=void 0);j=requirejs=function(b,c,e,h){var q,n="_";!I(b)&&"string"!==typeof b&&(q=b,I(c)?(b=c,c=e,e=h):b=[]);q&&q.context&&(n=q.context);(h=l(E,n))||(h=E[n]=j.s.newContext(n));q&&h.configure(q);return h.require(b,c,e)};j.config=function(b){return j(b)};j.nextTick="undefined"!==
typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=j);j.version="2.1.9";j.jsExtRegExp=/^\/|:|\?|\.js$/;j.isBrowser=z;w=j.s={contexts:E,newContext:ha};j({});y(["toUrl","undef","defined","specified"],function(b){j[b]=function(){var c=E._;return c.require[b].apply(c,arguments)}});if(z&&(x=w.head=document.getElementsByTagName("head")[0],C=document.getElementsByTagName("base")[0]))x=w.head=C.parentNode;j.onError=aa;j.createNode=function(b){var c=b.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml",
"html:script"):document.createElement("script");c.type=b.scriptType||"text/javascript";c.charset="utf-8";c.async=!0;return c};j.load=function(b,c,e){var h=b&&b.config||{};if(z)return h=j.createNode(h,c,e),h.setAttribute("data-requirecontext",b.contextName),h.setAttribute("data-requiremodule",c),h.attachEvent&&!(h.attachEvent.toString&&0>h.attachEvent.toString().indexOf("[native code"))&&!W?(O=!0,h.attachEvent("onreadystatechange",b.onScriptLoad)):(h.addEventListener("load",b.onScriptLoad,!1),h.addEventListener("error",
b.onScriptError,!1)),h.src=e,K=h,C?x.insertBefore(h,C):x.appendChild(h),K=null,h;if(da)try{importScripts(e),b.completeLoad(c)}catch(l){b.onError(A("importscripts","importScripts failed for "+c+" at "+e,l,[c]))}};z&&!s.skipDataMain&&M(document.getElementsByTagName("script"),function(b){x||(x=b.parentNode);if(J=b.getAttribute("data-main"))return q=J,s.baseUrl||(D=q.split("/"),q=D.pop(),fa=D.length?D.join("/")+"/":"./",s.baseUrl=fa),q=q.replace(ea,""),j.jsExtRegExp.test(q)&&(q=J),s.deps=s.deps?s.deps.concat(q):
[q],!0});define=function(b,c,e){var h,j;"string"!==typeof b&&(e=c,c=b,b=null);I(c)||(e=c,c=null);!c&&H(e)&&(c=[],e.length&&(e.toString().replace(la,"").replace(ma,function(b,e){c.push(e)}),c=(1===e.length?["require"]:["require","exports","module"]).concat(c)));if(O){if(!(h=K))P&&"interactive"===P.readyState||M(document.getElementsByTagName("script"),function(b){if("interactive"===b.readyState)return P=b}),h=P;h&&(b||(b=h.getAttribute("data-requiremodule")),j=E[h.getAttribute("data-requirecontext")])}(j?
j.defQueue:R).push([b,c,e])};define.amd={jQuery:!0};j.exec=function(b){return eval(b)};j(s)}})(this);

define("../lib/require.js", function(){});

/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
// See http://stackoverflow.com/questions/15901731/how-use-require-js-to-load-jquery-with-noconflict and http://requirejs.org/docs/jquery.html
define('jquery-private',['jquery'], function ($) {
    return $.noConflict();
});
/*!
 * @license EaselJS
 * Visit http://createjs.com/ for documentation, updates and examples.
 *
 * Copyright (c) 2011-2013 gskinner.com, inc.
 *
 * Distributed under the terms of the MIT license.
 * http://www.opensource.org/licenses/mit-license.html
 *
 * This notice shall be included in all copies or substantial portions of the Software.
 */
this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype;b.type=null,b.target=null,b.currentTarget=null,b.eventPhase=0,b.bubbles=!1,b.cancelable=!1,b.timeStamp=0,b.defaultPrevented=!1,b.propagationStopped=!1,b.immediatePropagationStopped=!1,b.removed=!1,b.initialize=function(a,b,c){this.type=a,this.bubbles=b,this.cancelable=c,this.timeStamp=(new Date).getTime()},b.preventDefault=function(){this.defaultPrevented=!0},b.stopPropagation=function(){this.propagationStopped=!0},b.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},b.remove=function(){this.removed=!0},b.clone=function(){return new a(this.type,this.bubbles,this.cancelable)},b.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){},b=a.prototype;a.initialize=function(a){a.addEventListener=b.addEventListener,a.on=b.on,a.removeEventListener=a.off=b.removeEventListener,a.removeAllEventListeners=b.removeAllEventListeners,a.hasEventListener=b.hasEventListener,a.dispatchEvent=b.dispatchEvent,a._dispatchEvent=b._dispatchEvent,a.willTrigger=b.willTrigger},b._listeners=null,b._captureListeners=null,b.initialize=function(){},b.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},b.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},b.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},b.off=b.removeEventListener,b.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},b.dispatchEvent=function(a,b){if("string"==typeof a){var c=this._listeners;if(!c||!c[a])return!1;a=new createjs.Event(a)}if(a.target=b||this,a.bubbles&&this.parent){for(var d=this,e=[d];d.parent;)e.push(d=d.parent);var f,g=e.length;for(f=g-1;f>=0&&!a.propagationStopped;f--)e[f]._dispatchEvent(a,1+(0==f));for(f=1;g>f&&!a.propagationStopped;f++)e[f]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return a.defaultPrevented},b.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},b.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},b.toString=function(){return"[EventDispatcher]"},b._dispatchEvent=function(a,b){var c,d=1==b?this._captureListeners:this._listeners;if(a&&d){var e=d[a.type];if(!e||!(c=e.length))return;a.currentTarget=this,a.eventPhase=b,a.removed=!1,e=e.slice();for(var f=0;c>f&&!a.immediatePropagationStopped;f++){var g=e[f];g.handleEvent?g.handleEvent(a):g(a),a.removed&&(this.off(a.type,g,1==b),a.removed=!1)}}},createjs.EventDispatcher=a}(),this.createjs=this.createjs||{},function(){"use strict";createjs.indexOf=function(a,b){for(var c=0,d=a.length;d>c;c++)if(b===a[c])return c;return-1}}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"UID cannot be instantiated"};a._nextID=0,a.get=function(){return a._nextID++},createjs.UID=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"Ticker cannot be instantiated."};a.RAF_SYNCHED="synched",a.RAF="raf",a.TIMEOUT="timeout",a.useRAF=!1,a.timingMode=null,a.maxDelta=0,a.removeEventListener=null,a.removeAllEventListeners=null,a.dispatchEvent=null,a.hasEventListener=null,a._listeners=null,createjs.EventDispatcher.initialize(a),a._addEventListener=a.addEventListener,a.addEventListener=function(){return!a._inited&&a.init(),a._addEventListener.apply(a,arguments)},a._paused=!1,a._inited=!1,a._startTime=0,a._pausedTime=0,a._ticks=0,a._pausedTicks=0,a._interval=50,a._lastTime=0,a._times=null,a._tickTimes=null,a._timerId=null,a._raf=!0,a.init=function(){a._inited||(a._inited=!0,a._times=[],a._tickTimes=[],a._startTime=a._getTime(),a._times.push(a._lastTime=0),a.setInterval(a._interval))},a.reset=function(){if(a._raf){var b=window.cancelAnimationFrame||window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||window.oCancelAnimationFrame||window.msCancelAnimationFrame;b&&b(a._timerId)}else clearTimeout(a._timerId);a.removeAllEventListeners("tick")},a.setInterval=function(b){a._interval=b,a._inited&&a._setupTick()},a.getInterval=function(){return a._interval},a.setFPS=function(b){a.setInterval(1e3/b)},a.getFPS=function(){return 1e3/a._interval},a.getMeasuredTickTime=function(b){var c=0,d=a._tickTimes;if(d.length<1)return-1;b=Math.min(d.length,b||0|a.getFPS());for(var e=0;b>e;e++)c+=d[e];return c/b},a.getMeasuredFPS=function(b){var c=a._times;return c.length<2?-1:(b=Math.min(c.length-1,b||0|a.getFPS()),1e3/((c[0]-c[b])/b))},a.setPaused=function(b){a._paused=b},a.getPaused=function(){return a._paused},a.getTime=function(b){return a._getTime()-a._startTime-(b?a._pausedTime:0)},a.getEventTime=function(b){return(a._lastTime||a._startTime)-(b?a._pausedTime:0)},a.getTicks=function(b){return a._ticks-(b?a._pausedTicks:0)},a._handleSynch=function(){var b=a._getTime()-a._startTime;a._timerId=null,a._setupTick(),b-a._lastTime>=.97*(a._interval-1)&&a._tick()},a._handleRAF=function(){a._timerId=null,a._setupTick(),a._tick()},a._handleTimeout=function(){a._timerId=null,a._setupTick(),a._tick()},a._setupTick=function(){if(null==a._timerId){var b=a.timingMode||a.useRAF&&a.RAF_SYNCHED;if(b==a.RAF_SYNCHED||b==a.RAF){var c=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame;if(c)return a._timerId=c(b==a.RAF?a._handleRAF:a._handleSynch),a._raf=!0,void 0}a._raf=!1,a._timerId=setTimeout(a._handleTimeout,a._interval)}},a._tick=function(){var b=a._getTime()-a._startTime,c=b-a._lastTime,d=a._paused;if(a._ticks++,d&&(a._pausedTicks++,a._pausedTime+=c),a._lastTime=b,a.hasEventListener("tick")){var e=new createjs.Event("tick"),f=a.maxDelta;e.delta=f&&c>f?f:c,e.paused=d,e.time=b,e.runTime=b-a._pausedTime,a.dispatchEvent(e)}for(a._tickTimes.unshift(a._getTime()-b);a._tickTimes.length>100;)a._tickTimes.pop();for(a._times.unshift(b);a._times.length>100;)a._times.pop()};var b=window.performance&&(performance.now||performance.mozNow||performance.msNow||performance.oNow||performance.webkitNow);a._getTime=function(){return b&&b.call(performance)||(new Date).getTime()},createjs.Ticker=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d,e,f,g,h,i,j){this.initialize(a,b,c,d,e,f,g,h,i,j)},b=a.prototype=new createjs.Event;b.stageX=0,b.stageY=0,b.rawX=0,b.rawY=0,b.nativeEvent=null,b.pointerID=0,b.primary=!1,b.addEventListener=null,b.removeEventListener=null,b.removeAllEventListeners=null,b.dispatchEvent=null,b.hasEventListener=null,b._listeners=null,createjs.EventDispatcher.initialize(b),b._get_localX=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).x},b._get_localY=function(){return this.currentTarget.globalToLocal(this.rawX,this.rawY).y};try{Object.defineProperties(b,{localX:{get:b._get_localX},localY:{get:b._get_localY}})}catch(c){}b.Event_initialize=b.initialize,b.initialize=function(a,b,c,d,e,f,g,h,i,j){this.Event_initialize(a,b,c),this.stageX=d,this.stageY=e,this.nativeEvent=f,this.pointerID=g,this.primary=h,this.rawX=null==i?d:i,this.rawY=null==j?e:j},b.clone=function(){return new a(this.type,this.bubbles,this.cancelable,this.stageX,this.stageY,this.target,this.nativeEvent,this.pointerID,this.primary,this.rawX,this.rawY)},b.toString=function(){return"[MouseEvent (type="+this.type+" stageX="+this.stageX+" stageY="+this.stageY+")]"},createjs.MouseEvent=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d,e,f){this.initialize(a,b,c,d,e,f)},b=a.prototype;a.identity=null,a.DEG_TO_RAD=Math.PI/180,b.a=1,b.b=0,b.c=0,b.d=1,b.tx=0,b.ty=0,b.alpha=1,b.shadow=null,b.compositeOperation=null,b.initialize=function(a,b,c,d,e,f){return this.a=null==a?1:a,this.b=b||0,this.c=c||0,this.d=null==d?1:d,this.tx=e||0,this.ty=f||0,this},b.prepend=function(a,b,c,d,e,f){var g=this.tx;if(1!=a||0!=b||0!=c||1!=d){var h=this.a,i=this.c;this.a=h*a+this.b*c,this.b=h*b+this.b*d,this.c=i*a+this.d*c,this.d=i*b+this.d*d}return this.tx=g*a+this.ty*c+e,this.ty=g*b+this.ty*d+f,this},b.append=function(a,b,c,d,e,f){var g=this.a,h=this.b,i=this.c,j=this.d;return this.a=a*g+b*i,this.b=a*h+b*j,this.c=c*g+d*i,this.d=c*h+d*j,this.tx=e*g+f*i+this.tx,this.ty=e*h+f*j+this.ty,this},b.prependMatrix=function(a){return this.prepend(a.a,a.b,a.c,a.d,a.tx,a.ty),this.prependProperties(a.alpha,a.shadow,a.compositeOperation),this},b.appendMatrix=function(a){return this.append(a.a,a.b,a.c,a.d,a.tx,a.ty),this.appendProperties(a.alpha,a.shadow,a.compositeOperation),this},b.prependTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return(i||j)&&(this.tx-=i,this.ty-=j),g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.prepend(l*d,m*d,-m*e,l*e,0,0),this.prepend(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c)):this.prepend(l*d,m*d,-m*e,l*e,b,c),this},b.appendTransform=function(b,c,d,e,f,g,h,i,j){if(f%360)var k=f*a.DEG_TO_RAD,l=Math.cos(k),m=Math.sin(k);else l=1,m=0;return g||h?(g*=a.DEG_TO_RAD,h*=a.DEG_TO_RAD,this.append(Math.cos(h),Math.sin(h),-Math.sin(g),Math.cos(g),b,c),this.append(l*d,m*d,-m*e,l*e,0,0)):this.append(l*d,m*d,-m*e,l*e,b,c),(i||j)&&(this.tx-=i*this.a+j*this.c,this.ty-=i*this.b+j*this.d),this},b.rotate=function(a){var b=Math.cos(a),c=Math.sin(a),d=this.a,e=this.c,f=this.tx;return this.a=d*b-this.b*c,this.b=d*c+this.b*b,this.c=e*b-this.d*c,this.d=e*c+this.d*b,this.tx=f*b-this.ty*c,this.ty=f*c+this.ty*b,this},b.skew=function(b,c){return b*=a.DEG_TO_RAD,c*=a.DEG_TO_RAD,this.append(Math.cos(c),Math.sin(c),-Math.sin(b),Math.cos(b),0,0),this},b.scale=function(a,b){return this.a*=a,this.d*=b,this.c*=a,this.b*=b,this.tx*=a,this.ty*=b,this},b.translate=function(a,b){return this.tx+=a,this.ty+=b,this},b.identity=function(){return this.alpha=this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this.shadow=this.compositeOperation=null,this},b.invert=function(){var a=this.a,b=this.b,c=this.c,d=this.d,e=this.tx,f=a*d-b*c;return this.a=d/f,this.b=-b/f,this.c=-c/f,this.d=a/f,this.tx=(c*this.ty-d*e)/f,this.ty=-(a*this.ty-b*e)/f,this},b.isIdentity=function(){return 0==this.tx&&0==this.ty&&1==this.a&&0==this.b&&0==this.c&&1==this.d},b.transformPoint=function(a,b,c){return c=c||{},c.x=a*this.a+b*this.c+this.tx,c.y=a*this.b+b*this.d+this.ty,c},b.decompose=function(b){null==b&&(b={}),b.x=this.tx,b.y=this.ty,b.scaleX=Math.sqrt(this.a*this.a+this.b*this.b),b.scaleY=Math.sqrt(this.c*this.c+this.d*this.d);var c=Math.atan2(-this.c,this.d),d=Math.atan2(this.b,this.a);return c==d?(b.rotation=d/a.DEG_TO_RAD,this.a<0&&this.d>=0&&(b.rotation+=b.rotation<=0?180:-180),b.skewX=b.skewY=0):(b.skewX=c/a.DEG_TO_RAD,b.skewY=d/a.DEG_TO_RAD),b},b.reinitialize=function(a,b,c,d,e,f,g,h,i){return this.initialize(a,b,c,d,e,f),this.alpha=null==g?1:g,this.shadow=h,this.compositeOperation=i,this},b.copy=function(a){return this.reinitialize(a.a,a.b,a.c,a.d,a.tx,a.ty,a.alpha,a.shadow,a.compositeOperation)},b.appendProperties=function(a,b,c){return this.alpha*=a,this.shadow=b||this.shadow,this.compositeOperation=c||this.compositeOperation,this},b.prependProperties=function(a,b,c){return this.alpha*=a,this.shadow=this.shadow||b,this.compositeOperation=this.compositeOperation||c,this},b.clone=function(){return(new a).copy(this)},b.toString=function(){return"[Matrix2D (a="+this.a+" b="+this.b+" c="+this.c+" d="+this.d+" tx="+this.tx+" ty="+this.ty+")]"},a.identity=new a,createjs.Matrix2D=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b){this.initialize(a,b)},b=a.prototype;b.x=0,b.y=0,b.initialize=function(a,b){return this.x=null==a?0:a,this.y=null==b?0:b,this},b.copy=function(a){return this.initialize(a.x,a.y)},b.clone=function(){return new a(this.x,this.y)},b.toString=function(){return"[Point (x="+this.x+" y="+this.y+")]"},createjs.Point=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d){this.initialize(a,b,c,d)},b=a.prototype;b.x=0,b.y=0,b.width=0,b.height=0,b.initialize=function(a,b,c,d){return this.x=a||0,this.y=b||0,this.width=c||0,this.height=d||0,this},b.copy=function(a){return this.initialize(a.x,a.y,a.width,a.height)},b.clone=function(){return new a(this.x,this.y,this.width,this.height)},b.toString=function(){return"[Rectangle (x="+this.x+" y="+this.y+" width="+this.width+" height="+this.height+")]"},createjs.Rectangle=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d,e,f,g){this.initialize(a,b,c,d,e,f,g)},b=a.prototype;b.target=null,b.overLabel=null,b.outLabel=null,b.downLabel=null,b.play=!1,b._isPressed=!1,b._isOver=!1,b.initialize=function(a,b,c,d,e,f,g){a.addEventListener&&(this.target=a,a.cursor="pointer",this.overLabel=null==c?"over":c,this.outLabel=null==b?"out":b,this.downLabel=null==d?"down":d,this.play=e,this.setEnabled(!0),this.handleEvent({}),f&&(g&&(f.actionsEnabled=!1,f.gotoAndStop&&f.gotoAndStop(g)),a.hitArea=f))},b.setEnabled=function(a){var b=this.target;a?(b.addEventListener("rollover",this),b.addEventListener("rollout",this),b.addEventListener("mousedown",this),b.addEventListener("pressup",this)):(b.removeEventListener("rollover",this),b.removeEventListener("rollout",this),b.removeEventListener("mousedown",this),b.removeEventListener("pressup",this))},b.toString=function(){return"[ButtonHelper]"},b.handleEvent=function(a){var b,c=this.target,d=a.type;"mousedown"==d?(this._isPressed=!0,b=this.downLabel):"pressup"==d?(this._isPressed=!1,b=this._isOver?this.overLabel:this.outLabel):"rollover"==d?(this._isOver=!0,b=this._isPressed?this.downLabel:this.overLabel):(this._isOver=!1,b=this._isPressed?this.overLabel:this.outLabel),this.play?c.gotoAndPlay&&c.gotoAndPlay(b):c.gotoAndStop&&c.gotoAndStop(b)},createjs.ButtonHelper=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d){this.initialize(a,b,c,d)},b=a.prototype;a.identity=null,b.color=null,b.offsetX=0,b.offsetY=0,b.blur=0,b.initialize=function(a,b,c,d){this.color=a,this.offsetX=b,this.offsetY=c,this.blur=d},b.toString=function(){return"[Shadow]"},b.clone=function(){return new a(this.color,this.offsetX,this.offsetY,this.blur)},a.identity=new a("transparent",0,0,0),createjs.Shadow=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.EventDispatcher;b.complete=!0,b.framerate=0,b._animations=null,b._frames=null,b._images=null,b._data=null,b._loadCount=0,b._frameHeight=0,b._frameWidth=0,b._numFrames=0,b._regX=0,b._regY=0,b.initialize=function(a){var b,c,d,e;if(null!=a){if(this.framerate=a.framerate||0,a.images&&(c=a.images.length)>0)for(e=this._images=[],b=0;c>b;b++){var f=a.images[b];if("string"==typeof f){var g=f;f=document.createElement("img"),f.src=g}e.push(f),f.getContext||f.complete||(this._loadCount++,this.complete=!1,function(a){f.onload=function(){a._handleImageLoad()}}(this))}if(null==a.frames);else if(a.frames instanceof Array)for(this._frames=[],e=a.frames,b=0,c=e.length;c>b;b++){var h=e[b];this._frames.push({image:this._images[h[4]?h[4]:0],rect:new createjs.Rectangle(h[0],h[1],h[2],h[3]),regX:h[5]||0,regY:h[6]||0})}else d=a.frames,this._frameWidth=d.width,this._frameHeight=d.height,this._regX=d.regX||0,this._regY=d.regY||0,this._numFrames=d.count,0==this._loadCount&&this._calculateFrames();if(this._animations=[],null!=(d=a.animations)){this._data={};var i;for(i in d){var j={name:i},k=d[i];if("number"==typeof k)e=j.frames=[k];else if(k instanceof Array)if(1==k.length)j.frames=[k[0]];else for(j.speed=k[3],j.next=k[2],e=j.frames=[],b=k[0];b<=k[1];b++)e.push(b);else{j.speed=k.speed,j.next=k.next;var l=k.frames;e=j.frames="number"==typeof l?[l]:l.slice(0)}(j.next===!0||void 0===j.next)&&(j.next=i),(j.next===!1||e.length<2&&j.next==i)&&(j.next=null),j.speed||(j.speed=1),this._animations.push(i),this._data[i]=j}}}},b.getNumFrames=function(a){if(null==a)return this._frames?this._frames.length:this._numFrames;var b=this._data[a];return null==b?0:b.frames.length},b.getAnimations=function(){return this._animations.slice(0)},b.getAnimation=function(a){return this._data[a]},b.getFrame=function(a){var b;return this._frames&&(b=this._frames[a])?b:null},b.getFrameBounds=function(a,b){var c=this.getFrame(a);return c?(b||new createjs.Rectangle).initialize(-c.regX,-c.regY,c.rect.width,c.rect.height):null},b.toString=function(){return"[SpriteSheet]"},b.clone=function(){var b=new a;return b.complete=this.complete,b._animations=this._animations,b._frames=this._frames,b._images=this._images,b._data=this._data,b._frameHeight=this._frameHeight,b._frameWidth=this._frameWidth,b._numFrames=this._numFrames,b._loadCount=this._loadCount,b},b._handleImageLoad=function(){0==--this._loadCount&&(this._calculateFrames(),this.complete=!0,this.dispatchEvent("complete"))},b._calculateFrames=function(){if(!this._frames&&0!=this._frameWidth){this._frames=[];for(var a=0,b=this._frameWidth,c=this._frameHeight,d=0,e=this._images;d<e.length;d++){for(var f=e[d],g=0|f.width/b,h=0|f.height/c,i=this._numFrames>0?Math.min(this._numFrames-a,g*h):g*h,j=0;i>j;j++)this._frames.push({image:f,rect:new createjs.Rectangle(j%g*b,(0|j/g)*c,b,c),regX:this._regX,regY:this._regY});a+=i}this._numFrames=a}},createjs.SpriteSheet=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b,c){this.f=a,this.params=b,this.path=null==c?!0:c}a.prototype.exec=function(a){this.f.apply(a,this.params)};var b=function(){this.initialize()},c=b.prototype;b.getRGB=function(a,b,c,d){return null!=a&&null==c&&(d=b,c=255&a,b=255&a>>8,a=255&a>>16),null==d?"rgb("+a+","+b+","+c+")":"rgba("+a+","+b+","+c+","+d+")"},b.getHSL=function(a,b,c,d){return null==d?"hsl("+a%360+","+b+"%,"+c+"%)":"hsla("+a%360+","+b+"%,"+c+"%,"+d+")"},b.Command=a,b.BASE_64={A:0,B:1,C:2,D:3,E:4,F:5,G:6,H:7,I:8,J:9,K:10,L:11,M:12,N:13,O:14,P:15,Q:16,R:17,S:18,T:19,U:20,V:21,W:22,X:23,Y:24,Z:25,a:26,b:27,c:28,d:29,e:30,f:31,g:32,h:33,i:34,j:35,k:36,l:37,m:38,n:39,o:40,p:41,q:42,r:43,s:44,t:45,u:46,v:47,w:48,x:49,y:50,z:51,0:52,1:53,2:54,3:55,4:56,5:57,6:58,7:59,8:60,9:61,"+":62,"/":63},b.STROKE_CAPS_MAP=["butt","round","square"],b.STROKE_JOINTS_MAP=["miter","round","bevel"];var d=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");if(d.getContext){var e=b._ctx=d.getContext("2d");b.beginCmd=new a(e.beginPath,[],!1),b.fillCmd=new a(e.fill,[],!1),b.strokeCmd=new a(e.stroke,[],!1),d.width=d.height=1}c._strokeInstructions=null,c._strokeStyleInstructions=null,c._strokeIgnoreScale=!1,c._fillInstructions=null,c._fillMatrix=null,c._instructions=null,c._oldInstructions=null,c._activeInstructions=null,c._active=!1,c._dirty=!1,c.initialize=function(){this.clear(),this._ctx=b._ctx},c.isEmpty=function(){return!(this._instructions.length||this._oldInstructions.length||this._activeInstructions.length)},c.draw=function(a){this._dirty&&this._updateInstructions();for(var b=this._instructions,c=0,d=b.length;d>c;c++)b[c].exec(a)},c.drawAsPath=function(a){this._dirty&&this._updateInstructions();for(var b,c=this._instructions,d=0,e=c.length;e>d;d++)((b=c[d]).path||0==d)&&b.exec(a)},c.moveTo=function(b,c){return this._activeInstructions.push(new a(this._ctx.moveTo,[b,c])),this},c.lineTo=function(b,c){return this._dirty=this._active=!0,this._activeInstructions.push(new a(this._ctx.lineTo,[b,c])),this},c.arcTo=function(b,c,d,e,f){return this._dirty=this._active=!0,this._activeInstructions.push(new a(this._ctx.arcTo,[b,c,d,e,f])),this},c.arc=function(b,c,d,e,f,g){return this._dirty=this._active=!0,null==g&&(g=!1),this._activeInstructions.push(new a(this._ctx.arc,[b,c,d,e,f,g])),this},c.quadraticCurveTo=function(b,c,d,e){return this._dirty=this._active=!0,this._activeInstructions.push(new a(this._ctx.quadraticCurveTo,[b,c,d,e])),this},c.bezierCurveTo=function(b,c,d,e,f,g){return this._dirty=this._active=!0,this._activeInstructions.push(new a(this._ctx.bezierCurveTo,[b,c,d,e,f,g])),this},c.rect=function(b,c,d,e){return this._dirty=this._active=!0,this._activeInstructions.push(new a(this._ctx.rect,[b,c,d,e])),this},c.closePath=function(){return this._active&&(this._dirty=!0,this._activeInstructions.push(new a(this._ctx.closePath,[]))),this},c.clear=function(){return this._instructions=[],this._oldInstructions=[],this._activeInstructions=[],this._strokeStyleInstructions=this._strokeInstructions=this._fillInstructions=this._fillMatrix=null,this._active=this._dirty=this._strokeIgnoreScale=!1,this},c.beginFill=function(b){return this._active&&this._newPath(),this._fillInstructions=b?[new a(this._setProp,["fillStyle",b],!1)]:null,this._fillMatrix=null,this},c.beginLinearGradientFill=function(b,c,d,e,f,g){this._active&&this._newPath();for(var h=this._ctx.createLinearGradient(d,e,f,g),i=0,j=b.length;j>i;i++)h.addColorStop(c[i],b[i]);return this._fillInstructions=[new a(this._setProp,["fillStyle",h],!1)],this._fillMatrix=null,this},c.beginRadialGradientFill=function(b,c,d,e,f,g,h,i){this._active&&this._newPath();for(var j=this._ctx.createRadialGradient(d,e,f,g,h,i),k=0,l=b.length;l>k;k++)j.addColorStop(c[k],b[k]);return this._fillInstructions=[new a(this._setProp,["fillStyle",j],!1)],this._fillMatrix=null,this},c.beginBitmapFill=function(b,c,d){this._active&&this._newPath(),c=c||"";var e=this._ctx.createPattern(b,c);return this._fillInstructions=[new a(this._setProp,["fillStyle",e],!1)],this._fillMatrix=d?[d.a,d.b,d.c,d.d,d.tx,d.ty]:null,this},c.endFill=function(){return this.beginFill()},c.setStrokeStyle=function(c,d,e,f,g){return this._active&&this._newPath(),this._strokeStyleInstructions=[new a(this._setProp,["lineWidth",null==c?"1":c],!1),new a(this._setProp,["lineCap",null==d?"butt":isNaN(d)?d:b.STROKE_CAPS_MAP[d]],!1),new a(this._setProp,["lineJoin",null==e?"miter":isNaN(e)?e:b.STROKE_JOINTS_MAP[e]],!1),new a(this._setProp,["miterLimit",null==f?"10":f],!1)],this._strokeIgnoreScale=g,this},c.beginStroke=function(b){return this._active&&this._newPath(),this._strokeInstructions=b?[new a(this._setProp,["strokeStyle",b],!1)]:null,this},c.beginLinearGradientStroke=function(b,c,d,e,f,g){this._active&&this._newPath();for(var h=this._ctx.createLinearGradient(d,e,f,g),i=0,j=b.length;j>i;i++)h.addColorStop(c[i],b[i]);return this._strokeInstructions=[new a(this._setProp,["strokeStyle",h],!1)],this},c.beginRadialGradientStroke=function(b,c,d,e,f,g,h,i){this._active&&this._newPath();for(var j=this._ctx.createRadialGradient(d,e,f,g,h,i),k=0,l=b.length;l>k;k++)j.addColorStop(c[k],b[k]);return this._strokeInstructions=[new a(this._setProp,["strokeStyle",j],!1)],this},c.beginBitmapStroke=function(b,c){this._active&&this._newPath(),c=c||"";var d=this._ctx.createPattern(b,c);return this._strokeInstructions=[new a(this._setProp,["strokeStyle",d],!1)],this},c.endStroke=function(){return this.beginStroke(),this},c.curveTo=c.quadraticCurveTo,c.drawRect=c.rect,c.drawRoundRect=function(a,b,c,d,e){return this.drawRoundRectComplex(a,b,c,d,e,e,e,e),this},c.drawRoundRectComplex=function(b,c,d,e,f,g,h,i){var j=(e>d?d:e)/2,k=0,l=0,m=0,n=0;0>f&&(f*=k=-1),f>j&&(f=j),0>g&&(g*=l=-1),g>j&&(g=j),0>h&&(h*=m=-1),h>j&&(h=j),0>i&&(i*=n=-1),i>j&&(i=j),this._dirty=this._active=!0;var o=this._ctx.arcTo,p=this._ctx.lineTo;return this._activeInstructions.push(new a(this._ctx.moveTo,[b+d-g,c]),new a(o,[b+d+g*l,c-g*l,b+d,c+g,g]),new a(p,[b+d,c+e-h]),new a(o,[b+d+h*m,c+e+h*m,b+d-h,c+e,h]),new a(p,[b+i,c+e]),new a(o,[b-i*n,c+e+i*n,b,c+e-i,i]),new a(p,[b,c+f]),new a(o,[b-f*k,c-f*k,b+f,c,f]),new a(this._ctx.closePath)),this},c.drawCircle=function(a,b,c){return this.arc(a,b,c,0,2*Math.PI),this},c.drawEllipse=function(b,c,d,e){this._dirty=this._active=!0;var f=.5522848,g=d/2*f,h=e/2*f,i=b+d,j=c+e,k=b+d/2,l=c+e/2;return this._activeInstructions.push(new a(this._ctx.moveTo,[b,l]),new a(this._ctx.bezierCurveTo,[b,l-h,k-g,c,k,c]),new a(this._ctx.bezierCurveTo,[k+g,c,i,l-h,i,l]),new a(this._ctx.bezierCurveTo,[i,l+h,k+g,j,k,j]),new a(this._ctx.bezierCurveTo,[k-g,j,b,l+h,b,l])),this},c.inject=function(b,c){return this._dirty=this._active=!0,this._activeInstructions.push(new a(b,[c])),this},c.drawPolyStar=function(b,c,d,e,f,g){this._dirty=this._active=!0,null==f&&(f=0),f=1-f,null==g?g=0:g/=180/Math.PI;var h=Math.PI/e;this._activeInstructions.push(new a(this._ctx.moveTo,[b+Math.cos(g)*d,c+Math.sin(g)*d]));for(var i=0;e>i;i++)g+=h,1!=f&&this._activeInstructions.push(new a(this._ctx.lineTo,[b+Math.cos(g)*d*f,c+Math.sin(g)*d*f])),g+=h,this._activeInstructions.push(new a(this._ctx.lineTo,[b+Math.cos(g)*d,c+Math.sin(g)*d]));return this},c.decodePath=function(a){for(var c=[this.moveTo,this.lineTo,this.quadraticCurveTo,this.bezierCurveTo,this.closePath],d=[2,2,4,6,0],e=0,f=a.length,g=[],h=0,i=0,j=b.BASE_64;f>e;){var k=a.charAt(e),l=j[k],m=l>>3,n=c[m];if(!n||3&l)throw"bad path data (@"+e+"): "+k;var o=d[m];m||(h=i=0),g.length=0,e++;for(var p=(1&l>>2)+2,q=0;o>q;q++){var r=j[a.charAt(e)],s=r>>5?-1:1;r=(31&r)<<6|j[a.charAt(e+1)],3==p&&(r=r<<6|j[a.charAt(e+2)]),r=s*r/10,q%2?h=r+=h:i=r+=i,g[q]=r,e+=p}n.apply(this,g)}return this},c.clone=function(){var a=new b;return a._instructions=this._instructions.slice(),a._activeInstructions=this._activeInstructions.slice(),a._oldInstructions=this._oldInstructions.slice(),this._fillInstructions&&(a._fillInstructions=this._fillInstructions.slice()),this._strokeInstructions&&(a._strokeInstructions=this._strokeInstructions.slice()),this._strokeStyleInstructions&&(a._strokeStyleInstructions=this._strokeStyleInstructions.slice()),a._active=this._active,a._dirty=this._dirty,a._fillMatrix=this._fillMatrix,a._strokeIgnoreScale=this._strokeIgnoreScale,a},c.toString=function(){return"[Graphics]"},c.mt=c.moveTo,c.lt=c.lineTo,c.at=c.arcTo,c.bt=c.bezierCurveTo,c.qt=c.quadraticCurveTo,c.a=c.arc,c.r=c.rect,c.cp=c.closePath,c.c=c.clear,c.f=c.beginFill,c.lf=c.beginLinearGradientFill,c.rf=c.beginRadialGradientFill,c.bf=c.beginBitmapFill,c.ef=c.endFill,c.ss=c.setStrokeStyle,c.s=c.beginStroke,c.ls=c.beginLinearGradientStroke,c.rs=c.beginRadialGradientStroke,c.bs=c.beginBitmapStroke,c.es=c.endStroke,c.dr=c.drawRect,c.rr=c.drawRoundRect,c.rc=c.drawRoundRectComplex,c.dc=c.drawCircle,c.de=c.drawEllipse,c.dp=c.drawPolyStar,c.p=c.decodePath,c._updateInstructions=function(){this._instructions=this._oldInstructions.slice(),this._instructions.push(b.beginCmd),this._appendInstructions(this._fillInstructions),this._appendInstructions(this._strokeInstructions),this._appendInstructions(this._strokeInstructions&&this._strokeStyleInstructions),this._appendInstructions(this._activeInstructions),this._fillInstructions&&this._appendDraw(b.fillCmd,this._fillMatrix),this._strokeInstructions&&this._appendDraw(b.strokeCmd,this._strokeIgnoreScale&&[1,0,0,1,0,0])},c._appendInstructions=function(a){a&&this._instructions.push.apply(this._instructions,a)},c._appendDraw=function(b,c){c?this._instructions.push(new a(this._ctx.save,[],!1),new a(this._ctx.transform,c,!1),b,new a(this._ctx.restore,[],!1)):this._instructions.push(b)},c._newPath=function(){this._dirty&&this._updateInstructions(),this._oldInstructions=this._instructions,this._activeInstructions=[],this._active=this._dirty=!1},c._setProp=function(a,b){this[a]=b},createjs.Graphics=b}(),this.createjs=this.createjs||{},function(){var a=function(){this.initialize()},b=a.prototype=new createjs.EventDispatcher;a._MOUSE_EVENTS=["click","dblclick","mousedown","mouseout","mouseover","pressmove","pressup","rollout","rollover"],a.suppressCrossDomainErrors=!1;var c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._hitTestCanvas=c,a._hitTestContext=c.getContext("2d"),c.width=c.height=1),a._nextCacheID=1,b.alpha=1,b.cacheCanvas=null,b.id=-1,b.mouseEnabled=!0,b.tickEnabled=!0,b.name=null,b.parent=null,b.regX=0,b.regY=0,b.rotation=0,b.scaleX=1,b.scaleY=1,b.skewX=0,b.skewY=0,b.shadow=null,b.visible=!0,b.x=0,b.y=0,b.compositeOperation=null,b.snapToPixel=!1,b.filters=null,b.cacheID=0,b.mask=null,b.hitArea=null,b.cursor=null,b._cacheOffsetX=0,b._cacheOffsetY=0,b._cacheScale=1,b._cacheDataURLID=0,b._cacheDataURL=null,b._matrix=null,b._rectangle=null,b._bounds=null,b.initialize=function(){this.id=createjs.UID.get(),this._matrix=new createjs.Matrix2D,this._rectangle=new createjs.Rectangle},b.isVisible=function(){return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY)},b.draw=function(a,b){var c=this.cacheCanvas;if(b||!c)return!1;var d,e=this._cacheScale,f=this._cacheOffsetX,g=this._cacheOffsetY;return(d=this._applyFilterBounds(f,g,0,0))&&(f=d.x,g=d.y),a.drawImage(c,f,g,c.width/e,c.height/e),!0},b.updateContext=function(a){var b,c=this.mask,d=this;c&&c.graphics&&!c.graphics.isEmpty()&&(b=c.getMatrix(c._matrix),a.transform(b.a,b.b,b.c,b.d,b.tx,b.ty),c.graphics.drawAsPath(a),a.clip(),b.invert(),a.transform(b.a,b.b,b.c,b.d,b.tx,b.ty)),b=d._matrix.identity().appendTransform(d.x,d.y,d.scaleX,d.scaleY,d.rotation,d.skewX,d.skewY,d.regX,d.regY),createjs.Stage._snapToPixelEnabled&&d.snapToPixel?a.transform(b.a,b.b,b.c,b.d,0|b.tx+.5,0|b.ty+.5):a.transform(b.a,b.b,b.c,b.d,b.tx,b.ty),a.globalAlpha*=d.alpha,d.compositeOperation&&(a.globalCompositeOperation=d.compositeOperation),d.shadow&&this._applyShadow(a,d.shadow)},b.cache=function(a,b,c,d,e){e=e||1,this.cacheCanvas||(this.cacheCanvas=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas")),this._cacheWidth=c,this._cacheHeight=d,this._cacheOffsetX=a,this._cacheOffsetY=b,this._cacheScale=e,this.updateCache()},b.updateCache=function(b){var c,d=this.cacheCanvas,e=this._cacheScale,f=this._cacheOffsetX*e,g=this._cacheOffsetY*e,h=this._cacheWidth,i=this._cacheHeight;if(!d)throw"cache() must be called before updateCache()";var j=d.getContext("2d");(c=this._applyFilterBounds(f,g,h,i))&&(f=c.x,g=c.y,h=c.width,i=c.height),h=Math.ceil(h*e),i=Math.ceil(i*e),h!=d.width||i!=d.height?(d.width=h,d.height=i):b||j.clearRect(0,0,h+1,i+1),j.save(),j.globalCompositeOperation=b,j.setTransform(e,0,0,e,-f,-g),this.draw(j,!0),this._applyFilters(),j.restore(),this.cacheID=a._nextCacheID++},b.uncache=function(){this._cacheDataURL=this.cacheCanvas=null,this.cacheID=this._cacheOffsetX=this._cacheOffsetY=0,this._cacheScale=1},b.getCacheDataURL=function(){return this.cacheCanvas?(this.cacheID!=this._cacheDataURLID&&(this._cacheDataURL=this.cacheCanvas.toDataURL()),this._cacheDataURL):null},b.getStage=function(){for(var a=this;a.parent;)a=a.parent;return a instanceof createjs.Stage?a:null},b.localToGlobal=function(a,b){var c=this.getConcatenatedMatrix(this._matrix);return null==c?null:(c.append(1,0,0,1,a,b),new createjs.Point(c.tx,c.ty))},b.globalToLocal=function(a,b){var c=this.getConcatenatedMatrix(this._matrix);return null==c?null:(c.invert(),c.append(1,0,0,1,a,b),new createjs.Point(c.tx,c.ty))},b.localToLocal=function(a,b,c){var d=this.localToGlobal(a,b);return c.globalToLocal(d.x,d.y)},b.setTransform=function(a,b,c,d,e,f,g,h,i){return this.x=a||0,this.y=b||0,this.scaleX=null==c?1:c,this.scaleY=null==d?1:d,this.rotation=e||0,this.skewX=f||0,this.skewY=g||0,this.regX=h||0,this.regY=i||0,this},b.getMatrix=function(a){var b=this;return(a?a.identity():new createjs.Matrix2D).appendTransform(b.x,b.y,b.scaleX,b.scaleY,b.rotation,b.skewX,b.skewY,b.regX,b.regY).appendProperties(b.alpha,b.shadow,b.compositeOperation)},b.getConcatenatedMatrix=function(a){a?a.identity():a=new createjs.Matrix2D;for(var b=this;null!=b;)a.prependTransform(b.x,b.y,b.scaleX,b.scaleY,b.rotation,b.skewX,b.skewY,b.regX,b.regY).prependProperties(b.alpha,b.shadow,b.compositeOperation),b=b.parent;return a},b.hitTest=function(b,c){var d=a._hitTestContext;d.setTransform(1,0,0,1,-b,-c),this.draw(d);
    var e=this._testHit(d);return d.setTransform(1,0,0,1,0,0),d.clearRect(0,0,2,2),e},b.set=function(a){for(var b in a)this[b]=a[b];return this},b.getBounds=function(){if(this._bounds)return this._rectangle.copy(this._bounds);var a=this.cacheCanvas;if(a){var b=this._cacheScale;return this._rectangle.initialize(this._cacheOffsetX,this._cacheOffsetY,a.width/b,a.height/b)}return null},b.getTransformedBounds=function(){return this._getBounds()},b.setBounds=function(a,b,c,d){null==a&&(this._bounds=a),this._bounds=(this._bounds||new createjs.Rectangle).initialize(a,b,c,d)},b.clone=function(){var b=new a;return this.cloneProps(b),b},b.toString=function(){return"[DisplayObject (name="+this.name+")]"},b.cloneProps=function(a){a.alpha=this.alpha,a.name=this.name,a.regX=this.regX,a.regY=this.regY,a.rotation=this.rotation,a.scaleX=this.scaleX,a.scaleY=this.scaleY,a.shadow=this.shadow,a.skewX=this.skewX,a.skewY=this.skewY,a.visible=this.visible,a.x=this.x,a.y=this.y,a._bounds=this._bounds,a.mouseEnabled=this.mouseEnabled,a.compositeOperation=this.compositeOperation},b._applyShadow=function(a,b){b=b||Shadow.identity,a.shadowColor=b.color,a.shadowOffsetX=b.offsetX,a.shadowOffsetY=b.offsetY,a.shadowBlur=b.blur},b._tick=function(a){var b=this._listeners;if(b&&b.tick){var c=new createjs.Event("tick");c.params=a,this._dispatchEvent(c,this,2)}},b._testHit=function(b){try{var c=b.getImageData(0,0,1,1).data[3]>1}catch(d){if(!a.suppressCrossDomainErrors)throw"An error has occurred. This is most likely due to security restrictions on reading canvas pixel data with local or cross-domain images."}return c},b._applyFilters=function(){if(this.filters&&0!=this.filters.length&&this.cacheCanvas)for(var a=this.filters.length,b=this.cacheCanvas.getContext("2d"),c=this.cacheCanvas.width,d=this.cacheCanvas.height,e=0;a>e;e++)this.filters[e].applyFilter(b,0,0,c,d)},b._applyFilterBounds=function(a,b,c,d){var e,f,g=this.filters;if(!g||!(f=g.length))return null;for(var h=0;f>h;h++){var i=this.filters[h],j=i.getBounds&&i.getBounds();j&&(e||(e=this._rectangle.initialize(a,b,c,d)),e.x+=j.x,e.y+=j.y,e.width+=j.width,e.height+=j.height)}return e},b._getBounds=function(a,b){return this._transformBounds(this.getBounds(),a,b)},b._transformBounds=function(a,b,c){if(!a)return a;var d=a.x,e=a.y,f=a.width,g=a.height,h=c?this._matrix.identity():this.getMatrix(this._matrix);(d||e)&&h.appendTransform(0,0,1,1,0,0,0,-d,-e),b&&h.prependMatrix(b);var i=f*h.a,j=f*h.b,k=g*h.c,l=g*h.d,m=h.tx,n=h.ty,o=m,p=m,q=n,r=n;return(d=i+m)<o?o=d:d>p&&(p=d),(d=i+k+m)<o?o=d:d>p&&(p=d),(d=k+m)<o?o=d:d>p&&(p=d),(e=j+n)<q?q=e:e>r&&(r=e),(e=j+l+n)<q?q=e:e>r&&(r=e),(e=l+n)<q?q=e:e>r&&(r=e),a.initialize(o,q,p-o,r-q)},b._hasMouseEventListener=function(){for(var b=a._MOUSE_EVENTS,c=0,d=b.length;d>c;c++)if(this.hasEventListener(b[c]))return!0;return!!this.cursor},createjs.DisplayObject=a}(),this.createjs=this.createjs||{},function(){var a=function(){this.initialize()},b=a.prototype=new createjs.DisplayObject;b.children=null,b.mouseChildren=!0,b.tickChildren=!0,b.DisplayObject_initialize=b.initialize,b.initialize=function(){this.DisplayObject_initialize(),this.children=[]},b.isVisible=function(){var a=this.cacheCanvas||this.children.length;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.DisplayObject_draw=b.draw,b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;for(var c=this.children.slice(0),d=0,e=c.length;e>d;d++){var f=c[d];f.isVisible()&&(a.save(),f.updateContext(a),f.draw(a),a.restore())}return!0},b.addChild=function(a){if(null==a)return a;var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addChild(arguments[c]);return arguments[b-1]}return a.parent&&a.parent.removeChild(a),a.parent=this,this.children.push(a),a},b.addChildAt=function(a,b){var c=arguments.length,d=arguments[c-1];if(0>d||d>this.children.length)return arguments[c-2];if(c>2){for(var e=0;c-1>e;e++)this.addChildAt(arguments[e],d+e);return arguments[c-2]}return a.parent&&a.parent.removeChild(a),a.parent=this,this.children.splice(b,0,a),a},b.removeChild=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeChild(arguments[d]);return c}return this.removeChildAt(createjs.indexOf(this.children,a))},b.removeChildAt=function(a){var b=arguments.length;if(b>1){for(var c=[],d=0;b>d;d++)c[d]=arguments[d];c.sort(function(a,b){return b-a});for(var e=!0,d=0;b>d;d++)e=e&&this.removeChildAt(c[d]);return e}if(0>a||a>this.children.length-1)return!1;var f=this.children[a];return f&&(f.parent=null),this.children.splice(a,1),!0},b.removeAllChildren=function(){for(var a=this.children;a.length;)a.pop().parent=null},b.getChildAt=function(a){return this.children[a]},b.getChildByName=function(a){for(var b=this.children,c=0,d=b.length;d>c;c++)if(b[c].name==a)return b[c];return null},b.sortChildren=function(a){this.children.sort(a)},b.getChildIndex=function(a){return createjs.indexOf(this.children,a)},b.getNumChildren=function(){return this.children.length},b.swapChildrenAt=function(a,b){var c=this.children,d=c[a],e=c[b];d&&e&&(c[a]=e,c[b]=d)},b.swapChildren=function(a,b){for(var c,d,e=this.children,f=0,g=e.length;g>f&&(e[f]==a&&(c=f),e[f]==b&&(d=f),null==c||null==d);f++);f!=g&&(e[c]=b,e[d]=a)},b.setChildIndex=function(a,b){var c=this.children,d=c.length;if(!(a.parent!=this||0>b||b>=d)){for(var e=0;d>e&&c[e]!=a;e++);e!=d&&e!=b&&(c.splice(e,1),c.splice(b,0,a))}},b.contains=function(a){for(;a;){if(a==this)return!0;a=a.parent}return!1},b.hitTest=function(a,b){return null!=this.getObjectUnderPoint(a,b)},b.getObjectsUnderPoint=function(a,b){var c=[],d=this.localToGlobal(a,b);return this._getObjectsUnderPoint(d.x,d.y,c),c},b.getObjectUnderPoint=function(a,b){var c=this.localToGlobal(a,b);return this._getObjectsUnderPoint(c.x,c.y)},b.DisplayObject_getBounds=b.getBounds,b.getBounds=function(){return this._getBounds(null,!0)},b.getTransformedBounds=function(){return this._getBounds()},b.clone=function(b){var c=new a;if(this.cloneProps(c),b)for(var d=c.children=[],e=0,f=this.children.length;f>e;e++){var g=this.children[e].clone(b);g.parent=c,d.push(g)}return c},b.toString=function(){return"[Container (name="+this.name+")]"},b.DisplayObject__tick=b._tick,b._tick=function(a){if(this.tickChildren)for(var b=this.children.length-1;b>=0;b--){var c=this.children[b];c.tickEnabled&&c._tick&&c._tick(a)}this.DisplayObject__tick(a)},b._getObjectsUnderPoint=function(b,c,d,e,f){var g=createjs.DisplayObject._hitTestContext,h=this._matrix;f=f||e&&this._hasMouseEventListener();for(var i=this.children,j=i.length,k=j-1;k>=0;k--){var l=i[k],m=l.hitArea;if(l.visible&&(m||l.isVisible())&&(!e||l.mouseEnabled))if(!m&&l instanceof a){var n=l._getObjectsUnderPoint(b,c,d,e,f);if(!d&&n)return e&&!this.mouseChildren?this:n}else{if(!f&&!l._hasMouseEventListener())continue;if(l.getConcatenatedMatrix(h),m&&(h.appendTransform(m.x,m.y,m.scaleX,m.scaleY,m.rotation,m.skewX,m.skewY,m.regX,m.regY),h.alpha=m.alpha),g.globalAlpha=h.alpha,g.setTransform(h.a,h.b,h.c,h.d,h.tx-b,h.ty-c),(m||l).draw(g),!this._testHit(g))continue;if(g.setTransform(1,0,0,1,0,0),g.clearRect(0,0,2,2),!d)return e&&!this.mouseChildren?this:l;d.push(l)}}return null},b._getBounds=function(a,b){var c=this.DisplayObject_getBounds();if(c)return this._transformBounds(c,a,b);var d,e,f,g,h=b?this._matrix.identity():this.getMatrix(this._matrix);a&&h.prependMatrix(a);for(var i=this.children.length,j=0;i>j;j++){var k=this.children[j];if(k.visible&&(c=k._getBounds(h))){var l=c.x,m=c.y,n=l+c.width,o=m+c.height;(d>l||null==d)&&(d=l),(n>e||null==e)&&(e=n),(f>m||null==f)&&(f=m),(o>g||null==g)&&(g=o)}}return null==e?null:this._rectangle.initialize(d,f,e-d,g-f)},createjs.Container=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.Container;a._snapToPixelEnabled=!1,b.autoClear=!0,b.canvas=null,b.mouseX=0,b.mouseY=0,b.snapToPixelEnabled=!1,b.mouseInBounds=!1,b.tickOnUpdate=!0,b.mouseMoveOutside=!1,b.nextStage=null,b._pointerData=null,b._pointerCount=0,b._primaryPointerID=null,b._mouseOverIntervalID=null,b.Container_initialize=b.initialize,b.initialize=function(a){this.Container_initialize(),this.canvas="string"==typeof a?document.getElementById(a):a,this._pointerData={},this.enableDOMEvents(!0)},b.update=function(){if(this.canvas){this.tickOnUpdate&&(this.dispatchEvent("tickstart"),this.tickEnabled&&this._tick(arguments.length?arguments:null),this.dispatchEvent("tickend")),this.dispatchEvent("drawstart"),a._snapToPixelEnabled=this.snapToPixelEnabled,this.autoClear&&this.clear();var b=this.canvas.getContext("2d");b.save(),this.updateContext(b),this.draw(b,!1),b.restore(),this.dispatchEvent("drawend")}},b.handleEvent=function(a){"tick"==a.type&&this.update(a)},b.clear=function(){if(this.canvas){var a=this.canvas.getContext("2d");a.setTransform(1,0,0,1,0,0),a.clearRect(0,0,this.canvas.width+1,this.canvas.height+1)}},b.toDataURL=function(a,b){b||(b="image/png");var c,d=this.canvas.getContext("2d"),e=this.canvas.width,f=this.canvas.height;if(a){c=d.getImageData(0,0,e,f);var g=d.globalCompositeOperation;d.globalCompositeOperation="destination-over",d.fillStyle=a,d.fillRect(0,0,e,f)}var h=this.canvas.toDataURL(b);return a&&(d.clearRect(0,0,e+1,f+1),d.putImageData(c,0,0),d.globalCompositeOperation=g),h},b.enableMouseOver=function(a){if(this._mouseOverIntervalID&&(clearInterval(this._mouseOverIntervalID),this._mouseOverIntervalID=null,0==a&&this._testMouseOver(!0)),null==a)a=20;else if(0>=a)return;var b=this;this._mouseOverIntervalID=setInterval(function(){b._testMouseOver()},1e3/Math.min(50,a))},b.enableDOMEvents=function(a){null==a&&(a=!0);var b,c,d=this._eventListeners;if(!a&&d){for(b in d)c=d[b],c.t.removeEventListener(b,c.f,!1);this._eventListeners=null}else if(a&&!d&&this.canvas){var e=window.addEventListener?window:document,f=this;d=this._eventListeners={},d.mouseup={t:e,f:function(a){f._handleMouseUp(a)}},d.mousemove={t:e,f:function(a){f._handleMouseMove(a)}},d.dblclick={t:this.canvas,f:function(a){f._handleDoubleClick(a)}},d.mousedown={t:this.canvas,f:function(a){f._handleMouseDown(a)}};for(b in d)c=d[b],c.t.addEventListener(b,c.f,!1)}},b.clone=function(){var b=new a(null);return this.cloneProps(b),b},b.toString=function(){return"[Stage (name="+this.name+")]"},b._getElementRect=function(a){var b;try{b=a.getBoundingClientRect()}catch(c){b={top:a.offsetTop,left:a.offsetLeft,width:a.offsetWidth,height:a.offsetHeight}}var d=(window.pageXOffset||document.scrollLeft||0)-(document.clientLeft||document.body.clientLeft||0),e=(window.pageYOffset||document.scrollTop||0)-(document.clientTop||document.body.clientTop||0),f=window.getComputedStyle?getComputedStyle(a):a.currentStyle,g=parseInt(f.paddingLeft)+parseInt(f.borderLeftWidth),h=parseInt(f.paddingTop)+parseInt(f.borderTopWidth),i=parseInt(f.paddingRight)+parseInt(f.borderRightWidth),j=parseInt(f.paddingBottom)+parseInt(f.borderBottomWidth);return{left:b.left+d+g,right:b.right+d-i,top:b.top+e+h,bottom:b.bottom+e-j}},b._getPointerData=function(a){var b=this._pointerData[a];return b||(b=this._pointerData[a]={x:0,y:0},null==this._primaryPointerID&&(this._primaryPointerID=a),(null==this._primaryPointerID||-1==this._primaryPointerID)&&(this._primaryPointerID=a)),b},b._handleMouseMove=function(a){a||(a=window.event),this._handlePointerMove(-1,a,a.pageX,a.pageY)},b._handlePointerMove=function(a,b,c,d){if(this.canvas){var e=this._getPointerData(a),f=e.inBounds;if(this._updatePointerPosition(a,b,c,d),f||e.inBounds||this.mouseMoveOutside){-1==a&&e.inBounds==!f&&this._dispatchMouseEvent(this,f?"mouseleave":"mouseenter",!1,a,e,b),this._dispatchMouseEvent(this,"stagemousemove",!1,a,e,b),this._dispatchMouseEvent(e.target,"pressmove",!0,a,e,b);var g=e.event;g&&g.hasEventListener("mousemove")&&g.dispatchEvent(new createjs.MouseEvent("mousemove",!1,!1,e.x,e.y,b,a,a==this._primaryPointerID,e.rawX,e.rawY),e.target),this.nextStage&&this.nextStage._handlePointerMove(a,b,c,d)}}},b._updatePointerPosition=function(a,b,c,d){var e=this._getElementRect(this.canvas);c-=e.left,d-=e.top;var f=this.canvas.width,g=this.canvas.height;c/=(e.right-e.left)/f,d/=(e.bottom-e.top)/g;var h=this._getPointerData(a);(h.inBounds=c>=0&&d>=0&&f-1>=c&&g-1>=d)?(h.x=c,h.y=d):this.mouseMoveOutside&&(h.x=0>c?0:c>f-1?f-1:c,h.y=0>d?0:d>g-1?g-1:d),h.posEvtObj=b,h.rawX=c,h.rawY=d,a==this._primaryPointerID&&(this.mouseX=h.x,this.mouseY=h.y,this.mouseInBounds=h.inBounds)},b._handleMouseUp=function(a){this._handlePointerUp(-1,a,!1)},b._handlePointerUp=function(a,b,c){var d=this._getPointerData(a);this._dispatchMouseEvent(this,"stagemouseup",!1,a,d,b);var e=d.target;e&&(this._getObjectsUnderPoint(d.x,d.y,null,!0)==e&&this._dispatchMouseEvent(e,"click",!0,a,d,b),this._dispatchMouseEvent(e,"pressup",!0,a,d,b));var f=d.event;f&&f.hasEventListener("mouseup")&&f.dispatchEvent(new createjs.MouseEvent("mouseup",!1,!1,d.x,d.y,b,a,a==this._primaryPointerID,d.rawX,d.rawY),e),c?(a==this._primaryPointerID&&(this._primaryPointerID=null),delete this._pointerData[a]):d.event=d.target=null,this.nextStage&&this.nextStage._handlePointerUp(a,b,c)},b._handleMouseDown=function(a){this._handlePointerDown(-1,a,a.pageX,a.pageY)},b._handlePointerDown=function(a,b,c,d){null!=d&&this._updatePointerPosition(a,b,c,d);var e=this._getPointerData(a);this._dispatchMouseEvent(this,"stagemousedown",!1,a,e,b),e.target=this._getObjectsUnderPoint(e.x,e.y,null,!0),e.event=this._dispatchMouseEvent(e.target,"mousedown",!0,a,e,b),this.nextStage&&this.nextStage._handlePointerDown(a,b,c,d)},b._testMouseOver=function(a){if(-1==this._primaryPointerID&&(a||this.mouseX!=this._mouseOverX||this.mouseY!=this._mouseOverY||!this.mouseInBounds)){var b,c,d,e,f=this._getPointerData(-1),g=f.posEvtObj,h=-1,i="";(a||this.mouseInBounds&&g&&g.target==this.canvas)&&(b=this._getObjectsUnderPoint(this.mouseX,this.mouseY,null,!0),this._mouseOverX=this.mouseX,this._mouseOverY=this.mouseY);var j=this._mouseOverTarget||[],k=j[j.length-1],l=this._mouseOverTarget=[];for(c=b;c;)l.unshift(c),null!=c.cursor&&(i=c.cursor),c=c.parent;for(this.canvas.style.cursor=i,d=0,e=l.length;e>d&&l[d]==j[d];d++)h=d;for(k!=b&&this._dispatchMouseEvent(k,"mouseout",!0,-1,f,g),d=j.length-1;d>h;d--)this._dispatchMouseEvent(j[d],"rollout",!1,-1,f,g);for(d=l.length-1;d>h;d--)this._dispatchMouseEvent(l[d],"rollover",!1,-1,f,g);k!=b&&this._dispatchMouseEvent(b,"mouseover",!0,-1,f,g)}},b._handleDoubleClick=function(a){var b=this._getPointerData(-1),c=this._getObjectsUnderPoint(b.x,b.y,null,!0);this._dispatchMouseEvent(c,"dblclick",!0,-1,b,a),this.nextStage&&this.nextStage._handleDoubleClick(a)},b._dispatchMouseEvent=function(a,b,c,d,e,f){if(a&&(c||a.hasEventListener(b))){var g=new createjs.MouseEvent(b,c,!1,e.x,e.y,f,d,d==this._primaryPointerID,e.rawX,e.rawY);return a.dispatchEvent(g),g}},createjs.Stage=a}(),this.createjs=this.createjs||{},function(){var a=function(a){this.initialize(a)},b=a.prototype=new createjs.DisplayObject;b.image=null,b.snapToPixel=!0,b.sourceRect=null,b.DisplayObject_initialize=b.initialize,b.initialize=function(a){this.DisplayObject_initialize(),"string"==typeof a?(this.image=document.createElement("img"),this.image.src=a):this.image=a},b.isVisible=function(){var a=this.cacheCanvas||this.image&&(this.image.complete||this.image.getContext||this.image.readyState>=2);return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.DisplayObject_draw=b.draw,b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;var c=this.sourceRect;return c?a.drawImage(this.image,c.x,c.y,c.width,c.height,0,0,c.width,c.height):a.drawImage(this.image,0,0),!0},b.DisplayObject_getBounds=b.getBounds,b.getBounds=function(){var a=this.DisplayObject_getBounds();if(a)return a;var b=this.sourceRect||this.image,c=this.image&&(this.image.complete||this.image.getContext||this.image.readyState>=2);return c?this._rectangle.initialize(0,0,b.width,b.height):null},b.clone=function(){var b=new a(this.image);return this.sourceRect&&(b.sourceRect=this.sourceRect.clone()),this.cloneProps(b),b},b.toString=function(){return"[Bitmap (name="+this.name+")]"},createjs.Bitmap=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b){this.initialize(a,b)},b=a.prototype=new createjs.DisplayObject;b.currentFrame=0,b.currentAnimation=null,b.paused=!0,b.spriteSheet=null,b.snapToPixel=!0,b.offset=0,b.currentAnimationFrame=0,b.framerate=0,b._advanceCount=0,b._animation=null,b._currentFrame=null,b.DisplayObject_initialize=b.initialize,b.initialize=function(a,b){this.DisplayObject_initialize(),this.spriteSheet=a,b&&this.gotoAndPlay(b)},b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet.complete;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.DisplayObject_draw=b.draw,b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;this._normalizeFrame();var c=this.spriteSheet.getFrame(0|this._currentFrame);if(!c)return!1;var d=c.rect;return a.drawImage(c.image,d.x,d.y,d.width,d.height,-c.regX,-c.regY,d.width,d.height),!0},b.play=function(){this.paused=!1},b.stop=function(){this.paused=!0},b.gotoAndPlay=function(a){this.paused=!1,this._goto(a)},b.gotoAndStop=function(a){this.paused=!0,this._goto(a)},b.advance=function(a){var b=this._animation&&this._animation.speed||1,c=this.framerate||this.spriteSheet.framerate,d=c&&null!=a?a/(1e3/c):1;this._animation?this.currentAnimationFrame+=d*b:this._currentFrame+=d*b,this._normalizeFrame()},b.DisplayObject_getBounds=b.getBounds,b.getBounds=function(){return this.DisplayObject_getBounds()||this.spriteSheet.getFrameBounds(this.currentFrame,this._rectangle)},b.clone=function(){var b=new a(this.spriteSheet);return this.cloneProps(b),b},b.toString=function(){return"[Sprite (name="+this.name+")]"},b.DisplayObject__tick=b._tick,b._tick=function(a){this.paused||this.advance(a&&a[0]&&a[0].delta),this.DisplayObject__tick(a)},b._normalizeFrame=function(){var a,b=this._animation,c=this.paused,d=this._currentFrame,e=this.currentAnimationFrame;if(b)if(a=b.frames.length,(0|e)>=a){var f=b.next;if(this._dispatchAnimationEnd(b,d,c,f,a-1));else{if(f)return this._goto(f,e-a);this.paused=!0,e=this.currentAnimationFrame=b.frames.length-1,this._currentFrame=b.frames[e]}}else this._currentFrame=b.frames[0|e];else if(a=this.spriteSheet.getNumFrames(),d>=a&&!this._dispatchAnimationEnd(b,d,c,a-1)&&(this._currentFrame-=a)>=a)return this._normalizeFrame();this.currentFrame=0|this._currentFrame},b._dispatchAnimationEnd=function(a,b,c,d,e){var f=a?a.name:null;if(this.hasEventListener("animationend")){var g=new createjs.Event("animationend");g.name=f,g.next=d,this.dispatchEvent(g)}var h=this._animation!=a||this._currentFrame!=b;return h||c||!this.paused||(this.currentAnimationFrame=e,h=!0),h},b.DisplayObject_cloneProps=b.cloneProps,b.cloneProps=function(a){this.DisplayObject_cloneProps(a),a.currentFrame=this.currentFrame,a._currentFrame=this._currentFrame,a.currentAnimation=this.currentAnimation,a.paused=this.paused,a._animation=this._animation,a.currentAnimationFrame=this.currentAnimationFrame,a.framerate=this.framerate},b._goto=function(a,b){if(isNaN(a)){var c=this.spriteSheet.getAnimation(a);c&&(this.currentAnimationFrame=b||0,this._animation=c,this.currentAnimation=a,this._normalizeFrame())}else this.currentAnimationFrame=0,this.currentAnimation=this._animation=null,this._currentFrame=a,this._normalizeFrame()},createjs.Sprite=a}(),this.createjs=this.createjs||{},function(){"use strict";var a="BitmapAnimation is deprecated in favour of Sprite. See VERSIONS file for info on changes.";if(!createjs.Sprite)throw a;(createjs.BitmapAnimation=function(b){console.log(a),this.initialize(b)}).prototype=new createjs.Sprite}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.DisplayObject;b.graphics=null,b.DisplayObject_initialize=b.initialize,b.initialize=function(a){this.DisplayObject_initialize(),this.graphics=a?a:new createjs.Graphics},b.isVisible=function(){var a=this.cacheCanvas||this.graphics&&!this.graphics.isEmpty();return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.DisplayObject_draw=b.draw,b.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this.graphics.draw(a),!0)},b.clone=function(b){var c=new a(b&&this.graphics?this.graphics.clone():this.graphics);return this.cloneProps(c),c},b.toString=function(){return"[Shape (name="+this.name+")]"},createjs.Shape=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype=new createjs.DisplayObject,c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");c.getContext&&(a._workingContext=c.getContext("2d"),c.width=c.height=1),a.H_OFFSETS={start:0,left:0,center:-.5,end:-1,right:-1},a.V_OFFSETS={top:0,hanging:-.01,middle:-.4,alphabetic:-.8,ideographic:-.85,bottom:-1},b.text="",b.font=null,b.color=null,b.textAlign="left",b.textBaseline="top",b.maxWidth=null,b.outline=0,b.lineHeight=0,b.lineWidth=null,b.DisplayObject_initialize=b.initialize,b.initialize=function(a,b,c){this.DisplayObject_initialize(),this.text=a,this.font=b,this.color=c},b.isVisible=function(){var a=this.cacheCanvas||null!=this.text&&""!==this.text;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.DisplayObject_draw=b.draw,b.draw=function(a,b){if(this.DisplayObject_draw(a,b))return!0;var c=this.color||"#000";return this.outline?(a.strokeStyle=c,a.lineWidth=1*this.outline):a.fillStyle=c,this._drawText(this._prepContext(a)),!0},b.getMeasuredWidth=function(){return this._prepContext(a._workingContext).measureText(this.text).width},b.getMeasuredLineHeight=function(){return 1.2*this._prepContext(a._workingContext).measureText("M").width},b.getMeasuredHeight=function(){return this._drawText(null,{}).height},b.DisplayObject_getBounds=b.getBounds,b.getBounds=function(){var b=this.DisplayObject_getBounds();if(b)return b;if(null==this.text||""==this.text)return null;var c=this._drawText(null,{}),d=this.maxWidth&&this.maxWidth<c.width?this.maxWidth:c.width,e=d*a.H_OFFSETS[this.textAlign||"left"],f=this.lineHeight||this.getMeasuredLineHeight(),g=f*a.V_OFFSETS[this.textBaseline||"top"];return this._rectangle.initialize(e,g,d,c.height)},b.clone=function(){var b=new a(this.text,this.font,this.color);return this.cloneProps(b),b},b.toString=function(){return"[Text (text="+(this.text.length>20?this.text.substr(0,17)+"...":this.text)+")]"},b.DisplayObject_cloneProps=b.cloneProps,b.cloneProps=function(a){this.DisplayObject_cloneProps(a),a.textAlign=this.textAlign,a.textBaseline=this.textBaseline,a.maxWidth=this.maxWidth,a.outline=this.outline,a.lineHeight=this.lineHeight,a.lineWidth=this.lineWidth},b._prepContext=function(a){return a.font=this.font,a.textAlign=this.textAlign||"left",a.textBaseline=this.textBaseline||"top",a},b._drawText=function(b,c){var d=!!b;d||(b=this._prepContext(a._workingContext));for(var e=this.lineHeight||this.getMeasuredLineHeight(),f=0,g=0,h=String(this.text).split(/(?:\r\n|\r|\n)/),i=0,j=h.length;j>i;i++){var k=h[i],l=null;if(null!=this.lineWidth&&(l=b.measureText(k).width)>this.lineWidth){var m=k.split(/(\s)/);k=m[0],l=b.measureText(k).width;for(var n=1,o=m.length;o>n;n+=2){var p=b.measureText(m[n]+m[n+1]).width;l+p>this.lineWidth?(d&&this._drawTextLine(b,k,g*e),l>f&&(f=l),k=m[n+1],l=b.measureText(k).width,g++):(k+=m[n]+m[n+1],l+=p)}}d&&this._drawTextLine(b,k,g*e),c&&null==l&&(l=b.measureText(k).width),l>f&&(f=l),g++}return c&&(c.count=g,c.width=f,c.height=g*e),c},b._drawTextLine=function(a,b,c){this.outline?a.strokeText(b,0,c,this.maxWidth||65535):a.fillText(b,0,c,this.maxWidth||65535)},createjs.Text=a}(),this.createjs=this.createjs||{},function(){"use strict";function a(a,b){this.initialize(a,b)}var b=a.prototype=new createjs.DisplayObject;b.text="",b.spriteSheet=null,b.lineHeight=0,b.letterSpacing=0,b.spaceWidth=0,b.DisplayObject_initialize=b.initialize,b.initialize=function(a,b){this.DisplayObject_initialize(),this.text=a,this.spriteSheet=b},b.DisplayObject_draw=b.draw,b.draw=function(a,b){return this.DisplayObject_draw(a,b)?!0:(this._drawText(a),void 0)},b.isVisible=function(){var a=this.cacheCanvas||this.spriteSheet&&this.spriteSheet.complete&&this.text;return!!(this.visible&&this.alpha>0&&0!=this.scaleX&&0!=this.scaleY&&a)},b.getBounds=function(){var a=this._rectangle;return this._drawText(null,a),a.width?a:null},b._getFrame=function(a,b){var c,d=b.getAnimation(a);return d||(a!=(c=a.toUpperCase())||a!=(c=a.toLowerCase())||(c=null),c&&(d=b.getAnimation(c))),d&&b.getFrame(d.frames[0])},b._getLineHeight=function(a){var b=this._getFrame("1",a)||this._getFrame("T",a)||this._getFrame("L",a)||a.getFrame(0);return b?b.rect.height:1},b._getSpaceWidth=function(a){var b=this._getFrame("1",a)||this._getFrame("l",a)||this._getFrame("e",a)||this._getFrame("a",a)||a.getFrame(0);return b?b.rect.width:1},b._drawText=function(a,b){var c,d,e,f=0,g=0,h=this.spaceWidth,i=this.lineHeight,j=this.spriteSheet,k=!!this._getFrame(" ",j);k||0!=h||(h=this._getSpaceWidth(j)),0==i&&(i=this._getLineHeight(j));for(var l=0,m=0,n=this.text.length;n>m;m++){var o=this.text.charAt(m);if(k||" "!=o)if("\n"!=o&&"\r"!=o){var p=this._getFrame(o,j);if(p){var q=p.rect;e=p.regX,c=q.width,a&&a.drawImage(p.image,q.x,q.y,c,d=q.height,f-e,g-p.regY,c,d),f+=c+this.letterSpacing}}else"\r"==o&&"\n"==this.text.charAt(m+1)&&m++,f-e>l&&(l=f-e),f=0,g+=i;else f+=h}f-e>l&&(l=f-e),b&&(b.width=l-this.letterSpacing,b.height=g+i)},createjs.BitmapText=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"SpriteSheetUtils cannot be instantiated"},b=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");b.getContext&&(a._workingCanvas=b,a._workingContext=b.getContext("2d"),b.width=b.height=1),a.addFlippedFrames=function(b,c,d,e){if(c||d||e){var f=0;c&&a._flip(b,++f,!0,!1),d&&a._flip(b,++f,!1,!0),e&&a._flip(b,++f,!0,!0)}},a.extractFrame=function(b,c){isNaN(c)&&(c=b.getAnimation(c).frames[0]);var d=b.getFrame(c);if(!d)return null;var e=d.rect,f=a._workingCanvas;f.width=e.width,f.height=e.height,a._workingContext.drawImage(d.image,e.x,e.y,e.width,e.height,0,0,e.width,e.height);var g=document.createElement("img");return g.src=f.toDataURL("image/png"),g},a.mergeAlpha=function(a,b,c){c||(c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas")),c.width=Math.max(b.width,a.width),c.height=Math.max(b.height,a.height);var d=c.getContext("2d");return d.save(),d.drawImage(a,0,0),d.globalCompositeOperation="destination-in",d.drawImage(b,0,0),d.restore(),c},a._flip=function(b,c,d,e){for(var f=b._images,g=a._workingCanvas,h=a._workingContext,i=f.length/c,j=0;i>j;j++){var k=f[j];k.__tmp=j,h.setTransform(1,0,0,1,0,0),h.clearRect(0,0,g.width+1,g.height+1),g.width=k.width,g.height=k.height,h.setTransform(d?-1:1,0,0,e?-1:1,d?k.width:0,e?k.height:0),h.drawImage(k,0,0);var l=document.createElement("img");l.src=g.toDataURL("image/png"),l.width=k.width,l.height=k.height,f.push(l)}var m=b._frames,n=m.length/c;for(j=0;n>j;j++){k=m[j];var o=k.rect.clone();l=f[k.image.__tmp+i*c];var p={image:l,rect:o,regX:k.regX,regY:k.regY};d&&(o.x=l.width-o.x-o.width,p.regX=o.width-k.regX),e&&(o.y=l.height-o.y-o.height,p.regY=o.height-k.regY),m.push(p)}var q="_"+(d?"h":"")+(e?"v":""),r=b._animations,s=b._data,t=r.length/c;for(j=0;t>j;j++){var u=r[j];k=s[u];var v={name:u+q,speed:k.speed,next:k.next,frames:[]};k.next&&(v.next+=q),m=k.frames;for(var w=0,x=m.length;x>w;w++)v.frames.push(m[w]+n*c);s[v.name]=v,r.push(v.name)}},createjs.SpriteSheetUtils=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){this.initialize()},b=a.prototype=new createjs.EventDispatcher;a.ERR_DIMENSIONS="frame dimensions exceed max spritesheet dimensions",a.ERR_RUNNING="a build is already running",b.maxWidth=2048,b.maxHeight=2048,b.spriteSheet=null,b.scale=1,b.padding=1,b.timeSlice=.3,b.progress=-1,b._frames=null,b._animations=null,b._data=null,b._nextFrameIndex=0,b._index=0,b._timerID=null,b._scale=1,b.initialize=function(){this._frames=[],this._animations={}},b.addFrame=function(b,c,d,e,f,g){if(this._data)throw a.ERR_RUNNING;var h=c||b.bounds||b.nominalBounds;return!h&&b.getBounds&&(h=b.getBounds()),h?(d=d||1,this._frames.push({source:b,sourceRect:h,scale:d,funct:e,params:f,scope:g,index:this._frames.length,height:h.height*d})-1):null},b.addAnimation=function(b,c,d,e){if(this._data)throw a.ERR_RUNNING;this._animations[b]={frames:c,next:d,frequency:e}},b.addMovieClip=function(b,c,d){if(this._data)throw a.ERR_RUNNING;var e=b.frameBounds,f=c||b.bounds||b.nominalBounds;if(!f&&b.getBounds&&(f=b.getBounds()),!f&&!e)return null;for(var g=this._frames.length,h=b.timeline.duration,i=0;h>i;i++){var j=e&&e[i]?e[i]:f;this.addFrame(b,j,d,function(a){var b=this.actionsEnabled;this.actionsEnabled=!1,this.gotoAndStop(a),this.actionsEnabled=b},[i],b)}var k=b.timeline._labels,l=[];for(var m in k)l.push({index:k[m],label:m});if(l.length){l.sort(function(a,b){return a.index-b.index});for(var i=0,n=l.length;n>i;i++){for(var o=l[i].label,p=g+l[i].index,q=g+(i==n-1?h:l[i+1].index),r=[],s=p;q>s;s++)r.push(s);this.addAnimation(o,r,!0)}}},b.build=function(){if(this._data)throw a.ERR_RUNNING;for(this._startBuild();this._drawNext(););return this._endBuild(),this.spriteSheet},b.buildAsync=function(b){if(this._data)throw a.ERR_RUNNING;this.timeSlice=b,this._startBuild();var c=this;this._timerID=setTimeout(function(){c._run()},50-50*Math.max(.01,Math.min(.99,this.timeSlice||.3)))},b.stopAsync=function(){clearTimeout(this._timerID),this._data=null},b.clone=function(){throw"SpriteSheetBuilder cannot be cloned."},b.toString=function(){return"[SpriteSheetBuilder]"},b._startBuild=function(){var b=this.padding||0;this.progress=0,this.spriteSheet=null,this._index=0,this._scale=this.scale;var c=[];this._data={images:[],frames:c,animations:this._animations};var d=this._frames.slice();if(d.sort(function(a,b){return a.height<=b.height?-1:1}),d[d.length-1].height+2*b>this.maxHeight)throw a.ERR_DIMENSIONS;for(var e=0,f=0,g=0;d.length;){var h=this._fillRow(d,e,g,c,b);if(h.w>f&&(f=h.w),e+=h.h,!h.h||!d.length){var i=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas");i.width=this._getSize(f,this.maxWidth),i.height=this._getSize(e,this.maxHeight),this._data.images[g]=i,h.h||(f=e=0,g++)}}},b._getSize=function(a,b){for(var c=4;Math.pow(2,++c)<a;);return Math.min(b,Math.pow(2,c))},b._fillRow=function(b,c,d,e,f){var g=this.maxWidth,h=this.maxHeight;c+=f;for(var i=h-c,j=f,k=0,l=b.length-1;l>=0;l--){var m=b[l],n=this._scale*m.scale,o=m.sourceRect,p=m.source,q=Math.floor(n*o.x-f),r=Math.floor(n*o.y-f),s=Math.ceil(n*o.height+2*f),t=Math.ceil(n*o.width+2*f);if(t>g)throw a.ERR_DIMENSIONS;s>i||j+t>g||(m.img=d,m.rect=new createjs.Rectangle(j,c,t,s),k=k||s,b.splice(l,1),e[m.index]=[j,c,t,s,d,Math.round(-q+n*p.regX-f),Math.round(-r+n*p.regY-f)],j+=t)}return{w:j,h:k}},b._endBuild=function(){this.spriteSheet=new createjs.SpriteSheet(this._data),this._data=null,this.progress=1,this.dispatchEvent("complete")},b._run=function(){for(var a=50*Math.max(.01,Math.min(.99,this.timeSlice||.3)),b=(new Date).getTime()+a,c=!1;b>(new Date).getTime();)if(!this._drawNext()){c=!0;break}if(c)this._endBuild();else{var d=this;this._timerID=setTimeout(function(){d._run()},50-a)}var e=this.progress=this._index/this._frames.length;if(this.hasEventListener("progress")){var f=new createjs.Event("progress");f.progress=e,this.dispatchEvent(f)}},b._drawNext=function(){var a=this._frames[this._index],b=a.scale*this._scale,c=a.rect,d=a.sourceRect,e=this._data.images[a.img],f=e.getContext("2d");return a.funct&&a.funct.apply(a.scope,a.params),f.save(),f.beginPath(),f.rect(c.x,c.y,c.width,c.height),f.clip(),f.translate(Math.ceil(c.x-d.x*b),Math.ceil(c.y-d.y*b)),f.scale(b,b),a.source.draw(f),f.restore(),++this._index<this._frames.length},createjs.SpriteSheetBuilder=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.DisplayObject;b.htmlElement=null,b._oldMtx=null,b._visible=!1,b.DisplayObject_initialize=b.initialize,b.initialize=function(a){"string"==typeof a&&(a=document.getElementById(a)),this.DisplayObject_initialize(),this.mouseEnabled=!1,this.htmlElement=a;
    var b=a.style;b.position="absolute",b.transformOrigin=b.WebkitTransformOrigin=b.msTransformOrigin=b.MozTransformOrigin=b.OTransformOrigin="0% 0%"},b.isVisible=function(){return null!=this.htmlElement},b.draw=function(){return this.visible&&(this._visible=!0),!0},b.cache=function(){},b.uncache=function(){},b.updateCache=function(){},b.hitTest=function(){},b.localToGlobal=function(){},b.globalToLocal=function(){},b.localToLocal=function(){},b.clone=function(){throw"DOMElement cannot be cloned."},b.toString=function(){return"[DOMElement (name="+this.name+")]"},b.DisplayObject__tick=b._tick,b._tick=function(a){var b=this.getStage();this._visible=!1,b&&b.on("drawend",this._handleDrawEnd,this,!0),this.DisplayObject__tick(a)},b._handleDrawEnd=function(){var a=this.htmlElement;if(a){var b=a.style,c=this._visible?"visible":"hidden";if(c!=b.visibility&&(b.visibility=c),this._visible){var d=this.getConcatenatedMatrix(this._matrix),e=this._oldMtx,f=1e4;if(e&&e.alpha==d.alpha||(b.opacity=""+(0|d.alpha*f)/f,e&&(e.alpha=d.alpha)),!e||e.tx!=d.tx||e.ty!=d.ty||e.a!=d.a||e.b!=d.b||e.c!=d.c||e.d!=d.d){var g="matrix("+(0|d.a*f)/f+","+(0|d.b*f)/f+","+(0|d.c*f)/f+","+(0|d.d*f)/f+","+(0|d.tx+.5);b.transform=b.WebkitTransform=b.OTransform=b.msTransform=g+","+(0|d.ty+.5)+")",b.MozTransform=g+"px,"+(0|d.ty+.5)+"px)",this._oldMtx=e?e.copy(d):d.clone()}}}},createjs.DOMElement=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){this.initialize()},b=a.prototype;b.initialize=function(){},b.getBounds=function(){return null},b.applyFilter=function(){},b.toString=function(){return"[Filter]"},b.clone=function(){return new a},createjs.Filter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype=new createjs.Filter;b.initialize=function(a,b,c){(isNaN(a)||0>a)&&(a=0),this.blurX=0|a,(isNaN(b)||0>b)&&(b=0),this.blurY=0|b,(isNaN(c)||1>c)&&(c=1),this.quality=0|c},b.blurX=0,b.blurY=0,b.quality=1,b.mul_table=[1,171,205,293,57,373,79,137,241,27,391,357,41,19,283,265,497,469,443,421,25,191,365,349,335,161,155,149,9,278,269,261,505,245,475,231,449,437,213,415,405,395,193,377,369,361,353,345,169,331,325,319,313,307,301,37,145,285,281,69,271,267,263,259,509,501,493,243,479,118,465,459,113,446,55,435,429,423,209,413,51,403,199,393,97,3,379,375,371,367,363,359,355,351,347,43,85,337,333,165,327,323,5,317,157,311,77,305,303,75,297,294,73,289,287,71,141,279,277,275,68,135,67,133,33,262,260,129,511,507,503,499,495,491,61,121,481,477,237,235,467,232,115,457,227,451,7,445,221,439,218,433,215,427,425,211,419,417,207,411,409,203,202,401,399,396,197,49,389,387,385,383,95,189,47,187,93,185,23,183,91,181,45,179,89,177,11,175,87,173,345,343,341,339,337,21,167,83,331,329,327,163,81,323,321,319,159,79,315,313,39,155,309,307,153,305,303,151,75,299,149,37,295,147,73,291,145,289,287,143,285,71,141,281,35,279,139,69,275,137,273,17,271,135,269,267,133,265,33,263,131,261,130,259,129,257,1],b.shg_table=[0,9,10,11,9,12,10,11,12,9,13,13,10,9,13,13,14,14,14,14,10,13,14,14,14,13,13,13,9,14,14,14,15,14,15,14,15,15,14,15,15,15,14,15,15,15,15,15,14,15,15,15,15,15,15,12,14,15,15,13,15,15,15,15,16,16,16,15,16,14,16,16,14,16,13,16,16,16,15,16,13,16,15,16,14,9,16,16,16,16,16,16,16,16,16,13,14,16,16,15,16,16,10,16,15,16,14,16,16,14,16,16,14,16,16,14,15,16,16,16,14,15,14,15,13,16,16,15,17,17,17,17,17,17,14,15,17,17,16,16,17,16,15,17,16,17,11,17,16,17,16,17,16,17,17,16,17,17,16,17,17,16,16,17,17,17,16,14,17,17,17,17,15,16,14,16,15,16,13,16,15,16,14,16,15,16,12,16,15,16,17,17,17,17,17,13,16,15,17,17,17,16,15,17,17,17,16,15,17,17,14,16,17,17,16,17,17,16,15,17,16,14,17,16,15,17,16,17,17,16,17,15,16,17,14,17,16,15,17,16,17,13,17,16,17,17,16,17,14,17,16,17,16,17,16,17,9],b.getBounds=function(){var a=.5*Math.pow(this.quality,.6);return new createjs.Rectangle(-this.blurX*a,-this.blurY*a,2*this.blurX*a,2*this.blurY*a)},b.applyFilter=function(a,b,c,d,e,f,g,h){f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}var k=this.blurX/2;if(isNaN(k)||0>k)return!1;k|=0;var l=this.blurY/2;if(isNaN(l)||0>l)return!1;if(l|=0,0==k&&0==l)return!1;var m=this.quality;(isNaN(m)||1>m)&&(m=1),m|=0,m>3&&(m=3),1>m&&(m=1);var b,c,n,o,p,q,r,s,t,u,v,w,x,y,z,A=i.data,B=k+k+1,C=l+l+1,D=d-1,E=e-1,F=k+1,G=l+1,H={r:0,b:0,g:0,a:0,next:null},I=H;for(n=1;B>n;n++)I=I.next={r:0,b:0,g:0,a:0,next:null};I.next=H;var J={r:0,b:0,g:0,a:0,next:null},K=J;for(n=1;C>n;n++)K=K.next={r:0,b:0,g:0,a:0,next:null};K.next=J;for(var L=null;m-->0;){r=q=0;var M=this.mul_table[k],N=this.shg_table[k];for(c=e;--c>-1;){for(s=F*(w=A[q]),t=F*(x=A[q+1]),u=F*(y=A[q+2]),v=F*(z=A[q+3]),I=H,n=F;--n>-1;)I.r=w,I.g=x,I.b=y,I.a=z,I=I.next;for(n=1;F>n;n++)o=q+((n>D?D:n)<<2),s+=I.r=A[o],t+=I.g=A[o+1],u+=I.b=A[o+2],v+=I.a=A[o+3],I=I.next;for(L=H,b=0;d>b;b++)A[q++]=s*M>>>N,A[q++]=t*M>>>N,A[q++]=u*M>>>N,A[q++]=v*M>>>N,o=r+((o=b+k+1)<D?o:D)<<2,s-=L.r-(L.r=A[o]),t-=L.g-(L.g=A[o+1]),u-=L.b-(L.b=A[o+2]),v-=L.a-(L.a=A[o+3]),L=L.next;r+=d}for(M=this.mul_table[l],N=this.shg_table[l],b=0;d>b;b++){for(q=b<<2,s=G*(w=A[q]),t=G*(x=A[q+1]),u=G*(y=A[q+2]),v=G*(z=A[q+3]),K=J,n=0;G>n;n++)K.r=w,K.g=x,K.b=y,K.a=z,K=K.next;for(p=d,n=1;l>=n;n++)q=p+b<<2,s+=K.r=A[q],t+=K.g=A[q+1],u+=K.b=A[q+2],v+=K.a=A[q+3],K=K.next,E>n&&(p+=d);if(q=b,L=J,m>0)for(c=0;e>c;c++)o=q<<2,A[o+3]=z=v*M>>>N,z>0?(A[o]=s*M>>>N,A[o+1]=t*M>>>N,A[o+2]=u*M>>>N):A[o]=A[o+1]=A[o+2]=0,o=b+((o=c+G)<E?o:E)*d<<2,s-=L.r-(L.r=A[o]),t-=L.g-(L.g=A[o+1]),u-=L.b-(L.b=A[o+2]),v-=L.a-(L.a=A[o+3]),L=L.next,q+=d;else for(c=0;e>c;c++)o=q<<2,A[o+3]=z=v*M>>>N,z>0?(z=255/z,A[o]=(s*M>>>N)*z,A[o+1]=(t*M>>>N)*z,A[o+2]=(u*M>>>N)*z):A[o]=A[o+1]=A[o+2]=0,o=b+((o=c+G)<E?o:E)*d<<2,s-=L.r-(L.r=A[o]),t-=L.g-(L.g=A[o+1]),u-=L.b-(L.b=A[o+2]),v-=L.a-(L.a=A[o+3]),L=L.next,q+=d}}return f.putImageData(i,g,h),!0},b.clone=function(){return new a(this.blurX,this.blurY,this.quality)},b.toString=function(){return"[BlurFilter]"},createjs.BlurFilter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.Filter;b.initialize=function(a){this.alphaMap=a},b.alphaMap=null,b._alphaMap=null,b._mapData=null,b.applyFilter=function(a,b,c,d,e,f,g,h){if(!this.alphaMap)return!0;if(!this._prepAlphaMap())return!1;f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}for(var k=i.data,l=this._mapData,m=k.length,n=0;m>n;n+=4)k[n+3]=l[n]||0;return f.putImageData(i,g,h),!0},b.clone=function(){return new a(this.alphaMap)},b.toString=function(){return"[AlphaMapFilter]"},b._prepAlphaMap=function(){if(!this.alphaMap)return!1;if(this.alphaMap==this._alphaMap&&this._mapData)return!0;this._mapData=null;var a,b=this._alphaMap=this.alphaMap,c=b;b instanceof HTMLCanvasElement?a=c.getContext("2d"):(c=createjs.createCanvas?createjs.createCanvas():document.createElement("canvas"),c.width=b.width,c.height=b.height,a=c.getContext("2d"),a.drawImage(b,0,0));try{var d=a.getImageData(0,0,b.width,b.height)}catch(e){return!1}return this._mapData=d.data,!0},createjs.AlphaMapFilter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.Filter;b.initialize=function(a){this.mask=a},b.mask=null,b.applyFilter=function(a,b,c,d,e,f,g,h){return this.mask?(f=f||a,null==g&&(g=b),null==h&&(h=c),f.save(),f.globalCompositeOperation="destination-in",f.drawImage(this.mask,g,h),f.restore(),!0):!0},b.clone=function(){return new a(this.mask)},b.toString=function(){return"[AlphaMaskFilter]"},createjs.AlphaMaskFilter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d,e,f,g,h){this.initialize(a,b,c,d,e,f,g,h)},b=a.prototype=new createjs.Filter;b.redMultiplier=1,b.greenMultiplier=1,b.blueMultiplier=1,b.alphaMultiplier=1,b.redOffset=0,b.greenOffset=0,b.blueOffset=0,b.alphaOffset=0,b.initialize=function(a,b,c,d,e,f,g,h){this.redMultiplier=null!=a?a:1,this.greenMultiplier=null!=b?b:1,this.blueMultiplier=null!=c?c:1,this.alphaMultiplier=null!=d?d:1,this.redOffset=e||0,this.greenOffset=f||0,this.blueOffset=g||0,this.alphaOffset=h||0},b.applyFilter=function(a,b,c,d,e,f,g,h){f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}for(var k=i.data,l=k.length,m=0;l>m;m+=4)k[m]=k[m]*this.redMultiplier+this.redOffset,k[m+1]=k[m+1]*this.greenMultiplier+this.greenOffset,k[m+2]=k[m+2]*this.blueMultiplier+this.blueOffset,k[m+3]=k[m+3]*this.alphaMultiplier+this.alphaOffset;return f.putImageData(i,g,h),!0},b.toString=function(){return"[ColorFilter]"},b.clone=function(){return new a(this.redMultiplier,this.greenMultiplier,this.blueMultiplier,this.alphaMultiplier,this.redOffset,this.greenOffset,this.blueOffset,this.alphaOffset)},createjs.ColorFilter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c,d){this.initialize(a,b,c,d)},b=a.prototype;a.DELTA_INDEX=[0,.01,.02,.04,.05,.06,.07,.08,.1,.11,.12,.14,.15,.16,.17,.18,.2,.21,.22,.24,.25,.27,.28,.3,.32,.34,.36,.38,.4,.42,.44,.46,.48,.5,.53,.56,.59,.62,.65,.68,.71,.74,.77,.8,.83,.86,.89,.92,.95,.98,1,1.06,1.12,1.18,1.24,1.3,1.36,1.42,1.48,1.54,1.6,1.66,1.72,1.78,1.84,1.9,1.96,2,2.12,2.25,2.37,2.5,2.62,2.75,2.87,3,3.2,3.4,3.6,3.8,4,4.3,4.7,4.9,5,5.5,6,6.5,6.8,7,7.3,7.5,7.8,8,8.4,8.7,9,9.4,9.6,9.8,10],a.IDENTITY_MATRIX=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1],a.LENGTH=a.IDENTITY_MATRIX.length,b.initialize=function(a,b,c,d){return this.reset(),this.adjustColor(a,b,c,d),this},b.reset=function(){return this.copyMatrix(a.IDENTITY_MATRIX)},b.adjustColor=function(a,b,c,d){return this.adjustHue(d),this.adjustContrast(b),this.adjustBrightness(a),this.adjustSaturation(c)},b.adjustBrightness=function(a){return 0==a||isNaN(a)?this:(a=this._cleanValue(a,255),this._multiplyMatrix([1,0,0,0,a,0,1,0,0,a,0,0,1,0,a,0,0,0,1,0,0,0,0,0,1]),this)},b.adjustContrast=function(b){if(0==b||isNaN(b))return this;b=this._cleanValue(b,100);var c;return 0>b?c=127+127*(b/100):(c=b%1,c=0==c?a.DELTA_INDEX[b]:a.DELTA_INDEX[b<<0]*(1-c)+a.DELTA_INDEX[(b<<0)+1]*c,c=127*c+127),this._multiplyMatrix([c/127,0,0,0,.5*(127-c),0,c/127,0,0,.5*(127-c),0,0,c/127,0,.5*(127-c),0,0,0,1,0,0,0,0,0,1]),this},b.adjustSaturation=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,100);var b=1+(a>0?3*a/100:a/100),c=.3086,d=.6094,e=.082;return this._multiplyMatrix([c*(1-b)+b,d*(1-b),e*(1-b),0,0,c*(1-b),d*(1-b)+b,e*(1-b),0,0,c*(1-b),d*(1-b),e*(1-b)+b,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.adjustHue=function(a){if(0==a||isNaN(a))return this;a=this._cleanValue(a,180)/180*Math.PI;var b=Math.cos(a),c=Math.sin(a),d=.213,e=.715,f=.072;return this._multiplyMatrix([d+b*(1-d)+c*-d,e+b*-e+c*-e,f+b*-f+c*(1-f),0,0,d+b*-d+.143*c,e+b*(1-e)+.14*c,f+b*-f+c*-.283,0,0,d+b*-d+c*-(1-d),e+b*-e+c*e,f+b*(1-f)+c*f,0,0,0,0,0,1,0,0,0,0,0,1]),this},b.concat=function(b){return b=this._fixMatrix(b),b.length!=a.LENGTH?this:(this._multiplyMatrix(b),this)},b.clone=function(){return(new a).copyMatrix(this)},b.toArray=function(){for(var b=[],c=0,d=a.LENGTH;d>c;c++)b[c]=this[c];return b},b.copyMatrix=function(b){for(var c=a.LENGTH,d=0;c>d;d++)this[d]=b[d];return this},b.toString=function(){return"[ColorMatrix]"},b._multiplyMatrix=function(a){for(var b=[],c=0;5>c;c++){for(var d=0;5>d;d++)b[d]=this[d+5*c];for(var d=0;5>d;d++){for(var e=0,f=0;5>f;f++)e+=a[d+5*f]*b[f];this[d+5*c]=e}}},b._cleanValue=function(a,b){return Math.min(b,Math.max(-b,a))},b._fixMatrix=function(b){return b instanceof a&&(b=b.toArray()),b.length<a.LENGTH?b=b.slice(0,b.length).concat(a.IDENTITY_MATRIX.slice(b.length,a.LENGTH)):b.length>a.LENGTH&&(b=b.slice(0,a.LENGTH)),b},createjs.ColorMatrix=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a){this.initialize(a)},b=a.prototype=new createjs.Filter;b.matrix=null,b.initialize=function(a){this.matrix=a},b.applyFilter=function(a,b,c,d,e,f,g,h){f=f||a,null==g&&(g=b),null==h&&(h=c);try{var i=a.getImageData(b,c,d,e)}catch(j){return!1}for(var k,l,m,n,o=i.data,p=o.length,q=this.matrix,r=q[0],s=q[1],t=q[2],u=q[3],v=q[4],w=q[5],x=q[6],y=q[7],z=q[8],A=q[9],B=q[10],C=q[11],D=q[12],E=q[13],F=q[14],G=q[15],H=q[16],I=q[17],J=q[18],K=q[19],L=0;p>L;L+=4)k=o[L],l=o[L+1],m=o[L+2],n=o[L+3],o[L]=k*r+l*s+m*t+n*u+v,o[L+1]=k*w+l*x+m*y+n*z+A,o[L+2]=k*B+l*C+m*D+n*E+F,o[L+3]=k*G+l*H+m*I+n*J+K;return f.putImageData(i,g,h),!0},b.toString=function(){return"[ColorMatrixFilter]"},b.clone=function(){return new a(this.matrix)},createjs.ColorMatrixFilter=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"Touch cannot be instantiated"};a.isSupported=function(){return"ontouchstart"in window||window.navigator.msPointerEnabled&&window.navigator.msMaxTouchPoints>0||window.navigator.pointerEnabled&&window.navigator.maxTouchPoints>0},a.enable=function(b,c,d){return b&&b.canvas&&a.isSupported()?(b.__touch={pointers:{},multitouch:!c,preventDefault:!d,count:0},"ontouchstart"in window?a._IOS_enable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_enable(b),!0):!1},a.disable=function(b){b&&("ontouchstart"in window?a._IOS_disable(b):(window.navigator.msPointerEnabled||window.navigator.pointerEnabled)&&a._IE_disable(b))},a._IOS_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IOS_handleEvent(b,c)};c.addEventListener("touchstart",d,!1),c.addEventListener("touchmove",d,!1),c.addEventListener("touchend",d,!1),c.addEventListener("touchcancel",d,!1)},a._IOS_disable=function(a){var b=a.canvas;if(b){var c=a.__touch.f;b.removeEventListener("touchstart",c,!1),b.removeEventListener("touchmove",c,!1),b.removeEventListener("touchend",c,!1),b.removeEventListener("touchcancel",c,!1)}},a._IOS_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();for(var c=b.changedTouches,d=b.type,e=0,f=c.length;f>e;e++){var g=c[e],h=g.identifier;g.target==a.canvas&&("touchstart"==d?this._handleStart(a,h,b,g.pageX,g.pageY):"touchmove"==d?this._handleMove(a,h,b,g.pageX,g.pageY):("touchend"==d||"touchcancel"==d)&&this._handleEnd(a,h,b))}}},a._IE_enable=function(b){var c=b.canvas,d=b.__touch.f=function(c){a._IE_handleEvent(b,c)};void 0===window.navigator.pointerEnabled?(c.addEventListener("MSPointerDown",d,!1),window.addEventListener("MSPointerMove",d,!1),window.addEventListener("MSPointerUp",d,!1),window.addEventListener("MSPointerCancel",d,!1),b.__touch.preventDefault&&(c.style.msTouchAction="none")):(c.addEventListener("pointerdown",d,!1),window.addEventListener("pointermove",d,!1),window.addEventListener("pointerup",d,!1),window.addEventListener("pointercancel",d,!1),b.__touch.preventDefault&&(c.style.touchAction="none")),b.__touch.activeIDs={}},a._IE_disable=function(a){var b=a.__touch.f;void 0===window.navigator.pointerEnabled?(window.removeEventListener("MSPointerMove",b,!1),window.removeEventListener("MSPointerUp",b,!1),window.removeEventListener("MSPointerCancel",b,!1),a.canvas&&a.canvas.removeEventListener("MSPointerDown",b,!1)):(window.removeEventListener("pointermove",b,!1),window.removeEventListener("pointerup",b,!1),window.removeEventListener("pointercancel",b,!1),a.canvas&&a.canvas.removeEventListener("pointerdown",b,!1))},a._IE_handleEvent=function(a,b){if(a){a.__touch.preventDefault&&b.preventDefault&&b.preventDefault();var c=b.type,d=b.pointerId,e=a.__touch.activeIDs;if("MSPointerDown"==c||"pointerdown"==c){if(b.srcElement!=a.canvas)return;e[d]=!0,this._handleStart(a,d,b,b.pageX,b.pageY)}else e[d]&&("MSPointerMove"==c||"pointermove"==c?this._handleMove(a,d,b,b.pageX,b.pageY):("MSPointerUp"==c||"MSPointerCancel"==c||"pointerup"==c||"pointercancel"==c)&&(delete e[d],this._handleEnd(a,d,b)))}},a._handleStart=function(a,b,c,d,e){var f=a.__touch;if(f.multitouch||!f.count){var g=f.pointers;g[b]||(g[b]=!0,f.count++,a._handlePointerDown(b,c,d,e))}},a._handleMove=function(a,b,c,d,e){a.__touch.pointers[b]&&a._handlePointerMove(b,c,d,e)},a._handleEnd=function(a,b,c){var d=a.__touch,e=d.pointers;e[b]&&(d.count--,a._handlePointerUp(b,c,!0),delete e[b])},createjs.Touch=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.EaselJS=createjs.EaselJS||{};a.version="0.7.1",a.buildDate="Thu, 12 Dec 2013 23:33:39 GMT"}();
define("easel", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.createjs;
    };
}(this)));

define('shared/eventManager',[],
function() {
    //all encompassing emitter name
    var ALL = "*";

    /**
     * A reader event.
     * @param emitterName the emitter name that this event was emitted with
     * @param type the topic that this event was fired for.
     * @param target the target of this event (means different things in different contexts).
     * @param data an object containing extra data.
     * @param async whether the event was called asynchronously
     * @constructor
     */
    var Event = function(emitterName, type, target, data, async) {
        this.emitterName = emitterName;
        this.type = type;
        this.target = target;
        this.data = data;
        this.async = async;
    };

    /**
     * An event manager which tracks emitters and topics.
     * To register as an emitter, use the register function.
     * To register to a topic, use the subscribe function.
     * @constructor
     */
    var EventManager = function() {
        // use `self` to ensure scope and context will always be correct when called
        var self = this;
        self.__ALL = ALL;
        self.__Constructor = EventManager;
        self.__EventConstructor = Event;

        var ASYNC_CALLBACKS = "async";
        var SYNC_CALLBACKS = "sync";

        self.topics = {};
        self.topics[ALL] = {};

        /**
         * Registers the given emitter name as available to subscribe to.
         * @param emitterName the name to use
         * @returns {boolean} true if the emitter name was registered, false if it was already registered
         */
        self.register = function(emitterName) {
            if (self.topics[emitterName] == undefined) {
                self.topics[emitterName] = {};
                return true;
            }
            return false;
        };

        /**
         * Subscribes the given callback function to the emitter name and topic combination.
         * @param emitterName the name of the emitter
         * @param topic the topic
         * @param callback the callback to subscribe and then call on emitting
         * @param async whether to run the callback asynchronously
         * @returns {boolean} whether the emitter name passed was registered by this function
         */
        self.subscribe = function(emitterName, topic, callback, async) {
            var emitterRegistered = self.register(emitterName);
            self.ensureTopicExists(emitterName, topic);
            self.topics[emitterName][topic][self.getSyncType(async)].push(callback);
            return emitterRegistered;
        };

        /**
         * Unsubscribes the given callback function from the emitter name and topic combination.
         * @param emitterName the name of the emitter
         * @param topic the topic
         * @param callback the callback to unsubscribe
         * @param async whether the callback was subscribed as asynchronous or not
         */
        self.unsubscribe = function(emitterName, topic, callback, async) {
            if (self.topics[emitterName] == undefined || self.topics[emitterName][topic] == undefined) {
                return;
            }
            var index = self.topics[emitterName][topic][self.getSyncType(async)].indexOf(callback);
            if (index > -1) {
                self.topics[emitterName][topic][self.getSyncType(async)].splice(index, 1);
            }
        };

        /**
         * Convenience function that returns the correct string that denotes async or sync callbacks.
         * @param isAync
         * @returns {string} the key
         */
        self.getSyncType = function(isAync) {
            return isAync ? ASYNC_CALLBACKS : SYNC_CALLBACKS;
        };

        /**
         * Calls all callbacks associated with this emitter name/topic combination.
         * @param emitterName the emitter name
         * @param topic the topic
         * @param target the target of this event, this will mean different things in different areas
         * @param data extra data to be passed in the event to the callback
         */
        self.emit = function(emitterName, topic, target, data) {
            self.register(emitterName);
            self.ensureTopicExists(emitterName, topic);

            var asyncCallbacks = [];
            var syncCallbacks = [];
            var asyncEvent = new Event(emitterName, topic, target, data, true);
            var syncEvent = new Event(emitterName, topic, target, data, false);

            if (emitterName != ALL) {
                //get all subscribed callbacks to the actual emitter name
                asyncCallbacks = asyncCallbacks.concat(self.topics[emitterName][topic][ASYNC_CALLBACKS]);
                syncCallbacks = syncCallbacks.concat(self.topics[emitterName][topic][SYNC_CALLBACKS]);
                //get all subscribed to this topic under the ALL emitter name
                asyncCallbacks = asyncCallbacks.concat(self.topics[ALL][topic][ASYNC_CALLBACKS]);
                syncCallbacks = syncCallbacks.concat(self.topics[ALL][topic][SYNC_CALLBACKS]);
            } else {
                for (var eName in self.topics) {
                    if (self.topics[eName][topic] != undefined) {
                        asyncCallbacks = asyncCallbacks.concat(self.topics[eName][topic][ASYNC_CALLBACKS]);
                        syncCallbacks = syncCallbacks.concat(self.topics[eName][topic][SYNC_CALLBACKS]);
                    }
                }
            }

            //emit events (do the async ones first)
            for (var i = 0; i < asyncCallbacks.length; i++) {
                self.rawEmit(asyncEvent, asyncCallbacks[i]);
            }
            for (i = 0; i < syncCallbacks.length; i++) {
                self.rawEmit(syncEvent, syncCallbacks[i]);
            }
        };

        /**
         * Actually emits the event to the callback in the correct way.
         * @param event the event
         * @param callback the callback
         */
        self.rawEmit = function(event, callback) {
            if (event.async) {
                setTimeout(function() {
                    callback(event);
                }, 0);
            } else {
                callback(event);
            }
        };

        /**
         * Ensures that the topic exists for the given emitter name and also ALL.
         * @param emitterName the emitter name
         * @param topic the topic
         */
        self.ensureTopicExists = function(emitterName, topic) {
            if (self.topics[emitterName][topic] == undefined) {
                self.topics[emitterName][topic] = {};
                self.topics[emitterName][topic][ASYNC_CALLBACKS] = [];
                self.topics[emitterName][topic][SYNC_CALLBACKS] = [];
                //make an ALL entry too but only if there isn't already one there
            }
            if (emitterName != ALL && self.topics[ALL][topic] == undefined) {
                self.topics[ALL][topic] = {};
                self.topics[ALL][topic][ASYNC_CALLBACKS] = [];
                self.topics[ALL][topic][SYNC_CALLBACKS] = [];
            }
        };

        self.isSubscribed = function(emitterName, topic, callback, async) {
            return (self.topics[emitterName] != undefined) &&
                    (self.topics[emitterName][topic] != undefined) &&
                    (self.topics[emitterName][topic][self.getSyncType(async)].indexOf(callback) > -1);
        };

        /**
         * Given a host object, binds the functions of the EventManager to it.
         * This is just a shortcut to allow direct access to the event manager of an object, e.g.:
         *    var a = new ObjectWithEventManager();
         *    a.subscribe("someEvent", function(event) {});
         * rather than:
         *    var a = new ObjectWithEventManager();
         *   a.eventManager.subscribe("someEvent", function(event) {});
         *
         * This could also be accomplished by the host declaring its own functions and just calling through
         * to its event manager in turn; this is a shortcut for that too.
         * @param host the object to bind the functions to.
         */
        self.bind = function(host) {
            host.subscribe = self.subscribe;
            host.unsubscribe = self.unsubscribe;
            host.emit = self.emit;
            host.register = self.register;
            host.rawEmit = self.rawEmit;
            host.getSyncType = self.getSyncType;
            host.isSubscribed = self.isSubscribed;
        }
    };

    return new EventManager();
});
define('shared/utils/eventUtils',[],
function() {
    /**
     * Convenience function which returns a function with the given scope.
     * Extra arguments can be passed to this function which will then be passed
     * to the method in addition to any other args passed when the callback is
     * called.
     * @param scope the scope that the method will applied with
     * @param method the function to call
     * @returns {Function}
     */
    var callback = function(scope, method) {
        var methodScope = scope;
        var f = method;
        var preArgs = Array.prototype.slice.call(arguments, 2);

        if (preArgs.length > 0)
            return function() {
                return f.apply(methodScope, preArgs.concat(Array.prototype.slice.call(arguments)));
            };

        return function() {
            return f.apply(methodScope, arguments);
        };
    };

    /**
     * Wrapper function that simply applies `addEventListener` to the first argument,
     *  using any remaining arguments as the arguments to that call
     * Note this is primarily a placeholder function to make future events managing refactoring easier; for example,
     *  using this function, it would be trivial to compile a list of all events the reader listens to
     * @param element the DOM element to add a listener to
     */
    var yuduAddEventListener = function(element) {
        var args = Array.prototype.slice.call(arguments, 1);
        element.addEventListener.apply(element, args);
    };

    /**
     * Wrapper function that simply applies `$.on` to the first argument,
     *  using any remaining arguments as the arguments to that call
     * Note this is primarily a placeholder function to make future events managing refactoring easier; for example,
     *  using this function, it would be trivial to compile a list of all jquery-triggered events the reader listens to
     * @param jQueryObject the $(selector) to add a listener to
     */
    var yuduOn = function(jQueryObject){
        var args = Array.prototype.slice.call(arguments,1);
        jQueryObject.on.apply(jQueryObject, args);
    };

    return {
        callback: callback,
        yuduAddEventListener : yuduAddEventListener,
        yuduOn : yuduOn
    };
});
define('shared/events',['shared/utils/eventUtils', 'jquery'],
    function(eventUtils, $) {

        var Events = function() {
            var self = this;
            $.extend(self, topics);

            // bind the utilities to this object
            self.callback = eventUtils.callback;
            self.yuduAddEventListener = eventUtils.yuduAddEventListener;
            self.yuduOn = eventUtils.yuduOn;
        };

        // Any topics that should be made globally available.
        var topics = {
            // General UI events.
            // There are several others in the more specific events.js files that could be moved here,
            // but which are currently only fired in one context (in the main reader, or in PhoneView).
            CRITICAL_ERROR: 'criticalError', // something went wrong that prevents the viewer functioning
            YUDU_BOOK_LOADED: 'yuduBookLoaded', // the yuduBook finished loading
            TAP: "tap", // A tap event happened within the article iframe

            LOADING_ACTIONS_DONE: "loadingActionsDone",

            RESIZE: 'resize', // the window was resized


            REQUEST_LOGIN_DETAILS: "requestLoginDetails",
            CHANGE_FOR_LOGIN_DETAILS: "changeForLoginDetails", // a change in login details is being supplied (before / triggering the change)
            LOGIN_DETAILS_CHANGED: "loginDetailsChanged", // a change in login details has occurred (after the change)
            LOGIN_SUCCESS: "loginSuccess",

            SHOW_LOGIN: "showLogin",
            NEEDS_BACKGROUND_LOGIN_ATTEMPT: "needsBackgroundLoginAttempt",

            // Global toolbar events (which individual toolbar implementations may implement or ignore as appropriate)
            SHOWHIDE_TOOLBAR: "showhideToolbar",

            // Sharing events
            SHARE_TO: {
                EMAIL: "email",
                FACEBOOK: "facebook",
                TWITTER: "twitter",
                LINKED_IN: "linkedIn"
            },
            // These are for when the dialogue opens/closes (as opposed to the separate events for completion of a
            // sharing action)
            SHARE_EMAIL_DIALOG_OPEN: "shareEmailOpen",
            SHARE_EMAIL_DIALOG_CLOSE: "shareEmailClose",

            // Events for shared UI controls.
            CLOSE_ACTIVE: "closeActive",

            // Events for Saml Login
            SAML_REQUEST_RECEIVED: "samlRequestReceived",
            SAML_AUTH_TOKEN_VALIDATION_RESPONSE_RECEIVED: "samlAuthTokenValidationResponseReceived"
        };

        return new Events();
    });

define('events',['shared/eventManager','shared/events', 'jquery'],
    function(eventManager, sharedEvents, $) {
        /*
         Events/topics.
         */
        var topics = {
            TILE_FETCHED: "tileFetched",
            TILE_FADE_START: "tileFadeStart",
            TILE_FADE_END: "tileFadeEnd",
            FETCH_TILE: "fetchTile",
            TOGGLE_KEY_NAVIGATION: 'toggleKeyNavigation',
            ZOOM: "zoom",
            ZOOM_SCALE: "zoomScale",
            BROWSER_ZOOM_LEVEL_CHANGED: "browserZoomLevelChanged",
            TOUCH: "touch",
            LEVEL_DRAGGED: "levelDragged",
            LOAD: "load",
            PAGE_CHANGED: "pageChanged",
            GOTO_PAGE: "goToPage",
            GOTO_PREVIOUS_PAGE: "goToPreviousPage",
            GOTO_NEXT_PAGE: "goToNextPage",
            READER_STARTED: "readerStarted",
            READER_LOADED: "readerLoaded",
            QUERY_STRING_PARSED: "queryStringParsed",
            ZOOMLEVEL_TILESLOADED: "zoomLevelTilesLoaded",
            SHIFTER_SPRINGING: "shifterSpringing",
            SHIFTER_ZOOMING: "shifterZooming",
            TWO_UP_CHANGED: "twoUpChanged",
            DRAG: "drag",
            DRAG_END: "dragEnd",
            DRAG_START: "dragStart",
            HISTORY_CHANGE: "historyChange",
            MOUSE_MOVE_STOP: "mouseMoveStop",
            INFORMATION_LOADED: "informationLoaded",
            HIDE_INFORMATION: "hideInformation",
            FIT_CHANGED: "fitChanged",
            LOGIN_DETAILS_FROM_LOCAL_STORAGE: "loginDetailsFromLocalStorage",
            DECRYPT_ALL_PAGES: "decryptAllPages",
            PAGE_DECRYPTED: "pageDecrypted",
            LOADING_FINISHED: "loadingFinished",
            TRIGGER: "trigger",
            YUDU_PREFIXED_MESSAGE_RECEIVED: "yuduPrefixedMessageReceived",
            MESSAGE_RECEIVED_FROM_ARTICLE_VIEW: "messageReceivedFromArticleView",
            OPEN_ARTICLE: "openArticle",
            VIEW_NOTE: "viewNote",
            NOTE_MOVED: "noteMoved",
            NOTE_TRANSFORM_CHECK: "noteTransformCheck",
            NOTE_DRAG_START: "noteDragStart",
            NOTES_BACKGROUND_INTERACTION: "notesBackgroundInteraction",
            NOTE_ADDED: "noteAdded",
            UGC_CHANGED: "ugcChanged",
            MEDIA_TOGGLED: "mediaToggled",
            LIVE_URL_RECEIVED: "liveUrlReceived",
            PUBLIC_API_LOGIN_STATE_CHANGED: "publicApiLoginStateChanged",
            CLOSE_LIGHTBOX: "closeLightbox",
            OVERLAY_FADE_START: "overlayFadeStart",
            OVERLAY_FADE_END: "overlayFadeEnd",
            OVERLAY_FADE_OUT_START: "overlayFadeOutStart",
            OVERLAY_FADE_OUT_END: "overlayFadeOutEnd",
            OVERLAY_FLASH_START: "overlayFlashStart",
            OVERLAY_FLASH_END: "overlayFlashEnd",
            OVERLAY_TWEENS_REMOVED: "overlayTweensRemoved",
            LAUNCHABLE_HTML_HOVER_ACTION: "launchableHtmlHoverAction",
            READER_TICK_STAGE_UPDATE: "readerTickStageUpdate",
            INIT_GA_CONSENT: "initGaConsent",
        };

        var brandableSubmoduleTopics = {
            COMMON: {
                RESIZE: "brandableResize",
                TOUCH: "brandableTouch",
                UGC_BOOKMARKS_CHANGED: "ugcBookmarksChanged",
                UGC_PAGE_HIGHLIGHTS_CHANGED: "ugcPageHighlightsChanged",
                UGC_NOTES_CHANGED: "ugcNotesChanged",
                LOGIN_SUCCESS: "brandableLoginSuccess",
                LOGIN_APPROVED: "brandableLoginApproved"
            },
            TOOLBAR: {
                FIT_WIDTH_OR_SCREEN_ACTION: "fitWidthOrScreenAction",
                UPDATE_SHOPPING_CART_BUTTON: "updateShoppingCartButton",
                UPDATE_BOOKMARK_BUTTON: "updateBookmarkButton",
                SEARCH_READY: "searchReady",
                LOADED: "brandableToolbarLoaded",
                BUTTON_TRIGGER_KEY_PRESSED: "buttonTriggerKeyPressed"
            },
            THUMBNAILS: {
                PAGE_CHANGED: "brandablePageChanged",
                TOGGLE_THUMBNAILS: "toggleThumbnails",
                UPDATE_THUMBNAIL: "updateThumbnail",
                HIDE_THUMBNAILS_PAGE_NOT_CHANGED: "hideThumbnailsNoPageChanged"
            },
            DOWNLOAD_PDF_CUSTOM_SELECTION_TOOLBAR: {
                UPDATE_SELECT_BUTTON_LABEL: "updateSelectButtonLabel",
                TOOLBAR_TOGGLED: "toolbarToggled",
                UPDATE_CURRENT_PAGES: "updateCurrentPages"
            },
            DRAWING_TOOLBARS: {
                TOGGLE_TOOLBARS: "toggleToolbars"
            },
            LOADING: {
                DISPLAY_PROGRESS: "displayProgress",
                END_LOADING: "endLoading"
            },
            STATISTICS: {
                VISITED: "yuduStats_visited",
                PAGE_VIEWED: "yuduStats_page_viewed",
                SEARCHED: "yuduStats_searched",
                EMAIL_LINK_CLICKED: "yuduStats_overlay_email",
                WEB_LINK_CLICKED: "yuduStats_overlay_weblink",
                PAGE_LINK_CLICKED: "yuduStats_overlay_pagelink",
                PRODUCT_CODE_CLICKED: "yuduStats_overlay_productCode",
                LOGO_CLICKED: "yuduStats_logo_clicked",
                VIDEO_WATCHED: "yuduStats_video_watched",
                VIDEO_RESUMED: "yuduStats_video_resumed",
                VIDEO_MILESTONE_REACHED: "yuduStats_video_milestone_reached",
                VIDEO_FINISHED: "yuduStats_video_finished",
                EMAILED: "yuduStats_emailed",
                SUBSCRIBED: "yuduStats_subscribed",
                TWEETED: "yuduStats_tweeted",
                FACEBOOKED: "yuduStats_facebooked"
            }
        };

        var BrandableSubmoduleEvents = function () {
            var self = sharedEvents;

            // bind the topics to this object
            $.extend(self, brandableSubmoduleTopics);

            // bind the event manager to this object
            //  note we do this explicitly to ensure only what is needed is exposed
            self.subscribe = eventManager.subscribe;
            self.unsubscribe = eventManager.unsubscribe;
            self.isSubscribed = eventManager.isSubscribed;

            // bind private event manager members to this object
            self.ALL = eventManager.__ALL;
            return self;
        };

        // make the brandable submodule topics a global object
        window.yudu_events = new BrandableSubmoduleEvents();

        var extendSharedEvents = function() {
            var self = sharedEvents;

            // bind the topics to this object
            $.extend(self, topics);

            // bind the event manager to this object
            eventManager.bind(self);

            // bind private event manager members to this object
            self.EventManager = eventManager.__Constructor;
            self.ALL = eventManager.__ALL;
            return self;
        };

        return extendSharedEvents();
    });

define('shared/config',[], function() {
    // config is for global values that can change over the lifetime of a reader instance
    var Config = function() {
        var self = this;
        self.__helpers = new ConfigHelpers(self);

        var liveUrl = false;

        // the size AFTER pixel adjustment (i.e. what we SHOULD USE)
        // these get overridden during initialisation with more sensible values
        self.width = 800;
        self.height = 450;
        self.pixelDensity = window.devicePixelRatio || 1;
        self.shouldUseHighRes = self.__helpers.shouldUseHighRes;
        self.isDesktop = false;
        self.clickAction = false;
        self.deviceUsesClicks = true;
        self.urlNavigationTarget = '_blank';
        self.nativeAndroidGoogleAnalyticsEnabled = false;

        self.queryObject = {};

        self.getQueryObject = function () {
            return self.queryObject;
        };

        self.setQueryObject = function (queryObject) {
            self.queryObject = queryObject;
        };

        self.getFromQuery = function (key) {
            return self.queryObject[key];
        };

        self.setIsDesktop = function (isDesktop) {
            self.isDesktop = isDesktop;
            self.deviceUsesClicks = isDesktop || !('ontouchstart' in document.documentElement);
            self.clickAction = self.deviceUsesClicks ? 'click' : 'touchstart';
        };
        
        self.isLoggedIn = false;
    };

    var ConfigHelpers = function(configModule) {
        var self = this;
        var configMod = configModule;

        // concept borrowed from the Reader's `src/ui/uiTools#shouldUseHighRes`
        self.shouldUseHighRes = function() {
            return configMod.pixelDensity >= 1.5;
        };
    };

    return new Config();
});

define('config',['events', 'shared/config', 'jquery'],
    function(events, sharedConfig, $) {
        // config is for global values that can change over the lifetime of a reader instance
        // TODO tidy up this module so it either uses getters/setters or it uses `this`

        function Config() {
            /* note that changing the default orientation can impact other things, such as the page mode, which defaults to
             *  two-page mode, but only _changes_ on a change of orientation */
            var orientation = 0;

            var pixelDensity = window.devicePixelRatio || 1;

            // canvas size WITHOUT pixelDensity. Only for setting canvas screen size.
            var canvasResizeWidth = 800;
            var canvasResizeHeight = 450;

            //tile overlap size (default to 1, will be overwritten if present in yuduBook.json)
            var overlap = 1;

            // page mode - note that these default values depend on the expected behaviour for desktop browser orientation
            var twoPageMode = true;
            var pageModeStopToggle = false;

            var fitOnlyWidth = false;

            var lowestZoomLevel = 0;
            var readerYOffset = 0;

            // Background colours
            var bgTopColour = "1B1B1B";
            var bgBottomColour = "1B1B1B";

            //Overlay colours
            var emailLinkOverlayColour = "00FF00";
            var phoneOverlayColour = "B3B1DE";
            var pageLinkOverlayColour = "0000FF";
            var webLinkOverlayColour = "FF0000";
            var productOverlayColour = "FFFF00";
            var launchableHtmlOverlayColour = "FF9900";
            var contentOverlayColour = "FF00FF";
            var searchOverlayColour = "008000";

            var overlayAlpha = 0.2;
            var transparentProductOverlays = false;

            var logoLinkUrl = false;

            var isPreviewEdition = false;
            var decryptionKey = false;
            var contentDecryptionHeaders = {};
            var pageDecrypted = false;

            var hasIntroPage = false;

            var editionListUrl = "edition_list/editions.html";

            var highlightLinksOnLoadEnabled = true;

            var orderFormEnabled = false;

            var bookmarksEnabled = false;

            var notesEnabled = false;

            var highlightsEnabled = false;

            var emailCollectionEnabled = false;

            var disableToggleToolbar = false;

            var fullscreenCompatible = document.body.requestFullscreen || document.body.msRequestFullscreen
                || document.body.mozRequestFullScreen || document.body.webkitRequestFullscreen;
            var tryToOpenWebOverlaysInNewWindow = true;

            var disableExtraZoom = false;

            var rememberedPageDisabled = false;

            var pageTurnEnabled = false;
            var pageTurnAudioEnabled = false;
            var pageTurnDurationMs = false;

            var setFitOnlyWidth = function (fitWidth) {
                if (this.fitOnlyWidth == fitWidth)
                    return;
                this.fitOnlyWidth = fitWidth;
                events.emit(events.ALL, events.FIT_CHANGED, this, {});
                events.emit(events.ALL, events.TOOLBAR.FIT_WIDTH_OR_SCREEN_ACTION, this, { fitOnlyWidth: fitWidth });
            };

            var userPreferences = {};

            var updateUserPreferenceSetting = function(setting, newValue) {
                userPreferences[setting] = newValue;
            };

            return {
                orientation: orientation,
                readerYOffset: readerYOffset,
                overlap: overlap,
                twoPageMode: twoPageMode,
                pageModeStopToggle: pageModeStopToggle,
                canvasResizeWidth: canvasResizeWidth,
                canvasResizeHeight: canvasResizeHeight,
                pixelDensity: pixelDensity,
                lowestZoomLevel: lowestZoomLevel,
                fitOnlyWidth: fitOnlyWidth,
                setFitOnlyWidth: setFitOnlyWidth,
                bgTopColour: bgTopColour,
                bgBottomColour: bgBottomColour,
                emailLinkOverlayColour: emailLinkOverlayColour,
                phoneOverlayColour: phoneOverlayColour,
                pageLinkOverlayColour: pageLinkOverlayColour,
                productOverlayColour: productOverlayColour,
                webLinkOverlayColour: webLinkOverlayColour,
                launchableHtmlOverlayColour: launchableHtmlOverlayColour,
                contentOverlayColour: contentOverlayColour,
                searchOverlayColour: searchOverlayColour,
                overlayAlpha: overlayAlpha,
                transparentProductOverlays: transparentProductOverlays,
                logoLinkUrl: logoLinkUrl,
                isPreviewEdition: isPreviewEdition,
                decryptionKey: decryptionKey,
                contentDecryptionHeaders: contentDecryptionHeaders,
                pageDecrypted: pageDecrypted,
                hasIntroPage: hasIntroPage,
                editionListUrl: editionListUrl,
                orderFormEnabled: orderFormEnabled,
                bookmarksEnabled: bookmarksEnabled,
                notesEnabled: notesEnabled,
                highlightsEnabled: highlightsEnabled,
                highlightLinksOnLoadEnabled: highlightLinksOnLoadEnabled,
                disableToggleToolbar: disableToggleToolbar,
                fullscreenCompatible: fullscreenCompatible,
                tryToOpenWebOverlaysInNewWindow: tryToOpenWebOverlaysInNewWindow,
                disableExtraZoom: disableExtraZoom,
                rememberedPageDisabled: rememberedPageDisabled,
                emailCollectionEnabled: emailCollectionEnabled,
                pageTurnEnabled: pageTurnEnabled,
                pageTurnAudioEnabled: pageTurnAudioEnabled,
                pageTurnDurationMs: pageTurnDurationMs,
                userPreferences: userPreferences,
                updateUserPreferenceSetting: updateUserPreferenceSetting
            };
        }

        return $.extend(sharedConfig, new Config());
    });

define('shared/constants',[], function() {
    // constants is for global values that will not be changed during the lifetime of a reader instance

    var constants = {

        toolbarIconBasePath: "./resources/artwork/",
        toolbarIconFileExtension: ".png",
        toolbarIconHighResPrefix: 'high_',

        baseResourcesFolder: "resources/",
        baseRequiredFolder: "required/",

        maxYuduBookFetchAttempts: 3,

        // these correspond to CSS classes used in message boxes
        messageTypes: {
            failure: "yudu_failure",
            success: "yudu_success",
            default: "yudu_default"
        },

        baseThumbnailFolder: "thumbnails/",  // the base folder containing the page thumbnails
        shareSiteTimeout: 3000,     //time to wait in milliseconds before timing out a share site request

        brandingConfigFiles: {
            toolbar: "./resources/toolbar/toolbarConfig.json",
            toolbarPhoneview: "./resources/toolbarPhoneview/toolbarPhoneviewConfig.json",
            thumbnails: "./resources/thumbnails/thumbnailsConfig.json",
            drawingToolbars: "./resources/drawingToolbars/drawingToolbarsConfig.json",
            downloadPdfCustomSelectionToolbar: "./resources/downloadPdfCustomSelectionToolbar/downloadPdfCustomSelectionToolbarConfig.json",
            loading: "./resources/loading/loadingConfig.json"
        }
    };

    return constants;
});

define('constants',['shared/constants', 'jquery'], function(sharedConstants, $) {
    // constants is for global values that will not be changed during the lifetime of a reader instance

    var constants = {
        fps: 60,                            //frame rate of the reader
        tickTimeMs: 1000 / 60,
        fetchHandlerpps: 5,
        pps: 3,                             // processes per second (number of times a second any tiles are loaded from the fetch queue)
        daemonpps: 30,                      // processes per second (number of times a second any tiles are loaded from the fetch queue) in the daemon

        swapTweenTime: 400,                 // level transition tween time
        tileFadeTime: 200,                  // time tiles take to fade in
        overlayFadeInTime: 150,             // time period over which overlays fade in
        overlayFadeOutTime: 500,            // time period over which overlays fade out
        pauseBeforeOverlayFlash: 400,       // default pause before overlay flash
        toolbarTimeout: 4000,               // time until toolbar disappears (phablet only)
        pageNumTransTime: 600,              // time taken to complete 1-2 page up mode change.

        tileFetchBatchSize: 8,              // the number of tiles to load at the same time
        daemonTileFetchBatchSize: 16,       // the number of tiles to load at the same time in the daemon
        maxNumTilesInQueue: 20,             // if there are fewer than this number of tiles loading. Load more tiles.

        maxPhoneWidth: 480,                 // max pixel dimensions we consider to definitely be a phone
        boundaryWidth: 100,                 // shifter boundary width which some part of the reader must remain within
        minAudioVideoWidth: 120,            // min width of an audio/video/urlContent overlay
        turnPageScreenTapThreshold: 0.1,    // amount of the left/right screen that will change the page.

        tileFailureColour: "#FF0000",       // if a tile image fails to be fetched, display a shape with this colour
        overlayFocusAlpha: 0.5,             // overlay alpha when not faded

        baseTileFolder: "tiles/",                           // the base folder containing the page tile folder
        overlayBackgroundUrl: "./required/pixel.png",        //url for the overlay background
        tileBackgroundUrl: "./resources/artwork/tileBackground.png",  //url for the tile image before the actual image is loaded
        tileErrorUrl: "./resources/artwork/tileError.png",            //url for the tile error image
        priceListUrl: "./pricelist.json",                   // product overlay data
        rolloversUrl: "./rollovers.json",                   // product overlay data
        customStringsPackURL: "./resources/customStringsPack.json",              // Contains any custom strings a client might have uploaded.
        informationDesktop: "./resources/info/desktop.html",                // html page for the desktop control information
        informationTouch: "./resources/info/touch.html",                // html page for the touch device control information
        rolloverTemplate: "./resources/rollovers/productDetailsTemplate.html",                // html template for rollovers
        stringsUrl: "./resources/strings.json",
        placeholderBackgroundUrl: "./resources/artwork/placeholderBackground.png",            //url for the placeholder background
        playButtonUrl: "./resources/artwork/playButton.png",            //url for the play button
        playButtonTranslucentUrl: "./resources/artwork/playButtonTranslucent.png",        //url for the opaque play button
        logoUrl: "./resources/logo.png",    //url for the logo
        wordPositionsFolder: "wordPositions/",
        basePrintablesFolder: "./print/", // url for the folder containing all additional printable resources
        articleViewerPage: "./htmlArticles/index.html",
        speakerNotesFolder: "speakerNotes/",

        audioResourcesFolder: "./resources/assets/audio/",
        tileFetcherDaemonLocation: 'readerDaemon.min.js',

        orientations: {
            landscape: 0,
            portrait: 1
        },

        ugcNoteDragTimeout: 700, // time to hold note before it can be moved
        ugcNotePlaceholderUrl: "./resources/artwork/note_placeholder.png", // url for the note icon
        ugcNotePlaceholderDragUrl: "./resources/artwork/note_placeholder_drag.png", // url for the dragged-note icon
        ugcSyncRetryTimer: 30000, // time to wait between sync reattempts after a failure (in ms)
        ugcSyncRefreshTimer: 1800000, // how often to refresh the sync (30mins in ms)

        maxOptionalJsonFetchAttempts: 2,
        maxWordPosFetchAttempts: 2,
        tileFetchRetryCount: 3,                   // number of times to try to fetch a tile from the host
        tileCheckRetryCount: 6,                   // number of times to retry a tile fetch after the blob got lost (IE11)

        urlContentOverlayTypes: {
            image: "image",
            video: "video",
            audio: "audio",
            youTube: "youTube",
            unknown: "unknown"
        },


    };

    return $.extend(sharedConstants, constants);
});

define('shared/resources',['shared/events'], function(events) {
// resources is for global values that are loaded once and then set for the lifetime of a reader instance

    var Resources = function() {
        var self = this;
        
        // settings json file. Mildly important.
        self.yuduBook = false;

        // The toolbar data
        self.toolbarConfig = false;
        self.toolbarHtml = false;

        self.setYuduBook = function (yuduBook) {
            self.yuduBook = yuduBook;
        };

        self.getYuduBook = function() {
            return self.yuduBook;
        };
    };

    return new Resources();
});

define('resources',['shared/resources', 'jquery'], function(sharedResources, $) {
    // resources is for global values that are loaded once and then set for the lifetime of a reader instance

    var Resources = function() {
        var self = this;
        $.extend(self, sharedResources);

        //the semi-transparent pixel image used for overlays so they work on the iPhone 4
        self.overlayBackground = false;

        //the background to use for a tile before the image is loaded
        self.tileBackground = false;

        //the image used when a tile fails to load
        self.tileError = false;

        //the background for media overlay placeholders
        self.placeholderBackground = false;

        //the play button for media overlay placeholders
        self.playButton = false;

        //the play button for media overlay placeholders
        self.playButtonTranslucent = false;

        //the toolbar logo
        self.logo = false;

        // Product Overlay details. Optional.
        self.priceList = false;

        // Product rollover details. Optional.
        self.rollovers = false;

        //Information HTML page
        self.infoPage = false;

        // The word positions for each page
        self.wordPositions = false;

        // The thumbnails data
        self.thumbnailsConfig = false;
        self.thumbnailsHtml = false;

        // The thumbnails data
        self.drawingToolbarsConfig = false;
        self.drawingToolbarsHtml = false;

        // The download pdf custom selection toolbar data
        self.downloadPdfCustomSelectionToolbarConfig = false;
        self.downloadPdfCustomSelectionToolbarHtml = false;

        //Loading data
        self.loadingConfig = false;
        self.loadingHtml = false;

        self.setYuduBook = function (yuduBook) {
            self.yuduBook = yuduBook;
            sharedResources.setYuduBook(yuduBook);
        };
    }

    return new Resources();
});

define('model/zoomLevel',[],
    function() {

        var ZoomLevel = function(z, width, height, tileWidth, tileHeight, baseURL, filePattern) {
            this.z = z;
            this.width = width;
            this.height = height;
            this.tileWidth = tileWidth;
            this.tileHeight = tileHeight;
            this.baseURL = baseURL;
            this.filePattern = filePattern;

            //size in number of tiles
            this.size = {
                x: Math.ceil(this.width / this.tileWidth),
                y: Math.ceil(this.height / this.tileHeight)
            };
        };

        return {
            ZoomLevel: ZoomLevel
        };
    });

define('views/zoomLevelView',['easel', 'config', 'resources', 'jquery', 'events'],
    function(createjs, config, resources, $, events) {

        /**
         * Class for that represents a zoom level and contains basically just the createjs container object.
         * @param width
         * @param height
         * @constructor
         */
        var ZoomLevelView = function(width, height) {
            //container for this zoom level; tiles will be added to this when rendered
            this.container = new createjs.Container();
            this.container.regX = width / 2;
            this.container.regY = height / 2;
            this.container.x = 0;
            this.container.y = 0;

            this.width = width;
            this.height = height;

            this.background = new createjs.Shape();
            this.background.graphics.beginBitmapFill(resources.tileBackground).drawRect(1, 1, this.width - 2, this.height - 2);
            this.container.addChild(this.background);

            /**
             * Draws a tile to the container by adding it as a child.
             * @param tile
             */
            this.drawTile = function(tile) {
                this.container.addChildAt(tile.image, 1);

                var isOnScreen = true;
                var leftTop = this.container.localToGlobal(tile.x, tile.y);
                var rightBottom = this.container.localToGlobal(tile.x + tile.width, tile.y + tile.width);

                if (rightBottom.y < 0 || rightBottom.x < 0 || leftTop.y > config.height || leftTop.x > config.width)
                    isOnScreen = false;

                if (isOnScreen) {
                    tile.triggerFadeIn();
                }
            };

            /**
             * Removes the background from the container
             */
            this.removeBackground = function() {
                this.container.removeChild(this.background);
            };

            /**
             * Hides this zoom level.
             */
            this.hide = function() {
                this.container.visible = false;
            };

            this.setAlignment = function(alignment) {
                var x = this.width / 2;
                switch (alignment) {
                    case createjs.Alignment.LEFT:
                        x = 0;
                        break;
                    case createjs.Alignment.RIGHT:
                        x = this.width;
                        break;
                }
                this.container.regX = x;
                this.container.regY = this.height / 2;
            };

            /**
             * Shows this zoom level.
             */
            this.show = function() {
                this.container.visible = true;
            };

            this.unload = function() {
                this.removeBackground();
                this.container.removeAllChildren();
                this.container.parent.removeChild(this.container);
                this.background = null;
                this.container = null;
            };
        };

        return {
            ZoomLevelView: ZoomLevelView
        };
    });

define('fetching/tileFetcher',['events', 'config', 'constants', 'resources'],
    function(events, config, constants, resources) {

        var EMITTER_NAME = "tileFetcher";

        /**
         * ONLY FETCH HANDLER SHOULD DIRECTLY CALL THIS CLASS!!!
         * DO NOT TOUCH!
         * @constructor
         */
        var TileFetcher = function() {

            //used to determine the download speed
            this.totalDownloaded = 0;
            this.averageDownloadTime = -1;

            this.start = function() {};
            this.stop = function() {};
            this.enqueue = function(request) {};
            this.flushQueues = function() {};
            this.fetchQueueSize = function() {};
            this.isBusy = function () {};


            /**
             * Adds the given tiles to the fetch queue.
             * @param tiles the tiles to fetch
             * @param zoomLevel the object to call drawTile on when the tile is downloaded
             */
            this.fetch = function(tiles, zoomLevel, priority) {
                // Called when the tile is downloaded (successfully or with errors).
                var onFinished = function() {
                    this.zoomLevel.tileLoaded(this.tile);
                    events.emit(EMITTER_NAME, events.TILE_FETCHED, this, {tile: this.tile, numTiles: tiles.length, zoomLevel: this.zoomLevel});
                };

                for (var i = 0; i < tiles.length; i++) {
                    var fetchRequest = {tiles: tiles, tile: tiles[i], zoomLevel: zoomLevel, fetchFailureCount: 0, checkFailureCount: 0, id: null};
                    fetchRequest.onFinished = events.callback(fetchRequest, onFinished);
                    fetchRequest.priority = !!priority;
                    tiles[i].setQueued();
                    this.enqueue(fetchRequest);
                }
            };


            /**
             * Called if the download succeeds.
             * @param img
             * @param startTime
             * @param request
             */
            this.requestSuccess = function(img, startTime, request) {
                this.totalDownloaded++;
                var newTime = Date.now() - startTime;
                this.averageDownloadTime = this.averageDownloadTime > 0 ? (this.averageDownloadTime + newTime) / 2 : newTime;

                request.tile.imageWidth = img.width;
                request.tile.imageHeight = img.height;
                request.tile.image = new createjs.Bitmap(img);
                request.tile.image.set({x: request.tile.x, y: request.tile.y, width: request.tile.width, height: request.tile.height});
                request.tile.setFetched();
                request.onFinished();
            };


            this.requestFailed = function(request) {
                request.tile.imageWidth = request.tile.width;
                request.tile.imageHeight = request.tile.height;
                if (resources.tileError) {
                    request.tile.image = new createjs.Shape();
                    var matrix = new createjs.Matrix2D;
                    var scaleX = request.tile.width / resources.tileError.width;
                    var scaleY = request.tile.height / resources.tileError.height;
                    matrix.scale(scaleX, scaleY);
                    request.tile.image.graphics.beginBitmapFill(resources.tileError, "no-repeat", matrix).drawRect(0, 0, request.tile.width, request.tile.height);
                }
                else {
                    request.tile.image = new createjs.Shape();
                    request.tile.image.graphics.beginFill(constants.tileFailureColour).drawRect(0, 0, request.tile.width, request.tile.height);
                }
                request.tile.image.set({x: request.tile.x, y: request.tile.y, width: request.tile.width, height: request.tile.height});
                request.tile.setFetched();
                request.onFinished();
            };

            this.isFetchQueueEmpty = function() {
                return this.fetchQueueSize() == 0;
            };

            this.getAverageDownloadTime = function() {
                return this.averageDownloadTime;
            };
        };

        return {
            TileFetcher: TileFetcher
        };
    });

/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
var CryptoJS=CryptoJS||function(u,p){var d={},l=d.lib={},s=function(){},t=l.Base={extend:function(a){s.prototype=this;var c=new s;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},
r=l.WordArray=t.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=p?c:4*a.length},toString:function(a){return(a||v).stringify(this)},concat:function(a){var c=this.words,e=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var k=0;k<a;k++)c[j+k>>>2]|=(e[k>>>2]>>>24-8*(k%4)&255)<<24-8*((j+k)%4);else if(65535<e.length)for(k=0;k<a;k+=4)c[j+k>>>2]=e[k>>>2];else c.push.apply(c,e);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<
32-8*(c%4);a.length=u.ceil(c/4)},clone:function(){var a=t.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],e=0;e<a;e+=4)c.push(4294967296*u.random()|0);return new r.init(c,a)}}),w=d.enc={},v=w.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++){var k=c[j>>>2]>>>24-8*(j%4)&255;e.push((k>>>4).toString(16));e.push((k&15).toString(16))}return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j+=2)e[j>>>3]|=parseInt(a.substr(j,
2),16)<<24-4*(j%8);return new r.init(e,c/2)}},b=w.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var e=[],j=0;j<a;j++)e.push(String.fromCharCode(c[j>>>2]>>>24-8*(j%4)&255));return e.join("")},parse:function(a){for(var c=a.length,e=[],j=0;j<c;j++)e[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new r.init(e,c)}},x=w.Utf8={stringify:function(a){try{return decodeURIComponent(escape(b.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return b.parse(unescape(encodeURIComponent(a)))}},
q=l.BufferedBlockAlgorithm=t.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=x.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,e=c.words,j=c.sigBytes,k=this.blockSize,b=j/(4*k),b=a?u.ceil(b):u.max((b|0)-this._minBufferSize,0);a=b*k;j=u.min(4*a,j);if(a){for(var q=0;q<a;q+=k)this._doProcessBlock(e,q);q=e.splice(0,a);c.sigBytes-=j}return new r.init(q,j)},clone:function(){var a=t.clone.call(this);
a._data=this._data.clone();return a},_minBufferSize:0});l.Hasher=q.extend({cfg:t.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){q.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,e){return(new a.init(e)).finalize(b)}},_createHmacHelper:function(a){return function(b,e){return(new n.HMAC.init(a,
e)).finalize(b)}}});var n=d.algo={};return d}(Math);
(function(){var u=CryptoJS,p=u.lib.WordArray;u.enc.Base64={stringify:function(d){var l=d.words,p=d.sigBytes,t=this._map;d.clamp();d=[];for(var r=0;r<p;r+=3)for(var w=(l[r>>>2]>>>24-8*(r%4)&255)<<16|(l[r+1>>>2]>>>24-8*((r+1)%4)&255)<<8|l[r+2>>>2]>>>24-8*((r+2)%4)&255,v=0;4>v&&r+0.75*v<p;v++)d.push(t.charAt(w>>>6*(3-v)&63));if(l=t.charAt(64))for(;d.length%4;)d.push(l);return d.join("")},parse:function(d){var l=d.length,s=this._map,t=s.charAt(64);t&&(t=d.indexOf(t),-1!=t&&(l=t));for(var t=[],r=0,w=0;w<
l;w++)if(w%4){var v=s.indexOf(d.charAt(w-1))<<2*(w%4),b=s.indexOf(d.charAt(w))>>>6-2*(w%4);t[r>>>2]|=(v|b)<<24-8*(r%4);r++}return p.create(t,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}})();
(function(u){function p(b,n,a,c,e,j,k){b=b+(n&a|~n&c)+e+k;return(b<<j|b>>>32-j)+n}function d(b,n,a,c,e,j,k){b=b+(n&c|a&~c)+e+k;return(b<<j|b>>>32-j)+n}function l(b,n,a,c,e,j,k){b=b+(n^a^c)+e+k;return(b<<j|b>>>32-j)+n}function s(b,n,a,c,e,j,k){b=b+(a^(n|~c))+e+k;return(b<<j|b>>>32-j)+n}for(var t=CryptoJS,r=t.lib,w=r.WordArray,v=r.Hasher,r=t.algo,b=[],x=0;64>x;x++)b[x]=4294967296*u.abs(u.sin(x+1))|0;r=r.MD5=v.extend({_doReset:function(){this._hash=new w.init([1732584193,4023233417,2562383102,271733878])},
_doProcessBlock:function(q,n){for(var a=0;16>a;a++){var c=n+a,e=q[c];q[c]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360}var a=this._hash.words,c=q[n+0],e=q[n+1],j=q[n+2],k=q[n+3],z=q[n+4],r=q[n+5],t=q[n+6],w=q[n+7],v=q[n+8],A=q[n+9],B=q[n+10],C=q[n+11],u=q[n+12],D=q[n+13],E=q[n+14],x=q[n+15],f=a[0],m=a[1],g=a[2],h=a[3],f=p(f,m,g,h,c,7,b[0]),h=p(h,f,m,g,e,12,b[1]),g=p(g,h,f,m,j,17,b[2]),m=p(m,g,h,f,k,22,b[3]),f=p(f,m,g,h,z,7,b[4]),h=p(h,f,m,g,r,12,b[5]),g=p(g,h,f,m,t,17,b[6]),m=p(m,g,h,f,w,22,b[7]),
f=p(f,m,g,h,v,7,b[8]),h=p(h,f,m,g,A,12,b[9]),g=p(g,h,f,m,B,17,b[10]),m=p(m,g,h,f,C,22,b[11]),f=p(f,m,g,h,u,7,b[12]),h=p(h,f,m,g,D,12,b[13]),g=p(g,h,f,m,E,17,b[14]),m=p(m,g,h,f,x,22,b[15]),f=d(f,m,g,h,e,5,b[16]),h=d(h,f,m,g,t,9,b[17]),g=d(g,h,f,m,C,14,b[18]),m=d(m,g,h,f,c,20,b[19]),f=d(f,m,g,h,r,5,b[20]),h=d(h,f,m,g,B,9,b[21]),g=d(g,h,f,m,x,14,b[22]),m=d(m,g,h,f,z,20,b[23]),f=d(f,m,g,h,A,5,b[24]),h=d(h,f,m,g,E,9,b[25]),g=d(g,h,f,m,k,14,b[26]),m=d(m,g,h,f,v,20,b[27]),f=d(f,m,g,h,D,5,b[28]),h=d(h,f,
m,g,j,9,b[29]),g=d(g,h,f,m,w,14,b[30]),m=d(m,g,h,f,u,20,b[31]),f=l(f,m,g,h,r,4,b[32]),h=l(h,f,m,g,v,11,b[33]),g=l(g,h,f,m,C,16,b[34]),m=l(m,g,h,f,E,23,b[35]),f=l(f,m,g,h,e,4,b[36]),h=l(h,f,m,g,z,11,b[37]),g=l(g,h,f,m,w,16,b[38]),m=l(m,g,h,f,B,23,b[39]),f=l(f,m,g,h,D,4,b[40]),h=l(h,f,m,g,c,11,b[41]),g=l(g,h,f,m,k,16,b[42]),m=l(m,g,h,f,t,23,b[43]),f=l(f,m,g,h,A,4,b[44]),h=l(h,f,m,g,u,11,b[45]),g=l(g,h,f,m,x,16,b[46]),m=l(m,g,h,f,j,23,b[47]),f=s(f,m,g,h,c,6,b[48]),h=s(h,f,m,g,w,10,b[49]),g=s(g,h,f,m,
E,15,b[50]),m=s(m,g,h,f,r,21,b[51]),f=s(f,m,g,h,u,6,b[52]),h=s(h,f,m,g,k,10,b[53]),g=s(g,h,f,m,B,15,b[54]),m=s(m,g,h,f,e,21,b[55]),f=s(f,m,g,h,v,6,b[56]),h=s(h,f,m,g,x,10,b[57]),g=s(g,h,f,m,t,15,b[58]),m=s(m,g,h,f,D,21,b[59]),f=s(f,m,g,h,z,6,b[60]),h=s(h,f,m,g,C,10,b[61]),g=s(g,h,f,m,j,15,b[62]),m=s(m,g,h,f,A,21,b[63]);a[0]=a[0]+f|0;a[1]=a[1]+m|0;a[2]=a[2]+g|0;a[3]=a[3]+h|0},_doFinalize:function(){var b=this._data,n=b.words,a=8*this._nDataBytes,c=8*b.sigBytes;n[c>>>5]|=128<<24-c%32;var e=u.floor(a/
4294967296);n[(c+64>>>9<<4)+15]=(e<<8|e>>>24)&16711935|(e<<24|e>>>8)&4278255360;n[(c+64>>>9<<4)+14]=(a<<8|a>>>24)&16711935|(a<<24|a>>>8)&4278255360;b.sigBytes=4*(n.length+1);this._process();b=this._hash;n=b.words;for(a=0;4>a;a++)c=n[a],n[a]=(c<<8|c>>>24)&16711935|(c<<24|c>>>8)&4278255360;return b},clone:function(){var b=v.clone.call(this);b._hash=this._hash.clone();return b}});t.MD5=v._createHelper(r);t.HmacMD5=v._createHmacHelper(r)})(Math);
(function(){var u=CryptoJS,p=u.lib,d=p.Base,l=p.WordArray,p=u.algo,s=p.EvpKDF=d.extend({cfg:d.extend({keySize:4,hasher:p.MD5,iterations:1}),init:function(d){this.cfg=this.cfg.extend(d)},compute:function(d,r){for(var p=this.cfg,s=p.hasher.create(),b=l.create(),u=b.words,q=p.keySize,p=p.iterations;u.length<q;){n&&s.update(n);var n=s.update(d).finalize(r);s.reset();for(var a=1;a<p;a++)n=s.finalize(n),s.reset();b.concat(n)}b.sigBytes=4*q;return b}});u.EvpKDF=function(d,l,p){return s.create(p).compute(d,
l)}})();
CryptoJS.lib.Cipher||function(u){var p=CryptoJS,d=p.lib,l=d.Base,s=d.WordArray,t=d.BufferedBlockAlgorithm,r=p.enc.Base64,w=p.algo.EvpKDF,v=d.Cipher=t.extend({cfg:l.extend(),createEncryptor:function(e,a){return this.create(this._ENC_XFORM_MODE,e,a)},createDecryptor:function(e,a){return this.create(this._DEC_XFORM_MODE,e,a)},init:function(e,a,b){this.cfg=this.cfg.extend(b);this._xformMode=e;this._key=a;this.reset()},reset:function(){t.reset.call(this);this._doReset()},process:function(e){this._append(e);return this._process()},
finalize:function(e){e&&this._append(e);return this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(e){return{encrypt:function(b,k,d){return("string"==typeof k?c:a).encrypt(e,b,k,d)},decrypt:function(b,k,d){return("string"==typeof k?c:a).decrypt(e,b,k,d)}}}});d.StreamCipher=v.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});var b=p.mode={},x=function(e,a,b){var c=this._iv;c?this._iv=u:c=this._prevBlock;for(var d=0;d<b;d++)e[a+d]^=
c[d]},q=(d.BlockCipherMode=l.extend({createEncryptor:function(e,a){return this.Encryptor.create(e,a)},createDecryptor:function(e,a){return this.Decryptor.create(e,a)},init:function(e,a){this._cipher=e;this._iv=a}})).extend();q.Encryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize;x.call(this,e,a,c);b.encryptBlock(e,a);this._prevBlock=e.slice(a,a+c)}});q.Decryptor=q.extend({processBlock:function(e,a){var b=this._cipher,c=b.blockSize,d=e.slice(a,a+c);b.decryptBlock(e,a);x.call(this,
e,a,c);this._prevBlock=d}});b=b.CBC=q;q=(p.pad={}).Pkcs7={pad:function(a,b){for(var c=4*b,c=c-a.sigBytes%c,d=c<<24|c<<16|c<<8|c,l=[],n=0;n<c;n+=4)l.push(d);c=s.create(l,c);a.concat(c)},unpad:function(a){a.sigBytes-=a.words[a.sigBytes-1>>>2]&255}};d.BlockCipher=v.extend({cfg:v.cfg.extend({mode:b,padding:q}),reset:function(){v.reset.call(this);var a=this.cfg,b=a.iv,a=a.mode;if(this._xformMode==this._ENC_XFORM_MODE)var c=a.createEncryptor;else c=a.createDecryptor,this._minBufferSize=1;this._mode=c.call(a,
this,b&&b.words)},_doProcessBlock:function(a,b){this._mode.processBlock(a,b)},_doFinalize:function(){var a=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){a.pad(this._data,this.blockSize);var b=this._process(!0)}else b=this._process(!0),a.unpad(b);return b},blockSize:4});var n=d.CipherParams=l.extend({init:function(a){this.mixIn(a)},toString:function(a){return(a||this.formatter).stringify(this)}}),b=(p.format={}).OpenSSL={stringify:function(a){var b=a.ciphertext;a=a.salt;return(a?s.create([1398893684,
1701076831]).concat(a).concat(b):b).toString(r)},parse:function(a){a=r.parse(a);var b=a.words;if(1398893684==b[0]&&1701076831==b[1]){var c=s.create(b.slice(2,4));b.splice(0,4);a.sigBytes-=16}return n.create({ciphertext:a,salt:c})}},a=d.SerializableCipher=l.extend({cfg:l.extend({format:b}),encrypt:function(a,b,c,d){d=this.cfg.extend(d);var l=a.createEncryptor(c,d);b=l.finalize(b);l=l.cfg;return n.create({ciphertext:b,key:c,iv:l.iv,algorithm:a,mode:l.mode,padding:l.padding,blockSize:a.blockSize,formatter:d.format})},
decrypt:function(a,b,c,d){d=this.cfg.extend(d);b=this._parse(b,d.format);return a.createDecryptor(c,d).finalize(b.ciphertext)},_parse:function(a,b){return"string"==typeof a?b.parse(a,this):a}}),p=(p.kdf={}).OpenSSL={execute:function(a,b,c,d){d||(d=s.random(8));a=w.create({keySize:b+c}).compute(a,d);c=s.create(a.words.slice(b),4*c);a.sigBytes=4*b;return n.create({key:a,iv:c,salt:d})}},c=d.PasswordBasedCipher=a.extend({cfg:a.cfg.extend({kdf:p}),encrypt:function(b,c,d,l){l=this.cfg.extend(l);d=l.kdf.execute(d,
b.keySize,b.ivSize);l.iv=d.iv;b=a.encrypt.call(this,b,c,d.key,l);b.mixIn(d);return b},decrypt:function(b,c,d,l){l=this.cfg.extend(l);c=this._parse(c,l.format);d=l.kdf.execute(d,b.keySize,b.ivSize,c.salt);l.iv=d.iv;return a.decrypt.call(this,b,c,d.key,l)}})}();
(function(){for(var u=CryptoJS,p=u.lib.BlockCipher,d=u.algo,l=[],s=[],t=[],r=[],w=[],v=[],b=[],x=[],q=[],n=[],a=[],c=0;256>c;c++)a[c]=128>c?c<<1:c<<1^283;for(var e=0,j=0,c=0;256>c;c++){var k=j^j<<1^j<<2^j<<3^j<<4,k=k>>>8^k&255^99;l[e]=k;s[k]=e;var z=a[e],F=a[z],G=a[F],y=257*a[k]^16843008*k;t[e]=y<<24|y>>>8;r[e]=y<<16|y>>>16;w[e]=y<<8|y>>>24;v[e]=y;y=16843009*G^65537*F^257*z^16843008*e;b[k]=y<<24|y>>>8;x[k]=y<<16|y>>>16;q[k]=y<<8|y>>>24;n[k]=y;e?(e=z^a[a[a[G^z]]],j^=a[a[j]]):e=j=1}var H=[0,1,2,4,8,
16,32,64,128,27,54],d=d.AES=p.extend({_doReset:function(){for(var a=this._key,c=a.words,d=a.sigBytes/4,a=4*((this._nRounds=d+6)+1),e=this._keySchedule=[],j=0;j<a;j++)if(j<d)e[j]=c[j];else{var k=e[j-1];j%d?6<d&&4==j%d&&(k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255]):(k=k<<8|k>>>24,k=l[k>>>24]<<24|l[k>>>16&255]<<16|l[k>>>8&255]<<8|l[k&255],k^=H[j/d|0]<<24);e[j]=e[j-d]^k}c=this._invKeySchedule=[];for(d=0;d<a;d++)j=a-d,k=d%4?e[j]:e[j-4],c[d]=4>d||4>=j?k:b[l[k>>>24]]^x[l[k>>>16&255]]^q[l[k>>>
8&255]]^n[l[k&255]]},encryptBlock:function(a,b){this._doCryptBlock(a,b,this._keySchedule,t,r,w,v,l)},decryptBlock:function(a,c){var d=a[c+1];a[c+1]=a[c+3];a[c+3]=d;this._doCryptBlock(a,c,this._invKeySchedule,b,x,q,n,s);d=a[c+1];a[c+1]=a[c+3];a[c+3]=d},_doCryptBlock:function(a,b,c,d,e,j,l,f){for(var m=this._nRounds,g=a[b]^c[0],h=a[b+1]^c[1],k=a[b+2]^c[2],n=a[b+3]^c[3],p=4,r=1;r<m;r++)var q=d[g>>>24]^e[h>>>16&255]^j[k>>>8&255]^l[n&255]^c[p++],s=d[h>>>24]^e[k>>>16&255]^j[n>>>8&255]^l[g&255]^c[p++],t=
d[k>>>24]^e[n>>>16&255]^j[g>>>8&255]^l[h&255]^c[p++],n=d[n>>>24]^e[g>>>16&255]^j[h>>>8&255]^l[k&255]^c[p++],g=q,h=s,k=t;q=(f[g>>>24]<<24|f[h>>>16&255]<<16|f[k>>>8&255]<<8|f[n&255])^c[p++];s=(f[h>>>24]<<24|f[k>>>16&255]<<16|f[n>>>8&255]<<8|f[g&255])^c[p++];t=(f[k>>>24]<<24|f[n>>>16&255]<<16|f[g>>>8&255]<<8|f[h&255])^c[p++];n=(f[n>>>24]<<24|f[g>>>16&255]<<16|f[h>>>8&255]<<8|f[k&255])^c[p++];a[b]=q;a[b+1]=s;a[b+2]=t;a[b+3]=n},keySize:8});u.AES=p._createHelper(d)})();

define("crypto", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.CryptoJS;
    };
}(this)));

define('shared/utils/queryStringUtils',[],
function() {
    var QueryStringUtils = function() {
        var self = this;

        /**
         * Given a URL, split it into the base, the query string, and the hash
         * Note the URL spec has the hash always being the last part, if present (URL?Query#Hash never URL#Hash?Query)
         * @param url {string}
         * @returns {{}} ; will contain members `url`, `query` and `hash` as appropriate
         */
        self.splitUrl = function(url) {
            var ret = {};
            var hashStartIndex = url.indexOf('#');
            if (hashStartIndex >= 0) {
                ret.hash = url.substr(hashStartIndex);
                url = url.substr(0, hashStartIndex);
            }
            var queryStringStartIndex = url.indexOf('?');
            if (queryStringStartIndex >= 0) {
                ret.query = url.substr(queryStringStartIndex);
                url = url.substr(0, queryStringStartIndex);
            }
            ret.url = url;
            return ret;
        };

        /**
         * Given a split URL, rejoin it into a single string
         * @param splitUrl {{}} ; split URL object
         * @returns {string}
         */
        self.joinUrl = function(splitUrl) {
            var ret = splitUrl.url;
            // note that an empty string is also falsey
            if (splitUrl.query) {
                if (splitUrl.query.charAt(0) !== '?') {
                    // make sure there will be a '?' separator
                    ret += '?';
                }
                ret += splitUrl.query;
            }
            if (splitUrl.hash) {
                if (splitUrl.hash.charAt(0) !== '#') {
                    // make sure there will be a '#' separator
                    ret += '#';
                }
                ret += splitUrl.hash;
            }
            return ret;
        };

        /**
         * Given a query string, parse it and return the values as a hash
         * The input should not include any hash component of the URL
         * @param queryString {string} ; the query string component of a URL path (that after the `?`)
         * @param flags {{}} ; hash of additional arguments to be supplied to the parser (omit for legacy handling)
         * @returns {{}}
         */
        self.parseQueryString = function(queryString, flags) {
            if (queryString.charAt(0) === '?') {
                // remove any prefix '?'
                queryString = queryString.slice(1);
            }
            if (!queryString.length) {
                // either not a valid string, or length of 0
                return {};
            }
            // will always have at least one query string parameter
            if (!flags) {
                // no flags object specified: use simple parser
                // NB: empty flags objects will not enter here
                return self.parseQueryStringSimple(queryString);
            } else {
                return self.parseQueryStringComplex(queryString, flags);
            }
        };

        /**
         * Simple query string parser
         * If multiple same-keys present, will return the value of the last
         * Valueless keys will be ignored
         * Function present to support legacy behaviour
         * @param queryString {string}
         * @returns {{}}
         */
        self.parseQueryStringSimple = function(queryString) {
            var ret = {};
            var queries = queryString.split('&');
            for (var i = 0; i < queries.length; i++) {
                var parts = queries[i].split("=");
                // check if it was of the form `key=value`
                if (parts.length === 2) {
                    // decode and replace + with space
                    ret[parts[0]] = decodeURIComponent(parts[1].replace(/\+/g, " "));
                }
            }
            return ret;
        };

        /**
         * More complex query-string parser
         * @param queryString {string} ; the query string component of a URL path (that after the `?`)
         * @param flags {{}} ; hash of additional arguments to be supplied to the parser
         * Permitted flags include
         *  - assumeSanity {boolean} ; if string is a known-valid query string, extra sanity checks can be suppressed
         *      by setting this to `true`
         *  - allowMultiples {boolean} ; whether multiple same-key parameters are expected (default: `false`)
         *      if multiples allowed, hash values will be arrays containing any query string parameter keys
         *      if no multiples allowed, hash values will be strings, last seen value has priority
         *  - trueForValueless {boolean} ; whether parameters without values (`&bar&`...) should return as `true`
         *      note that if multiples not allowed, priority will be given to parameters with values if both forms present
         *  - customValueless {string} ; if not `trueForValueless`, can specify a custom value for parameters without values
         *      defaults to `''` for legacy compatibility
         *      note that if multiples not allowed, priority will be given to parameters with values if both forms present
         * @returns {{}}
         */
        self.parseQueryStringComplex = function(queryString, flags) {
            // setup
            var assumeSanity = !!flags.assumeSanity;
            var allowMultiples = !!flags.allowMultiples;
            var trueForValueless = !!flags.trueForValueless;
            var valueless = trueForValueless ? true
                    : (typeof flags.customValueless !== 'undefined' ? flags.customValueless : '');
            var ret = {};
            // commence parsing
            var queries = queryString.split('&');
            for (var i = 0; i < queries.length; i++) {
                var parts = queries[i].split("=");
                var key = parts[0];
                if (!assumeSanity && key.length < 1) {
                    // dislike parameters with 0-length keys
                    continue;
                }
                var hasValue = false; // does the parameter have an actual value associated with it?
                var value = valueless; // default value for non-valued keys
                // check if it was of the form `key=value`
                if (parts.length > 1) {
                    var newValue;
                    if (!assumeSanity) {
                        // cope silently with additional `=`s
                        newValue = parts.slice(1).join('=');
                    } else {
                        newValue = parts[1];
                    }
                    if (newValue.length > 0) {
                        // decode and replace + with space
                        value = decodeURIComponent(newValue.replace(/\+/g, " "));
                        hasValue = true;
                    }
                }
                if (allowMultiples) {
                    if (!ret[key]) {
                        // first time the key has been seen: create a new array
                        ret[key] = [];
                    }
                    ret[key].push(value);
                } else if (hasValue || typeof ret[key] === 'undefined') {
                    // prioritise non-valueless values, otherwise only set if there is not yet a value for this key
                    ret[key] = value;
                }
            }
            return ret;
        };

        /**
         * Given a hash of parsed query string parameters, convert it back into a query string
         * Reverses the complex parse above, dealing with multiple keys and valueless keys as expected
         * @param qs {{}} ; a hash of either {{string}->{string|boolean}} or {{string}->[{string|boolean}]}
         * @returns {string} ; if there are any valid parameters, will begin with a '?', else an empty string
         *  (ie can always be appended to a partial URL safely)
         */
        self.stringifyQueryStringHash = function(qs) {
            var initialised = false;
            var multivalued = false;
            var ret = '';
            for (var key in qs) {
                if (qs.hasOwnProperty(key)) {
                    var value = qs[key];
                    var qsSubstring = initialised ? '&' : '?';
                    if (!initialised) {
                        if (typeof value === 'object') {
                            multivalued = true;
                        }
                        initialised = true;
                    }
                    try {
                        qsSubstring += stringifyQueryStringParameter(key, value, !multivalued);
                        ret += qsSubstring;
                    } catch (e) {
                        // something wasn't formatted right: skip it silently
                        if (ret.length < 1) {
                            // if the first one fails, make sure we reinitialise next time
                            initialised = false;
                        }
                    }
                }
            }
            return ret;
        };

        /**
         * Given a parameter's key and value, output it to a URL query-compatible format
         * @param key {string} ; the query string key
         * @param value {*} ; either a string(|`true`) or an array of strings(|`true`s) representing values
         * @param isLeaf {boolean} ; whether `value` is expected to be a singleton or array
         * @returns {string}
         */
        var stringifyQueryStringParameter = function(key, value, isLeaf) {
            var ret = '';
            if (isLeaf) {
                ret += key;
                if (value === true) {
                    return ret;
                }
                if (typeof value !== 'string') {
                    throw 'Invalid query string format';
                }
                ret += '=' + encodeURIComponent(value).replace(/ /g, "+");
            } else {
                if (!value.length) {
                    throw 'Invalid query string format';
                }
                for (var i = 0; i < value.length; i++) {
                    if (i > 0) {
                        ret += '&';
                    }
                    ret += stringifyQueryStringParameter(key, value[i], true);
                }
            }
            return ret;
        };

        /**
         * Add the specified string to the end of a URL as an additional query string parameter
         * The `queryString` should normally be of the form `key=value`
         * Does not check if the key is already present in the URL
         * Does not check for a hash
         * @param url {string} ; the target URL
         * @param queryString {string} ; string to postpend to the URL
         * @returns {string}
         */
        self.addQueryStringToURL = function(url, queryString) {
            if (!url) {
                return url;
            }

            var lastQuestionMark = url.lastIndexOf("?");
            var lastAmpersand = url.lastIndexOf("&");
            var joiningChar = "";
            if (lastQuestionMark == -1) {
                joiningChar = "?";
            } else {
                if ((lastQuestionMark != url.length - 1) && (lastAmpersand != url.length - 1)) {
                    joiningChar = "&";
                }
            }
            return url + joiningChar + queryString;
        };

        /**
         * Add the specified parameters to the URL as query string parameters
         * Does not check for duplicate parameter keys
         * Parameter values should be strings - non-strings will be ignored!
         * For arrays of same-key parameters, call the function repeatedly or refactor
         * @param url {string} ; the target URL
         * @param parameters {*} ; hash of parameters to be added as query string parameters to the url
         * @returns {string}
         */
        self.addToUrlQueryString = function(url, parameters) {
            var qs = [];
            for (var key in parameters) {
                if (parameters.hasOwnProperty(key)) {
                    if (typeof parameters[key] !== 'string') {
                        continue;
                    }
                    qs.push(key + '=' + parameters[key]);
                }
            }
            if (qs.length < 1) {
                return url;
            }
            var lastQuestionMark = url.lastIndexOf("?");
            var lastAmpersand = url.lastIndexOf("&");
            if (lastQuestionMark == -1) {
                url += '?';
            } else if ((lastQuestionMark != url.length - 1) && (lastAmpersand != url.length - 1)) {
                url += '&';
            }
            return url + qs.join('&');
        };

        /**
         * Add a random query string parameter value to a url. This can be used to bypass caching.
         * @param url The url to add a random query string parameter value to.
         * @param key The key of the query string parameter to be added.
         */
        self.addRandomQueryStringParameter = function (url, key) {
            var randomValue = Math.random().toString(36).substr(2);
            var parameterKeyValue = {};
            parameterKeyValue[key] = randomValue;
            return self.addToUrlQueryString(url, parameterKeyValue);
        };

        /**
         * Given a split URL, replace or add the specified query string parameter
         * Note that `replaceInQuery` is preferred both for multiple replacements (to prevent parsing repeatedly)
         *  and for provision of non-default optional arguments
         * @return {{}} ; split URL object
         */
        self.replaceForKeyInQuery = function(url, key, value) {
            var params = {};
            params[key] = value;
            return self.replaceInQuery(url, params, false);
        };

        /**
         * Given a split URL, replace the query string parameters with those in the specified hash
         * @param url {{}} ; URL in the format output by the `splitUrl` function above
         * @param newParameters {{}} ; parameters to replace in the query string
         * @param useMultiples {boolean} ; whether the query string should be multiple-keys compatible
         *  Note that if `useMultiples` then the `newParameters` should also be a hash of arrays
         * @return {{}} ; split URL object
         */
        self.replaceInQuery = function(url, newParameters, useMultiples) {
            var qs;
            if (url.query) {
                var flags = {
                    allowMultiples: useMultiples,
                    trueForValueless: true
                };
                qs = self.parseQueryString(url.query, flags);
            } else {
                qs = {};
            }
            // replace the parameters
            for (var key in newParameters) {
                if (newParameters.hasOwnProperty(key)) {
                    qs[key] = newParameters[key];
                }
            }
            // reform a new split URL (do not edit the one passed in)
            var newUrl = {
                url: url.url
            };
            newUrl.query = self.stringifyQueryStringHash(qs);
            if (url.hash) {
                newUrl.hash = url.hash;
            }
            return newUrl;
        };
    };

    return new QueryStringUtils();
});

define('utils/encryptedResourceFetchingUtils',['crypto', 'config', 'shared/utils/queryStringUtils', 'jquery'],
    function (crypto, config, queryStringUtils, $) {

        var RANDOM_QUERY_STRING_PARAM_KEY = 'encCacheRand';
        /**
         * Generate the Base64 encoded MD5 digest of a Base64 encoded message.
         * @param base64Message The Base64 encoded message.
         * @returns {*} The Base64 encoded MD5 digest of the given message.
         */
        var getBase64MD5DigestOfBase64Message = function (base64Message) {
            var message = crypto.enc.Base64.parse(base64Message);
            var digest = crypto.MD5(message);
            return crypto.enc.Base64.stringify(digest);
        };

        var useResourceAsHtmlElementSource = function(resourceUrl, htmlElement, onDecryptionError) {
            var onDecryptionSuccess = function (data) {
                var windowUrl = window.URL || window.webkitURL;
                htmlElement.src = windowUrl.createObjectURL(data);
            };
            $.isEmptyObject(config.contentDecryptionHeaders)
                    ? htmlElement.src = resourceUrl
                    : fetchBlob(queryStringUtils.addRandomQueryStringParameter(resourceUrl, RANDOM_QUERY_STRING_PARAM_KEY),
                            config.contentDecryptionHeaders, onDecryptionSuccess, onDecryptionError);
        };

        var useResourceAsCallbackArgument = function (resourceUrl, callback, onDecryptionError) {
            var onDecryptionSuccess = function (data) {
                var windowUrl = window.URL || window.webkitURL;
                callback(windowUrl.createObjectURL(data));
            };
            $.isEmptyObject(config.contentDecryptionHeaders)
                    ? callback(resourceUrl)
                    : fetchBlob(queryStringUtils.addRandomQueryStringParameter(resourceUrl, RANDOM_QUERY_STRING_PARAM_KEY),
                            config.contentDecryptionHeaders, onDecryptionSuccess, onDecryptionError);
        };

        var fetchBlob = function (url, headers, onSuccess, onError) {
            $.ajax({
                url: url,
                type: 'GET',
                headers: headers,
                xhrFields:{
                    responseType: 'blob'
                },
                success: function (data) {
                    onSuccess(data);
                },
                error: function (jqXHR, textStatus, errorThrown) {
                    onError && onError(jqXHR, textStatus, errorThrown);
                }
            });
        };

        return {
            RANDOM_QUERY_STRING_PARAM_KEY: RANDOM_QUERY_STRING_PARAM_KEY,
            getBase64MD5DigestOfBase64Message: getBase64MD5DigestOfBase64Message,
            useResourceAsHtmlElementSource: useResourceAsHtmlElementSource,
            useResourceAsCallbackArgument: useResourceAsCallbackArgument
        }
    });

define('fetching/tileFetcherSync',['events', 'config', 'constants', 'resources', 'fetching/tileFetcher', 'utils/encryptedResourceFetchingUtils'],
    function(events, config, constants, resources, tileFetcher, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "tileFetcherSync";

        /**
         * ONLY FETCH HANDLER SHOULD DIRECTLY CALL THIS CLASS!!!
         * DO NOT TOUCH!
         * I'M WATCHING YOU!!!
         * @constructor
         */
        var TileFetcherSync = function() {
            tileFetcher.TileFetcher.call(this);

            this.priorityQueue = [];
            this.queue = [];
            this.fetchingLookup = {};

            this.active = 0;
            this.nextRequestID = 0;

            // <Required by tileFetcher.js>
            this.start = function() {
                var intervalTime = 1000 / constants.pps;
                this.timer = setInterval(events.callback(this, this.processQueues), intervalTime);
            };

            this.stop = function() {
                clearInterval(this.timer);
            };

            this.enqueue = function(request) {
                if (request.priority) {
                    this.priorityQueue.push(request);
                }
                else {
                    this.queue.push(request);
                }
            };

            this.flushQueues = function() {

                for (var i = 0 ; i < this.queue.length ; i++) {
                    this.queue[i].tile.reset();
                }

                for (var i = 0 ; i < this.priorityQueue.length ; i++) {
                    this.priorityQueue[i].tile.reset();
                }

                this.queue = [];
                this.priorityQueue = [];
            };

            this.fetchQueueSize = function() {
                return this.queue.length + this.priorityQueue.length;
            };


            this.isBusy = function () {
                return (this.priorityQueue.length > 0 || this.queue.length > constants.maxNumTilesInQueue);
            };
            // </Required by tileFetcher.js>

            /**
             * Starts the download request.
             */
            this.fetchTile = function(request) {
                if (request.id == null) {
                    request.id = this.nextRequestID++;
                    this.fetchingLookup[request.id] = request;
                }
                request.tile.setFetching();

                var img = new Image();
                img.onload = events.callback(this, this.onFetchedImage, img, Date.now(), request);
                img.onerror = events.callback(this, this.onFetchError, request);
                encryptedResourceFetchingUtils.useResourceAsHtmlElementSource(request.tile.url, img, img.onerror);
            };


            this.processQueues = function() {
                if (this.active > constants.tileFetchBatchSize) {
                    return;
                }

                //the number of tiles we can load to max out the number in flight
                var toFetch = constants.tileFetchBatchSize - this.active;

                //get the batch of requests, note that [1,2].splice(0,10) returns [1,2]
                var highPriorityTiles = this.priorityQueue.splice(0,toFetch);

                toFetch = Math.max(0, toFetch - highPriorityTiles.length);
                var batch = highPriorityTiles.concat(this.queue.splice(0, toFetch));

                for (var i = 0; i < batch.length; i++) {
                    this.fetchTile(batch[i]);
                }

                this.active += batch.length;
            };

            this.onFetchError = function(request) {
                request.fetchFailureCount++;

                //if tile has not reached the retry limit then put the request back into the queue
                delete this.fetchingLookup[request.id];
                this.active--;
                if (request.fetchFailureCount < constants.tileFetchRetryCount) {
                    request.tile.setQueued();
                    this.enqueue(request);
                }
                else {
                    this.requestFailed(request);
                }
            };

            this.onFetchedImage = function(img, startTime, request) {
                delete this.fetchingLookup[request.id];
                this.active--;
                this.requestSuccess(img, startTime, request);
            };

        };
        TileFetcherSync.prototype = tileFetcher.TileFetcher.prototype;

        return {
            TileFetcherSync: TileFetcherSync,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('shared/localisation',['jquery'],
    function($) {

        // Localisation uses two global values as resources shared between the main reader and any other components
        // (primarily htmlArticles). If adding any further shared resources, these should be added into a common
        // shared/resources file (as should the main yuduBook data).
        var languagePack = globalLanguagePack;
        var customStringsPack = false;

        var Localisation = function() {
            var self = this;

            self.loadResources = function(url, callback) {
                $.getJSON(url, function(data) {
                    customStringsPack = data;
                    callback();
                }).fail(function() {
                    customStringsPack = false;
                    callback();
                });
            };

            self.get = function(code) {
                var overwrite = customStringsPack[code];
                if (overwrite) {
                    return overwrite;
                }
                var message = languagePack[code];
                if (message != undefined)
                    return message;
                else
                    return code;
            };

            self.localiseHtml = function(element) {
                //text replacements
                $(element).find(".yudu_localisable").each(function() {
                    var element = $(this);
                    element.text(self.get(element.text()));
                });

                //attribute replacements
                var prefix = "yudu_localisable-";
                $(element).find('*[class^="' + prefix + '"]').each(function() {
                    var element = $(this);
                    var classes = element.attr('class').split(" ");
                    var attribute = false;
                    for (var i = 0, l = classes.length; i < l; i++) {
                        if (classes[i].lastIndexOf(prefix, 0) === 0) {
                            attribute = classes[i].substring(prefix.length);
                            break;
                        }
                    }
                    if (attribute)
                        element.attr(attribute, self.get(element.attr(attribute)));
                });
            };

            // Provide a way to override the language pack and custom strings for unit testing
            self._private = {
                setDummyDataForTesting: function(testLanguagePage, testCustomStringsPack) {
                    languagePack = testLanguagePage;
                    customStringsPack = testCustomStringsPack;
                }
            };
        };

        return new Localisation();
    });

define('shared/hammerManager',[],
function() {
    var HammerManager = function() {
        var self = this;
        var hammer = null;

        // list of frequently used recogniser presets for Hammer2
        // all initialised to empty lists until the script is supplied
        self.recogniserPresets = {
            TAP_ONLY: []
        };

        /**
         * Setup libraries the module can use
         * Cannot import them directly since this is a shared module
         * @param hammer2lib {*} the Hammer2 library
         */
        self.setupLibraries = function(hammer2lib) {
            hammer = hammer2lib;
            self.createPresetsObject(self.recogniserPresets);
        };

        /**
         * Helper that adds preconfigured HammerJS recogniser objects to a base
         * Each preset can be passed as a set of `recognisers` to the Hammer Manager constructor
         * @param base {{}}
         */
        self.createPresetsObject = function(base) {
            base['TAP_ONLY'] = [ [hammer.Tap] ];
        };

        /**
         * Create a new Hammer Manager for the specified element with the default settings
         * Allows cross-platform gesture detection for that element
         * @param element {Element} to create a manager for
         * @returns {*} the Hammer Manager
         */
        self.createManager = function(element) {
            if (!hammer) {
                return null;
            }
            // create a new manager with the default recognisers and options
            return new hammer(element);
        };

        /**
         * Create a new Hammer Manager for the specified element
         * Accepts a set of custom recognisers, and uses those without further options
         * @param element {Element} to create a manager for
         * @param recognisers {{}} recogniser configuration to use, if unspecified falls back to Hammer defaults
         * @returns {*} the Hammer Manager
         */
        self.createManagerWithRecognisers = function(element, recognisers) {
            if (!hammer) {
                return null;
            }
            if (!recognisers) {
                // create a new manager with the default recognisers
                return self.createManager(element);
            }

            return new hammer.Manager(element, {
                // otherwise use the specified recognisers
                recognizers: recognisers
            });
        };

        self.createManagerForDoubleTap = function(element) {
            var hammerManager = self.createManagerWithRecognisers(element, null);

            // Recognising a doubletap requires some specific config of the recognisers. We need two TapRecognisers,
            // one for single tap and one for double tap; they need to not be mutually exclusive, and the single tap
            // should only be fired if the double tap fails. (This means that there's a 200ms delay after doing a
            // single tap before it's triggered - this is unavoidable if we want to detect double taps without also
            // triggering a single tap event at the same time.)
            // The configuration here follows the example at https://hammerjs.github.io/require-failure/.
            hammerManager.add(new hammer.Tap({ event: 'doubletap', taps: 2, posThreshold: 20, interval: 200 }));
            hammerManager.add(new hammer.Tap({ event: 'tap', taps: 1, interval:600 }));
            hammerManager.get('doubletap').recognizeWith('tap');
            hammerManager.get('tap').requireFailure('doubletap');

            return hammerManager;
        };

        /**
         * Create a new Hammer Manager for the specified element
         * Accepts any custom settings object, for complete control over the resulting manager object
         * @param element {Element} to create a manager for
         * @param options {{}} Hammer Manager options, if unspecified falls back to Hammer defaults
         * @returns {*} the Hammer Manager
         */
        self.createManagerWithOptions = function(element, options) {
            if (!hammer) {
                return null;
            }
            if (!options) {
                // create a new manager with the default recognisers
                return self.createManager(element);
            }
            // otherwise use the specified options
            return new hammer.Manager(element, options);
        };

        /**
         * Create a new Hammer Manager for the specified element
         * Initialises the manager with only the default Tap recogniser for basic interactions
         * @param element {Element} to create a manager for
         * @returns {*} the Hammer Manager
         */
        self.createTapManager = function(element) {
            return self.createManagerWithRecognisers(element, self.recogniserPresets.TAP_ONLY);
        };

        /**
         * Create a new Hammer Manager for the specified element and enable the pinch recogniser
         * @param element {Element} to create a manager for
         * @returns {*} the Hammer Manager
         */
        self.createPinchManager = function (element) {
            var hammerManager = self.createManagerWithRecognisers(element, null);
            hammerManager.get('pinch').set({ enable: true });
            return hammerManager;
        }
    };

    return new HammerManager();
});

define('shared/ui/messageBox',['jquery', 'shared/config', 'shared/constants', 'shared/events', 'shared/localisation', 'shared/hammerManager'],
function ($, config, constants, events, localisation, hammerManager) {

    var background = $("#yudu_messageBackground");
    var box = $("#yudu_messageBox");
    var message = $("#yudu_message");
    var messageLink = $("#yudu_messageLink");
    var closeButton = $("#yudu_messageClose");
    var okButton = $("#yudu_messageOk");
    var cancelButton = $("#yudu_messageCancel");

    var temporaryCallbacks = [];
    var emptyFunction = function() {};
    var finalCallback = emptyFunction;

    var show = function() {
        background.show();
        box.slideDown();
        events.subscribe(events.ALL, events.CLOSE_ACTIVE, hide);
    };

    var hide = function() {
        events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, hide);
        background.hide();
        box.hide();
        clearMessageText();
        clearMessageLink();
        removeTemporaryCallbacks();
        finalCallback();
        finalCallback = emptyFunction;
        setType(constants.messageTypes.default);
    };

    var setMessage = function(text, linkUrl, linkText) {
        clearMessageText();
        message.prepend(text);
        if (!linkUrl || !linkText) {
            messageLink.hide();
            clearMessageLink();
        }
        else {
            messageLink.attr('href', linkUrl);
            messageLink.text(linkText);
            messageLink.css('display', 'block'); // use this instead of show() to make it behave as a box model element
        }
    };

    var clearMessageText = function() {
        message.contents().filter(function() {
            return this.nodeType === Node.TEXT_NODE;
        }).remove();
    }

    var clearMessageLink = function() {
        messageLink.attr("href", "");
        messageLink.text("");
    }

    var setType = function(type) {
        message.removeClass();
        message.addClass(type);
    };

    var displayWithLink = function (text, linkUrl, linkText, type) {
        box.removeClass('yudu_twoButton');
        setMessage(text, linkUrl, linkText);
        setType(type);
        show();
    }

    var display = function(text, type) {
        displayWithLink(text, undefined, undefined, type);
    };

    var displayByCode = function(code, type) {
        display(localisation.get(code), type);
    };

    var displayTwoButtonPopup = function(text, okButtonCallback, cancelButtonCallback) {
        box.addClass('yudu_twoButton');
        applyTemporaryCallback(okButton, okButtonCallback);
        applyTemporaryCallback(cancelButton, cancelButtonCallback);
        setMessage(text);
        show();
    };

    /**
     * Complete control over the two-button popup
     * @param settings ; object with the settings to apply - must contain a "text" parameter
     * possible parameters include:
     *  - text: the message to display
     *  - leftLabel: temporary label for the left ("cancel"/red) button
     *  - leftCallback: callback for the left ("cancel"/red) button
     *  - rightLabel: temporary label for the right ("ok"/blue) button
     *  - rightCallback: callback for the right ("ok"/blue) button
     *  - backgroundCallback: callback for the messageBox being dismissed indirectly
     */
    var displayAdvancedTwoButtonPopup = function(settings) {
        box.addClass('yudu_twoButton');
        setMessage(settings.text);
        var leftLabelChanged = false;
        if (settings.leftLabel) {
            leftLabelChanged = cancelButton.text();
            cancelButton.text(settings.leftLabel);
        }
        if (settings.leftCallback) {
            applyTemporaryCallback(cancelButton, settings.leftCallback);
        }
        var rightLabelChanged = false;
        if (settings.rightLabel) {
            rightLabelChanged = okButton.text();
            okButton.text(settings.rightLabel);
        }
        if (settings.rightCallback) {
            applyTemporaryCallback(okButton, settings.rightCallback);
        }
        if (settings.backgroundCallback) {
            applyTemporaryCallback(background, settings.backgroundCallback);
        }
        finalCallback = function() {
            if (leftLabelChanged) {
                cancelButton.text(leftLabelChanged);
            }
            if (rightLabelChanged) {
                okButton.text(rightLabelChanged);
            }
        };
        show();
    };

    /**
     * To ensure all callbacks are removed from the two-button popup when it closes
     *      we need to keep track of what callbacks are assigned to what buttons
     *  Callbacks need to be removed when hiding the popup as it can close without any triggering
     * This class provides an interface for storing and accessing the temporary callbacks
     *      for easy removal when hiding the popup
     * @param button ; the button to add/remove the callback to/from
     * @param callback ; the callback to call should the button be clicked before the popup is otherwise hidden
     * @returns {{button: *, callback: *}}
     * @constructor
     */
    var TemporaryCallback = function(button, callback) {
        return {
            button: button,
            callback: callback
        }
    };

    /**
     * Method to apply a temporary callback to a button
     *  ensures the callback is applied to the button _and_ appropriately added to the array for removal
     *  This only supports max one callback per button! If you add multiple callbacks to the same button, only one
     *  will be called.
     * @param button
     * @param callback
     */
    var applyTemporaryCallback = function(button, callback) {
        events.yuduOn(button, config.clickAction, callback);
        temporaryCallbacks.push(new TemporaryCallback(button, callback));
    };

    /**
     * Method to clear all applied temporary callback functions
     */
    var removeTemporaryCallbacks = function() {
        while(temporaryCallbacks.length > 0) {
            var obj = temporaryCallbacks.pop();
            obj.button.off(config.clickAction, obj.callback);
        }
    };

    var init = function() {
        events.yuduOn(closeButton, config.clickAction, hide);
        events.yuduOn(cancelButton, config.clickAction, hide);
        events.yuduOn(okButton, config.clickAction, hide);
        events.yuduOn(background, config.clickAction, hide);
        localisation.localiseHtml(box);
    };

    return {
        init: init,
        show: show,
        hide: hide,
        setMessage: setMessage,
        setType: setType,
        displayWithLink: displayWithLink,
        display: display,
        displayByCode: displayByCode,
        displayTwoButtonPopup: displayTwoButtonPopup,
        displayAdvancedTwoButtonPopup: displayAdvancedTwoButtonPopup
    };
});

define('shared/utils/appUtils',[],
function() {
    var AppUtils = function() {
        var self = this;
        self.nativeWrapperPrefixPrototcol = 'yudu:';
        self.nativeWindowsAdditionalPrefixPrototcol = 'ms-appx-web:///';

        /**
         * Check whether the component is thought to be embedded in a wrapper app
         * Relies on APIs from those target platforms - if those APIs change, this may break
         * @param parsedQueryObject {{}} ; a hash with the parsed query string
         * @returns {boolean|*}
         */
        self.isThisAnApp = function(parsedQueryObject) {
            return (parsedQueryObject && parsedQueryObject['isApp'] === "true")
                    || self.deviceType.isMetro() || self.deviceType.isAndroid();
        };

        /**
         * Wrapper for two functions that check for the known API of specific platforms
         * Useful for distinguishing between the different wrapper app platforms
         * @type {{isMetro: Function, isAndroid: Function}}
         */
        self.deviceType = {
            isMetro: function() {
                return window.yuduinterface && window.yuduinterface.getPlatform
                    ? window.yuduinterface.getPlatform() === "windows"
                    : window.external && ('notify' in window.external);
            },
            isAndroid: function() {
                return window.yuduinterface && window.yuduinterface.getPlatform() === "android";
            }
        };

        self.getVersion = function(versionUtils) {
            var component = versionUtils.components.app;
            var major;
            var minor;
            var build;
            var revision;
            if (self.deviceType.isAndroid() || self.deviceType.isMetro()) {
                component = self.deviceType.isAndroid()
                    ? versionUtils.components.appAndroid : versionUtils.components.appWindows;
                var versionCode = (window.top.yuduinterface && window.top.yuduinterface.getVersion
                        && window.top.yuduinterface.getVersion()) || 0;
                revision = versionCode % 100;
                versionCode = Math.floor(versionCode/100);
                build = versionCode % 100;
                versionCode = Math.floor(versionCode/100);
                minor = versionCode % 100;
                major = Math.floor(versionCode/100);
            }
            return new versionUtils.VersionNumber(component, major, minor, build, revision);
        };

        //region Comms Prototype
        /*
         * The following region is taken from the communications refactor prototype
         * Modifications have tried to be minimised to make it simple to keep up to date with the base code
         * Note that all TODOs are omitted since duplication seems pointless
         * It should be kept up to date with any improvements made in the wrapper core
         */
        var SEPARATOR = ':';
        var origin = '_uninitialised';
        var messageHandlers = {};

        self.targets = {
            _uninitialised: '_uninitialised', // default, uninitialised value: if used, app is in an error state
            _native: '_native',
            _app: '_app',
            htmlReader: 'htmlReader',
            articleView: 'articleView'
        };

        /**
         * Designates the origin field for all communications from this component
         * Note that outgoing messages will fail without a non-default origin
         * @param instanceOrigin
         * @returns {boolean} ; has the origin been updated successfully
         */
        self.designateOrigin = function(instanceOrigin) {
            if (self.targets[origin] !== origin) {
                return false;
            }
            origin = instanceOrigin;
            return true;
        };

        /**
         * Register a handler for a message type
         * @param messageType ; the type to register as being listened for
         * @param callback ; the function that will accept the message
         * All callback functions should be of the form: `function(origin, parameters)` where:
         *      - `origin` is where the message has come from (in case a response needs to be sent)
         *      - `parameters` is a JSON/hash containing all required parameters
         */
        self.registerMessageResponder = function(messageType, callback) {
            if (typeof callback !== 'function') return;
            messageHandlers[messageType] = callback;
        };

        /**
         * Public helper method to expose message sending with implicit origin designation
         * @param messageType
         * @param target
         * @param parameters
         */
        self.sendMessage = function(messageType, target, parameters) {
            var messageString = self.prepareMessage(messageType, target, parameters);
            if (messageString === '') {
                return;
            }
            if (origin === target) {
                self.api.handleMessage(messageString);
            } else {
                sendMessagePrivate(messageString);
            }
        };

        /**
         * Prototype for the new message sending mechanism
         * Sends a message to the appropriate destination based on the specified target
         * @param messageString
         */
        var sendMessagePrivate = function(messageString) {
            if (messageString.length > 2000 && self.deviceType.isMetro()) {
                // IE has a url length limit of 2083 chars (and a path length limit of 2048 chars)
                // so if the message is not safe to send (we arbitrarily limit to 2000 chars) we need to split it
                sendMultipartMessage(messageString);
            } else {
                // otherwise send the message as normal
                sendMessageInner(messageString);
            }
        };

        /**
         * Prepare a message string from the given inputs
         * @param messageType ; the unique message code
         * @param target ; the destination for the message
         * @param parameters ; hash containing any parameters to be included in the message
         * @returns {string}
         */
        self.prepareMessage = function(messageType, target, parameters) {
            var messageString = '';
            if (origin === self.targets._uninitialised) {
                return messageString;
            }
            if (typeof messageType !== 'string' || self.targets[target] !== target) {
                return messageString;
            }
            parameters = parameters || {};
            if (self.deviceType.isMetro()) {
                messageString += 'ms-appx-web:///';
            }
            messageString += [
                'yudu',
                messageType,
                target,
                origin,
                encodeURIComponent(JSON.stringify(parameters))
            ].join(SEPARATOR);
            return messageString;
        };

        /**
         * Prototype for new message sending mechanism
         * Split and send a multipart message
         * The message type for a multipart message is `multipart`
         * Each part of a multipart message will have the following parameters:
         *      mmid: id of the message being sent in multiple parts
         *      mmcp: number of the current part being sent
         *      mmtn: total number of parts to be sent
         *      mmmp: the content for this part of the message
         * The common prefix of `mm` denotes a multipart message parameter
         * @param originalMessage ; complete message as a string
         */
        var sendMultipartMessage = function(originalMessage) {
            var uniqueId = getMultipartMessageId(100, 999);
            var splitMessage = messageSplitter(originalMessage, true);
            for (var i = 0; i < splitMessage.length; i++) {
                var parameters = {
                    mmid: uniqueId,
                    mmcp: i,
                    mmtn: splitMessage.length,
                    mmmp: splitMessage[i]
                };
                var messageForPart = [
                    'ms-appx-web:///yudu',
                    'multipart-v2',
                    self.targets._native,
                    origin,
                    encodeURIComponent(JSON.stringify(parameters))
                ].join(SEPARATOR);
                sendMessageInner(messageForPart);
            }
        };

        /**
         * Internal helper method to split a message
         * @param originalMessage ; complete message as a single string
         *  For pre-prototype messages, this should be URL encoded ready to insert into a URL
         *  For new-format messages, this should _not_ be URL encoded as the encoding will be applied once it is in the JSON
         *      This means the message needs to be URL encoded temporarily as part of the splitting calculation
         *      as the URL encoded message will be longer
         * @param splitAt ; maximum length of a message part
         *  IE has a url length limit of 2083 chars (and a path length limit of 2048 chars)
         *  For messages with minimal overhead, 1970 should be a safe splitting point (ie, pre-prototype splits)
         *  For multipart messages under the new format, with empty message parts, overhead is ~150 characters,
         *      so safest to use something in the region of 1830.
         * @param newFormat ; whether the split message needs to follow new or old formatting rules
         *  A temporary variable to determine whether URL encoding is required
         * @returns {Array} ; the split parts of the message
         */
        var messageSplitter = function(originalMessage, newFormat, splitAt) {
            if (typeof splitAt === 'undefined') {
                if (typeof newFormat === 'undefined') {
                    // assume using old formatting so old calls do not need refactoring
                    splitAt = 1970;
                    newFormat = false;
                } else {
                    splitAt = 1830;
                }
            }
            var messageToSplit;
            if (newFormat) {
                messageToSplit = encodeURIComponent(originalMessage);
            } else {
                messageToSplit = originalMessage;
            }
            var remnantStart = 0; // tracks what is left of the message to split
            var parts = [];
            while (remnantStart < messageToSplit.length) {
                var currentSplit = remnantStart + splitAt;
                var currentPart = messageToSplit.substring(remnantStart, currentSplit);
                var lastPercentCharacter = currentPart.indexOf('%', (currentPart.length-2));
                if (lastPercentCharacter >= 0 && currentPart.length == splitAt) {
                    // any percent signs in the original will be encoded
                    // so all remaining percent signs must be followed by two characters
                    // so if one of the last two characters is a percent sign, leave it to the next part
                    // unless this is the last part (should never happen as that would imply invalid encoding)
                    currentSplit = remnantStart + lastPercentCharacter;
                    currentPart = messageToSplit.substring(remnantStart, currentSplit);
                }
                parts.push(currentPart);
                remnantStart = currentSplit;
            }
            if (newFormat) {
                parts = parts.map(decodeURIComponent);
            }
            return parts;
        };

        /**
         * Defines the current mechanic used to send messages to the native layer
         * @param message
         */
        var sendMessageInner = function(message) {
            window.location.href = message;
        };

        /**
         * JavaScript message parsing and handling for messages the native layer forwards
         * @param message
         */
        self.handleMessage = function(message) {
            var parsed = self.parseMessage(message);
            handleMessageInner(parsed.messageType, parsed.origin, parsed.parameters);
        };

        /**
         * JavaScript message parsing for messages the native layer forwards
         * @param message
         * @returns {{}}
         */
        self.parseMessage = function(message) {
            message = stripWindowsPrefix(message);
            var messageParts = message.split(SEPARATOR, 4);
            if (messageParts.length < 4) {
                return {};
            }
            var messagePrefixesLength = SEPARATOR.length * messageParts.length;
            messageParts.map(function(s){messagePrefixesLength += s.length});
            var messageParameters = JSON.parse(decodeURIComponent(message.substring(messagePrefixesLength)));
            return {
                prefix: messageParts[0],
                messageType: messageParts[1],
                intendedTarget: messageParts[2],
                origin: messageParts[3],
                parameters: messageParameters
            };
        };

        var handleMessageInner = function(messageType, origin, parameters) {
            if (messageHandlers[messageType]) {
                messageHandlers[messageType](origin, parameters);
            }
        };

        /**
         * Remove a Windows-only message prefix from a stringified message
         * Current windows prefix is `ms-appx-web:///`
         * @param message {string}
         * @returns {string}
         */
        var stripWindowsPrefix = function(message) {
            if (message.substr(0, self.nativeWindowsAdditionalPrefixPrototcol.length) === self.nativeWindowsAdditionalPrefixPrototcol) {
                message = message.substr(self.nativeWindowsAdditionalPrefixPrototcol.length);
            }
            return message;
        };

        /**
         * Creates a unique string of the form currentDateInBase36-randomNumberBetweenMinAndMax.
         *
         * @param min The lower limit (inclusive) of the random number interval.
         * @param max The upper limit (inclusive) of the random number interval.
         * @returns {string} The unique string.
         */
        var getMultipartMessageId = function(min, max) {
            var rn = Math.floor(Math.random() * (max - min + 1)) + min;
            return Date.now().toString(36).toUpperCase() + '-' + rn;
        };

        self.api = {};
        self.api.handleMessage = self.handleMessage;
        self.api.parseMessage = self.parseMessage;
        //endregion
    };

    return new AppUtils();
});

/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
!function(e,t,n){typeof module!="undefined"&&module.exports?module.exports=n():typeof define=="function"&&define.amd?define(t,n):e[t]=n()}(this,"bowser",function(){function t(t){function n(e){var n=t.match(e);return n&&n.length>1&&n[1]||""}function r(e){var n=t.match(e);return n&&n.length>1&&n[2]||""}var i=n(/(ipod|iphone|ipad)/i).toLowerCase(),s=/like android/i.test(t),o=!s&&/android/i.test(t),u=/nexus\s*[0-6]\s*/i.test(t),a=!u&&/nexus\s*[0-9]+/i.test(t),f=/CrOS/.test(t),l=/silk/i.test(t),c=/sailfish/i.test(t),h=/tizen/i.test(t),p=/(web|hpw)os/i.test(t),d=/windows phone/i.test(t),v=/SamsungBrowser/i.test(t),m=!d&&/windows/i.test(t),g=!i&&!l&&/macintosh/i.test(t),y=!o&&!c&&!h&&!p&&/linux/i.test(t),b=n(/edge\/(\d+(\.\d+)?)/i),w=n(/version\/(\d+(\.\d+)?)/i),E=/tablet/i.test(t),S=!E&&/[^-]mobi/i.test(t),x=/xbox/i.test(t),T;/opera/i.test(t)?T={name:"Opera",opera:e,version:w||n(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)}:/opr|opios/i.test(t)?T={name:"Opera",opera:e,version:n(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i)||w}:/SamsungBrowser/i.test(t)?T={name:"Samsung Internet for Android",samsungBrowser:e,version:w||n(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)}:/coast/i.test(t)?T={name:"Opera Coast",coast:e,version:w||n(/(?:coast)[\s\/](\d+(\.\d+)?)/i)}:/yabrowser/i.test(t)?T={name:"Yandex Browser",yandexbrowser:e,version:w||n(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)}:/ucbrowser/i.test(t)?T={name:"UC Browser",ucbrowser:e,version:n(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)}:/mxios/i.test(t)?T={name:"Maxthon",maxthon:e,version:n(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)}:/epiphany/i.test(t)?T={name:"Epiphany",epiphany:e,version:n(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)}:/puffin/i.test(t)?T={name:"Puffin",puffin:e,version:n(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)}:/sleipnir/i.test(t)?T={name:"Sleipnir",sleipnir:e,version:n(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)}:/k-meleon/i.test(t)?T={name:"K-Meleon",kMeleon:e,version:n(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)}:d?(T={name:"Windows Phone",windowsphone:e},b?(T.msedge=e,T.version=b):(T.msie=e,T.version=n(/iemobile\/(\d+(\.\d+)?)/i))):/msie|trident/i.test(t)?T={name:"Internet Explorer",msie:e,version:n(/(?:msie |rv:)(\d+(\.\d+)?)/i)}:f?T={name:"Chrome",chromeos:e,chromeBook:e,chrome:e,version:n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)}:/chrome.+? edge/i.test(t)?T={name:"Microsoft Edge",msedge:e,version:b}:/vivaldi/i.test(t)?T={name:"Vivaldi",vivaldi:e,version:n(/vivaldi\/(\d+(\.\d+)?)/i)||w}:c?T={name:"Sailfish",sailfish:e,version:n(/sailfish\s?browser\/(\d+(\.\d+)?)/i)}:/seamonkey\//i.test(t)?T={name:"SeaMonkey",seamonkey:e,version:n(/seamonkey\/(\d+(\.\d+)?)/i)}:/firefox|iceweasel|fxios/i.test(t)?(T={name:"Firefox",firefox:e,version:n(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)},/\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(t)&&(T.firefoxos=e)):l?T={name:"Amazon Silk",silk:e,version:n(/silk\/(\d+(\.\d+)?)/i)}:/phantom/i.test(t)?T={name:"PhantomJS",phantom:e,version:n(/phantomjs\/(\d+(\.\d+)?)/i)}:/slimerjs/i.test(t)?T={name:"SlimerJS",slimer:e,version:n(/slimerjs\/(\d+(\.\d+)?)/i)}:/blackberry|\bbb\d+/i.test(t)||/rim\stablet/i.test(t)?T={name:"BlackBerry",blackberry:e,version:w||n(/blackberry[\d]+\/(\d+(\.\d+)?)/i)}:p?(T={name:"WebOS",webos:e,version:w||n(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)},/touchpad\//i.test(t)&&(T.touchpad=e)):/bada/i.test(t)?T={name:"Bada",bada:e,version:n(/dolfin\/(\d+(\.\d+)?)/i)}:h?T={name:"Tizen",tizen:e,version:n(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i)||w}:/qupzilla/i.test(t)?T={name:"QupZilla",qupzilla:e,version:n(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i)||w}:/chromium/i.test(t)?T={name:"Chromium",chromium:e,version:n(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i)||w}:/chrome|crios|crmo/i.test(t)?T={name:"Chrome",chrome:e,version:n(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)}:o?T={name:"Android",version:w}:/safari|applewebkit/i.test(t)?(T={name:"Safari",safari:e},w&&(T.version=w)):i?(T={name:i=="iphone"?"iPhone":i=="ipad"?"iPad":"iPod"},w&&(T.version=w)):/googlebot/i.test(t)?T={name:"Googlebot",googlebot:e,version:n(/googlebot\/(\d+(\.\d+))/i)||w}:T={name:n(/^(.*)\/(.*) /),version:r(/^(.*)\/(.*) /)},!T.msedge&&/(apple)?webkit/i.test(t)?(/(apple)?webkit\/537\.36/i.test(t)?(T.name=T.name||"Blink",T.blink=e):(T.name=T.name||"Webkit",T.webkit=e),!T.version&&w&&(T.version=w)):!T.opera&&/gecko\//i.test(t)&&(T.name=T.name||"Gecko",T.gecko=e,T.version=T.version||n(/gecko\/(\d+(\.\d+)?)/i)),!T.windowsphone&&!T.msedge&&(o||T.silk)?T.android=e:!T.windowsphone&&!T.msedge&&i?(T[i]=e,T.ios=e):g?T.mac=e:x?T.xbox=e:m?T.windows=e:y&&(T.linux=e);var N="";T.windowsphone?N=n(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i):i?(N=n(/os (\d+([_\s]\d+)*) like mac os x/i),N=N.replace(/[_\s]/g,".")):o?N=n(/android[ \/-](\d+(\.\d+)*)/i):T.webos?N=n(/(?:web|hpw)os\/(\d+(\.\d+)*)/i):T.blackberry?N=n(/rim\stablet\sos\s(\d+(\.\d+)*)/i):T.bada?N=n(/bada\/(\d+(\.\d+)*)/i):T.tizen&&(N=n(/tizen[\/\s](\d+(\.\d+)*)/i)),N&&(T.osversion=N);var C=N.split(".")[0];if(E||a||i=="ipad"||o&&(C==3||C>=4&&!S)||T.silk)T.tablet=e;else if(S||i=="iphone"||i=="ipod"||o||u||T.blackberry||T.webos||T.bada)T.mobile=e;return T.msedge||T.msie&&T.version>=10||T.yandexbrowser&&T.version>=15||T.vivaldi&&T.version>=1||T.chrome&&T.version>=20||T.samsungBrowser&&T.version>=4||T.firefox&&T.version>=20||T.safari&&T.version>=6||T.opera&&T.version>=10||T.ios&&T.osversion&&T.osversion.split(".")[0]>=6||T.blackberry&&T.version>=10.1||T.chromium&&T.version>=20?T.a=e:T.msie&&T.version<10||T.chrome&&T.version<20||T.firefox&&T.version<20||T.safari&&T.version<6||T.opera&&T.version<10||T.ios&&T.osversion&&T.osversion.split(".")[0]<6||T.chromium&&T.version<20?T.c=e:T.x=e,T}function r(e){return e.split(".").length}function i(e,t){var n=[],r;if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r++)n.push(t(e[r]));return n}function s(e){var t=Math.max(r(e[0]),r(e[1])),n=i(e,function(e){var n=t-r(e);return e+=(new Array(n+1)).join(".0"),i(e.split("."),function(e){return(new Array(20-e.length)).join("0")+e}).reverse()});while(--t>=0){if(n[0][t]>n[1][t])return 1;if(n[0][t]!==n[1][t])return-1;if(t===0)return 0}}function o(e,r,i){var o=n;typeof r=="string"&&(i=r,r=void 0),r===void 0&&(r=!1),i&&(o=t(i));var u=""+o.version;for(var a in e)if(e.hasOwnProperty(a)&&o[a]){if(typeof e[a]!="string")throw new Error("Browser version in the minVersion map should be a string: "+a+": "+String(e));return s([u,e[a]])<0}return r}function u(e,t,n){return!o(e,t,n)}var e=!0,n=t(typeof navigator!="undefined"?navigator.userAgent||"":"");return n.test=function(e){for(var t=0;t<e.length;++t){var r=e[t];if(typeof r=="string"&&r in n)return!0}return!1},n.isUnsupportedBrowser=o,n.compareVersions=s,n.check=u,n._detect=t,n});
define("bowser", function(){});

define('shared/utils/urlUtils',['shared/constants', 'shared/config', 'shared/ui/messageBox', 'bowser'],
    function(constants, config, messageBox, bowser) {
        var UrlUtils = function() {
            var self = this;

            self.openURL = function(url, attemptNewWindow) {
                if (config.getFromQuery('isApp')) {
                    self.navigateToUrl(url);
                    return;
                }
                if (attemptNewWindow) {
                    var windowReference = window.open(url, config.urlNavigationTarget);
                    // window reference returns `null` if the window could not be opened
                    if (!windowReference) {
                        if (bowser.msie || bowser.msedge) {
                            // MS browsers may also return `null` from `window.open` if the link targets another zone
                            //  for example, opening intranet links (like `sharepoint`) from an internet page
                            var settings = {
                                leftLabel: localisation.get('info.unableToOpenLink.back'),
                                rightLabel: localisation.get('info.unableToOpenLink.forward'),
                                rightCallback: events.callback(this, self.navigateToUrl, url),
                                text: localisation.get('info.unableToOpenLink.message')
                            };
                            messageBox.displayAdvancedTwoButtonPopup(settings);
                        } else {
                            self.navigateToUrl(url);
                        }
                    }
                } else {
                    self.navigateToUrl(url);
                }
            };

            self.navigateToUrl = function(url) {
                // we could just use window.open here but in case we're in an iframe do this instead
                window.top.location = url;
            };

        };

        return new UrlUtils();
    });

/**
 * This module should be used whenever use of window.localStorage is desired as it protects us against calls to it if it
 * is not present (for example in funky document modes of IE 11). If window.localStorage is available then this module
 * will simply return a reference to that interface unchanged. If it is not however it will return an object which
 * mirrors the functionality of the native window.localStorage object except that it stores information in memory and
 * thus any data is lost on page refresh. This replacement for window.localStorage is therefore clearly not designed to
 * mimic the functionality completely but more so it is designed protect against complete reader failure because
 * window.localStorage isn't available when it's probably only being used to store some preferences or local UGC data.
 */
define('shared/storage',[], function() {

    // test if local storage is available
    try {
        window.localStorage.setItem('localStorageTest', 1);
        window.localStorage.removeItem('localStorageTest');
        // if it is available, just return the actual local storage interface
        return window.localStorage;
    }
    catch (e) {
        // if there are any issues using local storage, create a fake version which just stores things in memory
        var Storage = function() {
            var self = this;

            self.storage = {};

            self.setItem = function(key, value) {
                var valueToStore;
                // to match the behaviour of the native local storage we need to treat undefined and null differently
                // to actual objects
                switch (value) {
                    case undefined:
                        valueToStore = 'undefined';
                        break;
                    case null:
                        valueToStore = 'null';
                        break;
                    default:
                        valueToStore = value.toString();
                }
                // store the value in our in memory cache
                self.storage[key] = valueToStore;
            };

            self.getItem = function(key) {
                // if the object doesn't exist in the storage cache return null to match the native local storage
                // behaviour
                return self.storage.hasOwnProperty(key) ? self.storage[key] : null;
            };

            self.removeItem = function(key) {
                delete self.storage[key];
            };

            self.clear = function() {
                self.storage = {};
            };

            self.key = function(index) {
                // this function is a bit odd as no order is guaranteed (see https://developer.mozilla.org/en-US/docs/Web/API/Storage/key)
                // therefore we can just return the first key we come to that is in the storage object
                for (var key in self.storage) {
                    if (self.storage.hasOwnProperty(key)) {
                        return key;
                    }
                }
            };
        };

        // instantiate the fake local storage and return it
        return new Storage();
    }
});

define('shared/utils/tools',['jquery', 'crypto', 'config', 'shared/storage', 'shared/utils/appUtils'],
    function($, crypto, config, storage, appUtils) {

        var uniqueUserId = null;
        var MAX_UID = 100000000;
        var USERID_KEY = "html_uid";

        var decryptJson = function (encryptedJson, passKey) {
            if (!encryptedJson.isEnc || !encryptedJson.data || !encryptedJson.iv)
                return null;

            var cipherParams = crypto.lib.CipherParams.create({
                ciphertext: crypto.enc.Base64.parse(encryptedJson.data)
            });
            var decrypted = crypto.AES.decrypt(
                cipherParams,
                crypto.enc.Hex.parse(passKey),
                {iv: crypto.enc.Hex.parse(encryptedJson.iv)});

            var decryptedString = decrypted.toString(crypto.enc.Utf8);
            try {
                return JSON.parse(decryptedString);
            }
            catch (e) {
                return null;
            }
        };

        var getUniqueUserId = function() {
            // try retrieving from the query string first as this will provide us with an app level deviceId if there's
            // one available (and we want the app level deviceId to have a higher priority than the reader level one)
            var fromQuery = config.getFromQuery('deviceId');
            if (fromQuery) {
                uniqueUserId = fromQuery;
                return uniqueUserId;
            }

            // otherwise see if we've already retrieved a userId and stored it locally
            if (uniqueUserId != null)
                return uniqueUserId;

            // then try retrieving the user id from localstorage
            var storedUserId = storage.getItem(USERID_KEY);
            if (storedUserId) {
                uniqueUserId = storedUserId;
                return uniqueUserId;
            }

            // otherwise generate a new id
            uniqueUserId = Math.floor(Math.random() * MAX_UID + 1);
            storage.setItem(USERID_KEY, uniqueUserId);

            return uniqueUserId;
        };

        var isThisAnApp = function() {
            return appUtils.isThisAnApp(config.getQueryObject());
        };

        var showHideElement = function(element, show) {
            if (show)
                element.show();
            else
                element.hide();
        };

        var isMobile = {
            Android: function () {
                return navigator.userAgent.match(/Android/i);
            },
            BlackBerry: function () {
                return navigator.userAgent.match(/BlackBerry/i);
            },
            iOS: function () {
                return navigator.userAgent.match(/iPhone|iPad|iPod/i);
            },
            Opera: function () {
                return navigator.userAgent.match(/Opera Mini/i);
            },
            Windows: function () {
                return navigator.userAgent.match(/IEMobile/i) || navigator.userAgent.match(/WPDesktop/i);
            },
            any: function () {
                return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());
            }
        };

        var removeElementFromArray = function(array, elementToRemove) {
            return array.filter(function(element) {
                return element !== elementToRemove
            });
        };

        return {
            decryptJson: decryptJson,
            getUniqueUserId: getUniqueUserId,
            isThisAnApp: isThisAnApp,
            showHideElement: showHideElement,
            isMobile: isMobile,
            removeElementFromArray: removeElementFromArray
        };
    });

define('utils/tools',['jquery', 'config', 'crypto', 'constants', 'resources', 'events', 'shared/ui/messageBox',
        'shared/localisation', 'shared/utils/appUtils', 'shared/utils/queryStringUtils', 'shared/utils/urlUtils', 'bowser', 'shared/storage', 'shared/utils/tools'],
    function($, config, crypto, constants, resources, events, messageBox,
             localisation, appUtils, queryStringUtils, urlUtils, bowser, storage, sharedTools) {

        function Tools() {
            var getPrettyQueryString = function (userPage) {
                var query = config.queryObject;

                var allowedKeys = ['distributorId'];
                // Publisher sends a list of keys for preservation in the `customUrlQueryParams` object.
                // This may or may not include `distributorId` which always needs to be preserved:
                // If it is included, we don't want to duplicate it's entry: just use the list Publisher sends,
                // If not, add it to Publisher's list.
                if (resources.yuduBook.orderForm
                    && resources.yuduBook.orderForm.submitToCustomUrl
                    && resources.yuduBook.orderForm.customUrlQueryParams) {
                    if ($.inArray('distributorId', resources.yuduBook.orderForm.customUrlQueryParams) >= 0) {
                        allowedKeys = resources.yuduBook.orderForm.customUrlQueryParams;
                    } else {
                        allowedKeys = allowedKeys.concat(resources.yuduBook.orderForm.customUrlQueryParams);
                    }
                }
                var niceOut = {};

                for (var i = 0, m = allowedKeys.length; i < m; i++) {
                    var key = allowedKeys[i];
                    if (typeof query[key] != 'undefined' && query[key] != null) {
                        niceOut[key] = query[key];
                    }
                }

                if (sharedTools.isThisAnApp()) {
                    niceOut.isApp = true;
                }

                if (userPage > (config.hasIntroPage ? 0 : 1)) {
                    niceOut.page = userPage;
                }

                niceOut.origin = 'reader'; // need to know this is an internal navigation
                return $.param(niceOut);
            };

            var clamp = function (min, value, max) {
                return value < min ? min : (value > max ? max : value);
            };

            // NOTE: This is only here because of the way IE scales its video UI
            // It will be out of date the second MS releases a new version of IE.
            // DO NOT USE THIS FUNCTION. EVER. FOR ANYTHING.
            // ...or I'll cry
            var isThisIE = function () {
                var userAgent = window.navigator.userAgent || "";

                if (userAgent.indexOf('MSIE ') > 0)
                    return true;

                if (userAgent.indexOf('Trident/') > 0)
                    return true;

                if (userAgent.indexOf('Edge/') > 0)
                    return true;

                return false;
            };

            var isVisible = function (element) {
                return !element.is(':hidden') && element.is(':visible');
            };

            var openURL = urlUtils.openURL;

            var getContentTypeFromUrl = function (url) {
                url = url.toLowerCase();

                if (getYouTubeUrlPattern().test(url)) {
                    return constants.urlContentOverlayTypes.youTube;
                }

                var queryStringIndex = url.indexOf("?");
                var urlWithoutQueryString = queryStringIndex < 0 ? url : url.substring(0, queryStringIndex);

                var extensionIndex = urlWithoutQueryString.lastIndexOf(".");
                if (extensionIndex < 0) {
                    return constants.urlContentOverlayTypes.unknown;
                }

                var extension = urlWithoutQueryString.substring(extensionIndex + 1);
                switch (extension) {
                    case "jpg":
                    case "jpeg":
                    case "png":
                    case "gif":
                        return constants.urlContentOverlayTypes.image;
                    case "mp4":
                    case "ogv":
                    case "ogg":
                    case "webm":
                        return constants.urlContentOverlayTypes.video;
                    case "mp3":
                        return constants.urlContentOverlayTypes.audio;
                    default:
                        return constants.urlContentOverlayTypes.unknown;
                }
            };

            var getYouTubeUrlPattern = function () {
                // Needs to be changed if the way youtube urls are constructed in the OED changes.
                return /(?:^http:\/\/www\.youtube\.com\/v\/)([\w\-]{11})(?:\?version=\d$)/ig;
            };

            /**
             * Behaviour varies depending on whether an input element is specified
             * If `!!videoElement` then checks if the element is that which is currently fullscreen
             * If not, then checks if there is a fullscreen element
             * Edit 201604: with the introduction of the Reader's own fullscreen mode, the below check had to be remanaged
             *  It seems to have been originally intended to detect a fullscreen video when an iOS tablet was rotated
             *  But without a change in behvaiour it failed to stop a video playing on page change when the reader was in fullscreen mode
             * If making future changes, please ensure that fullscreen videos on iOS tablets behave properly when rotating the device,
             *  and that playing videos are paused when the reader is in fullscreen mode and the page changes
             * @param videoElement ; element to check - if falsey will just check if there is something fullscreen
             * @returns {boolean} ; fullscreen element satisfying the above conditions
             */
            var isElementFullScreen = function (videoElement) {
                /*
                 * This comment appears to relate to the iOS video detection, it remains for legacy purposes, since iOS 8 is still supported
                 webkitDisplayingFullscreen has been deprecated in favour of an actual standard (the fullscreen API)
                 but it works for the one instance we need it to work which is iOS 8 iPad/iPhone where standards are for
                 chumps. Note also that IE10 doesn't support the fullscreen API, only IE11 does.
                 TODO: fix this properly when iOS stops being the worst.
                 */
                if (videoElement) {
                    return !!videoElement.webkitDisplayingFullscreen
                        || document.fullScreenElement === videoElement
                        || document.msFullscreenElement === videoElement
                        || document.mozFullScreenElement === videoElement
                        || document.webkitFullscreenElement === videoElement;
                } else {
                    return !!(document.fullScreenElement || document.msFullscreenElement
                    || document.mozFullScreenElement || document.webkitFullscreenElement);
                }
            };

            /**
             * This function is a combination of [this SO answer](http://stackoverflow.com/a/105074),
             *      and a comment's [extension function](https://gist.github.com/duzun/d1bfb5406a362e06eccd)
             *  Note it is declared rather than left annonymous for efficiency
             */
            function createUID() {
                /**
                 * given an input number `n` in decimal, this function floors it, converts it to base 16,
                 *      and ensures any letters are in uppercase
                 * @param n
                 * @returns {string}
                 */
                var stringifyNumber = function (n) {
                    return Math.floor(n).toString(16).toUpperCase();
                };
                /**
                 * generate a random number rn (base 16) with n characters, such that 0 <= rn (decimal) < 16^n
                 * `1 + Math.random()` ensures there is a leading 1 which, once stripped, ensures there are leading 0s
                 * `Math.pow(16, n)` could be complicated to `(1<<(n<<2))` but we choose legibility over debatable efficiency here
                 * @param n
                 * @returns {string}
                 */
                var createRandomHexes = function (n) {
                    return stringifyNumber((1 + Math.random()) * (Math.pow(16, n))).substring(1);
                };
                /**
                 * As `createRandomHexes` except it also performs bitwise-or against the time to avoid a potential bug
                 *      in Chrome that causes repetition of numbers generated by `Math.random()` after several million
                 *  `slice(-n)` then required to only use the last `n` characters
                 * @param n
                 * @returns {string}
                 */
                var createRandomHexesByDate = function (n) {
                    return stringifyNumber(( (1 + Math.random()) * (Math.pow(16, n)) ) ^ Date.now()).slice(-n);
                };
                /**
                 * given two numbers 0 <= `start` < `end` <= 16 this function chooses a random number `rn` between
                 *      start <= rn < end ; and outputs it in base 16
                 * @param start
                 * @param end
                 */
                var createRangeLimitedHex = function (start, end) {
                    return stringifyNumber(start + ((end - start) * Math.random()));
                };
                // this is the part of the function that actually creates a pseudo-GUID for us
                // target of form: 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'; where y is one of {89AB}
                return createRandomHexesByDate(4) + createRandomHexesByDate(4) + '-' +
                    createRandomHexes(4) + '-' +
                    '4' + createRandomHexes(3) + '-' +
                    createRangeLimitedHex(8, 12) + createRandomHexes(3) + '-' +
                    createRandomHexes(2) + Date.now().toString(16).slice(-10);
            }

            //region functions to capture mutable variables
            /**
             * Given an input,
             *  if a function, evaluate the function and return its return value, if any
             *  if not, return the input as-is
             * Not compatible with functions that cannot implicitly handle no-arg calls
             * This makes the below functions safe with both getters and literals
             * @param func {*}
             * @returns {*}
             */
            var calculateDynamicValue = function (func) {
                return typeof func === 'function' ? func() : func;
            };

            /**
             * Given an input, return a no-arg function that, when called, returns the dynamic value of the input
             * Will capture the value of `input`, and thanks to the dynamic value calculation, whether the input is
             *  a reference to a mutable variable that gets changed externally, or a function whose output changes,
             *  executing the function returned by a call to this function will always return the most up-to-date
             *  value of `input` available
             * If `input` is immutable, then it will be returned directly by the resultant function
             * Note: if a mutable object is passed in, its reference will be kept alive here, even if any external
             *  reference is reassigned (so eg if you pass in `{}`, make sure to _modify_ instead of reassigning)
             * @param input {*}
             * @returns {Function}
             */
            var returnDynamicInput = function (input) {
                return function () {
                    return calculateDynamicValue(input);
                }
            };

            /**
             * Given an input function and any arguments it requires, returns the dynamic value of that function evaluated
             *  with those arguments passed to it
             * Captures all arguments so that dynamic evaluation will use the preserved variables for future evaluation
             * Returns a no-arg getter that performs the dynamic evaluation with the original values on-demand
             * Arguments will themselves be dynamically evaluated to ensure any getters specified have literals retrieved
             * @param func {Function}
             * @returns {Function}
             */
            var returnFunctionWithDynamicArgs = function (func) {
                var args = Array.prototype.slice.call(arguments, 1);
                return function () {
                    return func.apply(this, args.map(calculateDynamicValue));
                }
            };
            //endregion

            /**
             * Helper that extracts the last path component of the current location.
             * @returns {string|null} The component if it exists, otherwise null.
             */
            var getLastPathComponent = function () {
                if (!document.location.pathname)
                    return null;

                var urlSet = document.location.pathname.match(/[^\/]+$/);
                if (!urlSet || urlSet.length == 0)
                    return null;

                return urlSet[0];
            };

            /**
             * Helper that adds or updates the page component of the query object and commits the change to history.
             * @param userPage The page number as presented to the user.
             * @param skipIfFirstPage If true, no changes are made as long as userPage refers to the edition's first page.
             */
            var addPageToQueryObjectAndPushPageHistory = function (userPage, skipIfFirstPage) {
                var pageIndexOffset = config.hasIntroPage ? 0 : 1;
                if (userPage == pageIndexOffset && skipIfFirstPage) {
                    return;
                }

                var queryObject = config.getQueryObject();
                queryObject['page'] = userPage;

                var newUrl = getLastPathComponent() + "?" + $.param(queryObject);
                history.pushState({page: userPage - pageIndexOffset}, document.title, newUrl);
            };

            return {
                parseQueryString: queryStringUtils.parseQueryString,
                getPrettyQueryString: getPrettyQueryString,
                clamp: clamp,
                openURL: openURL,
                isVisible: isVisible,
                getContentTypeFromUrl: getContentTypeFromUrl,
                getYouTubeUrlPattern: getYouTubeUrlPattern,
                isElementFullScreen: isElementFullScreen,
                isThisIE: isThisIE,
                deviceType: appUtils.deviceType,
                addQueryStringToURL: queryStringUtils.addQueryStringToURL,
                addToUrlQueryString: queryStringUtils.addToUrlQueryString,
                createUID: createUID,
                calculateDynamicValue: calculateDynamicValue,
                returnDynamicInput: returnDynamicInput,
                returnFunctionWithDynamicArgs: returnFunctionWithDynamicArgs,
                getLastPathComponent: getLastPathComponent,
                addPageToQueryObjectAndPushPageHistory: addPageToQueryObjectAndPushPageHistory
            };
        }
        return $.extend(sharedTools, new Tools());
    });

define('fetching/tileFetcherAsync',['events', 'constants', 'resources', 'fetching/tileFetcher', 'utils/tools', 'config',
            'shared/utils/queryStringUtils', 'utils/encryptedResourceFetchingUtils'],
    function(events, constants, resources, tileFetcher, tools, config,
             queryStringUtils, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "tileFetcherAsync";

        /**
         * ONLY FETCH HANDLER SHOULD DIRECTLY CALL THIS CLASS!!!
         * DO NOT TOUCH!
         * I'M WATCHING YOU!!!
         * @constructor
         */
        var TileFetcherAsync = function() {
            tileFetcher.TileFetcher.call(this);

            this.fetchingLookup = {};

            this.nextRequestID = 0;

            this.worker = null;

            this.url = window.URL || window.webkitURL;

            this.makeBlob = getBlobBuilderFunction();

            // <Required by tileFetcher.js>
            this.start = function() {
                this.url = window.URL || window.webkitURL;

                if (!this.worker) {
                    this.worker = new Worker(constants.tileFetcherDaemonLocation);
                }

                this.worker.postMessage({"cmd": "start", "pps": constants.daemonpps, "batchSize": constants.daemonTileFetchBatchSize});

                if (this.worker)
                    events.yuduAddEventListener(this.worker, 'message', events.callback(this, this.daemonEventResponder), false);
            };

            this.stop = function() {
                this.worker.postMessage({"cmd": "stop"});
                this.worker = null;
            };

            this.enqueue = function(request) {
                request.id = this.nextRequestID++;
                this.fetchingLookup[request.id] = request;

                if (this.worker) {
                    var tileUrl = request.tile.url;
                    if (!$.isEmptyObject(config.contentDecryptionHeaders)) {
                        tileUrl = queryStringUtils.addRandomQueryStringParameter(tileUrl,
                                encryptedResourceFetchingUtils.RANDOM_QUERY_STRING_PARAM_KEY);
                    }
                }
                    this.worker.postMessage({"cmd": "fetch", "url": tileUrl, "id": request.id,
                        "priority": request.priority, "headers": config.contentDecryptionHeaders});
            };

            this.flushQueues = function() {
                if (this.worker)
                    this.worker.postMessage({"cmd": "clear"});

                for (var key in this.fetchingLookup) {
                    if (this.fetchingLookup.hasOwnProperty(key))
                        this.fetchingLookup[key].tile.reset();
                }

                this.fetchingLookup = {};
            };

            this.fetchQueueSize = function() {
                var size = 0;
                for (var key in this.fetchingLookup) {
                    if (this.fetchingLookup.hasOwnProperty(key))
                        size += 1;
                }

                return size;
            };


            this.isBusy = function () {
                return this.fetchQueueSize() > constants.maxNumTilesInQueue;
            };

            // </Required by tileFetcher.js>


            this.daemonEventResponder = function(event) {
                var data = event.data;
                var request = this.fetchingLookup[Number(data.id)];

                if (!request && data.cmd != "log")
                    return;

                switch (data.cmd) {
                    case "fetched":
                        this.loadImageAndCheckAgain(request, data.url, data.startTime);
                        break;
                    case "fetchedCreate":
                        //make a blob ourselves rather than download a blob to make dataURLs work on Safari 6 (mobile)
                        var dataURL = this.url.createObjectURL(this.makeBlob(data.response));
                        this.loadImageAndCheckAgain(request, dataURL, data.startTime);
                        break;
                    case "fetchFail":
                        this.tileFetchError(request);
                        break;
                }
            };

            // I KNOW! I know. This is disgusting.
            // If the dark days come and you need more info: ask THS.
            this.loadImageAndCheckAgain = function(request, url, startTime) {

                // This function builds a closure that will evaluate the result of the request.
                function buildFinalCheckFunction (img, startTime, request) {
                    request.timeoutCall = null;

                    if (request.hasLoaded && img.complete && (typeof img.naturalWidth == "undefined" || img.naturalWidth != 0)) {
                        delete this.fetchingLookup[request.id];

                        this.requestSuccess(img, startTime, request);
                        this.url.revokeObjectURL(url);
                        return;
                    }
                    this.tileCheckError(request);
                }

                // Set up some early outs just in case.
                var img = new Image();
                img.onerror = img.onabort = events.callback(this, function() {
                    if (request.timeoutCall) {
                        clearInterval(request.timeoutCall);
                        this.tileCheckError(request);
                    }
                });
                img.onload = function() {
                    if (request.timeoutCall) {
                        clearInterval(request.timeoutCall);
                        request.hasLoaded = true;
                        request.finalCheckFunction();
                    }
                };

                request.finalCheckFunction = buildFinalCheckFunction.bind(this, img, startTime, request);
                // Check after some time to see if no events are fired
                request.timeoutCall = setTimeout(request.finalCheckFunction.bind(request), 1500);
                img.src = url; // HIT IT!
            };

            this.tileFetchError = function(request) {
                request.fetchFailureCount++;

                delete this.fetchingLookup[request.id];

                if (request.fetchFailureCount < constants.tileFetchRetryCount) {
                    request.tile.setQueued();
                    this.enqueue(request);
                }
                else {
                    this.requestFailed(request);
                }
            };

            this.tileCheckError = function(request) {
                request.checkFailureCount += 1;

                delete this.fetchingLookup[request.id];

                if (request.checkFailureCount < constants.tileCheckRetryCount) {
                    request.tile.setQueued();
                    this.enqueue(request);
                }
                else {
                    this.requestFailed(request);
                }
            };
        };
        TileFetcherAsync.prototype = tileFetcher.TileFetcher.prototype;

        var asyncSupported = function() {
            try {
                var url = window.URL || window.webkitURL;
                return (typeof(Worker) !== "undefined") && //check that Worker exists (this is how w3 checks)
                    ('Worker' in window) && //and again just to be sure (this is how Modernizr checks)
                    !navigator.userAgent.match(/iemobile/i) && //do not let windows phone use async IT WILL NOT WORK
                    !(tools.isThisAnApp() && tools.isThisIE()) && // don't allow the metro app to use webworkers (it sucks for some reason)
                    !(tools.deviceType.isAndroid()) && // Downloaded Android editions can't handle async and 'opened live' editions are ridiculously slow with async loading
                    (url != undefined) && //check that url is defined by either webkit or standard
                    (url.createObjectURL != undefined) && //only used if the worker can't use it (fetchedCreate)
                    //check that we can create Blob object in some way. Note that we create a Blob, which may fail
                    //with an TypeError: Illegal constructor exception
                    ((window.Blob && new Blob(["var doge = 'woo'"], {type: 'text/javascript'}) != null) ||
                    (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder));
            } catch (e) {
                return false;
            }
        };

        var getBlobBuilderFunction = function() {
            try {
                if (window.Blob) {
                    //we create a blob object here to check whether the Blob implementation actually works in this
                    //browser with these of parameters (i.e. the data and the options)
                    if (new Blob(["var doge = 'woo'"], {type: 'text/javascript'}) != null) {
                        return function(data) {
                            return new Blob([data], {type: 'image/jpeg'});
                        }
                    }
                }
            } catch (e) {
            }
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            return function(data) {
                var blob = new Builder();
                blob.append(data);
                return blob.getBlob('image/jpeg');
            }
        };

        return {
            TileFetcherAsync: TileFetcherAsync,
            asyncSupported: asyncSupported,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('fetching/fetchHandler',['events', 'config', 'constants', 'fetching/tileFetcherSync', 'fetching/tileFetcherAsync', 'shared/utils/tools', 'easel', 'jquery'],
    function(events, config, constants, tileFetcherSync, tileFetcherAsync, tools, createjs, $) {

        var EMITTER_NAME = "fetchHandler";

        var tileFetcher = null;

        if (tileFetcherAsync.asyncSupported()) {
            tileFetcher = new tileFetcherAsync.TileFetcherAsync();
        }
        else {
            tileFetcher = new tileFetcherSync.TileFetcherSync();
        }

        /**
         * Fetch handler abstracts handles the calls to the tileFetcher. If you want some specific tile: call loadTiles.
         * Otherwise, it will do some "aggressive" tile loading as it sees fit.
         * @constructor
         */
        var FetchHandler = function() {
            this.reader = null;

            //for each page/zoom level maintains the state of the tiles
            this.loadStatus = [];

            var downloadSpeed = {
                unknown: 0,
                low: 1,
                high: 2
            };

            this.lastPurgedTime = (new Date()).getTime();
            this.minTimeBetweenPurges = 2000;
            if (tools.isMobile.Windows()){
                // For windows mobile reduce the number of pages we keep loaded due to memory restrictions in IE mobile
                this.maxTilesBeforePurge = 210;
                this.maxLookAhead = 5;
                this.maxLookBack = 2;
            } else {
                // The average size of a tile is around 20kb so this equates to a maximum of around 100Mb
                this.maxTilesBeforePurge = 500;
                this.maxLookAhead = 10;
                this.maxLookBack = 2;
            }
            this.tilesFetched = 0;

            this.purgeFrameRate = 20;
            this.purgeFrameRateCount = 0;
            this.purgeFrameRateMax = 5;

            /**
             * Load some tiles!!
             * @param controller the tile renderer
             * @param {tiles|null} tileList of tiles in their various state of request (as given by getVisibleTiles)
             */
            this.loadTiles = function(controller, tileList, priority) {
                var loadStatus = this.getLoadStatus(controller.pageNumber, controller.z);
                var tiles = [];

                if (!tileList) {
                    tiles = controller.getUnfetchedTiles();
                    loadStatus.waitingFor = tiles;
                    loadStatus.numberVisibleTiles = 0;
                }
                else {
                    tiles = tileList.requireLoading;
                    loadStatus.waitingFor = tileList.waitingFor;
                    loadStatus.numberVisibleTiles = tileList.visibleTiles.length;
                }

                if (tiles.length > 0) {
                    tileFetcher.fetch(tiles, controller, priority);
                }
            };


            this.newRequests = function() {
                tileFetcher.flushQueues();
            };


            /**
             * For the given page / zoom level returns the the load status (initialising it if necessary)
             * @param pageNumber the page number
             * @param z the zoom level
             */
            this.getLoadStatus = function(pageNumber, z) {
                //check if the page is initialised in the load status
                if (this.loadStatus[pageNumber] == undefined) {
                    this.loadStatus[pageNumber] = {zoomLevels: []};
                }
                //check if the zoom level is in the load status
                if (this.loadStatus[pageNumber].zoomLevels[z] == undefined) {
                    var size = this.reader.pages[pageNumber].zoomLevels[z].zoomLevel.size;
                    this.loadStatus[pageNumber].zoomLevels[z] = {z: z, waitingFor: [], numberVisibleTiles: 0, totalTiles: size.x * size.y, numberLoaded: 0};
                }
                return this.loadStatus[pageNumber].zoomLevels[z];
            };


            this.classifyDownloadRate = function() {
                var speed = tileFetcher.getAverageDownloadTime();

                if (speed <= 0)
                    return downloadSpeed.unknown;
                if (speed < 200)
                    return downloadSpeed.high;
                return downloadSpeed.low
            };


            this.getAdjacentPagesToLoad = function(listOfPages, pageLookup, basePage) {
                var min = Math.max(basePage - this.maxLookBack, 0);
                var max = Math.min(basePage + this.maxLookAhead, this.reader.pages.length - 1);

                // add to list in order or priority.
                for (var i = basePage + 1; i <= max; i++) {
                    if (pageLookup[i])
                        continue;
                    listOfPages.push(i);
                    pageLookup[i] = true;
                }

                for (var i = basePage - 1; i >= min; i--) {
                    if (pageLookup[i])
                        continue;
                    listOfPages.push(i);
                    pageLookup[i] = true;
                }
            };

            this.getOptimisticFetchList = function() {
                var listOfPages = [];
                var pageLookup = {};

                var basePage = this.reader.shifter.getBasePage();

                this.getAdjacentPagesToLoad(listOfPages, pageLookup, basePage);
                var bottomZoomLevel = config.lowestZoomLevel;
                var levelsToFetch = [];

                for (var i = 0, m = listOfPages.length ; i < m ; i++) {
                    var pageNumber = listOfPages[i];
                    if (!this.reader.pages[pageNumber])
                        continue;
                    var page = this.reader.shifter.getPage(pageNumber);
                    if (page && !this.isFullyLoaded(pageNumber, bottomZoomLevel)) {
                        page.prepareZoomLevel(bottomZoomLevel);
                        levelsToFetch.push(page.zoomLevels[bottomZoomLevel]);
                    }
                }
                return levelsToFetch;
            };

            this.isFullyLoaded = function(pageNumber, z) {
                if (this.loadStatus[pageNumber] && this.loadStatus[pageNumber].zoomLevels[z]) {
                    var loadStatus = this.loadStatus[pageNumber].zoomLevels[z];
                    return loadStatus.totalTiles == loadStatus.numberLoaded;
                }
                return false;
            };

            this.manageLoadings = function() {
                if (tileFetcher.isBusy())
                    return;

                this.purgeIfNeeded();

                var levels = this.getOptimisticFetchList();
                for (var i = 0, m = levels.length ; i < m ; i++) {
                    this.loadTiles(levels[i], false);
                }
            };

            this.purgeIfNeeded = function() {
                var frameRate = createjs.Ticker.getMeasuredFPS();
                if (this.tilesFetched > this.maxTilesBeforePurge) {
                    this.tryPurge();
                    return true;
                }

                if (frameRate < this.purgeFrameRate) {
                    this.purgeFrameRateCount += 1;

                    if (this.purgeFrameRateCount > this.purgeFrameRateMax) {
                        this.purgeFrameRateCount = 0;
                        this.tryPurge();
                    }

                    return true;
                }

                this.purgeFrameRateCount = 0;
                return false;
            };


            this.tryPurge = function() {
                var nowTime = (new Date()).getTime();
                if (nowTime - this.lastPurgedTime < this.minTimeBetweenPurges)
                    return;

                this.lastPurgedTime = nowTime;

                var basePage = this.reader.shifter.getBasePage();
                var beforeClear = basePage - this.maxLookBack - 1;
                var afterClear = basePage + this.maxLookAhead + 1;

                for (var i = 0 ; i < beforeClear ; i++ ) {
                    if (!this.reader.pages[i])
                        continue;
                    this.tilesFetched -= this.reader.shifter.getPage(i).unloadAllTiles();
                    delete this.loadStatus[i];
                }

                for (var i = afterClear ; i < this.reader.pages.length ; i++ ) {
                    if (!this.reader.pages[i])
                        continue;
                    this.tilesFetched -= this.reader.shifter.getPage(i).unloadAllTiles();
                    delete this.loadStatus[i];
                }
            };

            this.tileFetched = function(event) {
                //update the load status
                var pageNumber = event.data.zoomLevel.pageNumber;
                var z = event.data.zoomLevel.z;
                var loadStatus = this.getLoadStatus(pageNumber, z);
                loadStatus.numberLoaded++;
                var index = $.inArray(event.data.tile, loadStatus.waitingFor);
                this.tilesFetched += 1;
                if (index >= 0)
                    loadStatus.waitingFor.splice(index, 1);

                if (loadStatus.waitingFor.length == 0) {
                    events.emit(EMITTER_NAME, events.ZOOMLEVEL_TILESLOADED, this, {pageNumber: pageNumber, z: z});
                }
            };

            this.start = function() {
                tileFetcher.start();
            };

            this.activatePreloader = function() {
                var intervalTime = 1000 / constants.fetchHandlerpps;
                this.timer = setInterval(events.callback(this, this.manageLoadings), intervalTime);
            };

            this.stop = function() {
                tileFetcher.stop();
                if(this.timer) {
                    clearInterval(this.timer);
                }
                tileFetcher = null;
            };
        };

        //singleton fetcher
        var fetchHandler = new FetchHandler();
        events.subscribe(events.ALL, events.TILE_FETCHED, events.callback(fetchHandler, fetchHandler.tileFetched));

        return {
            start: events.callback(fetchHandler, fetchHandler.start),
            stop: events.callback(fetchHandler, fetchHandler.stop),
            loadTiles: events.callback(fetchHandler, fetchHandler.loadTiles),
            isFullyLoaded: events.callback(fetchHandler, fetchHandler.isFullyLoaded),
            getLoadStatus: events.callback(fetchHandler, fetchHandler.getLoadStatus),
            newRequests: events.callback(fetchHandler, fetchHandler.newRequests),
            setReader: events.callback(fetchHandler, function(reader) { this.reader = reader; }),
            activatePreloader: events.callback(fetchHandler, fetchHandler.activatePreloader),
            EMITTER_NAME: EMITTER_NAME,
            _private: {
                getAdjacentPagesToLoad: events.callback(fetchHandler, fetchHandler.getAdjacentPagesToLoad),
                getOptimisticFetchList: events.callback(fetchHandler, fetchHandler.getOptimisticFetchList),
                tileFetcher: tileFetcher,
                maxLookAhead: fetchHandler.maxLookAhead
            }
        };
    });

define('model/tile',['easel', 'constants', 'events'],
    function(createjs, constants, events) {

        var EMITTER_NAME = "tile";

        var TileState = {
            start:0,
            queued:1,
            fetching:2,
            fetched:3
        };

        var Tile = function(x, y, width, height, url) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;

            //the actual image's width and height. This is read from the image when it is downloaded
            this.imageWidth = this.width;
            this.imageHeight = this.height;
            this.url = url;

            this.image = null;
            this.state = TileState.start;
        };

        Tile.prototype.triggerFadeIn = function() {
            if (!this.image)
                return;

            this.image.alpha = 0;
            var id = this.image.id;
            createjs.Tween
                .get(this.image, {override: true})
                .call(function() {
                    events.emit(EMITTER_NAME, events.TILE_FADE_START, this, { id: id });
                })
                .to({alpha: 1}, constants.tileFadeTime)
                .wait(500)
                .call(function() {
                    events.emit(EMITTER_NAME, events.TILE_FADE_END, this, { id: id });
                });
        };

        Tile.prototype.isComplete = function() {
            return this.state == TileState.fetched;
        };

        Tile.prototype.isEnroute = function() {
            return this.state == TileState.fetching || this.state == TileState.queued;
        };

        Tile.prototype.setFetched = function() {
            this.state = TileState.fetched;
        };

        Tile.prototype.setQueued = function() {
            this.state = TileState.queued;
        };

        Tile.prototype.setFetching = function() {
            this.state = TileState.fetching;
        };

        Tile.prototype.reset = function() {
            this.state = TileState.start;
        };

        return {
            Tile: Tile
        };
    });

define('controllers/zoomLevelController',['jquery', 'events', 'config', 'constants', 'model/zoomLevel', 'views/zoomLevelView', 'fetching/fetchHandler', 'model/tile'],
    function($, events, config, constants, zoomLevel, zoomLevelView, fetchHandler, tileModel) {

        var EMITTER_NAME = "zoomLevelController";

        /**
         * Class that controls a zoom level.
         * @param z the z of this level, e.g. it's index.
         * @param zoomInfo an object containing information about this zoom level.
         * @param baseURL the baseURL for each tile which will be used to construct the rest of the tile specific URLs.
         * @param filePattern the file format used for each tile.
         * @constructor
         */
        var ZoomLevelController = function(z, zoomSettings, zoomInfo, baseURL, filePattern, pageNumber) {
            //indicate that we are not yet initialised
            this.initialised = false;
            //create model object and view
            this.zoomLevel = new zoomLevel.ZoomLevel(z, zoomInfo.w, zoomInfo.h, zoomSettings.tileW, zoomSettings.tileH, baseURL, filePattern);
            //an array that will hold the tiles. This array will be 2 dimensional to mirror the actual tiles positions
            this.tiles = [];
            //the page number of this zoom level
            this.pageNumber = pageNumber;
            this.z = z;
            this.alignment = -1;

            /**
             * Initialises the object.
             */
            this.init = function() {
                this.initialised = true;
                this.createTiles();
                if (this.alignment >= 0) {
                    this.setAlignment(this.alignment);
                }
            };

            this.tileLoaded = function(tile) {
                this.zoomLevelView.drawTile(tile);
            };

            /**
             * Creates and returns the URL for the given x and y. These are of the form "/tile-{z}-{x}-{y}.{ext}"
             * e.g. "/tile-0-2-1.jpg"
             * @param x the x index of this tile, starting with 0 at the left edge
             * @param y the y index of this tile, starting with 0 at the top edge
             * @returns {string}
             */
            this.createURL = function(x, y) {
                var filename = this.zoomLevel.filePattern.replace("{$z}", this.zoomLevel.z).replace("{$x}", x).replace("{$y}", y);
                return constants.baseTileFolder + this.zoomLevel.baseURL + "/" + filename;
            };

            /**
             * Create all the tiles and the container to hold them for this zoom level.
             * Note that each tile created is purely an object containing it's dimensions and a position as well
             * as some other properties, but importantly no actual visual representation of the tile.
             * This allows us to create the tiles but not use up too much memory or time storing or fetching the images
             * as this is done when the tile becomes visible.
             */
            this.createTiles = function() {
                this.zoomLevelView = new zoomLevelView.ZoomLevelView(this.zoomLevel.width, this.zoomLevel.height);

                for (var x = 0; x < this.zoomLevel.size.x; x++) {
                    this.tiles[x] = [];
                    for (var y = 0; y < this.zoomLevel.size.y; y++) {
                        //calculate tile sizes
                        var tileWidth = this.calculateTileWidth(x);
                        var tileHeight = this.calculateTileHeight(y);
                        //calculate absolute tile positions
                        var ax = this.zoomLevel.tileWidth * x;
                        var ay = this.zoomLevel.tileHeight * y;
                        //create the tile URL to fetch image from
                        var url = this.createURL(x, y);

                        this.tiles[x][y] = new tileModel.Tile(ax, ay, tileWidth, tileHeight, url);
                    }
                }
            };

            /**
             * Calculates the tile width based on it's index. Tiles will be trimmed to fit the level
             * width, e.g. if the level width is 5 and the tile width is 4 then the tiles at x index 0
             * will be 4 wide whereas the tiles at index 1 will be 1 wide.
             * Tiles not at the edge will be incremented with an overlap value, this is to fix an iOS graphics bug.
             * @param tileXIndex
             */
            this.calculateTileWidth = function(tileXIndex) {
                if (tileXIndex == (this.zoomLevel.size.x - 1)) {
                    //tile width - (gap between zoom level width and the width of a full size tile row)
                    return this.zoomLevel.tileWidth - (((tileXIndex + 1) * this.zoomLevel.tileWidth) - this.zoomLevel.width);
                }
                return this.zoomLevel.tileWidth + config.overlap;
            };

            /**
             * Calculates the tile height based on it's index. Tiles will be trimmed to fit the level
             * height, e.g. if the level height is 5 and the tile height is 4 then the tiles at y index 0
             * will be 4 high whereas the tiles at index 1 will be 1 high.
             * Tiles not at the edge will be incremented with an overlap value, this is to fix an iOS graphics bug.
             * @param tileYIndex
             */
            this.calculateTileHeight = function(tileYIndex) {
                if (tileYIndex == (this.zoomLevel.size.y - 1)) {
                    //tile height - (gap between zoom level height and the height of a full size tile column)
                    return this.zoomLevel.tileHeight - (((tileYIndex + 1) * this.zoomLevel.tileHeight) - this.zoomLevel.height);
                }
                return this.zoomLevel.tileHeight + config.overlap;
            };

            /**
             * Fetch all tiles that are visible in the current 'viewport'.
             * Note: the current 'viewport' is defined by config.width and config.height and should be the size of
             * the stage (and hence canvas) we are rendering to.
             * Adjust VIEWPORT by dx, dy
             */
            this.load = function(dx, dy) {
                fetchHandler.loadTiles(this, this.getVisibleTiles(dx, dy), true);
            };

            /**
             * Find all the tiles that are visible in the current 'viewport' and return them. See load for 'viewport'
             * definition.
             */
            this.getVisibleTiles = function(dx, dy) {
                dx = dx || 0;
                dy = dy || 0;

                var visibleTiles = [];
                var requireLoading = [];
                var waitingFor = [];

                //the container that the tiles will be children of when fetched
                var container = this.getContainer();

                var tile = this.tiles[0][0];
                var tilePos = container.localToGlobal(tile.x + dx, tile.y + dy);
                var nextTilePos = container.localToGlobal(tile.x + dx + tile.width, tile.y + dy + tile.height);

                var tileX = tilePos.x;
                var tileW = nextTilePos.x - tilePos.x;
                var tileY = tilePos.y;
                var tileH = nextTilePos.y - tilePos.y;

                var xStart = Math.max(0, Math.ceil((-tileW - tileX) / tileW));
                var yStart = Math.max(0, Math.ceil((-tileH - tileY) / tileH));
                var firstXAt = tileX + xStart * tileW;
                var firstYAt = tileY + yStart * tileH;

                var xMax = Math.min(xStart + Math.ceil((config.width - firstXAt) / tileW), this.zoomLevel.size.x);
                var yMax = Math.min(yStart + Math.ceil((config.height - firstYAt) / tileH), this.zoomLevel.size.y);

                for (var x = xStart; x < xMax; x++) {
                    for (var y = yStart; y < yMax; y++) {
                        var tile = this.tiles[x][y];
                        if (!tile.isComplete()) {
                            waitingFor.push(tile);
                            if (!tile.isEnroute()) {
                                requireLoading.push(tile);
                            }
                        }
                        visibleTiles.push(tile);
                    }
                }
                return {visibleTiles: visibleTiles, requireLoading: requireLoading, waitingFor: waitingFor};
            };

            /**
             * Finds all the tiles for this zoom level that haven't yet been fetched
             */
            this.getUnfetchedTiles = function() {
                var tiles = [];
                for (var x = 0; x < this.zoomLevel.size.x; x++) {
                    for (var y = 0; y < this.zoomLevel.size.y; y++) {
                        var tile = this.tiles[x][y];
                        if (!tile.isComplete() && !tile.isEnroute()) {
                            tiles.push(tile);
                        }
                    }
                }
                return tiles;
            };

            /**
             * Hide this zoom level.
             */
            this.hide = function() {
                this.zoomLevelView.hide();
            };

            /**
             * Show this zoom level.
             */
            this.show = function() {
                this.zoomLevelView.show();
            };

            this.setAlignment = function(alignment) {
                this.alignment = alignment;
                if (this.initialised) {
                    this.zoomLevelView.setAlignment(alignment);
                }
            };

            /**
             * Provides convenient access to the zoom level view container object.
             */
            this.getContainer = function() {
                return this.zoomLevelView.container;
            };


            this.unload = function() {
                if (!this.initialised)
                    return 0;

                this.initialised = false;

                this.zoomLevelView.unload();
                this.zoomLevelView = null;

                var countTiles = 0;

                for (var x = 0; x < this.zoomLevel.size.x; x++) {
                    for (var y = 0; y < this.zoomLevel.size.y; y++) {
                        if (this.tiles[x][y].isComplete())
                            countTiles += 1;
                        this.tiles[x][y] = null;
                    }
                    this.tiles[x] = [];
                }

                this.tiles = null;
                this.tiles = [];

                return countTiles;
            };
        };

        return {
            ZoomLevelController: ZoomLevelController,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('model/page',[],
    function() {

        var Page = function(number, label, width, height, baseURL, filePattern) {
            this.number = number;
            this.label = label;
            this.width = width;
            this.height = height;
            this.baseURL = baseURL;
            this.filePattern = filePattern;
        };

        return {
            Page: Page
        };

    });

define('views/pageView',['easel'],
    function(createjs) {

        /**
         * Class for that represents a page view which is basically just the createjs container object.
         * @constructor
         */
        var PageView = function() {
            //core properties
            this.container = new createjs.Container();

            /**
             * Hides this page.
             */
            this.hide = function() {
                this.container.visible = false;
            };

            this.show = function() {
                this.container.visible = true;
            };

            this.isShowing = function() {
                return this.container.visible;
            };
        };

        return {
            PageView: PageView
        };
    });

define('shared/utils/stringUtils',[],
function() {
    var StringUtils = function() {
        var self = this;

        self.capitalizeFirstLetter = function(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        };

        /**
         * Utility function that checks if some base string begins with a known prefix
         * @param base String
         * @param prefix String
         * @returns {boolean}
         */
        self.startsWith = function(base, prefix) {
            if (typeof base !== 'string' || typeof prefix !== 'string') {
                return false;
            }
            return base.substr(0, prefix.length) === prefix;
        };

        /**
         * Utility function that unescapes XML from a string
         * This was added to escape '&amp;' specifically for search.js, when re-using please
         * check your use case and make adjustments where necessary. Code copied and reversed
         * from escape method in Publisher.
         * @param text String with unescaped XML entities
         * @returns {String}
         */
        self.unEscapeXml = function(text) {
            return text.replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">").replace("&apos;", "'")
                .replace("&quot;","\"").replace("\n","\r\n");
        }
    };

    return new StringUtils();
});

/*!
 * @license TweenJS
 * Visit http://createjs.com/ for documentation, updates and examples.
 *
 * Copyright (c) 2011-2013 gskinner.com, inc.
 *
 * Distributed under the terms of the MIT license.
 * http://www.opensource.org/licenses/mit-license.html
 *
 * This notice shall be included in all copies or substantial portions of the Software.
 */

/**!
 * SoundJS FlashPlugin also includes swfobject (http://code.google.com/p/swfobject/)
 */

this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype;b.type=null,b.target=null,b.currentTarget=null,b.eventPhase=0,b.bubbles=!1,b.cancelable=!1,b.timeStamp=0,b.defaultPrevented=!1,b.propagationStopped=!1,b.immediatePropagationStopped=!1,b.removed=!1,b.initialize=function(a,b,c){this.type=a,this.bubbles=b,this.cancelable=c,this.timeStamp=(new Date).getTime()},b.preventDefault=function(){this.defaultPrevented=!0},b.stopPropagation=function(){this.propagationStopped=!0},b.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},b.remove=function(){this.removed=!0},b.clone=function(){return new a(this.type,this.bubbles,this.cancelable)},b.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){},b=a.prototype;a.initialize=function(a){a.addEventListener=b.addEventListener,a.on=b.on,a.removeEventListener=a.off=b.removeEventListener,a.removeAllEventListeners=b.removeAllEventListeners,a.hasEventListener=b.hasEventListener,a.dispatchEvent=b.dispatchEvent,a._dispatchEvent=b._dispatchEvent,a.willTrigger=b.willTrigger},b._listeners=null,b._captureListeners=null,b.initialize=function(){},b.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},b.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},b.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},b.off=b.removeEventListener,b.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},b.dispatchEvent=function(a,b){if("string"==typeof a){var c=this._listeners;if(!c||!c[a])return!1;a=new createjs.Event(a)}if(a.target=b||this,a.bubbles&&this.parent){for(var d=this,e=[d];d.parent;)e.push(d=d.parent);var f,g=e.length;for(f=g-1;f>=0&&!a.propagationStopped;f--)e[f]._dispatchEvent(a,1+(0==f));for(f=1;g>f&&!a.propagationStopped;f++)e[f]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return a.defaultPrevented},b.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},b.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},b.toString=function(){return"[EventDispatcher]"},b._dispatchEvent=function(a,b){var c,d=1==b?this._captureListeners:this._listeners;if(a&&d){var e=d[a.type];if(!e||!(c=e.length))return;a.currentTarget=this,a.eventPhase=b,a.removed=!1,e=e.slice();for(var f=0;c>f&&!a.immediatePropagationStopped;f++){var g=e[f];g.handleEvent?g.handleEvent(a):g(a),a.removed&&(this.off(a.type,g,1==b),a.removed=!1)}}},createjs.EventDispatcher=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype=new createjs.EventDispatcher;a.NONE=0,a.LOOP=1,a.REVERSE=2,a.IGNORE={},a._tweens=[],a._plugins={},a.get=function(b,c,d,e){return e&&a.removeTweens(b),new a(b,c,d)},a.tick=function(b,c){for(var d=a._tweens.slice(),e=d.length-1;e>=0;e--){var f=d[e];c&&!f.ignoreGlobalPause||f._paused||f.tick(f._useTicks?1:b)}},a.handleEvent=function(a){"tick"==a.type&&this.tick(a.delta,a.paused)},a.removeTweens=function(b){if(b.tweenjs_count){for(var c=a._tweens,d=c.length-1;d>=0;d--)c[d]._target==b&&(c[d]._paused=!0,c.splice(d,1));b.tweenjs_count=0}},a.removeAllTweens=function(){for(var b=a._tweens,c=0,d=b.length;d>c;c++){var e=b[c];e.paused=!0,e.target.tweenjs_count=0}b.length=0},a.hasActiveTweens=function(b){return b?b.tweenjs_count:a._tweens&&!!a._tweens.length},a.installPlugin=function(b,c){var d=b.priority;null==d&&(b.priority=d=0);for(var e=0,f=c.length,g=a._plugins;f>e;e++){var h=c[e];if(g[h]){for(var i=g[h],j=0,k=i.length;k>j&&!(d<i[j].priority);j++);g[h].splice(j,0,b)}else g[h]=[b]}},a._register=function(b,c){var d=b._target,e=a._tweens;if(c)d&&(d.tweenjs_count=d.tweenjs_count?d.tweenjs_count+1:1),e.push(b),!a._inited&&createjs.Ticker&&(createjs.Ticker.addEventListener("tick",a),a._inited=!0);else{d&&d.tweenjs_count--;for(var f=e.length;f--;)if(e[f]==b)return e.splice(f,1),void 0}},b.ignoreGlobalPause=!1,b.loop=!1,b.duration=0,b.pluginData=null,b.target=null,b.position=null,b.passive=!1,b._paused=!1,b._curQueueProps=null,b._initQueueProps=null,b._steps=null,b._actions=null,b._prevPosition=0,b._stepPosition=0,b._prevPos=-1,b._target=null,b._useTicks=!1,b._inited=!1,b.initialize=function(b,c,d){this.target=this._target=b,c&&(this._useTicks=c.useTicks,this.ignoreGlobalPause=c.ignoreGlobalPause,this.loop=c.loop,c.onChange&&this.addEventListener("change",c.onChange),c.override&&a.removeTweens(b)),this.pluginData=d||{},this._curQueueProps={},this._initQueueProps={},this._steps=[],this._actions=[],c&&c.paused?this._paused=!0:a._register(this,!0),c&&null!=c.position&&this.setPosition(c.position,a.NONE)},b.wait=function(a,b){if(null==a||0>=a)return this;var c=this._cloneProps(this._curQueueProps);return this._addStep({d:a,p0:c,e:this._linearEase,p1:c,v:b})},b.to=function(a,b,c){return(isNaN(b)||0>b)&&(b=0),this._addStep({d:b||0,p0:this._cloneProps(this._curQueueProps),e:c,p1:this._cloneProps(this._appendQueueProps(a))})},b.call=function(a,b,c){return this._addAction({f:a,p:b?b:[this],o:c?c:this._target})},b.set=function(a,b){return this._addAction({f:this._set,o:this,p:[a,b?b:this._target]})},b.play=function(a){return a||(a=this),this.call(a.setPaused,[!1],a)},b.pause=function(a){return a||(a=this),this.call(a.setPaused,[!0],a)},b.setPosition=function(a,b){0>a&&(a=0),null==b&&(b=1);var c=a,d=!1;if(c>=this.duration&&(this.loop?c%=this.duration:(c=this.duration,d=!0)),c==this._prevPos)return d;var e=this._prevPos;if(this.position=this._prevPos=c,this._prevPosition=a,this._target)if(d)this._updateTargetProps(null,1);else if(this._steps.length>0){for(var f=0,g=this._steps.length;g>f&&!(this._steps[f].t>c);f++);var h=this._steps[f-1];this._updateTargetProps(h,(this._stepPosition=c-h.t)/h.d)}return 0!=b&&this._actions.length>0&&(this._useTicks?this._runActions(c,c):1==b&&e>c?(e!=this.duration&&this._runActions(e,this.duration),this._runActions(0,c,!0)):this._runActions(e,c)),d&&this.setPaused(!0),this.dispatchEvent("change"),d},b.tick=function(a){this._paused||this.setPosition(this._prevPosition+a)},b.setPaused=function(b){return this._paused=!!b,a._register(this,!b),this},b.w=b.wait,b.t=b.to,b.c=b.call,b.s=b.set,b.toString=function(){return"[Tween]"},b.clone=function(){throw"Tween can not be cloned."},b._updateTargetProps=function(b,c){var d,e,f,g,h,i;if(b||1!=c){if(this.passive=!!b.v,this.passive)return;b.e&&(c=b.e(c,0,1,1)),d=b.p0,e=b.p1}else this.passive=!1,d=e=this._curQueueProps;for(var j in this._initQueueProps){null==(g=d[j])&&(d[j]=g=this._initQueueProps[j]),null==(h=e[j])&&(e[j]=h=g),f=g==h||0==c||1==c||"number"!=typeof g?1==c?h:g:g+(h-g)*c;var k=!1;if(i=a._plugins[j])for(var l=0,m=i.length;m>l;l++){var n=i[l].tween(this,j,f,d,e,c,!!b&&d==e,!b);n==a.IGNORE?k=!0:f=n}k||(this._target[j]=f)}},b._runActions=function(a,b,c){var d=a,e=b,f=-1,g=this._actions.length,h=1;for(a>b&&(d=b,e=a,f=g,g=h=-1);(f+=h)!=g;){var i=this._actions[f],j=i.t;(j==e||j>d&&e>j||c&&j==a)&&i.f.apply(i.o,i.p)}},b._appendQueueProps=function(b){var c,d,e,f,g;for(var h in b)if(void 0===this._initQueueProps[h]){if(d=this._target[h],c=a._plugins[h])for(e=0,f=c.length;f>e;e++)d=c[e].init(this,h,d);this._initQueueProps[h]=this._curQueueProps[h]=void 0===d?null:d}else d=this._curQueueProps[h];for(var h in b){if(d=this._curQueueProps[h],c=a._plugins[h])for(g=g||{},e=0,f=c.length;f>e;e++)c[e].step&&c[e].step(this,h,d,b[h],g);this._curQueueProps[h]=b[h]}return g&&this._appendQueueProps(g),this._curQueueProps},b._cloneProps=function(a){var b={};for(var c in a)b[c]=a[c];return b},b._addStep=function(a){return a.d>0&&(this._steps.push(a),a.t=this.duration,this.duration+=a.d),this},b._addAction=function(a){return a.t=this.duration,this._actions.push(a),this},b._set=function(a,b){for(var c in a)b[c]=a[c]},createjs.Tween=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(a,b,c){this.initialize(a,b,c)},b=a.prototype=new createjs.EventDispatcher;b.ignoreGlobalPause=!1,b.duration=0,b.loop=!1,b.position=null,b._paused=!1,b._tweens=null,b._labels=null,b._labelList=null,b._prevPosition=0,b._prevPos=-1,b._useTicks=!1,b.initialize=function(a,b,c){this._tweens=[],c&&(this._useTicks=c.useTicks,this.loop=c.loop,this.ignoreGlobalPause=c.ignoreGlobalPause,c.onChange&&this.addEventListener("change",c.onChange)),a&&this.addTween.apply(this,a),this.setLabels(b),c&&c.paused?this._paused=!0:createjs.Tween._register(this,!0),c&&null!=c.position&&this.setPosition(c.position,createjs.Tween.NONE)},b.addTween=function(a){var b=arguments.length;if(b>1){for(var c=0;b>c;c++)this.addTween(arguments[c]);return arguments[0]}return 0==b?null:(this.removeTween(a),this._tweens.push(a),a.setPaused(!0),a._paused=!1,a._useTicks=this._useTicks,a.duration>this.duration&&(this.duration=a.duration),this._prevPos>=0&&a.setPosition(this._prevPos,createjs.Tween.NONE),a)},b.removeTween=function(a){var b=arguments.length;if(b>1){for(var c=!0,d=0;b>d;d++)c=c&&this.removeTween(arguments[d]);return c}if(0==b)return!1;for(var e=this._tweens,d=e.length;d--;)if(e[d]==a)return e.splice(d,1),a.duration>=this.duration&&this.updateDuration(),!0;return!1},b.addLabel=function(a,b){this._labels[a]=b;var c=this._labelList;if(c){for(var d=0,e=c.length;e>d&&!(b<c[d].position);d++);c.splice(d,0,{label:a,position:b})}},b.setLabels=function(a){this._labels=a?a:{}},b.getLabels=function(){var a=this._labelList;if(!a){a=this._labelList=[];var b=this._labels;for(var c in b)a.push({label:c,position:b[c]});a.sort(function(a,b){return a.position-b.position})}return a},b.getCurrentLabel=function(){var a=this.getLabels(),b=this.position,c=a.length;if(c){for(var d=0;c>d&&!(b<a[d].position);d++);return 0==d?null:a[d-1].label}return null},b.gotoAndPlay=function(a){this.setPaused(!1),this._goto(a)},b.gotoAndStop=function(a){this.setPaused(!0),this._goto(a)},b.setPosition=function(a,b){0>a&&(a=0);var c=this.loop?a%this.duration:a,d=!this.loop&&a>=this.duration;if(c==this._prevPos)return d;this._prevPosition=a,this.position=this._prevPos=c;for(var e=0,f=this._tweens.length;f>e;e++)if(this._tweens[e].setPosition(c,b),c!=this._prevPos)return!1;return d&&this.setPaused(!0),this.dispatchEvent("change"),d},b.setPaused=function(a){this._paused=!!a,createjs.Tween._register(this,!a)},b.updateDuration=function(){this.duration=0;for(var a=0,b=this._tweens.length;b>a;a++){var c=this._tweens[a];c.duration>this.duration&&(this.duration=c.duration)}},b.tick=function(a){this.setPosition(this._prevPosition+a)},b.resolve=function(a){var b=parseFloat(a);return isNaN(b)&&(b=this._labels[a]),b},b.toString=function(){return"[Timeline]"},b.clone=function(){throw"Timeline can not be cloned."},b._goto=function(a){var b=this.resolve(a);null!=b&&this.setPosition(b)},createjs.Timeline=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"Ease cannot be instantiated."};a.linear=function(a){return a},a.none=a.linear,a.get=function(a){return-1>a&&(a=-1),a>1&&(a=1),function(b){return 0==a?b:0>a?b*(b*-a+1+a):b*((2-b)*a+(1-a))}},a.getPowIn=function(a){return function(b){return Math.pow(b,a)}},a.getPowOut=function(a){return function(b){return 1-Math.pow(1-b,a)}},a.getPowInOut=function(a){return function(b){return(b*=2)<1?.5*Math.pow(b,a):1-.5*Math.abs(Math.pow(2-b,a))}},a.quadIn=a.getPowIn(2),a.quadOut=a.getPowOut(2),a.quadInOut=a.getPowInOut(2),a.cubicIn=a.getPowIn(3),a.cubicOut=a.getPowOut(3),a.cubicInOut=a.getPowInOut(3),a.quartIn=a.getPowIn(4),a.quartOut=a.getPowOut(4),a.quartInOut=a.getPowInOut(4),a.quintIn=a.getPowIn(5),a.quintOut=a.getPowOut(5),a.quintInOut=a.getPowInOut(5),a.sineIn=function(a){return 1-Math.cos(a*Math.PI/2)},a.sineOut=function(a){return Math.sin(a*Math.PI/2)},a.sineInOut=function(a){return-.5*(Math.cos(Math.PI*a)-1)},a.getBackIn=function(a){return function(b){return b*b*((a+1)*b-a)}},a.backIn=a.getBackIn(1.7),a.getBackOut=function(a){return function(b){return--b*b*((a+1)*b+a)+1}},a.backOut=a.getBackOut(1.7),a.getBackInOut=function(a){return a*=1.525,function(b){return(b*=2)<1?.5*b*b*((a+1)*b-a):.5*((b-=2)*b*((a+1)*b+a)+2)}},a.backInOut=a.getBackInOut(1.7),a.circIn=function(a){return-(Math.sqrt(1-a*a)-1)},a.circOut=function(a){return Math.sqrt(1- --a*a)},a.circInOut=function(a){return(a*=2)<1?-.5*(Math.sqrt(1-a*a)-1):.5*(Math.sqrt(1-(a-=2)*a)+1)},a.bounceIn=function(b){return 1-a.bounceOut(1-b)},a.bounceOut=function(a){return 1/2.75>a?7.5625*a*a:2/2.75>a?7.5625*(a-=1.5/2.75)*a+.75:2.5/2.75>a?7.5625*(a-=2.25/2.75)*a+.9375:7.5625*(a-=2.625/2.75)*a+.984375},a.bounceInOut=function(b){return.5>b?.5*a.bounceIn(2*b):.5*a.bounceOut(2*b-1)+.5},a.getElasticIn=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return-(a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b))}},a.elasticIn=a.getElasticIn(1,.3),a.getElasticOut=function(a,b){var c=2*Math.PI;return function(d){if(0==d||1==d)return d;var e=b/c*Math.asin(1/a);return a*Math.pow(2,-10*d)*Math.sin((d-e)*c/b)+1}},a.elasticOut=a.getElasticOut(1,.3),a.getElasticInOut=function(a,b){var c=2*Math.PI;return function(d){var e=b/c*Math.asin(1/a);return(d*=2)<1?-.5*a*Math.pow(2,10*(d-=1))*Math.sin((d-e)*c/b):.5*a*Math.pow(2,-10*(d-=1))*Math.sin((d-e)*c/b)+1}},a.elasticInOut=a.getElasticInOut(1,.3*1.5),createjs.Ease=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=function(){throw"MotionGuidePlugin cannot be instantiated."};a.priority=0,a._rotOffS,a._rotOffE,a._rotNormS,a._rotNormE,a.install=function(){return createjs.Tween.installPlugin(a,["guide","x","y","rotation"]),createjs.Tween.IGNORE},a.init=function(a,b,c){var d=a.target;return d.hasOwnProperty("x")||(d.x=0),d.hasOwnProperty("y")||(d.y=0),d.hasOwnProperty("rotation")||(d.rotation=0),"rotation"==b&&(a.__needsRot=!0),"guide"==b?null:c},a.step=function(b,c,d,e,f){if("rotation"==c&&(b.__rotGlobalS=d,b.__rotGlobalE=e,a.testRotData(b,f)),"guide"!=c)return e;var g,h=e;h.hasOwnProperty("path")||(h.path=[]);var i=h.path;if(h.hasOwnProperty("end")||(h.end=1),h.hasOwnProperty("start")||(h.start=d&&d.hasOwnProperty("end")&&d.path===i?d.end:0),h.hasOwnProperty("_segments")&&h._length)return e;var j=i.length,k=10;if(!(j>=6&&0==(j-2)%4))throw"invalid 'path' data, please see documentation for valid paths";h._segments=[],h._length=0;for(var l=2;j>l;l+=4){for(var m,n,o=i[l-2],p=i[l-1],q=i[l+0],r=i[l+1],s=i[l+2],t=i[l+3],u=o,v=p,w=0,x=[],y=1;k>=y;y++){var z=y/k,A=1-z;m=A*A*o+2*A*z*q+z*z*s,n=A*A*p+2*A*z*r+z*z*t,w+=x[x.push(Math.sqrt((g=m-u)*g+(g=n-v)*g))-1],u=m,v=n}h._segments.push(w),h._segments.push(x),h._length+=w}g=h.orient,h.orient=!0;var B={};return a.calc(h,h.start,B),b.__rotPathS=Number(B.rotation.toFixed(5)),a.calc(h,h.end,B),b.__rotPathE=Number(B.rotation.toFixed(5)),h.orient=!1,a.calc(h,h.end,f),h.orient=g,h.orient?(b.__guideData=h,a.testRotData(b,f),e):e},a.testRotData=function(a,b){if(void 0===a.__rotGlobalS||void 0===a.__rotGlobalE){if(a.__needsRot)return;a.__rotGlobalS=a.__rotGlobalE=void 0!==a._curQueueProps.rotation?a._curQueueProps.rotation:b.rotation=a.target.rotation||0}if(void 0!==a.__guideData){var c=a.__guideData,d=a.__rotGlobalE-a.__rotGlobalS,e=a.__rotPathE-a.__rotPathS,f=d-e;if("auto"==c.orient)f>180?f-=360:-180>f&&(f+=360);else if("cw"==c.orient){for(;0>f;)f+=360;0==f&&d>0&&180!=d&&(f+=360)}else if("ccw"==c.orient){for(f=d-(e>180?360-e:e);f>0;)f-=360;0==f&&0>d&&-180!=d&&(f-=360)}c.rotDelta=f,c.rotOffS=a.__rotGlobalS-a.__rotPathS,a.__rotGlobalS=a.__rotGlobalE=a.__guideData=a.__needsRot=void 0}},a.tween=function(b,c,d,e,f,g,h){var i=f.guide;if(void 0==i||i===e.guide)return d;if(i.lastRatio!=g){var j=(i.end-i.start)*(h?i.end:g)+i.start;switch(a.calc(i,j,b.target),i.orient){case"cw":case"ccw":case"auto":b.target.rotation+=i.rotOffS+i.rotDelta*g;break;case"fixed":default:b.target.rotation+=i.rotOffS}i.lastRatio=g}return"rotation"!=c||i.orient&&"false"!=i.orient?b.target[c]:d},a.calc=function(b,c,d){void 0==b._segments&&a.validate(b),void 0==d&&(d={x:0,y:0,rotation:0});for(var e=b._segments,f=b.path,g=b._length*c,h=e.length-2,i=0;g>e[i]&&h>i;)g-=e[i],i+=2;var j=e[i+1],k=0;for(h=j.length-1;g>j[k]&&h>k;)g-=j[k],k++;var l=k/++h+g/(h*j[k]);i=2*i+2;var m=1-l;return d.x=m*m*f[i-2]+2*m*l*f[i+0]+l*l*f[i+2],d.y=m*m*f[i-1]+2*m*l*f[i+1]+l*l*f[i+3],b.orient&&(d.rotation=57.2957795*Math.atan2((f[i+1]-f[i-1])*m+(f[i+3]-f[i+1])*l,(f[i+0]-f[i-2])*m+(f[i+2]-f[i+0])*l)),d},createjs.MotionGuidePlugin=a}(),this.createjs=this.createjs||{},function(){"use strict";var a=createjs.TweenJS=createjs.TweenJS||{};a.version="0.5.1",a.buildDate="Thu, 12 Dec 2013 23:33:38 GMT"}();
define("tween", ["easel"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.createjs;
    };
}(this)));

define('model/overlay',['events', 'constants', 'config', 'resources', 'tween', 'jquery', 'utils/encryptedResourceFetchingUtils'],
    function(events, constants, config, resources, createjs, $, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "overlay";

        var Overlay = function(x, y, width, height, zIndex, info, pageNumber, id) {

            this.id = id;
            this.x = Number(x);
            this.y = Number(y);
            this.width = Number(width);
            this.height = Number(height);
            this.zIndex = Number(zIndex);
            this.info = info;
            this.pageNumber = pageNumber;
            this.rect = null;
            this.hitArea = null;
            this.htmlElement = null;
            this.htmlElementVisible = false;

            this.rectColour = "FF00FF";
            this.defaultAlpha = config.overlayAlpha;
            this.highlightLinksOnLoadEnabled = config.highlightLinksOnLoadEnabled;

            this.overlayContainer = $("#yudu_overlays")[0];
            this.interactiveOverlayContainer = $("#yudu_interactiveOverlays")[0];

            this.isMouseIn = false;

            this.createRectAndHitArea = function() {
                this.rect = new createjs.Shape();

                this.rect.graphics.beginFill("#" + this.rectColour).drawRect(this.x, this.y, this.width, this.height);
                this.rect.alpha = this.defaultAlpha;
                this.rect.setBounds(this.x, this.y, this.width, this.height);
                this.hitArea = new createjs.Shape();
                //Bitmap fill necessary so overlay works on iPhone 4
                this.hitArea.graphics.beginBitmapFill(resources.overlayBackground).drawRect(this.x, this.y, this.width, this.height);
                this.rect.hitArea = this.hitArea;

                return this.rect;
            };

            this.intersect = function(point) {
                if (!this.rect)
                    return false;

                var lowerBound = this.rect.localToGlobal(this.x, this.y);
                var upperBound = this.rect.localToGlobal(this.x + this.width, this.y + this.height);

                if (point.x > lowerBound.x
                    && point.y > lowerBound.y
                    && point.x < upperBound.x
                    && point.y < upperBound.y)
                    return true;

                return false;
            };

            this.getScreenDimensions = function() {
                if (!this.rect)
                    return null;

                var lowerBound = this.rect.localToGlobal(this.x, this.y);
                var upperBound = this.rect.localToGlobal(this.x + this.width, this.y + this.height);


                return {x: lowerBound.x / config.pixelDensity,
                        y: lowerBound.y / config.pixelDensity,
                        w: (upperBound.x - lowerBound.x) / config.pixelDensity,
                        h: (upperBound.y - lowerBound.y) / config.pixelDensity};
            };

            this.handleTap = function(tapPoint) {
                if (this.intersect(tapPoint)) {
                    this.clicked();
                    return true;
                }

                return false;
            };

            Overlay.prototype.handleTap = this.handleTap;

            /**
             * Creates a DOM audio/video element and registers it with createjs
             * @param type the type of DOM element
             * @param src source for element
             */
            this.createDOMMediaElement = function(type, src, altsrc) {
                var domElement = document.createElement(type);
                domElement.controls = true;
                domElement.preload = "none";

                events.yuduAddEventListener(domElement, 'play', events.callback(this, this.onPlay), false);

                if (altsrc) {
                    if (src) {
                        var srcElem = document.createElement("source");
                        encryptedResourceFetchingUtils.useResourceAsHtmlElementSource(src, srcElem);
                        srcElem.type = "video/" + src.substr(src.lastIndexOf(".") + 1);
                        domElement.appendChild(srcElem);
                    }
                    var altSrcElem = document.createElement("source");
                    encryptedResourceFetchingUtils.useResourceAsHtmlElementSource(altsrc, altSrcElem);
                    var extension = altsrc.substr(altsrc.lastIndexOf(".") + 1);
                    altSrcElem.type = "video/" + (extension == "webm" ? "webm" : "ogg");
                    domElement.appendChild(altSrcElem);
                }
                else {
                    encryptedResourceFetchingUtils.useResourceAsHtmlElementSource(src, domElement);
                }
                return domElement;
            };

            this.onPlay = function() {
            };

            /**
             * Sets the minimum width of an overlay
             */
            this.setMinWidth = function(minWidth) {
                var width = Math.max(minWidth,parseInt(this.width));
                if (!isNaN(width)) {
                    this.width = width;
                }
            };

            /**
             * Triggers this overlay to flash briefly.
             */
            this.flash = function(delay) {
                if (!this.rect || !this.highlightLinksOnLoadEnabled)
                    return;

                delay = delay || 0;

                this.removeTweens();
                createjs.Tween
                    .get(this.rect, {override: true})
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FLASH_START, this, { id: id });
                    })
                    .wait(delay)
                    .to({alpha: constants.overlayFocusAlpha}, constants.overlayFadeInTime)
                    .to({alpha: this.defaultAlpha}, constants.overlayFadeOutTime)
                    .wait(500)
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FLASH_END, this, { id: id });
                    });
            };

            Overlay.prototype.flash = this.flash;

            this.fadeIn = function() {
                if (!this.rect)
                    return;

                this.removeTweens();
                createjs.Tween
                    .get(this.rect, {override: true})
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FADE_START, this, { id: id });
                    })
                    .to({alpha: constants.overlayFocusAlpha}, constants.overlayFadeInTime)
                    .wait(500)
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FADE_END, this, { id: id });
                    });
            };

            Overlay.prototype.fadeIn = this.fadeIn;

            this.fadeOut = function() {
                if (!this.rect)
                    return;

                this.removeTweens();
                createjs.Tween
                    .get(this.rect, {override: true})
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FADE_OUT_START, this, { id: id });
                    })
                    .to({alpha: this.defaultAlpha}, constants.overlayFadeOutTime)
                    .wait(500)
                    .call(function() {
                        events.emit(EMITTER_NAME, events.OVERLAY_FADE_OUT_END, this, { id: id });
                    });
            };

            Overlay.prototype.fadeOut = this.fadeOut;

            this.mouseIn = function() {
                this.isMouseIn = true;
                this.fadeIn();
            };

            this.mouseOut = function() {
                this.isMouseIn = false;
                this.fadeOut();
            };

            this.clicked = function() {
            };

            this.isFading = function() {
                return createjs.Tween.hasActiveTweens(this.rect) > 0;
            };

            this.triggerAutoPlay = function() {
            };

            this.triggerToggle = function() {
            };

            this.triggerOff = function() {
            };

            this.createMediaPlaceHolder = function() {
                // Keep this at 0,0 so the intersection routine works!
                this.rect = new createjs.Container();

                var self = this;
                if(!info["@tp"]){
                    defaultThumbnail();
                }
                else {
                    var img = new Image();

                    img.onload = function () {
                        var background = img;
                        var playButton = resources.playButtonTranslucent;
                        scaleImage(background, playButton);
                    };

                    img.onerror = defaultThumbnail;

                    encryptedResourceFetchingUtils.useResourceAsHtmlElementSource(info["@tp"], img);
                }

                function defaultThumbnail(){
                    var background = resources.placeholderBackground;
                    var playButton = resources.playButton;
                    scaleImage(background, playButton);
                }

                function scaleImage(background, playButton) {
                    self.background = new createjs.Bitmap(background);
                    self.background.scaleX = self.width / background.width;
                    self.background.scaleY = self.height / background.height;
                    self.background.set({x: self.x, y: self.y});


                    self.button = new createjs.Bitmap(playButton);
                    var halfWidth = (self.width * 0.5) / playButton.width;
                    var halfHeight = (self.height * 0.5) / playButton.height;
                    var bestScale = Math.min(halfWidth, halfHeight);
                    self.button.scaleX = self.button.scaleY = bestScale;
                    self.button.set({x: self.x + self.width / 2 - bestScale * playButton.width * 0.5,
                        y: self.y + self.height / 2 - bestScale * playButton.height * 0.5
                    });

                    self.rect.addChild(self.background);
                    self.rect.addChild(self.button);
                }
            };

            this.subscribeToInteractionEvents = function(action) {
                events.subscribe(events.ALL, events.SHOWHIDE_TOOLBAR, action, false);
                events.subscribe(events.ALL, events.DRAG, action, false);
                events.subscribe(events.ALL, events.PAGE_CHANGED, action, false);
                events.subscribe(events.ALL, events.ZOOM, action, false);
                events.subscribe(events.ALL, events.ZOOM_SCALE, action, false);
                events.subscribe(events.ALL, events.TWO_UP_CHANGED, action, false);
                events.subscribe(events.ALL, events.FIT_CHANGED, action, false);
                events.subscribe(events.ALL, events.SHIFTER_SPRINGING, action, false);
                events.subscribe(events.ALL, events.TRIGGER, action, false);
            };

            this.removeTweens = function () {
                createjs.Tween.removeTweens(this.rect);
                events.emit(EMITTER_NAME, events.OVERLAY_TWEENS_REMOVED, this, { id: id });
            };

            this.isValid = true;

            Overlay.zIndexComparator = function(overlay1, overlay2) {
                return overlay1.zIndex - overlay2.zIndex;
            };
        };

        return {
            Overlay: Overlay
        };
    });

define('shared/tools',['config', 'shared/storage'],
    function(config, storage) {

        var uniqueUserId = null;
        var USERID_KEY = "html_uid";
        var MAX_UID = 100000000;

        var getReferral = function() {
            var fromQuery = config.getFromQuery('refUrl');
            if (fromQuery)
                return decodeURIComponent(fromQuery);

            return document.referrer;
        };

        var getUniqueUserId = function() {
            // try retrieving from the query string first as this will provide us with an app level deviceId if there's
            // one available (and we want the app level deviceId to have a higher priority than the reader level one)
            var fromQuery = config.getFromQuery('deviceId');
            if (fromQuery) {
                uniqueUserId = fromQuery;
                return uniqueUserId;
            }

            // otherwise see if we've already retrieved a userId and stored it locally
            if (uniqueUserId != null)
                return uniqueUserId;

            // then try retrieving the user id from localstorage
            var storedUserId = storage.getItem(USERID_KEY);
            if (storedUserId) {
                uniqueUserId = storedUserId;
                return uniqueUserId;
            }

            // otherwise generate a new id
            uniqueUserId = Math.floor(Math.random() * MAX_UID + 1);
            storage.setItem(USERID_KEY, uniqueUserId);


            return uniqueUserId;
        };

        /**
         * Determine the OS of the current machine from the user agent string
         * @returns {*}
         */
        var getOS = function() {
            var oscpu = navigator.oscpu;
            var os = null;

            if (oscpu) {
                os = tryMatchOSFromSet(oscpu);
                if (os)
                    return os;
            }

            os = tryMatchOSFromSet(navigator.userAgent);

            if (os)
                return os;

            if (oscpu)
                return oscpu;

            return navigator.platform;
        };

        /**
         * Checks the input string against known user-agent strings for historical operating systems
         * @param desc ; input to check, usually a user agent string
         * @returns {*} ; OS if found, else `null`
         */
        var tryMatchOSFromSet = function(desc) {
            // The order of these is important!
            var clientStrings = [
                {s:'Windows 3.11', r:/Win16/},
                {s:'Windows 95', r:/(Windows 95|Win95|Windows_95)/},
                {s:'Windows ME', r:/(Win 9x 4.90|Windows ME)/},
                {s:'Windows 98', r:/(Windows 98|Win98)/},
                {s:'Windows CE', r:/Windows CE/},
                {s:'Windows 2000', r:/(Windows NT 5.0|Windows 2000)/},
                {s:'Windows XP', r:/(Windows NT 5.1|Windows XP)/},
                {s:'Windows Server 2003', r:/Windows NT 5.2/},
                {s:'Windows Vista', r:/Windows NT 6.0/},
                {s:'Windows 7', r:/(Windows 7|Windows NT 6.1)/},
                {s:'Windows 8.1', r:/(Windows 8.1|Windows NT 6.3)/},
                {s:'Windows 8', r:/(Windows 8|Windows NT 6.2)/},
                {s:'Windows 10', r:/(Windows 10|Windows NT 10.0)/},
                {s:'Windows NT 4.0', r:/(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/},
                {s:'Windows ME', r:/Windows ME/},
                {s:'Android', r:/Android/},
                {s:'Open BSD', r:/OpenBSD/},
                {s:'Sun OS', r:/SunOS/},
                {s:'Linux', r:/(Linux|X11)/},
                {s:'iOS', r:/(iPhone|iPad|iPod)/},
                {s:'Mac OS X', r:/Mac OS X/},
                {s:'Mac OS', r:/(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/},
                {s:'QNX', r:/QNX/},
                {s:'UNIX', r:/UNIX/},
                {s:'BeOS', r:/BeOS/},
                {s:'OS/2', r:/OS\/2/}
            ];

            for (var i = 0, m = clientStrings.length ; i < m ; i++) {
                var cs = clientStrings[i];
                if (cs.r.test(desc))
                    return cs.s;
            }
            return null;
        };

        return {
            getUniqueUserId: getUniqueUserId,
            getReferral: getReferral,
            getOS: getOS
        };
    });
define('utils/stats/yuduReporting',['jquery', 'shared/tools', 'shared/utils/tools'],
    function($, tools, sharedTools) {

        var yuduBookSettings = null;
        var events = {};
        var visitId = -1;

        var lastPageId = null;
        var lastPageLabel = null;
        var lastPageId2 = null;
        var lastPageLabel2 = null;

        var init = function(integrationApi) {
            events = integrationApi.events;
            yuduBookSettings = integrationApi.yuduBookSettings;
            return true;
        };

        var paths = {
            visit: "/Visit",
            action: "/Action",
            pageview: "/PageView",
            search: "/Search",
            email: "/EmailAddress",
            link: "/Link",
            productCode: "/ProductCode"
        };

        var getUrl = function(typePath) {
            return yuduBookSettings.statsUrl + paths[typePath];
        };

        /**
         * Record a new visit event
         * The input data should at least contain `startPage` and `startLabel` properties, and may optionally
         *  also include `secondStartPage` and `secondStartLabel` properties.
         * @param visitData {*}
         */
        var newVisit = function(visitData) {
            if (yuduBookSettings.preview) {
                previewVisit();
                return;
            }

            var url = getUrl('visit');

            lastPageId = visitData.startPage;
            lastPageLabel = visitData.startLabel;
            lastPageId2 = visitData.secondStartPage;
            lastPageLabel2 = visitData.secondStartLabel;

            var data = {
                operatingSystem: tools.getOS(),
                startPageNumber: visitData.startPage,
                startPageLabel: visitData.startLabel,
                bookId: yuduBookSettings.id,
                referrerUrl: tools.getReferral(),
                browser: navigator.userAgent,
                uniqueUserId: sharedTools.getUniqueUserId(),
                screenResolution: screen.width + "x" + screen.height,
                flashVersion: "unknown",
                hierarchyPosition: yuduBookSettings.hierarchyPosition,
                appType: "HTML-Reader"
            };

            $.post(url, data, onVisitRecorded, 'text');
        };

        /**
         * Edition is a preview: we primarily want to know a visit count for expiring the preview
         */
        var previewVisit = function() {
            var url = yuduBookSettings.statsUrl;
            $.get(url, {bookId: yuduBookSettings.id});
        };

        /**
         * Callback for when a new visit record has been successfully transmitted
         * @param data ; data supplied by the event
         */
        var onVisitRecorded = function(data) {
            visitId = data;
            var pageViewData = {
                newPage: lastPageId,
                newPageLabel: lastPageLabel
            };
            if (lastPageId2 && lastPageLabel2) {
                pageViewData.newPage2 = lastPageId2;
                pageViewData.newPageLabel2 = lastPageLabel2;
            }
            pageView(pageViewData);
        };

        /**
         * Record a new page-view event
         * The input data should at least contain `newPage` and `newPageLabel` properties, and may optionally
         *  also include `newPage2` and `newPageLabel2` properties.
         * @param pageViewData {*}
         */
        var pageView = function(pageViewData) {
            if (visitId < 0) {
                return;
            }

            var url = getUrl('pageview');

            var data = {
                visitId: visitId,
                firstPageNumber: pageViewData.newPage,
                firstPageLabel: pageViewData.newPageLabel
            };
            if (pageViewData.newPage2) {
                data.secondPageNumber = pageViewData.newPage2;
                data.secondPageLabel = pageViewData.newPageLabel2;
                lastPageId2 = pageViewData.newPage2;
                lastPageLabel2 = pageViewData.newPageLabel2;
            }

            lastPageId = pageViewData.newPage;
            lastPageLabel = pageViewData.newPageLabel;

            $.post(url, data);
        };

        /**
         * Record a new "action" event
         * Needs to be able to handle all the actions
         * The input data should at least contain an `actionType` property.
         * An extra string in the optional `extraInfo` property will automatically be included in the action tracking request.
         * @param actionData {*}
         */
        var action = function(actionData) {
            if (visitId < 0) {
                return;
            }
            if (!shouldSendDataForEvent(actionData)) {
                return;
            }

            var url = getUrl('action');
            var extraInfo = actionData.extraInfo || "";

            if (typeof actionData.pageNumber != 'undefined' && lastPageId2 != null && actionData.pageNumber == lastPageId2) {
                var data = {
                    visitId: visitId,
                    pageNumber: lastPageId2,
                    pageLabel: lastPageLabel2,
                };
            } else {
                var data = {
                    visitId: visitId,
                    pageNumber: lastPageId,
                    pageLabel: lastPageLabel,
                }
            }
            /* Link clicks are sent to the LinkController which also adds an action event */
            if (actionData.actionType == events.overlay_weblink) {
                linkClick(extraInfo, data);
                return;
            }
            if (actionData.actionType == events.overlay_productCode) {
                productCodeClick(extraInfo, actionData.productCode, data);
                return;
            }
            data.actionType = actionData.actionType;
            data.extraInfo = extraInfo;
            $.post(url, data);
        };

        /**
         * Determine whether the triggering action requires any data to be sent for this integration
         * Currently used to exclude actions added for specific clients from general use-cases
         * @param actionData {*}
         */
        var shouldSendDataForEvent = function(actionData) {
            switch (actionData.actionType) {
                case events.video_resumed:
                case events.video_milestone_reached:
                case events.video_finished:
                    return false;
            }
            return true;
        };

        /**
         * Record a new "link followed" event
         * This remains off the integration interface, so parameters are not passed in via a hash
         * @param link string ; target URL for the link
         */
        var linkClick = function(link, data) {
            if (visitId < 0) {
                return;
            }
            var url = getUrl('link');
            data.url= link || "";
            $.post(url, data);
        };

        var productCodeClick = function(extraInfo, productCode, data) {
            if (visitId < 0) {
                return;
            }
            var url = getUrl('productCode');
            data.url = extraInfo || "";
            data.extraInfo = productCode || "";
            $.post(url, data);
        };

        /**
         * Record a new search event
         * The input data should at least contain a `searchPhrase` property.
         * @param searchData {*}
         */
        var search = function(searchData) {
            if (visitId < 0) {
                return;
            }

            var url = getUrl('search');

            var data = {
                visitId: visitId,
                pageNumber: lastPageId,
                pageLabel: lastPageLabel,
                searchPhrase: searchData.searchPhrase
            };

            $.post(url, data);
        };

        var email = function(emailAddress) {
            var url = getUrl('email');
            var bookId = !!yuduBookSettings.dataCollectionAtPubNode ?
                yuduBookSettings.pubId : yuduBookSettings.id;

            var data = {
                "emailAddress": emailAddress,
                "bookId": bookId,
                "readerPlatform": "HTML-Reader"
            };
            $.post(url, data);
        };

        return {
            init: init,
            newVisit: newVisit,
            pageView: pageView,
            action: action,
            search: search,
            email: email
        };
});

define('environmentActive',[], function() {
    // Remember to update the tests if this changes
    return {
        mode: 'production'
    };
});

define('environment',['environmentActive'],
function(env) {
    var modes = {
        dev: 'development',
        prod: 'production',
        test: 'test'
    };

    var isDevelopment = env.mode === modes.dev;
    var isTest = env.mode === modes.test;
    var isProduction = env.mode === modes.prod;

    return {
        modes: modes,
        isDevelopment: isDevelopment,
        isTest: isTest,
        isProduction: isProduction,
        currentMode: env.mode
    };
});

define('utils/stats/gaIntegration',['require', 'environment', 'constants', 'shared/utils/eventUtils', 'shared/utils/appUtils',
            'shared/utils/queryStringUtils', 'shared/config'],
function(require, env, constants, eventUtils, appUtils,
        queryStringUtils, config) {
    var externalTrackingId;
    var externalMeasurementId;
    var platform;
    var editionValue;
    var gaTrackers = [];

    var yuduBookSettings = {};
    var events = {};

    var actions = {
        newVisit: 'new visit',
        search: 'text search'
    };

    var categories = {
        reader: 'Edition',
        overlay: 'Overlay'
    };

    var socialNetworks = {
        email: 'Email',
        facebook: 'Facebook',
        twitter: 'Twitter',
        unknown: 'Unknown'
    };

    /*
     * The Google Analytics "on-page" snippet is split between the `preLoad` (can be run immediately)
     *  and the `init` (called when integrating into the reader's statistics module
     * Note that some GA "standard" calls are modified to use our own functions instead,
     *  to allow us to handle multiple trackers more readily
     */
    var preLoad = function() {
        window.ga = window.ga || function () {
            (ga.q = ga.q || []).push(arguments)
        };
        ga.l = +new Date;

        window.dataLayer = window.dataLayer || [];
        window.gtag = window.gtag || function() {dataLayer.push(arguments);};
        gtag('js', new Date());
        gtag('consent', 'default', {
            'analytics_storage': 'denied',
            'ad_storage': 'denied'
        });

        /*
         * The first implementation attempted to use the `autotrack` plugin
         * If using GA plugins in the future, bear this in mind:
         *  recall that GA does not track until all its required plugins are available,
         *  yet the doc states plugins should not be loaded prior to the snippet being run (to guarantee the `q` exists),
         *  and requirejs has no obvious way to defer running a non-AMD dependency.
         *      (requirejs simply runs non-AMD scripts when it encounters them, and wraps the global objects specified
          *      in the app's shim exports in a minimal AMD module that solely returns the global object)
         * The easiest way to resolve that is to put them into an AMD module _function_ to be run on demand, which also
         *  avoids having to `include` the script in the build settings to include them during the require optimisation.
         */
    };

    var init = function(integrationApi) {
        events = integrationApi.events;
        yuduBookSettings = integrationApi.yuduBookSettings;
        externalTrackingId = yuduBookSettings.googleAnalyticsTrackerId; // Universal Analytics
        externalMeasurementId = yuduBookSettings.googleAnalyticsMeasurementId; // Google Analytics 4
        editionValue = yuduBookSettings.gaReportNameInsteadOfNodeId ? yuduBookSettings.name : '' + yuduBookSettings.id;
        if (!!externalTrackingId && window.gaScriptNotLoaded || !externalMeasurementId && window.gtagScriptNotLoaded) {
            // If any type of Google Analytics is enabled and there is a problem loading its corresponding script, then
            // just silently turn off the module
            return;
        }
        // Determine the platform the edition is being accessed from
        determineEditionPlatform();

        var externalEditionDimensionIndex = yuduBookSettings.gaEditionDimensionIndex;
        var externalPlatformDimensionIndex = yuduBookSettings.gaPlatformDimensionIndex;

        if (!!externalTrackingId) {
            createNewTracker(externalTrackingId, 'uTracker', externalEditionDimensionIndex, externalPlatformDimensionIndex);
        }

        if (!!externalMeasurementId && platform !== "Android Reader") {
            createNewTag(externalMeasurementId);
        }

        if (gaTrackers.length > 0 || !!externalMeasurementId || config.nativeAndroidGoogleAnalyticsEnabled) {
            var path = location.pathname + location.search;
            interceptPageChanges();
            // if there are trackers, listen for page changes if needed and send a visit tracking request
            if (gaTrackers.length > 0) {
                // anonymise the IP to avoid personal data collection issues
                callForAllTrackers('set', 'anonymizeIp', true);
                // Initial `pageview` event
                callForAllTrackers('send', 'pageview', sanitisePath(path));
            }
            // if there is a GA4 measurement id, send a visit event
            if (!!externalMeasurementId) {
                if (platform !== 'Android Reader') { // ga4 events are handled natively for android
                    // anonymise the IP to avoid personal data collection issues
                    gtag('set', {'anonymize_ip': true});
                    // Initial `page_view` event
                    gtag('event', 'page_view', {
                        'page_location': sanitisePath(path)
                    })
                }
            }
            if (config.nativeAndroidGoogleAnalyticsEnabled && platform === 'Android Reader') {
                appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                    event: 'page_view',
                    page_number: getPageNumberFromPath(path),
                    edition: editionValue
                })
            }
            return true;
        }
        return false;
    };

    var sanitisePath = function(path) {
        var splitPath = queryStringUtils.splitUrl(path);
        if (!splitPath.query) {
            return path;
        }

        var queryHash = queryStringUtils.parseQueryString(splitPath.query);
        var newQueryHash = {};
        var parametersToKeep = ['page', 'distributorId', 'preventInfoPage', 'isApp'];

        parametersToKeep.forEach(function(parameter) {
            if (queryHash.hasOwnProperty(parameter)) {
                newQueryHash[parameter] = queryHash[parameter];
            }
        });

        splitPath.query = queryStringUtils.stringifyQueryStringHash(newQueryHash);
        return queryStringUtils.joinUrl(splitPath);
    };

    var getPageNumberFromPath = function(path) {
        var splitPath = queryStringUtils.splitUrl(path);
        if (!splitPath.query) {
            return '1';
        }
        var queryHash = queryStringUtils.parseQueryString(splitPath.query);
        if (queryHash.hasOwnProperty('page')) {
            return queryHash['page'];
        } else {
            return '1';
        }
    }

    /**
     * Intercept changes in the URL and copy the changes to the trackers
     * Based heavily on the `url-change-tracker` component of the GA plugin `autotrack` that attempted to automatically
     *  capture page changes, but in overriding `history.replaceState` it used a function that passed on its arguments
     *  which meant that in IE11, if the optional third (url) parameter was not specified, it would be literally
     *  interpreted as the string `undefined` instead.
     */
    var interceptPageChanges = function() {
        // Prevent errors in unsupported browsers
        if (!history.pushState || !window.addEventListener) {
            return;
        }

        var currentPath = location.pathname + location.search;

        var isObject = function(obj) {
            return typeof obj == 'object' && obj !== null;
        };

        var updateTrackerData = function(shouldSendPageview) {
            // Set the default.
            shouldSendPageview = shouldSendPageview !== false;

            // Call the update logic asychronously so user callbacks happen first.
            setTimeout(function() {
                var oldPath = currentPath;
                var newPath = location.pathname + location.search;

                if (oldPath != newPath) {
                    currentPath = newPath;

                    callForAllTrackers('set', {
                        page: sanitisePath(newPath),
                        title: isObject(history.state) && history.state.title || document.title
                    });

                    if (shouldSendPageview) {
                        callForAllTrackers('send', 'pageview');
                        if (platform === 'Android Reader') {
                            if (config.nativeAndroidGoogleAnalyticsEnabled) {
                                appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                                    event: 'page_view',
                                    page_number: getPageNumberFromPath(newPath),
                                    page_title: isObject(history.state) && history.state.title || document.title,
                                    edition: editionValue
                                })
                            }
                        } else {
                            gtag('event', 'page_view', {
                                'page_location': sanitisePath(newPath),
                                'page_title': isObject(history.state) && history.state.title || document.title
                            });
                        }
                    }
                }
            }, 0);
        };

        // Override history.pushState.
        var originalPushState = history.pushState;
        history.pushState = function(state, title, url) {
            var args = Array.prototype.slice.call(arguments);
            if (isObject(args[0]) && args[1]){
                args[0].title = args[1];
            }
            originalPushState.apply(history, args);
            updateTrackerData();
        };

        // Override history.replaceState.
        var originalReplaceState = history.replaceState;
        history.replaceState = function(state, title, url) {
            var args = Array.prototype.slice.call(arguments);
            if (isObject(args[0]) && args[1]){
                args[0].title = args[1];
            }
            originalReplaceState.apply(history, args);
            updateTrackerData(false);
        };

        // Handles URL changes via user interaction.
        eventUtils.yuduAddEventListener(window, 'popstate', updateTrackerData);
    };

    /**
     * Creates a new Universal Analytics tracker object for the specified tracking ID under the specified name
     * @param trackingId
     * @param name
     * @param editionDimensionIndex The index of the 'Edition' custom dimension, provided by Google Analytics on setup
     * @param platformDimensionIndex The index of the 'Platform' custom dimension, provided by Google Analytics on setup
     */
    var createNewTracker = function(trackingId, name, editionDimensionIndex, platformDimensionIndex) {
        ga('create', {
            trackingId: trackingId,
            cookieDomain: 'auto',
            name: name
        });

        // Set the custom dimensions if they exist
        if (editionDimensionIndex > 0) {
            if(yuduBookSettings.gaReportNameInsteadOfNodeId){
                ga(name + '.set', 'dimension' + editionDimensionIndex, yuduBookSettings.name);
            }else {
                ga(name + '.set', 'dimension' + editionDimensionIndex, '' + yuduBookSettings.id);
            }
        }
        if (platformDimensionIndex > 0) {
            ga(name + '.set', 'dimension' + platformDimensionIndex, platform);
        }

        gaTrackers.push(name);
    };

    /**
     * Sets up a new Google Analytics 4 tag object for the specified measurement ID
     * @param measurementId
     */
    var createNewTag = function(measurementId) {
        gtag('consent', 'update', {
            'analytics_storage': 'granted'
        });
        gtag('config', measurementId, {
            'send_page_view': false,
            'edition': editionValue,
            'platform': platform,
            'debug_mode': true });
    };

    /**
     * Adds the specified command to the GA command queue for all of the currently known trackers
     * The command to call on the ga object must be the first argument
     * This function expects the arguments to have the same form as required if calling ga directly
     * All it does is allow us to easily map a single command onto all our trackers
     */
    var callForAllTrackers = function() {
        if (arguments.length < 2) {
            return;
        }
        for (var i = 0, m = gaTrackers.length; i < m; i++) {
            var args = Array.prototype.slice.call(arguments);
            args[0] = gaTrackers[i] + '.' + args[0];
            ga.apply(this, args);
        }
    };

    /*
     * Google doc on available event fields:
     * (https://developers.google.com/analytics/devguides/collection/analyticsjs/events)
     *      Field Name      Type    Required	Description
     *      eventCategory   text    yes         Typically the object that was interacted with
     *      eventAction     text    yes         The type of interaction
     *      eventLabel      text    no          Useful for categorizing events
     *      eventValue      integer no          A numeric value associated with the event
     * And the same for social interactions:
     * (https://developers.google.com/analytics/devguides/collection/analyticsjs/social-interactions)
     *      Field Name      Type    Required    Description
     *      socialNetwork   text    yes         The network on which the action occurs (e.g. Facebook, Twitter)
     *      socialAction    text    yes         The type of action that happens (e.g. Like, Send, Tweet).
     *      socialTarget    text    yes         Specifies the target of a social interaction. This value is typically a URL but can be any text.
     */

    var newVisit = function() {
        callForAllTrackers('send', {
            hitType: 'event',
            eventCategory: categories.reader,
            eventAction: actions.newVisit,
            eventLabel: '' + yuduBookSettings.id
        });
        if (platform === 'Android Reader') {
            if (config.nativeAndroidGoogleAnalyticsEnabled) {
                appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                    event: actions.newVisit,
                    event_category: categories.reader,
                    event_label: '' + yuduBookSettings.id,
                    edition: editionValue
                })
            }
        } else {
            gtag('event', actions.newVisit, {
                'event_category': categories.reader,
                'event_label': '' + yuduBookSettings.id
            })
        }
    };

    var pageView = function() {
        // done automatically by `interceptPageChanges` above
        // TODO: check this works in apps (and doesn't track messages)
    };

    var action = function(actionData) {
        if (!shouldSendDataForEvent(actionData)) { return; }
        var dataForEvent = determineDataForEvent(actionData);
        callForAllTrackers('send', dataForEvent);
        if (platform === 'Android Reader') {
            if (config.nativeAndroidGoogleAnalyticsEnabled) {
                appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                    event: dataForEvent.eventAction,
                    event_category: dataForEvent.eventCategory,
                    event_label: dataForEvent.eventLabel,
                    edition: editionValue
                })
            }
        } else {
            gtag('event', dataForEvent.eventAction, {
                'event_category': dataForEvent.eventCategory,
                'event_label': dataForEvent.eventLabel
            })
        }
        if (isSocialInteraction(actionData)) {
            var socialData = determineSocialData(actionData);
            callForAllTrackers('send', socialData);
            if (platform === 'Android Reader') {
                if (config.nativeAndroidGoogleAnalyticsEnabled) {
                    appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                        event: 'social_' + socialData.socialAction,
                        network: socialData.socialNetwork,
                        target: socialData.socialTarget,
                        edition: editionValue
                    })
                }
            } else {
                gtag('event', 'social_' + socialData.socialAction, {
                    'network': socialData.socialNetwork,
                    'target': socialData.socialTarget
                })
            }
        }
    };

    var shouldSendDataForEvent = function(actionData) {
        switch (actionData.actionType) {
            case events.video_resumed:
            case events.video_milestone_reached:
            case events.video_finished:
                return false;
        }
        return true;
    };

    var determineDataForEvent = function(actionData) {
        return {
            hitType: 'event',
            eventCategory: determineEventCategoryByActionType(actionData.actionType),
            eventAction: sanitiseActionTypeForGaAction(actionData.actionType),
            eventLabel: actionData.extraInfo
        };
    };

    var determineEventCategoryByActionType = function(actionType) {
        switch (actionType) {
            case events.overlay_email:
            case events.overlay_pagelink:
            case events.overlay_weblink:
            case events.overlay_productCode:
            case events.video_watched:
                return categories.overlay;
            default:
                return categories.reader;
        }
    };

    var sanitiseActionTypeForGaAction = function(actionType) {
        return actionType.toLowerCase().replace(/_/g, ' ');
    };

    var isSocialInteraction = function(actionData) {
        switch (actionData.actionType) {
            case events.emailed:
            case events.facebooked:
            case events.tweeted:
                return true;
            default:
                return false;
        }
    };

    var determineSocialData = function(actionData) {
        return {
            hitType: 'social',
            socialNetwork: determineSocialNetworkByActionType(actionData.actionType),
            socialAction: sanitiseActionTypeForGaAction(actionData.actionType),
            socialTarget: actionData.extraInfo
        };
    };

    var determineSocialNetworkByActionType = function(actionData) {
        switch (actionData.actionType) {
            case events.emailed:
                return socialNetworks.email;
            case events.facebooked:
                return socialNetworks.facebook;
            case events.tweeted:
                return socialNetworks.twitter;
            default:
                // emergency catch-all in case an action is added to `isSocialInteraction` above but not included here
                return socialNetworks.unknown;
        }
    };

    var search = function(searchData) {
        callForAllTrackers('send', {
            hitType: 'event',
            eventCategory: categories.reader,
            eventAction: actions.search,
            eventLabel: searchData.searchPhrase
        });
        if (platform === 'Android Reader') {
            if (config.nativeAndroidGoogleAnalyticsEnabled) {
                appUtils.sendMessage('gaMessage', appUtils.targets._app, {
                    event: 'search',
                    network: categories.reader,
                    target: searchData.searchPhrase,
                    edition: editionValue
                })
            }
        } else {
            gtag('event', 'search', {
                'event_category': categories.reader,
                'event_label': searchData.searchPhrase
            })
        }
    };

    var determineEditionPlatform = function() {
        if (appUtils.deviceType.isAndroid()) {
            platform = 'Android Reader';
        } else if (appUtils.deviceType.isMetro()) {
            platform = 'Windows Reader';
        } else {
            platform = 'Html Reader'
        }
    };

    preLoad();

    return {
        init: init,
        newVisit: newVisit,
        pageView: pageView,
        action: action,
        search: search
    };
});

define('utils/stats/adobeDtmIntegration',[],
function() {
    var integrationId = "ADOBE_DTM";
    var integrationEnabled = true;

    var yuduBookSettings = {};
    var integrationSettings = {};
    var events = {};

    var init = function(integrationApi) {
        events = integrationApi.events;
        yuduBookSettings = integrationApi.yuduBookSettings;
        if (yuduBookSettings.stats && yuduBookSettings.stats.integrationSettings) {
            var generalIntegrationSettings = yuduBookSettings.stats.integrationSettings;
            if (generalIntegrationSettings.integrationsEnabled) {
                integrationEnabled = !!generalIntegrationSettings.integrationsEnabled[integrationId];
                if (!integrationEnabled) {
                    return false;
                }
            }
            if (generalIntegrationSettings[integrationId]) {
                integrationSettings = generalIntegrationSettings[integrationId];
            }
        }
        return true;
    };

    var newVisit = function() {
        // done automatically by snippets
    };

    var pageView = function() {
        // done automatically by snippets
    };

    var action = function(actionData) {
        if (!shouldSendDataForEvent(actionData)) { return; }
        window._satellite && window._satellite.track && window._satellite.track(integrationSettings.ruleNames[actionData.actionType]);
    };

    var shouldSendDataForEvent = function(actionData) {
        // if a direct call rule name has been specified, then we track
        // otherwise we do nothing and assume their snippets will collect sufficient information
        return integrationSettings.ruleNames && integrationSettings.ruleNames[actionData.actionType]
    };

    var search = function(searchData) {
        // handled like other actions
        action({
            actionType: events.searched,
            extraInfo: searchData.searchPhrase
        });
    };

    return {
        init: init,
        newVisit: newVisit,
        pageView: pageView,
        action: action,
        search: search
    };
});

define('utils/stats/customEventIntegration',['events'],
function(events) {
    var CustomEventIntegration = function() {
        var self = this;
        var yuduBookSettings = {};
        var statsEvents = {};

        self.init = function (integrationApi) {
            statsEvents = integrationApi.events;
            yuduBookSettings = integrationApi.yuduBookSettings;
            return true;
        };

        self.newVisit = function (visitData) {
            var details = {
                page1: {
                    index: visitData.startPage,
                    number: visitData.startPage + visitData.indexOffset,
                    label: visitData.startLabel
                }
            };
            if (typeof visitData.secondStartPage != 'undefined') {
                details.page2 = {
                    index: visitData.secondStartPage,
                    number: visitData.secondStartPage + visitData.indexOffset,
                    label: visitData.secondStartLabel
                }
            }
            details.pretty = prettyPrintPageDetails(details);
            events.emit(yudu_events.ALL, yudu_events.STATISTICS.VISITED, self, details);
        };

        self.pageView = function (pageViewData) {
            var details = {
                page1: {
                    index: pageViewData.newPage,
                    number: pageViewData.newPage + pageViewData.indexOffset,
                    label: pageViewData.newPageLabel
                }
            };
            if (typeof pageViewData.newPage2 != 'undefined') {
                details.page2 = {
                    index: pageViewData.newPage2,
                    number: pageViewData.newPage2 + pageViewData.indexOffset,
                    label: pageViewData.newPageLabel2
                }
            }
            details.pretty = prettyPrintPageDetails(details);
            events.emit(yudu_events.ALL, yudu_events.STATISTICS.PAGE_VIEWED, self, details);
        };

        self.action = function (actionData) {
            var eventToEmit = yudu_events.STATISTICS[actionData.actionType];
            if (eventToEmit) {
                events.emit(yudu_events.ALL, eventToEmit, self, transcribeActionData(actionData));
            }
        };

        /**
         * Copies details from the input action data hash to a new hash to separate public object from internal ones
         * @param actionData {{}}
         */
        var transcribeActionData = function(actionData) {
            var details = {};
            switch (actionData.actionType) {
                case statsEvents.overlay_email:
                case statsEvents.overlay_weblink:
                case statsEvents.overlay_pagelink:
                case statsEvents.logo_clicked:
                case statsEvents.subscribed:
                case statsEvents.tweeted:
                case statsEvents.facebooked:
                    details.target = actionData.extraInfo;
                    break;
                case statsEvents.video_watched:
                case statsEvents.video_resumed:
                case statsEvents.video_finished:
                    details.url = actionData.extraInfo;
                    details.videoName = actionData.videoName;
                    break;
                case statsEvents.video_milestone_reached:
                    details.milestone = actionData.extraInfo;
                    details.url = actionData.src;
                    details.videoName = actionData.videoName;
                    break;
                case statsEvents.emailed:
                    details.sharedUrl = actionData.extraInfo;
                    break;
                case statsEvents.overlay_productCode:
                    details.target = actionData.target;
                    details.productCode = actionData.productCode;
                    break
                default:
                    details.extraInfo = actionData.extraInfo;
            }
            return details;
        };

        self.search = function (searchData) {
            var details = { searchPhrase: searchData.searchPhrase};
            events.emit(yudu_events.ALL, yudu_events.STATISTICS.SEARCHED, self, details);
        };

        var prettyPrintPageDetails = function(eventData) {
            var prettyDetails = {};
            if (eventData.page2) {
                prettyDetails.index = '' + eventData.page1.index + '-' + eventData.page2.index;
                prettyDetails.number = '' + eventData.page1.number + '-' + eventData.page2.number;
                prettyDetails.label = '' + eventData.page1.label + '-' + eventData.page2.label;
            } else {
                prettyDetails.index = '' + eventData.page1.index;
                prettyDetails.number = '' + eventData.page1.number;
                prettyDetails.label = '' + eventData.page1.label;
            }
            return prettyDetails;
        };
    };

    return new CustomEventIntegration();
});

define('utils/statistics',['jquery', 'utils/stats/yuduReporting', 'utils/stats/gaIntegration', 'utils/stats/adobeDtmIntegration',
        'utils/stats/customEventIntegration', 'shared/storage'],
function($, yuduReporting, gaIntegration, adobeDtmIntegration, customEventIntegration, storage) {
    var StatisticsModule = function() {
        // use `self` not `this` to ensure consistent scoping between private (`var`) and publicly (`self.`) exposed functions
        var self = this;
        var integrationApi = {};
        var GA_CONSENT_PREFIX = "gaConsent-";
        self.settings = {};
        self.eventOverrides = {};

        self.events = {
            searched: "SEARCHED", // placeholder for a search action - will be handled separately internally
            overlay_email: "EMAIL_LINK_CLICKED", // email overlay triggered
            overlay_weblink: "WEB_LINK_CLICKED", // web link overlay triggered
            overlay_pagelink: "PAGE_LINK_CLICKED", // page link overlay triggered
            overlay_productCode:"PRODUCT_CODE_CLICKED", //product code overlay clicked
            logo_clicked: "LOGO_CLICKED", // logo triggered
            video_watched: "VIDEO_WATCHED", // video played for the first time
            video_resumed: "VIDEO_RESUMED", // video played (not first time) or resumed
            video_milestone_reached: "VIDEO_MILESTONE_REACHED", // triggered when a video reaches specific milestones during playback
            video_finished: "VIDEO_FINISHED", // triggered when a video completes playback
            emailed: "EMAILED", // edition shared via email
            subscribed: "SUBSCRIBED", // edition viewer has subscribed
            tweeted: "TWEETED", // edition shared via Twitter
            facebooked: "FACEBOOKED" // edition shared via Facebook
        };

        var integrations = [];
        /*
         * All integrations should support the following interface:
         *  {
         *      init(yuduBookSettings)
         *      newVisit(...)
         *      pageView(...)
         *      action(...)
         *      search(...)
         *  }
         */

        /**
         * Basically an initialisation function by another name, called when the yuduBook has been loaded
         * @param settings ; settings from the yuduBook JSON
         */
        self.setYuduBookSettings = function(settings) {
            integrationApi.events = self.events;
            integrationApi.yuduBookSettings = settings;
            if (settings.stats) {
                self.settings = settings.stats;
            }
            if (self.settings.eventSettings && self.settings.eventSettings.globalOverrides) {
                self.eventOverrides = self.settings.eventSettings.globalOverrides;
            }
            addIntegration(yuduReporting);
            addIntegration(adobeDtmIntegration);
            addIntegration(customEventIntegration);
        };

        /**
         * Attempt to integrate a statistics submodule
         * Passes the integration API to each
         * @param integrationModule
         */
        var addIntegration = function(integrationModule) {
            var success = integrationModule.init(integrationApi);
            if (success) {
                // only add integrations that have successfully initialised
                integrations.push(integrationModule);
            }
        };

        /**
         * Helper function that calls the `newVisit` function of all active integrations
         * Applies a copy of all arguments to each call
         */
        self.newVisit = function() {
            for (var i = 0, m = integrations.length; i < m; i++) {
                integrations[i].newVisit.apply(this, Array.prototype.slice.call(arguments));
            }
        };

        /**
         * Helper function that calls the `pageView` function of all active integrations
         * Applies a copy of all arguments to each call
         */
        self.pageView = function() {
            for (var i = 0, m = integrations.length; i < m; i++) {
                integrations[i].pageView.apply(this, Array.prototype.slice.call(arguments));
            }
        };

        /**
         * Helper function that calls the `action` function of all active integrations
         * Applies a copy of all arguments to each call
         */
        self.action = function(actionData) {
            if (!shouldSendDataForEvent(actionData)) { return; }
            for (var i = 0, m = integrations.length; i < m; i++) {
                integrations[i].action.apply(this, Array.prototype.slice.call(arguments));
            }
        };

        /**
         * Should the specified action trigger the currently enabled integrations?
         * Ties in to the global overrides specified from Publisher
         * @param actionData ; the action data for the event that is being recorded
         * @returns {boolean}
         */
        var shouldSendDataForEvent = function(actionData) {
            // Recall that if an event is in the event overrides JSON, it should _not_ be tracked
            // Such events will have truthy values in the JSON to enable a simple lookup (ommitted values are falsey)
            //  but then need their values to be inverted for the output
            return !self.eventOverrides[actionData.actionType];
        };

        /**
         * Helper function that calls the `search` function of all active integrations
         * Applies a copy of all arguments to each call
         */
        self.search = function() {
            if (!!self.eventOverrides[self.events.searched]) {
                // As with `shouldSendDataForEvent`, if the `searched` placeholder is specified in the overrides,
                //  the client does _not_ want to track search events
                return;
            }
            for (var i = 0, m = integrations.length; i < m; i++) {
                integrations[i].search.apply(this, Array.prototype.slice.call(arguments));
            }
        };

        self.enableGoogleAnalytics = function() {
            addIntegration(gaIntegration);
            gaIntegration.newVisit.apply(this);
        }
    };

    return new StatisticsModule();
});

define('utils/urlUtils',['config'],
function (config) {

    var parseParameterisedUrl = function(url) {
        if (!url) {
            // if not a non-empty string, return whatever was passed in
            return url;
        }
        var output = "";
        var lookingFor = 0;
        var startedAt = 0;
        var paramName = "";
        for (var i = 0; i < url.length; i++) {
            if (0 == lookingFor) {
                if ('<' == url.charAt(i)) {
                    // found a parameter, add preceding text to output string
                    output += url.substring(startedAt, i);
                    // update search variables
                    lookingFor = 1;
                    startedAt = i+1;
                }
            } else if (1 == lookingFor) {
                if ('|' == url.charAt(i)) {
                    // at the divider, remember parameter name for substitution
                    paramName = url.substring(startedAt, i);
                    // update search variables
                    lookingFor = 2;
                    startedAt = i + 1;
                } else if ('>' == url.charAt(i)) {
                    // found end of parameter, perform substitution
                    // note there is no default value
                    output += substituteTokenValue(url.substring(startedAt, i), false);
                    // update search variables
                    lookingFor = 0;
                    startedAt = i + 1;
                }
            } else if ('>' == url.charAt(i)) {
                // 2 == lookingFor
                // found end of parameter, perform substitution
                output += substituteTokenValue(paramName, url.substring(startedAt, i));
                // update search variables
                lookingFor = 0;
                startedAt = i + 1;
            }
        }
        // 0 == lookingFor at this stage as per validiation of parameterised URLs by Publisher
        if (startedAt < url.length) {
            output += url.substring(startedAt, url.length);
        }
        return output;
    };

    var substituteTokenValue = function(paramName, defaultValue) {
        var queryVal = config.getFromQuery(paramName);
        if (queryVal || queryVal === "") {
            // parameter exists in current URL's query string, substitute in appropriate value
            return queryVal;
        } else if (defaultValue) {
            // no value available: use default value if specified
            return defaultValue;
        }
        // no value and no default: remove the token
        return "";
    };

    return {
        parseParameterisedUrl: parseParameterisedUrl
    };
});
/**
 * This module handles attempts to communicate with an app wrapper layer
 */
define('shared/utils/appWrapHook',['jquery', 'shared/utils/tools', 'config', 'resources', 'events', 'shared/utils/appUtils'],
    function($, tools, config, resources, events, appUtils) {

        var EMITTER_NAME = "appWrapHook";

        var init = function(hasEncryptedPage) {
            if (tools.isThisAnApp()) {
                status.setStatus.initialised();
            }
            appUtils.designateOrigin(appUtils.targets.htmlReader);
            window.wrapperAction = wrapperAction;
            if (hasEncryptedPage && status.ready()) {
                tryGettingDecryptionKey();
            }
            tryGettingUserCredentialsFromQueryString();

            if(appUtils.deviceType.isAndroid()) {
                appUtils.sendMessage('getGaSetting');
            }
        };

        /**
         * Attempts to retrieve the username and password from the query string if it's available. If it is available
         * then this will fire a login details change to ensure the right components get updated with the information.
         */
        var tryGettingUserCredentialsFromQueryString = function() {
            var usernameFromQuery = config.getFromQuery('username');
            var passwordFromQuery = config.getFromQuery('password');
            var subscriberIdFromQuery = config.getFromQuery('subscriberId');
            if (usernameFromQuery && passwordFromQuery) {
                events.emit(EMITTER_NAME, events.CHANGE_FOR_LOGIN_DETAILS, this, {
                    superLoginSuccess: true,
                    tokenKey: false,
                    tokenId: false,
                    subscriberEmail: false,
                    subscriberId: subscriberIdFromQuery || false,
                    deviceId: tools.getUniqueUserId(),
                    username: usernameFromQuery,
                    password: passwordFromQuery
                });
            }
        };

        /**
         * Search for a decryption key for an edition with at least one encrypted page
         * Looks first in the query string, as apps have historically used the URL to pass messages to the HTML reader
         * If none is available, uses the more recent direct-communication channels
         */
        var tryGettingDecryptionKey = function() {
            if (nativeComms.queryContainsKey()) {
                return;
            }

            return trySendingSimpleMessage('gimmeKey:' + resources.yuduBook.settings.id + ':' + resources.yuduBook.settings.pubId, true);
        };

        /**
         * Attempt to open the login UI of the app wrapper
         *  should be tried before attempting to login locally
         * Note that this method does not currently guarantee to provide the reader with credentials if successful
         *  this could be refactored to request a credentials response on success if the need is important enough to display a login UI
         * @returns boolean ; whether an attempt has been made - not an indication of success or failure
         */
        var trySuperLogin = function() {
            if (!status.initialised()) {
                return false;
            }
            return trySendingSimpleMessage("superLogin", true);
        };

        /**
         * Search for login credentials for an edition
         * Note that this method should not require the app to open a login UI:
         *  no credentials available will simply mean none are provided
         * If a login UI should be shown, consider refactoring the `trySuperLogin` method above
         *  to request a credentials response on success
         * @returns boolean ; whether an attempt has been made - not an indication of success or failure
         */
        var tryGettingSuperCredentials = function() {
            if (!status.ready() || status.superFailed()) {
                return false;
            }
            return trySendingSimpleMessage("readerNeedsCredentials", false);
        };

        /**
         * Request the wrapper app opens an external URL
         *  - used to insert app-level variables into a parameterisable URL
         * @returns boolean ; whether an attempt has been made - not an indication of success or failure
         */
        var tryOpeningExternalUrl = function(url) {
            if (!status.initialised()) {
                return false;
            }
            return trySendingSimpleMessage("openExternalUrl:" + url, false);
        };

        var tryGettingLiveUrl = function(editionId) {
            if (!status.ready()) {
                return false;
            }
            return trySendingSimpleMessage("getLiveUrl:" + editionId, true);
        };

        /**
         * Public interface function to expose the simple message sending function
         * Message should begin with the message type, followed by any parameters that should be colon-delimited
         * @param msg {string} ; complete, stringified message to send
         */
        var sendSimpleMessage = function(msg) {
            trySendingSimpleMessage(msg, false);
        };

        /**
         * Helper function to ensure the status is updated and the relevant communications channels are
         *  attempted when trying to pass a message to a native wrapper app
         * @param msg ; message string to send to the app
         * @param withListener ; whether the message expects a response
         */
        var trySendingSimpleMessage = function(msg, withListener) {
            if (withListener) {
                status.setStatus.aboutToSend();
            }
            return nativeComms.sendMessage(msg);
        };

        /**
         * Public interface function to expose the "message with parameters" sending function
         * @param msg {string} ; the message type to send
         * @param parameters {{}} ; [optional] hash of parameters to include in the message
         */
        var sendMessageWithParameters = function(msg, parameters) {
            trySendingMessageWithParameters(msg, parameters);
        };

        /**
         * Helper function to send a message to the native layer with an arbitrary set of parameters
         * Note this will use the new format of message - see `appUtils` doc for information
         * @param msg {string} ; message type (recognisable keyword)
         * @param parameters {{}} ; hash of parameters to include in the message
         */
        var trySendingMessageWithParameters = function(msg, parameters) {
            var params = parameters || {};
            appUtils.sendMessage(msg, appUtils.targets._app, params);
        };

        var wrapperAction = {
            decryptKey: function(key) {
                config.decryptionKey = key;
                status.setStatus.messageDecrypted();
                events.emit(EMITTER_NAME, events.LOGIN_SUCCESS, this, {key: key, success: true});
            },
            debug: function() {
            },
            superLogin: function(tokenKey, tokenId, subscriberEmail, subscriberId, deviceId,
                                 subscriberLoginUsername, subscriberPassword) {
                status.setStatus.receivedSuperLogin();
                events.emit(EMITTER_NAME, events.CHANGE_FOR_LOGIN_DETAILS, this, {
                    superLoginSuccess: true,
                    tokenKey: wrapperAction.nullValueFilter(tokenKey),
                    tokenId: wrapperAction.nullValueFilter(tokenId),
                    subscriberEmail: wrapperAction.nullValueFilter(subscriberEmail),
                    subscriberId: wrapperAction.nullValueFilter(subscriberId),
                    deviceId: wrapperAction.nullValueFilter(deviceId),
                    username: wrapperAction.nullValueFilter(subscriberLoginUsername),
                    password: wrapperAction.nullValueFilter(subscriberPassword)
                });
            },
            nullValueFilter: function(input) {
                if (input == 'false') {
                    return false;
                } else if (input == '') {
                    return false;
                }
                return input;
            },
            superLoginFailed: function() {
                status.setStatus.noSuper();
                events.emit(EMITTER_NAME, events.SHOW_LOGIN, this, {noSuper:true});
            },
            storeLiveUrl: function(liveUrl) {
                if (liveUrl !== "") {
                    var dummyAnchor = document.createElement('a');
                    dummyAnchor.href = liveUrl;
                    var liveUrlHost = dummyAnchor.host;
                    // I KNOW! I know. For some reason, the host comes back with a port even though the liveUrl doesn't
                    // have one, so we need to remove implicit ports.
                    if (liveUrlHost.indexOf(':80') > -1) {
                        liveUrlHost = liveUrlHost.replace(':80', '');
                    }
                    else if (liveUrlHost.indexOf(':443') > -1) {
                        liveUrlHost = liveUrlHost.replace(':443', '');
                    }
                    // ARGH! pathname may or may not start with '/'. We need '/', so...
                    var liveUrlPathname = dummyAnchor.pathname;
                    liveUrlPathname = liveUrlPathname.charAt(0) == '/' ? liveUrlPathname : '/' + liveUrlPathname;
                    config.liveUrl = dummyAnchor.protocol + '//' + liveUrlHost + liveUrlPathname;
                }
                else {
                    config.liveUrl = liveUrl;
                }
                events.emit(EMITTER_NAME, events.LIVE_URL_RECEIVED, this, {});
            },
            setGASetting: function(gaSetting) {
                config.nativeAndroidGoogleAnalyticsEnabled = gaSetting;
                events.emit(EMITTER_NAME, events.INIT_GA_CONSENT);
            },
            closedInAppBrowser: function() {
                if(resources.yuduBook.settings.closeLightboxOnInAppReturn) {
                    events.emit(EMITTER_NAME, events.CLOSE_LIGHTBOX);
                }
            },
            handleMessage: appUtils.api.handleMessage
        };

        var status = function() {
            var initialised = false;
            var superLoginFailed = false;
            var messageSent = false;
            var messageReceived = false;

            var setStatus = {
                initialised: function() { // this module is ready to attempt communication
                    initialised = true;
                },
                messageDecrypted: function() { // decryption key obtained via app message
                    messageReceived = true;
                },
                receivedSuperLogin: function() { // login credentials received via app message
                    messageReceived = true;
                    superLoginFailed = false;
                },
                noSuper: function() { // message received from app that the super login has failed
                    superLoginFailed = true;
                    messageReceived = true;
                },
                aboutToSend: function() { // message sending/sent but no response yet received
                    messageSent = true;
                }
            };

            var isInitialised = function() {
                return initialised;
            };

            var readyToHook = function() {
                return isInitialised() && (!messageSent || messageReceived);
            };

            var superFailed = function() {
                return superLoginFailed;
            };

            return {
                initialised: isInitialised,
                ready: readyToHook,
                superFailed: superFailed,
                setStatus: setStatus
            };
        }();

        // Communicating with the native layer
        var nativeComms = {
            queryContainsKey: function() {
                var keyFromQuery = config.getFromQuery('key');
                if (keyFromQuery) {
                    wrapperAction.decryptKey(keyFromQuery);
                    return true;
                }
                return false
            },
            sendMessage: function(message) {
                if (appUtils.deviceType.isMetro()) {
                    message = 'ms-appx-web:///yudu:' + message;
                    // IE has a url length limit of 2083 chars (and a path length limit of 2048 chars), so in case the
                    // message we are trying to send has at most 2000 chars (rounded for convenience), we simply change
                    // the location to it...
                    if (message.length <= 2000) {
                        window.location.href = message;
                    }
                    // ... otherwise we split the message into 2000 chars chunks and send it using a multipart command.
                    // The structure of the multipart command is
                    // 'ms-appx-web:///yudu:multipart:<uniqueId>:<numberOfCurrentChunk>:<totalNumberOfChunks>:<urlEncodedChunk>'
                    else {
                        var uniqueId = getMultipartMessageId(100, 999);
                        message = encodeURIComponent(message);
                        var total = Math.ceil(message.length / 2000);
                        for (var i = 0; i < total; i++) {
                            var newLocation = 'ms-appx-web:///yudu:multipart:';
                            newLocation += uniqueId + ':';
                            newLocation += i + ':';
                            newLocation += total + ':';
                            newLocation += message.substring(2000 * i, Math.min(2000 * (i + 1), message.length));
                            window.location.href = newLocation;
                        }
                    }
                    return true;
                } else if (appUtils.deviceType.isAndroid()) {
                    window.location.href = "yudu:" + message;
                    return true;
                }
                return false;
            }
        };

        /**
         * Creates a unique string of the form currentDateInBase36-randomNumberBetweenMinAndMax.
         *
         * @param min The lower limit (inclusive) of the random number interval.
         * @param max The upper limit (inclusive) of the random number interval.
         * @returns {string} The unique string.
         */
        var getMultipartMessageId = function(min, max) {
            var rn = Math.floor(Math.random() * (max - min + 1)) + min;
            return Date.now().toString(36).toUpperCase() + '-' + rn;
        };

        return {
            init: init,
            trySuperLogin: trySuperLogin,
            tryGettingSuperCredentials: tryGettingSuperCredentials,
            tryOpeningExternalUrl: tryOpeningExternalUrl,
            tryGettingLiveUrl: tryGettingLiveUrl,
            sendMessage: sendSimpleMessage,
            sendMessageWithParameters: sendMessageWithParameters,
            registerHandlerForMessageWithParameters: appUtils.registerMessageResponder
        }
    }
);

define('model/webLinkOverlay',['events', 'config', 'shared/utils/stringUtils', 'model/overlay',
            'utils/statistics', 'utils/tools', 'utils/urlUtils', 'shared/utils/appWrapHook'],
    function(events, config, stringUtils, overlay,
             statistics, tools, urlUtils, appWrapHook) {
        var EMITTER_NAME = 'webOverlay';
        var recognisedSchemas = {
            htmlArticle: 'htmlArticle:'
        };

        var WebLinkOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.link = info["@t"];
            this.tip = info["@tip"];
            this.isMagic = false;
            this.magicSchema = false;

            this.rectColour = config.webLinkOverlayColour;

            /**
             * Inits the overlay by creating a visual representation, the hit area and binding some events.
             */
            this.init = function() {
                this.createRectAndHitArea();
                this.checkForMagicLink();
                return this.rect;
            };

            /**
             * Listener that is triggered when this overlay is clicked on.
             */
            this.clicked = function() {
                var actualisedLink = urlUtils.parseParameterisedUrl(this.link);
                if (this.isMagic && this.magicClicked(actualisedLink)) {
                    return;
                }
                statistics.action({
                    actionType: statistics.events.overlay_weblink,
                    pageNumber: this.pageNumber,
                    extraInfo: actualisedLink
                });
                if (tools.isThisAnApp()) {
                    //check for custom scheme
                    var link = document.createElement('a');
                    link.setAttribute('href', actualisedLink);
                    if (link.protocol !== 'http:' && link.protocol !== 'https') {
                        //look for pageLink urls of the form
                        //<clientName>://pageLink/editionId/<editionId>/pageNumber/<pageNumber>/
                        var identifier = '//pageLink/';
                        var index = actualisedLink.indexOf(identifier);
                        if (index != -1) {
                            var pathSplit = actualisedLink.substring(index + identifier.length).split('/');
                            if (pathSplit.length >= 4 && pathSplit[0] == 'editionId' && pathSplit[2] == 'pageNumber'){
                                appWrapHook.sendMessage('goEdition:' + pathSplit[1] + ':' + pathSplit[3]);
                                return;
                            }
                        }
                    }
                }
                if (actualisedLink != this.link && tools.isThisAnApp() && tools.deviceType.isAndroid()) {
                    // if we are in the android native app, we want the app to do the substitution for us for access to app-level variables
                    appWrapHook.tryOpeningExternalUrl(encodeURIComponent(this.link));
                } else {
                    // not a parameterised URL or not in an app: just open the URL
                    tools.openURL(actualisedLink, config.tryToOpenWebOverlaysInNewWindow);
                }
            };

            /**
             * Check if this link is magic or not
             */
            this.checkForMagicLink = function() {
                var actualisedLink = urlUtils.parseParameterisedUrl(this.link);
                for (var key in recognisedSchemas) {
                    if (recognisedSchemas.hasOwnProperty(key)) {
                        if (stringUtils.startsWith(actualisedLink, recognisedSchemas[key])) {
                            this.isMagic = true;
                            this.magicSchema = recognisedSchemas[key];
                            return;
                        }
                    }
                }
            };

            /**
             * Handle a magic link being clicked
             * @param url {string} ; the final URL for use
             * @returns {boolean} ; whether the magic link has been handled
             */
            this.magicClicked = function(url) {
                switch (this.magicSchema) {
                    case recognisedSchemas.htmlArticle:
                        var article = url.substr(recognisedSchemas.htmlArticle.length);
                        events.emit(EMITTER_NAME, events.OPEN_ARTICLE, this, {article: article});
                        return true;
                }
                return false;
            }
        };
        WebLinkOverlay.prototype = overlay.Overlay.prototype;

        return {
            WebLinkOverlay: WebLinkOverlay
        };
    });

define('views/overlayView',['easel'],
    function(createjs) {

        /**
         * Class that represents a level that the overlays are rendered on - essentially just a container
         * @constructor
         */
        var OverlayView = function() {
            this.container = new createjs.Container();

            /**
             * Adds the specified visual representation of an overlay to this layer.
             * @param overlay the visual representation of an overlay
             */
            this.addOverlay = function(overlay) {
                this.container.addChild(overlay);
            };

            this.getOverlayIndex = function(overlay) {
                return this.container.getChildIndex(overlay);
            };

            this.replaceOverlay = function(overlay, index) {
                this.container.removeChildAt(index);
                this.container.addChildAt(overlay, index);
            };

            /**
             * Hides this layer
             */
            this.hide = function() {
                this.container.visible = false;
            };

            /**
             * Shows this layer
             */
            this.show = function() {
                this.container.visible = true;
            };
        };

        return {
            OverlayView: OverlayView
        };
    });

define('model/emailLinkOverlay',['events', 'config', 'model/overlay', 'utils/statistics', 'utils/tools'],
    function(events, config, overlay, statistics, tools) {

        var EmailLinkOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.email = info["@t"];
            this.tip = info["@tip"];

            this.rectColour = config.emailLinkOverlayColour;

            /**
             * Inits the overlay by creating a visual representation, the hit area and binding some events.
             */
            this.init = function() {
                this.createRectAndHitArea();
                return this.rect;
            };

            /**
             * Listener that is triggered when this overlay is clicked on.
             */
            this.clicked = function() {
                statistics.action({
                    actionType: statistics.events.overlay_email,
                    pageNumber: this.pageNumber,
                    extraInfo: this.email
                });
                tools.openURL("mailto:" + this.email, false);
            };
        };
        EmailLinkOverlay.prototype = overlay.Overlay.prototype;

        return {
            EmailLinkOverlay: EmailLinkOverlay
        };
    });

define('model/pageLinkOverlay',['events', 'config', 'model/overlay', 'utils/statistics'],
    function(events, config, overlay, statistics) {

        var EMITTER_NAME = "pageLinkOverlay";

        var PageLinkOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.targetPage = info["@t"];
            this.tip = info["@tip"];

            this.rectColour = config.pageLinkOverlayColour;

            /**
             * Inits the overlay by creating a visual representation, the hit area and binding some events.
             */
            this.init = function() {
                this.createRectAndHitArea();
                events.register(EMITTER_NAME);
                return this.rect;
            };

            /**
             * Listener that is triggered when this overlay is clicked on.
             */
            this.clicked = function() {
                statistics.action({
                    actionType: statistics.events.overlay_pagelink,
                    pageNumber: this.pageNumber,
                    extraInfo: this.targetPage
                });
                events.emit(EMITTER_NAME, events.GOTO_PAGE, this, {pageNumber: this.targetPage});
            };
        };
        PageLinkOverlay.prototype = overlay.Overlay.prototype;

        return {
            PageLinkOverlay: PageLinkOverlay,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('shared/utils/utils',[],
function() {
    var Utils = function() {
        var self = this;

        /**
         * Given a base object, and an optional arbitrary number of strings denoting names of object attributes,
         *  returns the object found at the conclusion of the tree walk, or `undefined` if it is unavailable.
         * Note that after `base`, any additional arguments should be either string or integer literals
         *  string literal if searching a named property of an object
         *  integer literal if looking up an index of an array
         * Throws an exception if no base is supplied.
         * Does not throw an exception if an intermediate object is itself `undefined` - instead silently returns early
         * Inspired by the ruby gem `andand`
         * @param base
         * @returns {*}
         */
        self.getLeafOrUndefined = function(base) {
            if (arguments.length < 1) {
                throw 'Exception: Invalid number of arguments.';
            } else if (typeof base === 'undefined') {
                return base;
            }
            var undef; // purposely undefined
            var subproperty = base;
            for (var i = 1, m = arguments.length; i < m; i++) {
                try {
                    subproperty = subproperty[arguments[i]];
                } catch (e) {
                    // most interrupted walks will terminate at a getter that returns `undefined`
                    // this try/catch is primarily for properties overwritten with custom getter behaviour
                    return undef;
                }
                if (typeof subproperty === 'undefined') {
                    return undef;
                }
            }
            return subproperty;
        };
        /*
        Example usage.
        If the `base` is an object with structure:
            {
                a: {
                    one: 1,
                    two: [2, 3],
                    three: {
                        inner: 'leaf'
                    }
                }
            }
        Then
        ```
        > console.log(utils.propertyAtLeafOrUndefined(base, 'a', 'one'))
             // fetch a leaf
        1
        > console.log(utils.propertyAtLeafOrUndefined(base, 'a', 'two', 1))
             // can walk arrays as well as objects
        3
        > console.log(utils.propertyAtLeafOrUndefined(base, 'a', 'three'))
             // fetches whatever object is at that leaf, literal or not
        Object {inner: "leaf"}
        > console.log(utils.propertyAtLeafOrUndefined(base, 'a', 'four'))
             // missing leaves return undefined
        _undefined_
        > console.log(utils.propertyAtLeafOrUndefined(base, 'b', 'two'))
             // broken chains safely return undefined without raising an "Uncaught TypeError: ... of undefined" exception
        _undefined_
        ```
        */

        /**
         * Given any arbitrary number of string filepath fragments, concatenates them, ensuring there is at most
         *  one folder divider symbol between each fragment
         * @returns {string}
         */
        self.combinePaths = function() {
            var ret = '';
            for (var i = 0, m = arguments.length; i < m; i++) {
                var substr = arguments[i];
                if (typeof substr === 'undefined') {
                    continue;
                }
                if (i !== 0) {
                    // not the first substring
                    var lastSubstringEndedWithSlash = ret[ret.length - 1] === '/';
                    var thisSubstringStartsWithSlash = substr[0] === '/';
                    if (!lastSubstringEndedWithSlash && !thisSubstringStartsWithSlash) {
                        // if the previous string did not end in `/` and this does not start in `/`, add one
                        ret += '/';
                    } else if (lastSubstringEndedWithSlash && thisSubstringStartsWithSlash) {
                        // if the previous string did end in `/` but this does too, remove it
                        substr = substr.substr(1, substr.length);
                    }
                }
                ret += substr;
            }
            return ret;
        };

        /**
         * Creates a debouncing function wrapper
         * Note that a non-immediate debounced function only executes once the wait has expired with no further calls to
         *  the debounced function. Thus calling a debounced function with a wait of 30ms every 20ms will result in the
         *  function never actually firing. In such circumstances a throttle may be more appropriate.
         * Debounce a function that should only occur at the end of a series of events. For example, when implementing
         *  a window resize event listener, it makes sense to debounce the listener so it will only fire once the resize
         *  has finished, saving unneeded calculations during the resize itself.
         * Returned function has some additional properties that can be used to access the timeout:
         *  `clearTimeout` stops the timeout
         *  `isActive` checks if the timeout is still running
         * @param callback {Function} the function to debounce
         * @param wait {number} the time to wait (ms) before freeing the debounce lock
         * @param immediate {boolean} should the function be called at the start of the wait (`true`) or the end
         * @param bounceReturnVal {*} return value for bounces
         * @returns {Function} debounced wrapper function
         */
        self.debounce = function(callback, wait, immediate, bounceReturnVal) {
            // scoped variable for tracking the timeout between calls to the debounced function
            var timeout;
            // this will be the returned function
            var debounced = function() {
                // prepare for the callback
                var context = this;
                var args = arguments;
                // this is what the timeout actually ends up calling
                var later = function() {
                    // make sure to clear the timeout variable so we easily know if the timeout completed
                    timeout = null;
                    // if the function was called immediately, don't call it again
                    if (!immediate) {
                        callback.apply(context, args);
                    }
                };
                // if the function should be called immediately, we still need to check if a timeout is in progress
                var callNow = immediate && !timeout;
                // clear the timeout to allow us to reset the timer's progress
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
                // if calling immediately, it is safe to trigger the callback now that the timeout is started
                if (callNow) {
                    return callback.apply(context, args);
                }
                return bounceReturnVal;
            };
            /**
             * Helper that stops and resets any active timers for this debounced function
             */
            debounced.clearTimeout = function() {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
            };
            /**
             * Accessor to trivially determine if a timer is running for this debounced function
             * @returns {boolean} is it running?
             */
            debounced.isActive = function() {
                return !!timeout;
            };
            return debounced;
        };

        /**
         * Debounces a function like the above, but keeps track of the last call to prevent repeatedly clearing and
         *  setting timeouts (expensive) in preference of just assigning (cheap) a date (cheaper than `setInterval`)
         * Requests an animation frame for determining if it is suitable to trigger the callback.
         * Should be more suitable for performance-critical functionality like handling animations.
         * Note that unless performance is a known issue, the above should be preferred; this is experimental.
         * @param callback {Function} what to call when the timer expires
         * @param wait {number} desired target wait time
         */
        self.performanceCriticalDebounce = function(callback, wait) {
            var last = null;
            var undefined;
            var context;
            var args;
            var timeout = null;
            /**
             * Helper that resets stored state to suitable initial values
             */
            var reset = function() {
                last = null;
                context = undefined;
                args = undefined;
                timeout = null;
            };
            /**
             * The external function to be called when trying to trigger the original callback
             * Starts a timer if none is running, otherwise updates the last called state variable for bouncing
             */
            var debounced = function() {
                // capture some context
                context = this;
                args = arguments;
                if (timeout !== null) {
                    // timer already active: mark the current time
                    last = Date.now();
                    return;
                }
                // start the timer
                timeout = setTimeout(laterSafe, wait);
            };
            /**
             * The function any triggered timeouts will end up calling
             * Resets the timer if the bounce handler has been called
             */
            var later = function() {
                if (last !== null) {
                    // something else has since bounced this function: find out how much longer we should wait
                    var newPause = wait - (Date.now() - last);
                    // ensure it is not so small as to not be worth resetting (~18ms/frame @60fps)
                    newPause = newPause < 30 ? 30 : newPause;
                    // restart timer with the new wait time
                    timeout = setTimeout(laterSafe, newPause);
                    // remember to update state
                    last = null;
                    return;
                }
                // nothing else bounced this, so call the original callback and reset
                if (context) {
                    callback.apply(context, args);
                } else {
                    callback();
                }
                reset();
            };
            /**
             * Wraps `later` in a request to obtain an animation-frame thread entry-point
             * This should keep it safer for high-frequency calls towards the tail end of a
             */
            var laterSafe = function() {
                requestAnimationFrame(later);
            };
            /**
             * Helper that stops and resets any active timers for this debounced function
             */
            debounced.clearTimeout = function() {
                if (timeout) {
                    clearTimeout(timeout);
                    reset();
                }
            };
            /**
             * Accessor to trivially determine if a timer is running for this debounced function
             * @returns {boolean} is it running?
             */
            debounced.isActive = function() {
                return !!timeout;
            };
            return debounced;
        };

        /**
         * Creates a throttled function wrapper
         * Note that a throttled function will only execute at most once in each period defined by the limit. A function
         *  called more often that the limit will have the extra calls ignored. Thus a throttled function with a limit
         *  of 60ms called every 20ms will usually only fire the callback every 60ms. Note that when the limit is a
         *  multiple of the frequency, the function may or may not fire again at the limit depending on whether the lock
         *  is released first.
         * @param callback {Function} the function to throttle
         * @param throttleLimit {number} the limit (ms) to the frequency of calls that succeed
         * @returns {Function} throttled wrapper function
         */
        self.throttle = function(callback, throttleLimit) {
            // scoped variable for tracking the throttle's state between calls to the throttled function
            var wait = false;
            return function () {
                var result;
                // if the throttle is not active, it is safe to trigger the callback
                if (!wait) {
                    result = callback.call();
                    // but now the throttle needs to be activated to prevent further calls
                    wait = true;
                    // and the throttle needs to be released after the specified period of time
                    setTimeout(function () {
                        wait = false;
                    }, throttleLimit);
                }
                // allows us to pass on whatever the throttled function returned - always undefined if throttle active
                return result;
            }
        };
    };

    return new Utils();
});

define('hammer2',[], function() {
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Modifications Copyright (c) 2017, 2020 YUDU Ltd.
 *
 * Modified 2020-07-27 to add an event handler on touchstart that calls e.preventDefault(), to fix a problem with
 * iOS 13.1+ that makes doubletaps undetectable.
 *
 * Licensed under the MIT license */
return (function(window, document, exportName, undefined) {
  'use strict';

var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
var TEST_ELEMENT = document.createElement('div');

var TYPE_FUNCTION = 'function';

var round = Math.round;
var abs = Math.abs;
var now = Date.now;

/**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
function setTimeoutContext(fn, timeout, context) {
    return setTimeout(bindFn(fn, context), timeout);
}

/**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
function invokeArrayArg(arg, fn, context) {
    if (Array.isArray(arg)) {
        each(arg, context[fn], context);
        return true;
    }
    return false;
}

/**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
function each(obj, iterator, context) {
    var i;

    if (!obj) {
        return;
    }

    if (obj.forEach) {
        obj.forEach(iterator, context);
    } else if (obj.length !== undefined) {
        i = 0;
        while (i < obj.length) {
            iterator.call(context, obj[i], i, obj);
            i++;
        }
    } else {
        for (i in obj) {
            obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
        }
    }
}

/**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
function deprecate(method, name, message) {
    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
    return function() {
        var e = new Error('get-stack-trace');
        var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '')
            .replace(/^\s+at\s+/gm, '')
            .replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';

        var log = window.console && (window.console.warn || window.console.log);
        if (log) {
            log.call(window.console, deprecationMessage, stack);
        }
        return method.apply(this, arguments);
    };
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
var assign;
if (typeof Object.assign !== 'function') {
    assign = function assign(target) {
        if (target === undefined || target === null) {
            throw new TypeError('Cannot convert undefined or null to object');
        }

        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                    if (source.hasOwnProperty(nextKey)) {
                        output[nextKey] = source[nextKey];
                    }
                }
            }
        }
        return output;
    };
} else {
    assign = Object.assign;
}

/**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
var extend = deprecate(function extend(dest, src, merge) {
    var keys = Object.keys(src);
    var i = 0;
    while (i < keys.length) {
        if (!merge || (merge && dest[keys[i]] === undefined)) {
            dest[keys[i]] = src[keys[i]];
        }
        i++;
    }
    return dest;
}, 'extend', 'Use `assign`.');

/**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
var merge = deprecate(function merge(dest, src) {
    return extend(dest, src, true);
}, 'merge', 'Use `assign`.');

/**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
function inherit(child, base, properties) {
    var baseP = base.prototype,
        childP;

    childP = child.prototype = Object.create(baseP);
    childP.constructor = child;
    childP._super = baseP;

    if (properties) {
        assign(childP, properties);
    }
}

/**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
function bindFn(fn, context) {
    return function boundFn() {
        return fn.apply(context, arguments);
    };
}

/**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
function boolOrFn(val, args) {
    if (typeof val == TYPE_FUNCTION) {
        return val.apply(args ? args[0] || undefined : undefined, args);
    }
    return val;
}

/**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
function ifUndefined(val1, val2) {
    return (val1 === undefined) ? val2 : val1;
}

/**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function addEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.addEventListener(type, handler, false);
    });

    // Added to prevent problem in iOS 13.1+ where doubletaps are handled as a single tap.
    target.addEventListener('touchstart', function(e) {
        if (e.target && e.target.id === 'yudu_interactionDiv') {
            e.preventDefault();
        }
    });
}

/**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
function removeEventListeners(target, types, handler) {
    each(splitStr(types), function(type) {
        target.removeEventListener(type, handler, false);
    });
}

/**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
function hasParent(node, parent) {
    while (node) {
        if (node == parent) {
            return true;
        }
        node = node.parentNode;
    }
    return false;
}

/**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
function inStr(str, find) {
    return str.indexOf(find) > -1;
}

/**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
function splitStr(str) {
    return str.trim().split(/\s+/g);
}

/**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
function inArray(src, find, findByKey) {
    if (src.indexOf && !findByKey) {
        return src.indexOf(find);
    } else {
        var i = 0;
        while (i < src.length) {
            if ((findByKey && src[i][findByKey] == find) || (!findByKey && src[i] === find)) {
                return i;
            }
            i++;
        }
        return -1;
    }
}

/**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
function toArray(obj) {
    return Array.prototype.slice.call(obj, 0);
}

/**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
function uniqueArray(src, key, sort) {
    var results = [];
    var values = [];
    var i = 0;

    while (i < src.length) {
        var val = key ? src[i][key] : src[i];
        if (inArray(values, val) < 0) {
            results.push(src[i]);
        }
        values[i] = val;
        i++;
    }

    if (sort) {
        if (!key) {
            results = results.sort();
        } else {
            results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
            });
        }
    }

    return results;
}

/**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
function prefixed(obj, property) {
    var prefix, prop;
    var camelProp = property[0].toUpperCase() + property.slice(1);

    var i = 0;
    while (i < VENDOR_PREFIXES.length) {
        prefix = VENDOR_PREFIXES[i];
        prop = (prefix) ? prefix + camelProp : property;

        if (prop in obj) {
            return prop;
        }
        i++;
    }
    return undefined;
}

/**
 * get a unique id
 * @returns {number} uniqueId
 */
var _uniqueId = 1;
function uniqueId() {
    return _uniqueId++;
}

/**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
function getWindowForElement(element) {
    var doc = element.ownerDocument || element;
    return (doc.defaultView || doc.parentWindow || window);
}

var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;

var SUPPORT_TOUCH = ('ontouchstart' in window);
var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);

var INPUT_TYPE_TOUCH = 'touch';
var INPUT_TYPE_PEN = 'pen';
var INPUT_TYPE_MOUSE = 'mouse';
var INPUT_TYPE_KINECT = 'kinect';

var COMPUTE_INTERVAL = 25;

var INPUT_START = 1;
var INPUT_MOVE = 2;
var INPUT_END = 4;
var INPUT_CANCEL = 8;

var DIRECTION_NONE = 1;
var DIRECTION_LEFT = 2;
var DIRECTION_RIGHT = 4;
var DIRECTION_UP = 8;
var DIRECTION_DOWN = 16;

var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;

var PROPS_XY = ['x', 'y'];
var PROPS_CLIENT_XY = ['clientX', 'clientY'];

/**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
function Input(manager, callback) {
    var self = this;
    this.manager = manager;
    this.callback = callback;
    this.element = manager.element;
    this.target = manager.options.inputTarget;

    // smaller wrapper around the handler, for the scope and the enabled state of the manager,
    // so when disabled the input events are completely bypassed.
    this.domHandler = function(ev) {
        if (boolOrFn(manager.options.enable, [manager])) {
            self.handler(ev);
        }
    };

    this.init();

}

Input.prototype = {
    /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
    handler: function() { },

    /**
     * bind the events
     */
    init: function() {
        this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    },

    /**
     * unbind the events
     */
    destroy: function() {
        this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
        this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
        this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
    }
};

/**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
function createInputInstance(manager) {
    var Type;
    var inputClass = manager.options.inputClass;

    if (inputClass) {
        Type = inputClass;
    } else if (SUPPORT_POINTER_EVENTS) {
        Type = PointerEventInput;
    } else if (SUPPORT_ONLY_TOUCH) {
        Type = TouchInput;
    } else if (!SUPPORT_TOUCH) {
        Type = MouseInput;
    } else {
        Type = TouchMouseInput;
    }
    return new (Type)(manager, inputHandler);
}

/**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
function inputHandler(manager, eventType, input) {
    var pointersLen = input.pointers.length;
    var changedPointersLen = input.changedPointers.length;
    var isFirst = (eventType & INPUT_START && (pointersLen - changedPointersLen === 0));
    var isFinal = (eventType & (INPUT_END | INPUT_CANCEL) && (pointersLen - changedPointersLen === 0));

    input.isFirst = !!isFirst;
    input.isFinal = !!isFinal;

    if (isFirst) {
        manager.session = {};
    }

    // source event is the normalized value of the domEvents
    // like 'touchstart, mouseup, pointerdown'
    input.eventType = eventType;

    // compute scale, rotation etc
    computeInputData(manager, input);

    // emit secret event
    manager.emit('hammer.input', input);

    manager.recognize(input);
    manager.session.prevInput = input;
}

/**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
function computeInputData(manager, input) {
    var session = manager.session;
    var pointers = input.pointers;
    var pointersLength = pointers.length;

    // store the first input to calculate the distance and direction
    if (!session.firstInput) {
        session.firstInput = simpleCloneInputData(input);
    }

    // to compute scale and rotation we need to store the multiple touches
    if (pointersLength > 1 && !session.firstMultiple) {
        session.firstMultiple = simpleCloneInputData(input);
    } else if (pointersLength === 1) {
        session.firstMultiple = false;
    }

    var firstInput = session.firstInput;
    var firstMultiple = session.firstMultiple;
    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;

    var center = input.center = getCenter(pointers);
    input.timeStamp = now();
    input.deltaTime = input.timeStamp - firstInput.timeStamp;

    input.angle = getAngle(offsetCenter, center);
    input.distance = getDistance(offsetCenter, center);

    computeDeltaXY(session, input);
    input.offsetDirection = getDirection(input.deltaX, input.deltaY);

    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
    input.overallVelocityX = overallVelocity.x;
    input.overallVelocityY = overallVelocity.y;
    input.overallVelocity = (abs(overallVelocity.x) > abs(overallVelocity.y)) ? overallVelocity.x : overallVelocity.y;

    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;

    input.maxPointers = !session.prevInput ? input.pointers.length : ((input.pointers.length >
        session.prevInput.maxPointers) ? input.pointers.length : session.prevInput.maxPointers);

    computeIntervalInputData(session, input);

    // find the correct target
    var target = manager.element;
    if (hasParent(input.srcEvent.target, target)) {
        target = input.srcEvent.target;
    }
    input.target = target;
}

function computeDeltaXY(session, input) {
    var center = input.center;
    var offset = session.offsetDelta || {};
    var prevDelta = session.prevDelta || {};
    var prevInput = session.prevInput || {};

    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
        prevDelta = session.prevDelta = {
            x: prevInput.deltaX || 0,
            y: prevInput.deltaY || 0
        };

        offset = session.offsetDelta = {
            x: center.x,
            y: center.y
        };
    }

    input.deltaX = prevDelta.x + (center.x - offset.x);
    input.deltaY = prevDelta.y + (center.y - offset.y);
}

/**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
function computeIntervalInputData(session, input) {
    var last = session.lastInterval || input,
        deltaTime = input.timeStamp - last.timeStamp,
        velocity, velocityX, velocityY, direction;

    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
        var deltaX = input.deltaX - last.deltaX;
        var deltaY = input.deltaY - last.deltaY;

        var v = getVelocity(deltaTime, deltaX, deltaY);
        velocityX = v.x;
        velocityY = v.y;
        velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;
        direction = getDirection(deltaX, deltaY);

        session.lastInterval = input;
    } else {
        // use latest velocity info if it doesn't overtake a minimum period
        velocity = last.velocity;
        velocityX = last.velocityX;
        velocityY = last.velocityY;
        direction = last.direction;
    }

    input.velocity = velocity;
    input.velocityX = velocityX;
    input.velocityY = velocityY;
    input.direction = direction;
}

/**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
function simpleCloneInputData(input) {
    // make a simple copy of the pointers because we will get a reference if we don't
    // we only need clientXY for the calculations
    var pointers = [];
    var i = 0;
    while (i < input.pointers.length) {
        pointers[i] = {
            clientX: round(input.pointers[i].clientX),
            clientY: round(input.pointers[i].clientY)
        };
        i++;
    }

    return {
        timeStamp: now(),
        pointers: pointers,
        center: getCenter(pointers),
        deltaX: input.deltaX,
        deltaY: input.deltaY
    };
}

/**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
function getCenter(pointers) {
    var pointersLength = pointers.length;

    // no need to loop when only one touch
    if (pointersLength === 1) {
        return {
            x: round(pointers[0].clientX),
            y: round(pointers[0].clientY)
        };
    }

    var x = 0, y = 0, i = 0;
    while (i < pointersLength) {
        x += pointers[i].clientX;
        y += pointers[i].clientY;
        i++;
    }

    return {
        x: round(x / pointersLength),
        y: round(y / pointersLength)
    };
}

/**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
function getVelocity(deltaTime, x, y) {
    return {
        x: x / deltaTime || 0,
        y: y / deltaTime || 0
    };
}

/**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
function getDirection(x, y) {
    if (x === y) {
        return DIRECTION_NONE;
    }

    if (abs(x) >= abs(y)) {
        return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
}

/**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
function getDistance(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];

    return Math.sqrt((x * x) + (y * y));
}

/**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
function getAngle(p1, p2, props) {
    if (!props) {
        props = PROPS_XY;
    }
    var x = p2[props[0]] - p1[props[0]],
        y = p2[props[1]] - p1[props[1]];
    return Math.atan2(y, x) * 180 / Math.PI;
}

/**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
function getRotation(start, end) {
    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
}

/**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
function getScale(start, end) {
    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
}

var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
};

var MOUSE_ELEMENT_EVENTS = 'mousedown';
var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';

/**
 * Mouse events input
 * @constructor
 * @extends Input
 */
function MouseInput() {
    this.evEl = MOUSE_ELEMENT_EVENTS;
    this.evWin = MOUSE_WINDOW_EVENTS;

    this.pressed = false; // mousedown state

    Input.apply(this, arguments);
}

inherit(MouseInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function MEhandler(ev) {
        var eventType = MOUSE_INPUT_MAP[ev.type];

        // on start we want to have the left mouse button down
        if (eventType & INPUT_START && ev.button === 0) {
            this.pressed = true;
        }

        if (eventType & INPUT_MOVE && ev.which !== 1) {
            eventType = INPUT_END;
        }

        // mouse must be down
        if (!this.pressed) {
            return;
        }

        if (eventType & INPUT_END) {
            this.pressed = false;
        }

        this.callback(this.manager, eventType, {
            pointers: [ev],
            changedPointers: [ev],
            pointerType: INPUT_TYPE_MOUSE,
            srcEvent: ev
        });
    }
});

var POINTER_INPUT_MAP = {
    pointerdown: INPUT_START,
    pointermove: INPUT_MOVE,
    pointerup: INPUT_END,
    pointercancel: INPUT_CANCEL,
    pointerout: INPUT_CANCEL
};

// in IE10 the pointer types is defined as an enum
var IE10_POINTER_TYPE_ENUM = {
    2: INPUT_TYPE_TOUCH,
    3: INPUT_TYPE_PEN,
    4: INPUT_TYPE_MOUSE,
    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
};

var POINTER_ELEMENT_EVENTS = 'pointerdown';
var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';

// IE10 has prefixed support, and case-sensitive
if (window.MSPointerEvent && !window.PointerEvent) {
    POINTER_ELEMENT_EVENTS = 'MSPointerDown';
    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
}

/**
 * Pointer events input
 * @constructor
 * @extends Input
 */
function PointerEventInput() {
    this.evEl = POINTER_ELEMENT_EVENTS;
    this.evWin = POINTER_WINDOW_EVENTS;

    Input.apply(this, arguments);

    this.store = (this.manager.session.pointerEvents = []);
}

inherit(PointerEventInput, Input, {
    /**
     * handle mouse events
     * @param {Object} ev
     */
    handler: function PEhandler(ev) {
        var store = this.store;
        var removePointer = false;

        var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
        var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
        var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;

        var isTouch = (pointerType == INPUT_TYPE_TOUCH);

        // get index of the event in the store
        var storeIndex = inArray(store, ev.pointerId, 'pointerId');

        // start and mouse must be down
        if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
            if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
            }
        } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            removePointer = true;
        }

        // it not found, so the pointer hasn't been down (so it's probably a hover)
        if (storeIndex < 0) {
            return;
        }

        // update the event in the store
        store[storeIndex] = ev;

        this.callback(this.manager, eventType, {
            pointers: store,
            changedPointers: [ev],
            pointerType: pointerType,
            srcEvent: ev
        });

        if (removePointer) {
            // remove from the store
            store.splice(storeIndex, 1);
        }
    }
});

var SINGLE_TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Touch events input
 * @constructor
 * @extends Input
 */
function SingleTouchInput() {
    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
    this.started = false;

    Input.apply(this, arguments);
}

inherit(SingleTouchInput, Input, {
    handler: function TEhandler(ev) {
        var type = SINGLE_TOUCH_INPUT_MAP[ev.type];

        // should we handle the touch events?
        if (type === INPUT_START) {
            this.started = true;
        }

        if (!this.started) {
            return;
        }

        var touches = normalizeSingleTouches.call(this, ev, type);

        // when done, reset the started state
        if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
            this.started = false;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function normalizeSingleTouches(ev, type) {
    var all = toArray(ev.touches);
    var changed = toArray(ev.changedTouches);

    if (type & (INPUT_END | INPUT_CANCEL)) {
        all = uniqueArray(all.concat(changed), 'identifier', true);
    }

    return [all, changed];
}

var TOUCH_INPUT_MAP = {
    touchstart: INPUT_START,
    touchmove: INPUT_MOVE,
    touchend: INPUT_END,
    touchcancel: INPUT_CANCEL
};

var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';

/**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
function TouchInput() {
    this.evTarget = TOUCH_TARGET_EVENTS;
    this.targetIds = {};

    Input.apply(this, arguments);
}

inherit(TouchInput, Input, {
    handler: function MTEhandler(ev) {
        var type = TOUCH_INPUT_MAP[ev.type];
        var touches = getTouches.call(this, ev, type);
        if (!touches) {
            return;
        }

        this.callback(this.manager, type, {
            pointers: touches[0],
            changedPointers: touches[1],
            pointerType: INPUT_TYPE_TOUCH,
            srcEvent: ev
        });
    }
});

/**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
function getTouches(ev, type) {
    var allTouches = toArray(ev.touches);
    var targetIds = this.targetIds;

    // when there is only one touch, the process can be simplified
    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
        targetIds[allTouches[0].identifier] = true;
        return [allTouches, allTouches];
    }

    var i,
        targetTouches,
        changedTouches = toArray(ev.changedTouches),
        changedTargetTouches = [],
        target = this.target;

    // get target touches from touches
    targetTouches = allTouches.filter(function(touch) {
        return hasParent(touch.target, target);
    });

    // collect touches
    if (type === INPUT_START) {
        i = 0;
        while (i < targetTouches.length) {
            targetIds[targetTouches[i].identifier] = true;
            i++;
        }
    }

    // filter changed touches to only contain touches that exist in the collected target ids
    i = 0;
    while (i < changedTouches.length) {
        if (targetIds[changedTouches[i].identifier]) {
            changedTargetTouches.push(changedTouches[i]);
        }

        // cleanup removed touches
        if (type & (INPUT_END | INPUT_CANCEL)) {
            delete targetIds[changedTouches[i].identifier];
        }
        i++;
    }

    if (!changedTargetTouches.length) {
        return;
    }

    return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true),
        changedTargetTouches
    ];
}

/**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */

var DEDUP_TIMEOUT = 2500;
var DEDUP_DISTANCE = 25;

function TouchMouseInput() {
    Input.apply(this, arguments);

    var handler = bindFn(this.handler, this);
    this.touch = new TouchInput(this.manager, handler);
    this.mouse = new MouseInput(this.manager, handler);

    this.primaryTouch = null;
    this.lastTouches = [];
}

inherit(TouchMouseInput, Input, {
    /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
    handler: function TMEhandler(manager, inputEvent, inputData) {
        var isTouch = (inputData.pointerType == INPUT_TYPE_TOUCH),
            isMouse = (inputData.pointerType == INPUT_TYPE_MOUSE);

        if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
            return;
        }

        // when we're in a touch event, record touches to  de-dupe synthetic mouse event
        if (isTouch) {
            recordTouches.call(this, inputEvent, inputData);
        } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
            return;
        }

        this.callback(manager, inputEvent, inputData);
    },

    /**
     * remove the event listeners
     */
    destroy: function destroy() {
        this.touch.destroy();
        this.mouse.destroy();
    }
});

function recordTouches(eventType, eventData) {
    if (eventType & INPUT_START) {
        this.primaryTouch = eventData.changedPointers[0].identifier;
        setLastTouch.call(this, eventData);
    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
        setLastTouch.call(this, eventData);
    }
}

function setLastTouch(eventData) {
    var touch = eventData.changedPointers[0];

    if (touch.identifier === this.primaryTouch) {
        var lastTouch = {x: touch.clientX, y: touch.clientY};
        this.lastTouches.push(lastTouch);
        var lts = this.lastTouches;
        var removeLastTouch = function() {
            var i = lts.indexOf(lastTouch);
            if (i > -1) {
                lts.splice(i, 1);
            }
        };
        setTimeout(removeLastTouch, DEDUP_TIMEOUT);
    }
}

function isSyntheticEvent(eventData) {
    var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
    for (var i = 0; i < this.lastTouches.length; i++) {
        var t = this.lastTouches[i];
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
            return true;
        }
    }
    return false;
}

var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;

// magical touchAction value
var TOUCH_ACTION_COMPUTE = 'compute';
var TOUCH_ACTION_AUTO = 'auto';
var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
var TOUCH_ACTION_NONE = 'none';
var TOUCH_ACTION_PAN_X = 'pan-x';
var TOUCH_ACTION_PAN_Y = 'pan-y';
var TOUCH_ACTION_MAP = getTouchActionProps();

/**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
function TouchAction(manager, value) {
    this.manager = manager;
    this.set(value);
}

TouchAction.prototype = {
    /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
    set: function(value) {
        // find out the touch-action by the event handlers
        if (value == TOUCH_ACTION_COMPUTE) {
            value = this.compute();
        }

        if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
            this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
        }
        this.actions = value.toLowerCase().trim();
    },

    /**
     * just re-set the touchAction value
     */
    update: function() {
        this.set(this.manager.options.touchAction);
    },

    /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
    compute: function() {
        var actions = [];
        each(this.manager.recognizers, function(recognizer) {
            if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
            }
        });
        return cleanTouchActions(actions.join(' '));
    },

    /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
    preventDefaults: function(input) {
        var srcEvent = input.srcEvent;
        var direction = input.offsetDirection;

        // if the touch action did prevented once this session
        if (this.manager.session.prevented) {
            srcEvent.preventDefault();
            return;
        }

        var actions = this.actions;
        var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
        var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
        var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

        if (hasNone) {
            //do not prevent defaults if this is a tap gesture

            var isTapPointer = input.pointers.length === 1;
            var isTapMovement = input.distance < 2;
            var isTapTouchTime = input.deltaTime < 250;

            if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
            }
        }

        if (hasPanX && hasPanY) {
            // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
            return;
        }

        if (hasNone ||
            (hasPanY && direction & DIRECTION_HORIZONTAL) ||
            (hasPanX && direction & DIRECTION_VERTICAL)) {
            return this.preventSrc(srcEvent);
        }
    },

    /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
    preventSrc: function(srcEvent) {
        this.manager.session.prevented = true;
        srcEvent.preventDefault();
    }
};

/**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
function cleanTouchActions(actions) {
    // none
    if (inStr(actions, TOUCH_ACTION_NONE)) {
        return TOUCH_ACTION_NONE;
    }

    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);

    // if both pan-x and pan-y are set (different recognizers
    // for different directions, e.g. horizontal pan but vertical swipe?)
    // we need none (as otherwise with pan-x pan-y combined none of these
    // recognizers will work, since the browser would handle all panning
    if (hasPanX && hasPanY) {
        return TOUCH_ACTION_NONE;
    }

    // pan-x OR pan-y
    if (hasPanX || hasPanY) {
        return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
    }

    // manipulation
    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
        return TOUCH_ACTION_MANIPULATION;
    }

    return TOUCH_ACTION_AUTO;
}

function getTouchActionProps() {
    if (!NATIVE_TOUCH_ACTION) {
        return false;
    }
    var touchMap = {};
    var cssSupports = window.CSS && window.CSS.supports;
    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function(val) {

        // If css.supports is not supported but there is native touch-action assume it supports
        // all values. This is the case for IE 10 and 11.
        touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
    });
    return touchMap;
}

/**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
var STATE_POSSIBLE = 1;
var STATE_BEGAN = 2;
var STATE_CHANGED = 4;
var STATE_ENDED = 8;
var STATE_RECOGNIZED = STATE_ENDED;
var STATE_CANCELLED = 16;
var STATE_FAILED = 32;

/**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
function Recognizer(options) {
    this.options = assign({}, this.defaults, options || {});

    this.id = uniqueId();

    this.manager = null;

    // default is enable true
    this.options.enable = ifUndefined(this.options.enable, true);

    this.state = STATE_POSSIBLE;

    this.simultaneous = {};
    this.requireFail = [];
}

Recognizer.prototype = {
    /**
     * @virtual
     * @type {Object}
     */
    defaults: {},

    /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
    set: function(options) {
        assign(this.options, options);

        // also update the touchAction, in case something changed about the directions/enabled state
        this.manager && this.manager.touchAction.update();
        return this;
    },

    /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    recognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
            return this;
        }

        var simultaneous = this.simultaneous;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (!simultaneous[otherRecognizer.id]) {
            simultaneous[otherRecognizer.id] = otherRecognizer;
            otherRecognizer.recognizeWith(this);
        }
        return this;
    },

    /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRecognizeWith: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        delete this.simultaneous[otherRecognizer.id];
        return this;
    },

    /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    requireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
            return this;
        }

        var requireFail = this.requireFail;
        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        if (inArray(requireFail, otherRecognizer) === -1) {
            requireFail.push(otherRecognizer);
            otherRecognizer.requireFailure(this);
        }
        return this;
    },

    /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
    dropRequireFailure: function(otherRecognizer) {
        if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
            return this;
        }

        otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
        var index = inArray(this.requireFail, otherRecognizer);
        if (index > -1) {
            this.requireFail.splice(index, 1);
        }
        return this;
    },

    /**
     * has require failures boolean
     * @returns {boolean}
     */
    hasRequireFailures: function() {
        return this.requireFail.length > 0;
    },

    /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
    canRecognizeWith: function(otherRecognizer) {
        return !!this.simultaneous[otherRecognizer.id];
    },

    /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
    emit: function(input) {
        var self = this;
        var state = this.state;

        function emit(event) {
            self.manager.emit(event, input);
        }

        // 'panstart' and 'panmove'
        if (state < STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }

        emit(self.options.event); // simple 'eventName' events

        if (input.additionalEvent) { // additional event(panleft, panright, pinchin, pinchout...)
            emit(input.additionalEvent);
        }

        // panend and pancancel
        if (state >= STATE_ENDED) {
            emit(self.options.event + stateStr(state));
        }
    },

    /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
    tryEmit: function(input) {
        if (this.canEmit()) {
            return this.emit(input);
        }
        // it's failing anyway
        this.state = STATE_FAILED;
    },

    /**
     * can we emit?
     * @returns {boolean}
     */
    canEmit: function() {
        var i = 0;
        while (i < this.requireFail.length) {
            if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
            }
            i++;
        }
        return true;
    },

    /**
     * update the recognizer
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        // make a new copy of the inputData
        // so we can change the inputData without messing up the other recognizers
        var inputDataClone = assign({}, inputData);

        // is is enabled and allow recognizing?
        if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
            this.reset();
            this.state = STATE_FAILED;
            return;
        }

        // reset when we've reached the end
        if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
            this.state = STATE_POSSIBLE;
        }

        this.state = this.process(inputDataClone);

        // the recognizer has recognized a gesture
        // so trigger an event
        if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
            this.tryEmit(inputDataClone);
        }
    },

    /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
    process: function(inputData) { }, // jshint ignore:line

    /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
    getTouchAction: function() { },

    /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
    reset: function() { }
};

/**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
function stateStr(state) {
    if (state & STATE_CANCELLED) {
        return 'cancel';
    } else if (state & STATE_ENDED) {
        return 'end';
    } else if (state & STATE_CHANGED) {
        return 'move';
    } else if (state & STATE_BEGAN) {
        return 'start';
    }
    return '';
}

/**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
function directionStr(direction) {
    if (direction == DIRECTION_DOWN) {
        return 'down';
    } else if (direction == DIRECTION_UP) {
        return 'up';
    } else if (direction == DIRECTION_LEFT) {
        return 'left';
    } else if (direction == DIRECTION_RIGHT) {
        return 'right';
    }
    return '';
}

/**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
    var manager = recognizer.manager;
    if (manager) {
        return manager.get(otherRecognizer);
    }
    return otherRecognizer;
}

/**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
function AttrRecognizer() {
    Recognizer.apply(this, arguments);
}

inherit(AttrRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof AttrRecognizer
     */
    defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
    },

    /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
    attrTest: function(input) {
        var optionPointers = this.options.pointers;
        return optionPointers === 0 || input.pointers.length === optionPointers;
    },

    /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
    process: function(input) {
        var state = this.state;
        var eventType = input.eventType;

        var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
        var isValid = this.attrTest(input);

        // on cancel input and we've recognized before, return STATE_CANCELLED
        if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
            return state | STATE_CANCELLED;
        } else if (isRecognized || isValid) {
            if (eventType & INPUT_END) {
                return state | STATE_ENDED;
            } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
            }
            return state | STATE_CHANGED;
        }
        return STATE_FAILED;
    }
});

/**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function PanRecognizer() {
    AttrRecognizer.apply(this, arguments);

    this.pX = null;
    this.pY = null;
}

inherit(PanRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PanRecognizer
     */
    defaults: {
        event: 'pan',
        threshold: 10,
        pointers: 1,
        direction: DIRECTION_ALL
    },

    getTouchAction: function() {
        var direction = this.options.direction;
        var actions = [];
        if (direction & DIRECTION_HORIZONTAL) {
            actions.push(TOUCH_ACTION_PAN_Y);
        }
        if (direction & DIRECTION_VERTICAL) {
            actions.push(TOUCH_ACTION_PAN_X);
        }
        return actions;
    },

    directionTest: function(input) {
        var options = this.options;
        var hasMoved = true;
        var distance = input.distance;
        var direction = input.direction;
        var x = input.deltaX;
        var y = input.deltaY;

        // lock to axis?
        if (!(direction & options.direction)) {
            if (options.direction & DIRECTION_HORIZONTAL) {
                direction = (x === 0) ? DIRECTION_NONE : (x < 0) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
            } else {
                direction = (y === 0) ? DIRECTION_NONE : (y < 0) ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
            }
        }
        input.direction = direction;
        return hasMoved && distance > options.threshold && direction & options.direction;
    },

    attrTest: function(input) {
        return AttrRecognizer.prototype.attrTest.call(this, input) &&
            (this.state & STATE_BEGAN || (!(this.state & STATE_BEGAN) && this.directionTest(input)));
    },

    emit: function(input) {

        this.pX = input.deltaX;
        this.pY = input.deltaY;

        var direction = directionStr(input.direction);

        if (direction) {
            input.additionalEvent = this.options.event + direction;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
function PinchRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(PinchRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'pinch',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
    },

    emit: function(input) {
        if (input.scale !== 1) {
            var inOut = input.scale < 1 ? 'in' : 'out';
            input.additionalEvent = this.options.event + inOut;
        }
        this._super.emit.call(this, input);
    }
});

/**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
function PressRecognizer() {
    Recognizer.apply(this, arguments);

    this._timer = null;
    this._input = null;
}

inherit(PressRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PressRecognizer
     */
    defaults: {
        event: 'press',
        pointers: 1,
        time: 251, // minimal time of the pointer to be pressed
        threshold: 9 // a minimal movement is ok, but keep it low
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_AUTO];
    },

    process: function(input) {
        var options = this.options;
        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTime = input.deltaTime > options.time;

        this._input = input;

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (!validMovement || !validPointers || (input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime)) {
            this.reset();
        } else if (input.eventType & INPUT_START) {
            this.reset();
            this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
            }, options.time, this);
        } else if (input.eventType & INPUT_END) {
            return STATE_RECOGNIZED;
        }
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function(input) {
        if (this.state !== STATE_RECOGNIZED) {
            return;
        }

        if (input && (input.eventType & INPUT_END)) {
            this.manager.emit(this.options.event + 'up', input);
        } else {
            this._input.timeStamp = now();
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
function RotateRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(RotateRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof RotateRecognizer
     */
    defaults: {
        event: 'rotate',
        threshold: 0,
        pointers: 2
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_NONE];
    },

    attrTest: function(input) {
        return this._super.attrTest.call(this, input) &&
            (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
    }
});

/**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
function SwipeRecognizer() {
    AttrRecognizer.apply(this, arguments);
}

inherit(SwipeRecognizer, AttrRecognizer, {
    /**
     * @namespace
     * @memberof SwipeRecognizer
     */
    defaults: {
        event: 'swipe',
        threshold: 10,
        velocity: 0.3,
        direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
        pointers: 1
    },

    getTouchAction: function() {
        return PanRecognizer.prototype.getTouchAction.call(this);
    },

    attrTest: function(input) {
        var direction = this.options.direction;
        var velocity;

        if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
            velocity = input.overallVelocity;
        } else if (direction & DIRECTION_HORIZONTAL) {
            velocity = input.overallVelocityX;
        } else if (direction & DIRECTION_VERTICAL) {
            velocity = input.overallVelocityY;
        }

        return this._super.attrTest.call(this, input) &&
            direction & input.offsetDirection &&
            input.distance > this.options.threshold &&
            input.maxPointers == this.options.pointers &&
            abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
    },

    emit: function(input) {
        var direction = directionStr(input.offsetDirection);
        if (direction) {
            this.manager.emit(this.options.event + direction, input);
        }

        this.manager.emit(this.options.event, input);
    }
});

/**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
function TapRecognizer() {
    Recognizer.apply(this, arguments);

    // previous time and center,
    // used for tap counting
    this.pTime = false;
    this.pCenter = false;

    this._timer = null;
    this._input = null;
    this.count = 0;
}

inherit(TapRecognizer, Recognizer, {
    /**
     * @namespace
     * @memberof PinchRecognizer
     */
    defaults: {
        event: 'tap',
        pointers: 1,
        taps: 1,
        interval: 300, // max time between the multi-tap taps
        time: 250, // max time of the pointer to be down (like finger on the screen)
        threshold: 9, // a minimal movement is ok, but keep it low
        posThreshold: 10 // a multi-tap can be a bit off the initial position
    },

    getTouchAction: function() {
        return [TOUCH_ACTION_MANIPULATION];
    },

    process: function(input) {
        var options = this.options;

        var validPointers = input.pointers.length === options.pointers;
        var validMovement = input.distance < options.threshold;
        var validTouchTime = input.deltaTime < options.time;

        this.reset();

        if ((input.eventType & INPUT_START) && (this.count === 0)) {
            return this.failTimeout();
        }

        // we only allow little movement
        // and we've reached an end event, so a tap is possible
        if (validMovement && validTouchTime && validPointers) {
            if (input.eventType != INPUT_END) {
                return this.failTimeout();
            }

            var validInterval = this.pTime ? (input.timeStamp - this.pTime < options.interval) : true;
            var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;

            this.pTime = input.timeStamp;
            this.pCenter = input.center;

            if (!validMultiTap || !validInterval) {
                this.count = 1;
            } else {
                this.count += 1;
            }

            this._input = input;

            // if tap count matches we have recognized it,
            // else it has began recognizing...
            var tapCount = this.count % options.taps;
            if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                    return STATE_RECOGNIZED;
                } else {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED;
                        this.tryEmit();
                    }, options.interval, this);
                    return STATE_BEGAN;
                }
            }
        }
        return STATE_FAILED;
    },

    failTimeout: function() {
        this._timer = setTimeoutContext(function() {
            this.state = STATE_FAILED;
        }, this.options.interval, this);
        return STATE_FAILED;
    },

    reset: function() {
        clearTimeout(this._timer);
    },

    emit: function() {
        if (this.state == STATE_RECOGNIZED) {
            this._input.tapCount = this.count;
            this.manager.emit(this.options.event, this._input);
        }
    }
});

/**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Hammer(element, options) {
    options = options || {};
    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
    return new Manager(element, options);
}

/**
 * @const {string}
 */
Hammer.VERSION = '2.0.7';

/**
 * default settings
 * @namespace
 */
Hammer.defaults = {
    /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
    domEvents: false,

    /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
    touchAction: TOUCH_ACTION_COMPUTE,

    /**
     * @type {Boolean}
     * @default true
     */
    enable: true,

    /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
    inputTarget: null,

    /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
    inputClass: null,

    /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
    preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [RotateRecognizer, {enable: false}],
        [PinchRecognizer, {enable: false}, ['rotate']],
        [SwipeRecognizer, {direction: DIRECTION_HORIZONTAL}],
        [PanRecognizer, {direction: DIRECTION_HORIZONTAL}, ['swipe']],
        [TapRecognizer],
        [TapRecognizer, {event: 'doubletap', taps: 2}, ['tap']],
        [PressRecognizer]
    ],

    /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
    cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: 'none',

        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: 'none',

        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: 'none',

        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: 'none',

        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: 'none',

        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: 'rgba(0,0,0,0)'
    }
};

var STOP = 1;
var FORCED_STOP = 2;

/**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
function Manager(element, options) {
    this.options = assign({}, Hammer.defaults, options || {});

    this.options.inputTarget = this.options.inputTarget || element;

    this.handlers = {};
    this.session = {};
    this.recognizers = [];
    this.oldCssProps = {};

    this.element = element;
    this.input = createInputInstance(this);
    this.touchAction = new TouchAction(this, this.options.touchAction);

    toggleCssProps(this, true);

    each(this.options.recognizers, function(item) {
        var recognizer = this.add(new (item[0])(item[1]));
        item[2] && recognizer.recognizeWith(item[2]);
        item[3] && recognizer.requireFailure(item[3]);
    }, this);
}

Manager.prototype = {
    /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
    set: function(options) {
        assign(this.options, options);

        // Options that need a little more setup
        if (options.touchAction) {
            this.touchAction.update();
        }
        if (options.inputTarget) {
            // Clean up existing event listeners and reinitialize
            this.input.destroy();
            this.input.target = options.inputTarget;
            this.input.init();
        }
        return this;
    },

    /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
    stop: function(force) {
        this.session.stopped = force ? FORCED_STOP : STOP;
    },

    /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
    recognize: function(inputData) {
        var session = this.session;
        if (session.stopped) {
            return;
        }

        // run the touch-action polyfill
        this.touchAction.preventDefaults(inputData);

        var recognizer;
        var recognizers = this.recognizers;

        // this holds the recognizer that is being recognized.
        // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
        // if no recognizer is detecting a thing, it is set to `null`
        var curRecognizer = session.curRecognizer;

        // reset when the last recognizer is recognized
        // or when we're in a new session
        if (!curRecognizer || (curRecognizer && curRecognizer.state & STATE_RECOGNIZED)) {
            curRecognizer = session.curRecognizer = null;
        }

        var i = 0;
        while (i < recognizers.length) {
            recognizer = recognizers[i];

            // find out if we are allowed try to recognize the input for this one.
            // 1.   allow if the session is NOT forced stopped (see the .stop() method)
            // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
            //      that is being recognized.
            // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
            //      this can be setup with the `recognizeWith()` method on the recognizer.
            if (session.stopped !== FORCED_STOP && ( // 1
                    !curRecognizer || recognizer == curRecognizer || // 2
                    recognizer.canRecognizeWith(curRecognizer))) { // 3
                recognizer.recognize(inputData);
            } else {
                recognizer.reset();
            }

            // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
            // current active recognizer. but only if we don't already have an active recognizer
            if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
            }
            i++;
        }
    },

    /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
    get: function(recognizer) {
        if (recognizer instanceof Recognizer) {
            return recognizer;
        }

        var recognizers = this.recognizers;
        for (var i = 0; i < recognizers.length; i++) {
            if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
            }
        }
        return null;
    },

    /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
    add: function(recognizer) {
        if (invokeArrayArg(recognizer, 'add', this)) {
            return this;
        }

        // remove existing
        var existing = this.get(recognizer.options.event);
        if (existing) {
            this.remove(existing);
        }

        this.recognizers.push(recognizer);
        recognizer.manager = this;

        this.touchAction.update();
        return recognizer;
    },

    /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
    remove: function(recognizer) {
        if (invokeArrayArg(recognizer, 'remove', this)) {
            return this;
        }

        recognizer = this.get(recognizer);

        // let's make sure this recognizer exists
        if (recognizer) {
            var recognizers = this.recognizers;
            var index = inArray(recognizers, recognizer);

            if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
            }
        }

        return this;
    },

    /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
    on: function(events, handler) {
        if (events === undefined) {
            return;
        }
        if (handler === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            handlers[event] = handlers[event] || [];
            handlers[event].push(handler);
        });
        return this;
    },

    /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
    off: function(events, handler) {
        if (events === undefined) {
            return;
        }

        var handlers = this.handlers;
        each(splitStr(events), function(event) {
            if (!handler) {
                delete handlers[event];
            } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
            }
        });
        return this;
    },

    /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
    emit: function(event, data) {
        // we also want to trigger dom events
        if (this.options.domEvents) {
            triggerDomEvent(event, data);
        }

        // no handlers, so skip it all
        var handlers = this.handlers[event] && this.handlers[event].slice();
        if (!handlers || !handlers.length) {
            return;
        }

        data.type = event;
        data.preventDefault = function() {
            data.srcEvent.preventDefault();
        };

        var i = 0;
        while (i < handlers.length) {
            handlers[i](data);
            i++;
        }
    },

    /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
    destroy: function() {
        this.element && toggleCssProps(this, false);

        this.handlers = {};
        this.session = {};
        this.input.destroy();
        this.element = null;
    }
};

/**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
function toggleCssProps(manager, add) {
    var element = manager.element;
    if (!element.style) {
        return;
    }
    var prop;
    each(manager.options.cssProps, function(value, name) {
        prop = prefixed(element.style, name);
        if (add) {
            manager.oldCssProps[prop] = element.style[prop];
            element.style[prop] = value;
        } else {
            element.style[prop] = manager.oldCssProps[prop] || '';
        }
    });
    if (!add) {
        manager.oldCssProps = {};
    }
}

/**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
function triggerDomEvent(event, data) {
    var gestureEvent = document.createEvent('Event');
    gestureEvent.initEvent(event, true, true);
    gestureEvent.gesture = data;
    data.target.dispatchEvent(gestureEvent);
}

assign(Hammer, {
    INPUT_START: INPUT_START,
    INPUT_MOVE: INPUT_MOVE,
    INPUT_END: INPUT_END,
    INPUT_CANCEL: INPUT_CANCEL,

    STATE_POSSIBLE: STATE_POSSIBLE,
    STATE_BEGAN: STATE_BEGAN,
    STATE_CHANGED: STATE_CHANGED,
    STATE_ENDED: STATE_ENDED,
    STATE_RECOGNIZED: STATE_RECOGNIZED,
    STATE_CANCELLED: STATE_CANCELLED,
    STATE_FAILED: STATE_FAILED,

    DIRECTION_NONE: DIRECTION_NONE,
    DIRECTION_LEFT: DIRECTION_LEFT,
    DIRECTION_RIGHT: DIRECTION_RIGHT,
    DIRECTION_UP: DIRECTION_UP,
    DIRECTION_DOWN: DIRECTION_DOWN,
    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
    DIRECTION_VERTICAL: DIRECTION_VERTICAL,
    DIRECTION_ALL: DIRECTION_ALL,

    Manager: Manager,
    Input: Input,
    TouchAction: TouchAction,

    TouchInput: TouchInput,
    MouseInput: MouseInput,
    PointerEventInput: PointerEventInput,
    TouchMouseInput: TouchMouseInput,
    SingleTouchInput: SingleTouchInput,

    Recognizer: Recognizer,
    AttrRecognizer: AttrRecognizer,
    Tap: TapRecognizer,
    Pan: PanRecognizer,
    Swipe: SwipeRecognizer,
    Pinch: PinchRecognizer,
    Rotate: RotateRecognizer,
    Press: PressRecognizer,

    on: addEventListeners,
    off: removeEventListeners,
    each: each,
    merge: merge,
    extend: extend,
    assign: assign,
    inherit: inherit,
    bindFn: bindFn,
    prefixed: prefixed
});

return Hammer;

})(window, document, 'Hammer');

});

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.4
 *
 * Requires: 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('jquery.mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'];
    var lowestDelta, lowestDeltaXY;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    $.event.special.mousewheel = {
        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = [].slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            absDeltaXY = 0,
            fn;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta; }
        if ( orgEvent.detail )     { delta = orgEvent.detail * -1; }

        // At a minimum, setup the deltaY to be delta
        deltaY = delta;

        // Firefox < 17 related to DOMMouseScroll event
        if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaY = 0;
            deltaX = delta * -1;
        }

        // New school wheel delta (wheel event)
        if ( orgEvent.deltaY ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( orgEvent.deltaX ) {
            deltaX = orgEvent.deltaX;
            delta  = deltaX * -1;
        }

        // Webkit
        if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY; }
        if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Look for lowest delta to normalize the delta values
        absDelta = Math.abs(delta);
        if ( !lowestDelta || absDelta < lowestDelta ) { lowestDelta = absDelta; }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if ( !lowestDeltaXY || absDeltaXY < lowestDeltaXY ) { lowestDeltaXY = absDeltaXY; }

        // Get a whole value for the deltas
        fn     = delta > 0 ? 'floor' : 'ceil';
        delta  = Math[fn](delta  / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

}));

/*! Hammer.JS - v1.0.5 - 2013-04-07
 * http://eightmedia.github.com/hammer.js
 *
 * Copyright (c) 2013 Jorik Tangelder <j.tangelder@gmail.com>;
 * Licensed under the MIT license */

(function(t,e){"use strict";function n(){if(!i.READY){i.event.determineEventTypes();for(var t in i.gestures)i.gestures.hasOwnProperty(t)&&i.detection.register(i.gestures[t]);i.event.onTouch(i.DOCUMENT,i.EVENT_MOVE,i.detection.detect),i.event.onTouch(i.DOCUMENT,i.EVENT_END,i.detection.detect),i.READY=!0}}var i=function(t,e){return new i.Instance(t,e||{})};i.defaults={stop_browser_behavior:{userSelect:"none",touchAction:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}},i.HAS_POINTEREVENTS=navigator.pointerEnabled||navigator.msPointerEnabled,i.HAS_TOUCHEVENTS="ontouchstart"in t,i.MOBILE_REGEX=/mobile|tablet|ip(ad|hone|od)|android/i,i.NO_MOUSEEVENTS=i.HAS_TOUCHEVENTS&&navigator.userAgent.match(i.MOBILE_REGEX),i.EVENT_TYPES={},i.DIRECTION_DOWN="down",i.DIRECTION_LEFT="left",i.DIRECTION_UP="up",i.DIRECTION_RIGHT="right",i.POINTER_MOUSE="mouse",i.POINTER_TOUCH="touch",i.POINTER_PEN="pen",i.EVENT_START="start",i.EVENT_MOVE="move",i.EVENT_END="end",i.DOCUMENT=document,i.plugins={},i.READY=!1,i.Instance=function(t,e){var r=this;return n(),this.element=t,this.enabled=!0,this.options=i.utils.extend(i.utils.extend({},i.defaults),e||{}),this.options.stop_browser_behavior&&i.utils.stopDefaultBrowserBehavior(this.element,this.options.stop_browser_behavior),i.event.onTouch(t,i.EVENT_START,function(t){r.enabled&&i.detection.startDetect(r,t)}),this},i.Instance.prototype={on:function(t,e){for(var n=t.split(" "),i=0;n.length>i;i++)this.element.addEventListener(n[i],e,!1);return this},off:function(t,e){for(var n=t.split(" "),i=0;n.length>i;i++)this.element.removeEventListener(n[i],e,!1);return this},trigger:function(t,e){var n=i.DOCUMENT.createEvent("Event");n.initEvent(t,!0,!0),n.gesture=e;var r=this.element;return i.utils.hasParent(e.target,r)&&(r=e.target),r.dispatchEvent(n),this},enable:function(t){return this.enabled=t,this}};var r=null,o=!1,s=!1;i.event={bindDom:function(t,e,n){for(var i=e.split(" "),r=0;i.length>r;r++)t.addEventListener(i[r],n,!1)},onTouch:function(t,e,n){var a=this;this.bindDom(t,i.EVENT_TYPES[e],function(c){var u=c.type.toLowerCase();if(!u.match(/mouse/)||!s){(u.match(/touch/)||u.match(/pointerdown/)||u.match(/mouse/)&&1===c.which)&&(o=!0),u.match(/touch|pointer/)&&(s=!0);var h=0;o&&(i.HAS_POINTEREVENTS&&e!=i.EVENT_END?h=i.PointerEvent.updatePointer(e,c):u.match(/touch/)?h=c.touches.length:s||(h=u.match(/up/)?0:1),h>0&&e==i.EVENT_END?e=i.EVENT_MOVE:h||(e=i.EVENT_END),h||null===r?r=c:c=r,n.call(i.detection,a.collectEventData(t,e,c)),i.HAS_POINTEREVENTS&&e==i.EVENT_END&&(h=i.PointerEvent.updatePointer(e,c))),h||(r=null,o=!1,s=!1,i.PointerEvent.reset())}})},determineEventTypes:function(){var t;t=i.HAS_POINTEREVENTS?i.PointerEvent.getEvents():i.NO_MOUSEEVENTS?["touchstart","touchmove","touchend touchcancel"]:["touchstart mousedown","touchmove mousemove","touchend touchcancel mouseup"],i.EVENT_TYPES[i.EVENT_START]=t[0],i.EVENT_TYPES[i.EVENT_MOVE]=t[1],i.EVENT_TYPES[i.EVENT_END]=t[2]},getTouchList:function(t){return i.HAS_POINTEREVENTS?i.PointerEvent.getTouchList():t.touches?t.touches:[{identifier:1,pageX:t.pageX,pageY:t.pageY,target:t.target}]},collectEventData:function(t,e,n){var r=this.getTouchList(n,e),o=i.POINTER_TOUCH;return(n.type.match(/mouse/)||i.PointerEvent.matchType(i.POINTER_MOUSE,n))&&(o=i.POINTER_MOUSE),{center:i.utils.getCenter(r),timeStamp:(new Date).getTime(),target:n.target,touches:r,eventType:e,pointerType:o,srcEvent:n,preventDefault:function(){this.srcEvent.preventManipulation&&this.srcEvent.preventManipulation(),this.srcEvent.preventDefault&&this.srcEvent.preventDefault()},stopPropagation:function(){this.srcEvent.stopPropagation()},stopDetect:function(){return i.detection.stopDetect()}}}},i.PointerEvent={pointers:{},getTouchList:function(){var t=this,e=[];return Object.keys(t.pointers).sort().forEach(function(n){e.push(t.pointers[n])}),e},updatePointer:function(t,e){return t==i.EVENT_END?this.pointers={}:(e.identifier=e.pointerId,this.pointers[e.pointerId]=e),Object.keys(this.pointers).length},matchType:function(t,e){if(!e.pointerType)return!1;var n={};return n[i.POINTER_MOUSE]=e.pointerType==e.MSPOINTER_TYPE_MOUSE||e.pointerType==i.POINTER_MOUSE,n[i.POINTER_TOUCH]=e.pointerType==e.MSPOINTER_TYPE_TOUCH||e.pointerType==i.POINTER_TOUCH,n[i.POINTER_PEN]=e.pointerType==e.MSPOINTER_TYPE_PEN||e.pointerType==i.POINTER_PEN,n[t]},getEvents:function(){return["pointerdown MSPointerDown","pointermove MSPointerMove","pointerup pointercancel MSPointerUp MSPointerCancel"]},reset:function(){this.pointers={}}},i.utils={extend:function(t,n,i){for(var r in n)t[r]!==e&&i||(t[r]=n[r]);return t},hasParent:function(t,e){for(;t;){if(t==e)return!0;t=t.parentNode}return!1},getCenter:function(t){for(var e=[],n=[],i=0,r=t.length;r>i;i++)e.push(t[i].pageX),n.push(t[i].pageY);return{pageX:(Math.min.apply(Math,e)+Math.max.apply(Math,e))/2,pageY:(Math.min.apply(Math,n)+Math.max.apply(Math,n))/2}},getVelocity:function(t,e,n){return{x:Math.abs(e/t)||0,y:Math.abs(n/t)||0}},getAngle:function(t,e){var n=e.pageY-t.pageY,i=e.pageX-t.pageX;return 180*Math.atan2(n,i)/Math.PI},getDirection:function(t,e){var n=Math.abs(t.pageX-e.pageX),r=Math.abs(t.pageY-e.pageY);return n>=r?t.pageX-e.pageX>0?i.DIRECTION_LEFT:i.DIRECTION_RIGHT:t.pageY-e.pageY>0?i.DIRECTION_UP:i.DIRECTION_DOWN},getDistance:function(t,e){var n=e.pageX-t.pageX,i=e.pageY-t.pageY;return Math.sqrt(n*n+i*i)},getScale:function(t,e){return t.length>=2&&e.length>=2?this.getDistance(e[0],e[1])/this.getDistance(t[0],t[1]):1},getRotation:function(t,e){return t.length>=2&&e.length>=2?this.getAngle(e[1],e[0])-this.getAngle(t[1],t[0]):0},isVertical:function(t){return t==i.DIRECTION_UP||t==i.DIRECTION_DOWN},stopDefaultBrowserBehavior:function(t,e){var n,i=["webkit","khtml","moz","ms","o",""];if(e&&t.style){for(var r=0;i.length>r;r++)for(var o in e)e.hasOwnProperty(o)&&(n=o,i[r]&&(n=i[r]+n.substring(0,1).toUpperCase()+n.substring(1)),t.style[n]=e[o]);"none"==e.userSelect&&(t.onselectstart=function(){return!1})}}},i.detection={gestures:[],current:null,previous:null,stopped:!1,startDetect:function(t,e){this.current||(this.stopped=!1,this.current={inst:t,startEvent:i.utils.extend({},e),lastEvent:!1,name:""},this.detect(e))},detect:function(t){if(this.current&&!this.stopped){t=this.extendEventData(t);for(var e=this.current.inst.options,n=0,r=this.gestures.length;r>n;n++){var o=this.gestures[n];if(!this.stopped&&e[o.name]!==!1&&o.handler.call(o,t,this.current.inst)===!1){this.stopDetect();break}}return this.current&&(this.current.lastEvent=t),t.eventType==i.EVENT_END&&!t.touches.length-1&&this.stopDetect(),t}},stopDetect:function(){this.previous=i.utils.extend({},this.current),this.current=null,this.stopped=!0},extendEventData:function(t){var e=this.current.startEvent;if(e&&(t.touches.length!=e.touches.length||t.touches===e.touches)){e.touches=[];for(var n=0,r=t.touches.length;r>n;n++)e.touches.push(i.utils.extend({},t.touches[n]))}var o=t.timeStamp-e.timeStamp,s=t.center.pageX-e.center.pageX,a=t.center.pageY-e.center.pageY,c=i.utils.getVelocity(o,s,a);return i.utils.extend(t,{deltaTime:o,deltaX:s,deltaY:a,velocityX:c.x,velocityY:c.y,distance:i.utils.getDistance(e.center,t.center),angle:i.utils.getAngle(e.center,t.center),direction:i.utils.getDirection(e.center,t.center),scale:i.utils.getScale(e.touches,t.touches),rotation:i.utils.getRotation(e.touches,t.touches),startEvent:e}),t},register:function(t){var n=t.defaults||{};return n[t.name]===e&&(n[t.name]=!0),i.utils.extend(i.defaults,n,!0),t.index=t.index||1e3,this.gestures.push(t),this.gestures.sort(function(t,e){return t.index<e.index?-1:t.index>e.index?1:0}),this.gestures}},i.gestures=i.gestures||{},i.gestures.Hold={name:"hold",index:10,defaults:{hold_timeout:500,hold_threshold:1},timer:null,handler:function(t,e){switch(t.eventType){case i.EVENT_START:clearTimeout(this.timer),i.detection.current.name=this.name,this.timer=setTimeout(function(){"hold"==i.detection.current.name&&e.trigger("hold",t)},e.options.hold_timeout);break;case i.EVENT_MOVE:t.distance>e.options.hold_threshold&&clearTimeout(this.timer);break;case i.EVENT_END:clearTimeout(this.timer)}}},i.gestures.Tap={name:"tap",index:100,defaults:{tap_max_touchtime:250,tap_max_distance:10,tap_always:!0,doubletap_distance:20,doubletap_interval:300},handler:function(t,e){if(t.eventType==i.EVENT_END){var n=i.detection.previous,r=!1;if(t.deltaTime>e.options.tap_max_touchtime||t.distance>e.options.tap_max_distance)return;n&&"tap"==n.name&&t.timeStamp-n.lastEvent.timeStamp<e.options.doubletap_interval&&t.distance<e.options.doubletap_distance&&(e.trigger("doubletap",t),r=!0),(!r||e.options.tap_always)&&(i.detection.current.name="tap",e.trigger(i.detection.current.name,t))}}},i.gestures.Swipe={name:"swipe",index:40,defaults:{swipe_max_touches:1,swipe_velocity:.7},handler:function(t,e){if(t.eventType==i.EVENT_END){if(e.options.swipe_max_touches>0&&t.touches.length>e.options.swipe_max_touches)return;(t.velocityX>e.options.swipe_velocity||t.velocityY>e.options.swipe_velocity)&&(e.trigger(this.name,t),e.trigger(this.name+t.direction,t))}}},i.gestures.Drag={name:"drag",index:50,defaults:{drag_min_distance:10,drag_max_touches:1,drag_block_horizontal:!1,drag_block_vertical:!1,drag_lock_to_axis:!1,drag_lock_min_distance:25},triggered:!1,handler:function(t,n){if(i.detection.current.name!=this.name&&this.triggered)return n.trigger(this.name+"end",t),this.triggered=!1,e;if(!(n.options.drag_max_touches>0&&t.touches.length>n.options.drag_max_touches))switch(t.eventType){case i.EVENT_START:this.triggered=!1;break;case i.EVENT_MOVE:if(t.distance<n.options.drag_min_distance&&i.detection.current.name!=this.name)return;i.detection.current.name=this.name,(i.detection.current.lastEvent.drag_locked_to_axis||n.options.drag_lock_to_axis&&n.options.drag_lock_min_distance<=t.distance)&&(t.drag_locked_to_axis=!0);var r=i.detection.current.lastEvent.direction;t.drag_locked_to_axis&&r!==t.direction&&(t.direction=i.utils.isVertical(r)?0>t.deltaY?i.DIRECTION_UP:i.DIRECTION_DOWN:0>t.deltaX?i.DIRECTION_LEFT:i.DIRECTION_RIGHT),this.triggered||(n.trigger(this.name+"start",t),this.triggered=!0),n.trigger(this.name,t),n.trigger(this.name+t.direction,t),(n.options.drag_block_vertical&&i.utils.isVertical(t.direction)||n.options.drag_block_horizontal&&!i.utils.isVertical(t.direction))&&t.preventDefault();break;case i.EVENT_END:this.triggered&&n.trigger(this.name+"end",t),this.triggered=!1}}},i.gestures.Transform={name:"transform",index:45,defaults:{transform_min_scale:.01,transform_min_rotation:1,transform_always_block:!1},triggered:!1,handler:function(t,n){if(i.detection.current.name!=this.name&&this.triggered)return n.trigger(this.name+"end",t),this.triggered=!1,e;if(!(2>t.touches.length))switch(n.options.transform_always_block&&t.preventDefault(),t.eventType){case i.EVENT_START:this.triggered=!1;break;case i.EVENT_MOVE:var r=Math.abs(1-t.scale),o=Math.abs(t.rotation);if(n.options.transform_min_scale>r&&n.options.transform_min_rotation>o)return;i.detection.current.name=this.name,this.triggered||(n.trigger(this.name+"start",t),this.triggered=!0),n.trigger(this.name,t),o>n.options.transform_min_rotation&&n.trigger("rotate",t),r>n.options.transform_min_scale&&(n.trigger("pinch",t),n.trigger("pinch"+(1>t.scale?"in":"out"),t));break;case i.EVENT_END:this.triggered&&n.trigger(this.name+"end",t),this.triggered=!1}}},i.gestures.Touch={name:"touch",index:-1/0,defaults:{prevent_default:!1,prevent_mouseevents:!1},handler:function(t,n){return n.options.prevent_mouseevents&&t.pointerType==i.POINTER_MOUSE?(t.stopDetect(),e):(n.options.prevent_default&&t.preventDefault(),t.eventType==i.EVENT_START&&n.trigger(this.name,t),e)}},i.gestures.Release={name:"release",index:1/0,handler:function(t,e){t.eventType==i.EVENT_END&&e.trigger(this.name,t)}},"object"==typeof module&&"object"==typeof module.exports?module.exports=i:(t.Hammer=i,"function"==typeof t.define&&t.define.amd&&t.define("hammer",[],function(){return i}))})(this),function(t,e){"use strict";t!==e&&(Hammer.event.bindDom=function(n,i,r){t(n).on(i,function(t){var n=t.originalEvent||t;n.pageX===e&&(n.pageX=t.pageX,n.pageY=t.pageY),n.target||(n.target=t.target),n.which===e&&(n.which=n.button),n.preventDefault||(n.preventDefault=t.preventDefault),n.stopPropagation||(n.stopPropagation=t.stopPropagation),r.call(this,n)})},Hammer.Instance.prototype.on=function(e,n){return t(this.element).on(e,n)},Hammer.Instance.prototype.off=function(e,n){return t(this.element).off(e,n)},Hammer.Instance.prototype.trigger=function(e,n){var i=t(this.element);return i.has(n.target).length&&(i=t(n.target)),i.trigger({type:e,gesture:n})},t.fn.hammer=function(e){return this.each(function(){var n=t(this),i=n.data("hammer");i?i&&e&&Hammer.utils.extend(i.options,e):n.data("hammer",new Hammer(this,e||{}))})})}(window.jQuery||window.Zepto);
define("jquery.hammer", ["jquery"], function(){});

define('interactions',['config', 'events', 'shared/hammerManager', 'shared/utils/utils',
        'hammer2', 'jquery', 'jquery.mousewheel', 'jquery.hammer'],
    function(config, events, hammerManager, sharedUtils,
             hammer, $) {

        //key values
        var KEY_LEFT = 37;
        var KEY_UP = 38;
        var KEY_RIGHT = 39;
        var KEY_DOWN = 40;
        var KEY_ESCAPE = 27;
        var KEY_RETURN = 13;
        var KEY_SPACEBAR = 32;
        var allowKeyNavigation = true;

        var EMITTER_NAME = "interaction";

        var reader;
        var element;
        var hammerContext;
        var blockingDefaultTransforms = true;

        var isPinching = false;
        var zoomed = false;

        /**
         * Performs any pre-initialisation steps
         * Necessary because interactions initialisation occurs late, but we may still need to listen for state changes
         */
        var preinit = function() {
            hammerManager.setupLibraries(hammer);
            events.subscribe(events.ALL, events.BROWSER_ZOOM_LEVEL_CHANGED, handleBrowserZoomStateChange, true);
        };

        var canDragPage = function(event) {
            if (isPinching) {
                return false;
            }
            if (event.nativeEvent.touches && event.nativeEvent.touches.length > 1) {
                return false;
            }
            if (event.nativeEvent.pointerId && !event.nativeEvent.isPrimary) {
                return false;
            }
            return true;
        };

        /**
         * Handles double tap events.
         */
        var doubleTapHandler = function(event) {

            var direction;

            if(zoomed) {
                direction = -1;
                zoomed = false;
            } else {
                direction = 1;
                zoomed = true;
            }
            events.emit(EMITTER_NAME, events.ZOOM, this, {"direction": direction, "x": event.srcEvent.pageX * config.pixelDensity, "y": event.srcEvent.pageY * config.pixelDensity});
        };

        /**
         * Handles pinch events. Both pinch in and out are handled here.
         * @param event the event from Hammer.js with the data about the pinch.
         */
        var pinchHandler = function(event) {
            if (!blockingDefaultTransforms) { return; }
            isPinching = true;
            events.emit(EMITTER_NAME, events.ZOOM_SCALE, this,
                    {"scale": event.scale, "x": event.center.x * config.pixelDensity, "y": event.center.y * config.pixelDensity});
        };

        /**
         * Handles any touch end event by calculating the zoom direction and then emitting a zoom event.
         */
        var release = function(event) {
            if (isPinching) {
                events.emit(EMITTER_NAME, events.ZOOM_SCALE, this, {"end": true, "x": event.gesture.center.pageX * config.pixelDensity, "y": event.gesture.center.pageY * config.pixelDensity});
            }
            isPinching = false;
            dragEnd(event);
        };

        var dragStart = function(event) {
            event.gesture.preventDefault();
            element.css("z-index", "50000");
            element.off("mousemove");
            events.emit(EMITTER_NAME, events.DRAG_START, this, event.gesture);
        };

        var drag = function(event) {
            event.gesture.preventDefault();
            events.emit(EMITTER_NAME, events.DRAG, this, event.gesture);
        };

        var dragEnd = function(event) {
            event.gesture.preventDefault();
            element.css("z-index", "");
            if (reader.mouseOverEnabled) {
                events.yuduOn(element, "mousemove", events.callback(reader, reader.fadeInOrOutOverlayIfNecessary));
            }
            events.emit(EMITTER_NAME, events.DRAG_END, this, event.gesture);
        };

        var tap = function(event) {
            if (!event.srcEvent.pageX && !event.srcEvent.pageY && event.center.x && event.center.y) {
                var newEvent = Object.assign({}, event.srcEvent);
                newEvent.pageX = event.center.x;
                newEvent.pageY = event.center.y;
                events.emit(EMITTER_NAME, events.TAP, this, newEvent);
                return;
            }

            events.emit(EMITTER_NAME, events.TAP, this, event.srcEvent);
        };

        var touch = function(event) {
            events.emit(EMITTER_NAME, events.TOUCH, this, event.gesture);
        };

        /**
         * Handles mouse wheel events.
         * @param event the mousewheel event.
         * @param delta the direction and magnitude of the zoom.
         */
        var mouseWheelHandler = function(event, delta) {
            event.preventDefault();
            event.stopImmediatePropagation();
            events.emit(EMITTER_NAME, events.ZOOM, this, {"direction": delta, "x": event.pageX * config.pixelDensity, "y": event.pageY * config.pixelDensity});
        };

        /**
         * Responds to key presses.
         * @param event the keyboard event
         */
        var keyPress = function(event) {
            if (event.which == KEY_ESCAPE) {
                events.emit(EMITTER_NAME, events.CLOSE_ACTIVE, this, {});
            }

            if (!allowKeyNavigation)
                return;

            switch (event.which) {
                case KEY_LEFT:
                    events.emit(EMITTER_NAME, events.GOTO_PREVIOUS_PAGE, this, {}, false);
                    break;
                case KEY_RIGHT:
                    events.emit(EMITTER_NAME, events.GOTO_NEXT_PAGE, this, {}, false);
                    break;
                case KEY_UP:
                    events.emit(EMITTER_NAME, events.ZOOM, this, {"direction": 1, "x": config.width / 2, "y": config.height / 2});
                    break;
                case KEY_DOWN:
                    events.emit(EMITTER_NAME, events.ZOOM, this, {"direction": -1, "x": config.width / 2, "y": config.height / 2});
                    break;
                case KEY_RETURN:
                case KEY_SPACEBAR:
                    events.emit(EMITTER_NAME, yudu_events.TOOLBAR.BUTTON_TRIGGER_KEY_PRESSED);
                    break;
            }
        };

        /**
         * Handles all interaction with actual canvas element and also resizing events from the window.
         * @param theReader The reader being interacted with.
         */
        var init = function(theReader) {
            //properties from construction parameters
            reader = theReader;

            //register as an emitter
            events.register(EMITTER_NAME);

            // bind to internal events
            events.subscribe(events.ALL, events.TOGGLE_KEY_NAVIGATION, handleToggleKeyNavigation);

            //store a reference to the element all our event listeners will be bound to
            element = $("#yudu_interactionDiv");

            //bind hammer events on the element (the canvas)
            hammerContext = element.hammer({
                // when true, prevent default browser actions on "transforms" (multi-touch gestures)
                transform_always_block: blockingDefaultTransforms
            });

            //using the hammerManager instead of jquery hammer for these two gestures as they require special setting
            //gesture is not included in the event which is generated by hammerManager, it is only generated by the jquery wrapper, srcEvent however containts the needed components
            //TODO: the rest of the gestures should probably use the hammer manager for consistency, but this isn't essential
            var tapManager = hammerManager.createManagerForDoubleTap(element[0]);
            events.yuduOn(tapManager, "tap", tap);
            events.yuduOn(tapManager, "doubletap", doubleTapHandler);

            var pinchManager = hammerManager.createPinchManager(element[0]);
            events.yuduOn(pinchManager, "pinch", pinchHandler);

            events.yuduOn(hammerContext, "release", release);
            events.yuduOn(hammerContext, "drag", drag);
            events.yuduOn(hammerContext, "dragend", dragEnd);
            events.yuduOn(hammerContext, "dragstart", dragStart);
            events.yuduOn(hammerContext, "touch", touch);

            //bind mouse wheel events
            element.bind("mousewheel", mouseWheelHandler);

            events.yuduOn(element, "mousemove", events.callback(reader, reader.fadeInOrOutOverlayIfNecessary));

            //bind keyboard events
            window.onkeydown = keyPress;

            // bind to window resize events
            var resizeCallback = events.callback(this, function() {
                // this call has to be wrapped in a scoped lambda to ensure that it's internal scope is to the Reader
                reader.updateReaderSize();
            });
            // debounce the function so that we don't waste processing during a resize
            resizeCallback = sharedUtils.debounce(resizeCallback, 300);
            window.addEventListener('resize', resizeCallback);

            //enable touch recognition on the stage
            createjs.Touch.enable(reader.stage);

            window.onpopstate = function(event) {
                if (event && event.state && typeof event.state.page != "undefined" && event.state.page != null) {
                    var page = event.state.page;
                    events.emit(EMITTER_NAME, events.HISTORY_CHANGE, this, {page: page});
                }
            };

            events.yuduOn($('html'), 'touchmove', function() {
                events.emit(EMITTER_NAME, events.MOUSE_MOVE_STOP, this, {});
                $('html').off('touchmove');
            });
        };

        var handleToggleKeyNavigation = function(event) {
            if (typeof event.data.isAllowed !== 'undefined') {
                setAllowKeyNavigation(event.data.isAllowed);
            } else {
                setAllowKeyNavigation(!allowKeyNavigation);
            }
        };

        /**
         * Re-enable blocked default browser actions for multi-touch gestures (eg pinch to zoom)
         */
        var enableDefaultTransformActions = function() {
            if (!blockingDefaultTransforms) {
                return;
            }
            if (hammerContext) {
                hammerContext.data('hammer').options.transform_always_block = false;
            }
            blockingDefaultTransforms = false;
        };

        /**
         * Re-disable permitted default browser actions for multi-touch gestures (eg pinch to zoom)
         */
        var disableDefaultTransformActions = function() {
            if (blockingDefaultTransforms) {
                return;
            }
            if (hammerContext) {
                hammerContext.data('hammer').options.transform_always_block = true;
            }
            blockingDefaultTransforms = true;
        };

        /**
         * Event handler for when a zoom-state change is detected
         * @param event {{}} emitted event - event data available under `data` property
         */
        var handleBrowserZoomStateChange = function(event) {
            if (event.data.isZoomedIn) {
                enableDefaultTransformActions();
            } else {
                disableDefaultTransformActions();
            }
        };

        /**
         * Binds key press events
         */
        var setAllowKeyNavigation = function(isAllowed) {
            allowKeyNavigation = isAllowed;
        };

        preinit();

        return {
            init: init,
            setAllowKeyNavigation: setAllowKeyNavigation,
            canDragPage: canDragPage,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('ui/orderForm',['constants', 'events', 'config', 'resources', 'interactions', 'shared/ui/messageBox', 'shared/localisation', 'utils/tools',
        'utils/urlUtils', 'shared/storage', 'jquery'],
    function (constants, events, config, resources, interactions, messageBox, localisation, tools,
              urlUtils, storage, $) {

        var ORDER_ITEMS_KEY;

        var KEY_RETURN = 13;

        var EMITTER_NAME = "orderForm";

        var BASKET_IMAGE_SIZE = 64;

        var background = $('#yudu_orderFormBackground');
        var form = $('#yudu_orderForm');
        var orderFormTitle = $('#yudu_orderFormTitle');
        var formTableWrapper = $('#yudu_orderFormTableWrapper');
        var formTable = $('#yudu_orderFormTable');
        var orderFormTableHeading = $('#yudu_orderFormTableHeading');
        var deliveryDetailsTable = $('#yudu_deliveryDetailsTable');
        var totalPriceRow = $('#yudu_totalPriceRow');
        var totalPriceCell = $('#yudu_totalPrice');
        var emptyOrderFormButton = $('#yudu_emptyOrderForm');
        var orderFormButtons = $('#yudu_orderFormButtons');
        var dismissOrderFormButton = $('#yudu_dismissOrderForm');
        var nextViewOrderFormButton = $('#yudu_nextViewOrderForm');
        var previousViewOrderFormButton = $('#yudu_previousViewOrderForm');
        var sendOrderFormButton = $('#yudu_sendOrderForm');
        var emptyFormInfo = $('#yudu_emptyFormInfo');
        var downloadToCsvButton = null;

        var deliveryDetailsUI = {
            "name": $("#yudu_deliveryDetailsName"),
            "accountNumber": $("#yudu_deliveryDetailsAccountNumber"),
            "phone": $("#yudu_deliveryDetailsPhone"),
            "poNumber": $("#yudu_deliveryDetailsPONumber"),
            "email": $("#yudu_deliveryDetailsEmail"),
            "companyName": $("#yudu_deliveryDetailsCompanyName"),
            "customUserFieldRow": $("#yudu_customUserFieldRow"),
            "customUserFieldName": $("#yudu_deliveryDetailsCustomUserFieldName"),
            "customUserField": $("#yudu_deliveryDetailsCustomUserField"),
            "billingAddress1": $("#yudu_deliveryDetailsBillingAddress1"),
            "billingAddress2": $("#yudu_deliveryDetailsBillingAddress2"),
            "billingCity": $("#yudu_deliveryDetailsBillingCity"),
            "billingState": $("#yudu_deliveryDetailsBillingState"),
            "billingPostCode": $("#yudu_deliveryDetailsBillingPostCode"),
            "billingCountry": $("#yudu_deliveryDetailsBillingCountry"),
            "deliveryAddress1": $("#yudu_deliveryDetailsDeliveryAddress1"),
            "deliveryAddress2": $("#yudu_deliveryDetailsDeliveryAddress2"),
            "deliveryCity": $("#yudu_deliveryDetailsDeliveryCity"),
            "deliveryState": $("#yudu_deliveryDetailsDeliveryState"),
            "deliveryPostCode": $("#yudu_deliveryDetailsDeliveryPostCode"),
            "deliveryCountry": $("#yudu_deliveryDetailsDeliveryCountry"),
            "deliveryNotes": $("#yudu_deliveryDetailsAdditionalInformation"),
            "deliveryDetailsSameAsBillingCheckbox": $('#yudu_deliveryDetailsDeliveryAddressSameAsBillingAddress')
        };

        var orderFormResponseMessage;

        var postageInfo;

        var settings;

        var orderItemsJson = {};

        var totalPrice = 0;

        var totalNumber = 0;

        var hideTimeout;

        var initialQuantity;

        var init = function() {
            events.yuduOn(background, config.clickAction, hideWithoutSlide);
            events.yuduOn(form, config.clickAction, function(){ clearTimeout(hideTimeout); });
            events.yuduOn(emptyOrderFormButton, config.clickAction, removeAllItems);
            events.yuduOn(dismissOrderFormButton, config.clickAction, hideWithoutSlide);
            events.yuduOn(nextViewOrderFormButton, config.clickAction, toggleTableView);
            events.yuduOn(previousViewOrderFormButton, config.clickAction, toggleTableView);
            events.yuduOn(sendOrderFormButton, config.clickAction, sendForm);

            events.subscribe(events.All, events.RESIZE, onResize);

            // If setting 'display: none' in CSS instead, when toggling later it's set to 'display: block' rather than
            // 'display: table-row', so we hide it this way instead.
            totalPriceRow.toggle();
            deliveryDetailsTable.toggle();

            settings = resources.yuduBook.orderForm;

            if (settings.submitToCustomUrl) {
                nextViewOrderFormButton.hide();
                sendOrderFormButton.show();
            } else {
                deliveryDetailsUI.deliveryDetailsSameAsBillingCheckbox.change(function(e) {
                    if (deliveryDetailsUI.deliveryDetailsSameAsBillingCheckbox.prop("checked")) {
                        deliveryDetailsUI.deliveryAddress1.val(deliveryDetailsUI.billingAddress1.val());
                        deliveryDetailsUI.deliveryAddress2.val(deliveryDetailsUI.billingAddress2.val());
                        deliveryDetailsUI.deliveryCity.val(deliveryDetailsUI.billingCity.val());
                        deliveryDetailsUI.deliveryState.val(deliveryDetailsUI.billingState.val());
                        deliveryDetailsUI.deliveryPostCode.val(deliveryDetailsUI.billingPostCode.val());
                        deliveryDetailsUI.deliveryCountry.val(deliveryDetailsUI.billingCountry.val());

                        addBillingAddressChangeListeners();
                    } else {
                        removeBillingAddressChangeListeners();
                    }
                });

                orderFormResponseMessage = $("#yudu_orderFormResponse");

                if(settings.userField1) {
                    deliveryDetailsUI.customUserFieldName.text(settings.userField1);
                    deliveryDetailsUI.customUserFieldRow.css("display", "table-row");
                }
            }

            // If download cart to CSV is enabled, we dynamically generate the button and form on the order form
            // necessary to do so and add the appropriate event listener
            if (!!settings.downloadCartToCsvEnabled) {
                createDownloadCartForm();
                events.yuduOn(downloadToCsvButton, config.clickAction, downloadCart);
                downloadToCsvButton.show();
            }

            //make sure the shopping carts are unique for each book
            ORDER_ITEMS_KEY = 'orderItem-' + resources.yuduBook.settings.id;

            if (settings.formHeaderLabel) {
                orderFormTitle.html(settings.formHeaderLabel);
                orderFormTitle.removeClass('yudu_localisable');
            }

            if (settings.sendOrderLabel) {
                sendOrderFormButton.html(settings.sendOrderLabel);
                sendOrderFormButton.removeClass('yudu_localisable');
            }

            if (!settings.showProduct) {
                $('.yudu_product_code').remove();
            }

            if (!settings.showPrice) {
                $('#yudu_itemPriceHeading').remove();
                $('#yudu_priceHeading').remove();
                $('#yudu_totalPriceRow').remove();
            }
            else {
                var itemPriceHeading = $('#yudu_itemPriceHeading');
                itemPriceHeading.html(itemPriceHeading.html() + " (" + settings.currency + ")");

                var priceHeading = $('#yudu_priceHeading');
                priceHeading.html(priceHeading.html() + " (" + settings.currency + ")");

                var totalPriceText = $('#yudu_totalPriceText');
                totalPriceText.html(totalPriceText.html() + " (" + settings.currency + ")");
            }

            if (!settings.showQuantity) {
                $('.yudu_quantity').remove();
                $('.yudu_quantityButtonIncrease').remove();
                $('.yudu_quantityButtonDecrease').remove();
            }

            if (!settings.showBillingDelivery) {
                $('#yudu_billingDeliveryTableTopRow').remove();
                $('#yudu_billingDeliveryTableAddress1Row').remove();
                $('#yudu_billingDeliveryTableAddress2Row').remove();
                $('#yudu_billingDeliveryTableCityRow').remove();
                $('#yudu_billingDeliveryTableStateRow').remove();
                $('#yudu_billingDeliveryTablePostCodeRow').remove();
                $('#yudu_billingDeliveryTableCountryRow').remove();
            } else if (settings.mandatoryBillingDelivery) {
                $('#yudu_deliveryDetailsBillingAddress1Label').append('*');
                $('#yudu_deliveryDetailsBillingCityLabel').append('*');
                $('#yudu_deliveryDetailsBillingStateLabel').append('*');
                $('#yudu_deliveryDetailsBillingPostCodeLabel').append('*');
                $('#yudu_deliveryDetailsBillingCountryLabel').append('*');
                $('#yudu_deliveryDetailsDeliveryAddress1Label').append('*');
                $('#yudu_deliveryDetailsDeliveryCityLabel').append('*');
                $('#yudu_deliveryDetailsDeliveryStateLabel').append('*');
                $('#yudu_deliveryDetailsDeliveryPostCodeLabel').append('*');
                $('#yudu_deliveryDetailsDeliveryCountryLabel').append('*');
            }

            if (!settings.showAccountNumber) {
                $("#yudu_deliveryDetailsAccountNumber").remove();
                $("#yudu_deliveryDetailsAccountNumberLabel").remove();
            }  else if (settings.mandatoryAccountNumber) {
                $("#yudu_deliveryDetailsAccountNumberLabel").append('*');
            }

            if (!settings.showPONumber) {
                $("#yudu_deliveryDetailsPONumber").remove();
                $("#yudu_deliveryDetailsPONumberLabel").remove();
            }   else if (settings.mandatoryPONumber) {
                $("#yudu_deliveryDetailsPONumberLabel").append('*');
            }

            if (settings.mandatoryCompanyName) {
                $("#yudu_deliveryDetailsCompanyNameLabel").append('*');
            }

            $("#yudu_deliveryDetailsNameLabel").append('*');
            $("#yudu_deliveryDetailsPhoneLabel").append('*');
            $("#yudu_deliveryDetailsEmailLabel").append('*');

            if (settings.field1) {
                var f1Heading = getCellDiv().html(settings.field1);
                f1Heading.insertBefore(itemPriceHeading);

                var f1TotalPriceRow = getCellDiv();
                f1TotalPriceRow.insertBefore(totalPriceText);
            }

            if (settings.field2) {
                var f2Heading = getCellDiv().html(settings.field2);
                f2Heading.insertBefore(itemPriceHeading);

                var f2TotalPriceRow = getCellDiv();
                f2TotalPriceRow.insertBefore(totalPriceText);
            }

            if (settings.postageText)
                $(".yudu_removeButton", totalPriceRow).html(settings.postageText);

            if (settings.postageLinkText) {
                postageInfo = $(document.createElement('div')).attr('id', 'yudu_postageInfo');
                if (settings.postageLinkUrl) {
                    postageInfo.append($(document.createElement('a'))
                        .attr('href', settings.postageLinkUrl).attr('target', '_blank').html(settings.postageLinkText));
                }
                else {
                    postageInfo.html(settings.postageLinkText);
                }
                postageInfo.insertAfter(emptyFormInfo);
            }

            if (storage.getItem(ORDER_ITEMS_KEY))
                orderItemsJson = JSON.parse(storage.getItem(ORDER_ITEMS_KEY));

            if (!$.isEmptyObject(orderItemsJson)) {
                toggleFormComponents();

                for (var productCode in orderItemsJson) {
                    if (orderItemsJson.hasOwnProperty(productCode)) {
                        var quantity = orderItemsJson[productCode].quantity ? Number(orderItemsJson[productCode].quantity) : 1;
                        var itemPrice = Number(orderItemsJson[productCode].itemPrice);

                        addTableRow(productCode, orderItemsJson[productCode].description, itemPrice, quantity,
                            orderItemsJson[productCode][settings.field1], orderItemsJson[productCode][settings.field2], orderItemsJson[productCode].granularity, orderItemsJson[productCode].basketImageUrl);

                        totalPrice += Number(quantity) * itemPrice;
                        totalNumber += Number(quantity);
                    }
                }

                totalPriceCell.html(totalPrice.toFixed(2));
                updateShoppingCartButton({numberOfProducts:totalNumber});
            }

            events.yuduOn(form, "touchmove", function(event){
                event.preventDefault();
            });
            events.yuduOn(formTableWrapper, "touchmove", function(event){
                if (formTableWrapper[0].offsetHeight < formTableWrapper[0].scrollHeight ||
                    formTableWrapper[0].offsetWidth < formTableWrapper[0].scrollWidth)
                    event.stopPropagation();
            });
        };

        var addBillingAddressChangeListeners = function() {
            events.yuduOn(deliveryDetailsUI.billingAddress1, "input", copyValuesAcross(deliveryDetailsUI.billingAddress1, deliveryDetailsUI.deliveryAddress1));
            events.yuduOn(deliveryDetailsUI.billingAddress2, "input", copyValuesAcross(deliveryDetailsUI.billingAddress2, deliveryDetailsUI.deliveryAddress2));
            events.yuduOn(deliveryDetailsUI.billingCity, "input", copyValuesAcross(deliveryDetailsUI.billingCity, deliveryDetailsUI.deliveryCity));
            events.yuduOn(deliveryDetailsUI.billingState, "input", copyValuesAcross(deliveryDetailsUI.billingState, deliveryDetailsUI.deliveryState));
            events.yuduOn(deliveryDetailsUI.billingPostCode, "input", copyValuesAcross(deliveryDetailsUI.billingPostCode, deliveryDetailsUI.deliveryPostCode));
            events.yuduOn(deliveryDetailsUI.billingCountry, "input", copyValuesAcross(deliveryDetailsUI.billingCountry, deliveryDetailsUI.deliveryCountry));
        };

        var removeBillingAddressChangeListeners = function() {
            deliveryDetailsUI.billingAddress1.off("input");
            deliveryDetailsUI.billingAddress2.off("input");
            deliveryDetailsUI.billingCity.off("input");
            deliveryDetailsUI.billingState.off("input");
            deliveryDetailsUI.billingPostCode.off("input");
            deliveryDetailsUI.billingCountry.off("input");
        };

        var copyValuesAcross = function(fromElement, toElement) {
            return function() {
                toElement.val(fromElement.val());
            }
        };

        var createDownloadCartForm = function() {
            // Create the form
            var downloadCartForm = document.createElement('form');
            downloadCartForm.setAttribute('method', 'POST');
            var queryString = '?filename=' + generateCartFileName();
            downloadCartForm.setAttribute('action', settings.downloadCartToCsvUrl + queryString);
            downloadCartForm.setAttribute('id', 'downloadCartForm');

            var csvDataInput = document.createElement('input');
            csvDataInput.setAttribute('id', 'csvData');
            csvDataInput.setAttribute('name', 'csvData');
            csvDataInput.setAttribute('type', 'hidden');

            // Create the button
            var downloadCartButton = document.createElement('button');
            downloadCartButton.setAttribute('id', 'yudu_downloadCartToCsv');
            downloadCartButton.setAttribute('class', 'yudu_orderFormButton yudu_localisable');
            downloadCartButton.setAttribute('type', 'button');
            var tabindex = parseInt(sendOrderFormButton.attr('tabindex')) + 1;
            downloadCartButton.setAttribute('tabindex', tabindex);
            downloadCartButton.disabled = true;
            downloadCartButton.textContent = 'orderForm.download';

            // Append dom elements
            downloadCartForm.appendChild(csvDataInput);
            downloadCartForm.appendChild(downloadCartButton);
            orderFormButtons.append(downloadCartForm);

            downloadToCsvButton = $(downloadCartButton);

            localisation.localiseHtml(downloadCartForm);
        };

        var generateCartFileName = function() {
            var editionName = resources.yuduBook.settings.shortName;

            // Format the date
            var date = new Date();
            var month = date.getMonth();
            month++;
            var formattedDate = date.getFullYear() + ('0' + month).slice(-2) + date.getDate();

            return 'cart-' + editionName + '-' + formattedDate + '.csv';
        };

        var showForDuration = function(duration) {
            interactions.setAllowKeyNavigation(false);
            background.show();
            events.emit(EMITTER_NAME, events.SHOWHIDE_TOOLBAR, this, {show: false});
            form.slideDown(function() {
                formTableWrapper.scrollTop(0);
                onResize();
                events.subscribe(events.ALL, events.CLOSE_ACTIVE, hideWithoutSlide);
                if (duration)
                    hideTimeout = setTimeout(hideWithSlide, duration);
            });
        };

        var hideWithSlide = function() {
            hide(true);
        };

        var hideWithoutSlide = function() {
            hide(false);
        };

        var hide = function(slide) {
            clearTimeout(hideTimeout);
            events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, hideWithoutSlide);
            background.hide();
            if (slide) {
                form.slideUp(function (){
                    interactions.setAllowKeyNavigation(true);
                });
            } else {
                form.hide();
                interactions.setAllowKeyNavigation(true);
            }
        };

        var onResize = function() {
            var titleHeight = orderFormTitle.height() + parseInt(orderFormTitle.css('margin-top')) + parseInt(orderFormTitle.css('margin-bottom'));
            var buttonsHeight = $('.yudu_orderFormButton').height() + parseInt(orderFormButtons.css('margin-top')) + parseInt(orderFormButtons.css('margin-bottom'));
            var postageInfoHeight = 0;
            if (postageInfo)
                postageInfoHeight = postageInfo.height() + parseInt(postageInfo.css('margin-top')) + parseInt(postageInfo.css('margin-bottom'));
            var padding = parseInt(form.css('padding-top')) + parseInt(form.css('padding-bottom'));
            formTableWrapper.css('max-height', (config.canvasResizeHeight - titleHeight - buttonsHeight - postageInfoHeight - padding - (config.isDesktop ? 0 : 20)) + 'px');
            setOrderFormTextSize();
        };

        var setOrderFormTextSize = function() {
            var fontSize = tools.clamp(60, $('body').width() * 0.1, 90);
            formTable.css('font-size', fontSize + '%');
            $('.inputField').css('font-size', (fontSize + 10) + '%');
            $('.yudu_removeItem').css('font-size', (fontSize + 10) + '%');
        };

        var toggleFormComponents = function() {
            emptyFormInfo.toggle();
            totalPriceRow.toggle();
            emptyOrderFormButton.toggle();
            if (postageInfo)
                postageInfo.toggle();
            sendOrderFormButton.toggleClass('enabled');
            nextViewOrderFormButton.toggleClass('enabled');
            sendOrderFormButton[0].disabled = !sendOrderFormButton[0].disabled;
            nextViewOrderFormButton[0].disabled = !nextViewOrderFormButton[0].disabled;
            if (!!settings.downloadCartToCsvEnabled) {
                downloadToCsvButton.toggleClass('enabled');
                downloadToCsvButton[0].disabled = !downloadToCsvButton[0].disabled;
            }
            updateShoppingCartButton({toggleIcon:true});
        };

        var addItem = function(productCode) {
            var safeProductCode = getSafeProductCode(productCode);

            if ($.isEmptyObject(orderItemsJson))
                toggleFormComponents();

            var newItem = true;
            var batchSize = 1;

            if (orderItemsJson[productCode]) {
                newItem = false;
                if (orderItemsJson[productCode].granularity) {
                    batchSize = orderItemsJson[productCode].granularity;
                }

                if (settings.showQuantity) {
                    var newQuantity = Number(orderItemsJson[productCode].quantity) + Number(batchSize);
                    orderItemsJson[productCode].quantity = newQuantity;

                    //jquery doesn't seem to work if the product code contains special characters, even if they are escaped
                    document.getElementById(safeProductCode + 'Quantity').value = newQuantity;
                    $(document.getElementById(safeProductCode + 'Price')).html((newQuantity * Number(orderItemsJson[productCode].itemPrice)).toFixed(2));
                }

            }
            else {
                var description = resources.priceList[safeProductCode].desc;
                var price = Number(resources.priceList[safeProductCode].price);
                var granularity = resources.priceList[safeProductCode].granularity;
                var basketImageUrl = resources.priceList[safeProductCode].basket_image;

                orderItemsJson[productCode] = {description: description, itemPrice: price, granularity: granularity, basketImageUrl: basketImageUrl};

                if (orderItemsJson[productCode].granularity) {
                    batchSize = orderItemsJson[productCode].granularity;
                }

                if (settings.showQuantity)
                    orderItemsJson[productCode].quantity = batchSize;

                var customField1;
                var customField2;

                if (settings.field1) {
                    customField1 = "";
                    orderItemsJson[productCode][settings.field1] = customField1;
                }
                if (settings.field2) {
                    customField2 = "";
                    orderItemsJson[productCode][settings.field2] = customField2;
                }

                addTableRow(productCode, description, price, orderItemsJson[productCode].quantity, customField1, customField2, granularity, basketImageUrl);
            }

            if (newItem || settings.showQuantity) {
                totalPrice += Number(orderItemsJson[productCode].itemPrice) * batchSize;
                totalPriceCell.html(totalPrice.toFixed(2));
                totalNumber += Number(batchSize);
                updateShoppingCartButton({numberOfProducts:totalNumber});
            }

            updateBasket();

            showForDuration(5000);
        };

        var updateBasket = function() {
            storage.setItem(ORDER_ITEMS_KEY, JSON.stringify(orderItemsJson));
        };

        var addTableRow = function(productCode, description, itemPrice, quantity, customField1, customField2, granularity, basketImageUrl) {
            var safeProductCode = getSafeProductCode(productCode);
            var quantityDecrease;
            var quantityIncrease;

            var rowDiv = $(document.createElement('div')).addClass('yudu_orderFormTableRow').attr('id', safeProductCode);

            if (basketImageUrl) {
                var basketImage = $('<img />').attr('src', basketImageUrl).height(BASKET_IMAGE_SIZE).width(BASKET_IMAGE_SIZE);
                rowDiv.append(getCellDiv().html(basketImage));
            } else{
                rowDiv.append(getCellDiv().html(""));
            }

            if (settings.showProduct) {
                rowDiv.append(getCellDiv().html(productCode));
            }

            rowDiv.append(getCellDiv().addClass('yudu_description').html(description));

            if (settings.showQuantity) {
                if (granularity) {
                    quantityDecrease = $(document.createElement('button')).addClass('quantityButton').html('-');
                    rowDiv.append(getCellDiv().html(quantityDecrease));
                } else {
                    rowDiv.append(getCellDiv().html(""));
                }

                var quantityInput = $(document.createElement('input')).attr('value', quantity).addClass('inputField').attr('id', safeProductCode + 'Quantity');
                events.yuduOn(quantityInput, 'focus', function () {
                    initialQuantity = orderItemsJson[productCode].quantity.toString();
                });
                events.yuduOn(quantityInput, 'input', function () {
                    if (this.value.length > initialQuantity.length) {
                        var addedText = this.value.slice(initialQuantity.length, this.value.length);
                        if (isNaN(addedText))
                            this.value = this.value.slice(0, initialQuantity.length);
                        else if (this.value.length > 9)
                            this.value = this.value.slice(0, 9);
                    }
                    initialQuantity = this.value;

                    events.yuduOn($(this), 'focusout', function () {
                        $(this).off('focusout');
                        if (this.value.length == 0) {
                            if (granularity) {
                                this.value = granularity;
                            } else {
                                this.value = 1;
                            }
                        }
                        updateItemQuantity(productCode, safeProductCode, this);
                    });
                });
                quantityInput.keypress(function (event) {
                    if (event.which == KEY_RETURN)
                        $(this).focusout();
                });
                rowDiv.append(getCellDiv().html(quantityInput));

                if (granularity) {
                    quantityIncrease = $(document.createElement('button')).addClass('quantityButton').html('+');
                    rowDiv.append(getCellDiv().html(quantityIncrease));

                    quantityInput.attr('disabled','true');
                    var quantityInputField = quantityInput[0];
                    events.yuduOn(quantityDecrease, config.clickAction, function(){
                        quantityInputField.value = quantityInputField.value - granularity;
                        if (quantityInputField.value <= 0) {
                            quantityInputField.value = granularity;
                        }
                        updateItemQuantity(productCode, safeProductCode, quantityInputField)
                    });
                    events.yuduOn(quantityIncrease, config.clickAction, function(){
                        quantityInputField.value = Number(quantityInputField.value) + Number(granularity);
                        updateItemQuantity(productCode, safeProductCode, quantityInputField)
                    });

                } else {
                    rowDiv.append(getCellDiv().html(""));
                }
            }

            if (customField1 != null) {
                var customField1Input = $(document.createElement('input')).attr('value', customField1).addClass('inputField');
                events.yuduOn(customField1Input, 'focusout', function () {
                    orderItemsJson[productCode][settings.field1] = this.value;
                    updateBasket();
                });
                customField1Input.keypress(function (event) {
                    if (event.which == KEY_RETURN)
                        $(this).focusout();
                });
                rowDiv.append(getCellDiv().html(customField1Input));
            }

            if (customField2 != null) {
                var customField2Input = $(document.createElement('input')).attr('value', customField2).addClass('inputField');
                events.yuduOn(customField2Input, 'focusout', function () {
                    orderItemsJson[productCode][settings.field2] = this.value;
                    updateBasket();
                });
                customField2Input.keypress(function (event) {
                    if (event.which == KEY_RETURN)
                        $(this).focusout();
                });
                rowDiv.append(getCellDiv().html(customField2Input));
            }

            if (settings.showPrice) {
                rowDiv.append(getCellDiv().html(itemPrice.toFixed(2)));

                rowDiv.append(getCellDiv().attr('id', safeProductCode + 'Price').html((quantity * itemPrice).toFixed(2)));

            }

            var removeItemButton = $(document.createElement('button')).attr('type', 'button').addClass('yudu_removeItem').html(localisation.get('orderForm.removeItem'));
            events.yuduOn(removeItemButton, config.clickAction, function(){ removeItem(productCode); });
            rowDiv.append(getCellDiv().addClass('yudu_removeButton').html(removeItemButton));

            rowDiv.insertAfter(orderFormTableHeading);
        };

        var updateItemQuantity = function(productCode, safeProductCode, quantityInput) {
            totalPrice -= Number(orderItemsJson[productCode].quantity) * Number(orderItemsJson[productCode].itemPrice);
            totalNumber -= Number(orderItemsJson[productCode].quantity);

            orderItemsJson[productCode].quantity = quantityInput.value;
            updateBasket();

            var itemTotalPrice = Number(quantityInput.value) * Number(orderItemsJson[productCode].itemPrice);
            $(document.getElementById(safeProductCode + 'Price')).html(itemTotalPrice.toFixed(2));

            totalPrice += Number(itemTotalPrice);
            totalPriceCell.html(totalPrice.toFixed(2));
            totalNumber += Number(quantityInput.value);
            updateShoppingCartButton({numberOfProducts:totalNumber});

        };

        var getCellDiv = function() {
            return $(document.createElement('div')).addClass('yudu_orderFormTableCell');
        };

        var getSafeProductCode = function(productCode) {
            return productCode.trim().replace(/ /g, "_").replace(/\./g, "_").toLowerCase();
        };

        var removeItem = function(productCode) {
            var quantity = orderItemsJson[productCode].quantity ? Number(orderItemsJson[productCode].quantity) : 1;
            totalPrice -= quantity * Number(orderItemsJson[productCode].itemPrice);
            totalPriceCell.html(totalPrice.toFixed(2));
            totalNumber -= quantity;
            updateShoppingCartButton({numberOfProducts:totalNumber});

            delete orderItemsJson[productCode];
            updateBasket();

            var safeProductCode = getSafeProductCode(productCode);
            $(document.getElementById(safeProductCode)).remove();

            if ($.isEmptyObject(orderItemsJson))
                toggleFormComponents();
        };

        var removeAllItems = function() {
            orderItemsJson = {};
            updateBasket();

            totalPrice = 0;
            totalNumber = 0;

            formTable.empty();
            formTable.append(orderFormTableHeading);
            formTable.append(totalPriceRow);
            events.yuduOn(emptyOrderFormButton, config.clickAction, removeAllItems);

            toggleFormComponents();
        };

        var toggleTableView = function () {
            formTable.toggle();
            deliveryDetailsTable.toggle();
            nextViewOrderFormButton.toggle();
            previousViewOrderFormButton.toggle();
            sendOrderFormButton.toggle();
            if (postageInfo)
                postageInfo.toggle();
        };

        var checkMandatoryFields = function () {

            var missingMandatoryFields = [];

            if (!deliveryDetailsUI.name.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.name");
            }
            if (!deliveryDetailsUI.phone.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.phone");
            }
            if (!deliveryDetailsUI.email.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.email");
            }

            if (settings.mandatoryAccountNumber && !deliveryDetailsUI.accountNumber.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.accountNumber");
            }
            if (settings.mandatoryPONumber && !deliveryDetailsUI.poNumber.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.poNumber");
            }
            if (settings.mandatoryCompanyName && !deliveryDetailsUI.companyName.val()) {
                missingMandatoryFields.push("orderForm.deliveryDetails.companyName");
            }

            if (settings.mandatoryBillingDelivery) {
                if (!deliveryDetailsUI.billingAddress1.val()||
                    !deliveryDetailsUI.billingCity.val()    ||
                    !deliveryDetailsUI.billingState.val()   ||
                    !deliveryDetailsUI.billingPostCode.val()||
                    !deliveryDetailsUI.billingCountry.val()) {
                    missingMandatoryFields.push("orderForm.deliveryDetails.billingAddress");
                }
                if (!deliveryDetailsUI.deliveryAddress1.val()||
                    !deliveryDetailsUI.deliveryCity.val()    ||
                    !deliveryDetailsUI.deliveryState.val()   ||
                    !deliveryDetailsUI.deliveryPostCode.val()||
                    !deliveryDetailsUI.deliveryCountry.val()) {
                    missingMandatoryFields.push("orderForm.deliveryDetails.deliveryAddress");
                }
            }

            return missingMandatoryFields;
        };

        var sendForm = function() {
            orderFormResponseMessage && orderFormResponseMessage.hide();

            if (!settings.submitToCustomUrl) {
                var missingFields = checkMandatoryFields();
                if (missingFields.length != 0) {
                    var missingFieldsString = "";
                    for (var i = 0; i < missingFields.length; i++) {
                        missingFieldsString = missingFieldsString + localisation.get(missingFields[i]) + ", ";
                    }
                    missingFieldsString = missingFieldsString.slice(0, -2);
                    orderFormResponseMessage.text(localisation.get("orderForm.missingMandatoryDetails") + missingFieldsString);
                    orderFormResponseMessage.show();
                    return;
                }
            }

            var orderFormJson = {bookId: resources.yuduBook.settings.id, currency: settings.currency,
                customField1Name: settings.field1, customField2Name: settings.field2, totalPrice: totalPrice.toFixed(2),
                postage: settings.postageText};

            var distributorId = config.getFromQuery('distributorId');
            if (distributorId)
                orderFormJson.distributorId = distributorId;

            var orderItems = [];

            for (var productCode in orderItemsJson) {
                var orderItem = {productCode: productCode, description: orderItemsJson[productCode].description, price: Number(orderItemsJson[productCode].itemPrice).toFixed(2)};

                if (settings.field1)
                    orderItem.customField1 = orderItemsJson[productCode][settings.field1];
                if (settings.field2)
                    orderItem.customField2 = orderItemsJson[productCode][settings.field2];
                if (orderItemsJson[productCode].granularity)
                    orderItem.granularity = orderItemsJson[productCode].granularity;
                if (orderItemsJson[productCode].basketImageUrl)
                    orderItem.basketImageUrl =  orderItemsJson[productCode].basketImageUrl;

                if (settings.showQuantity) {
                    orderItem.quantity = orderItemsJson[productCode].quantity;
                    orderItem.quantityPrice = (Number(orderItem.quantity) * Number(orderItem.price)).toFixed(2);
                }
                else
                    orderItem.quantityPrice = Number(orderItem.price).toFixed(2);

                orderItems.push(orderItem);
            }

            orderFormJson.orderItems = orderItems;

            if (!settings.submitToCustomUrl) {
                // get the user's details and delivery info for inclusion in the order email sent from publisher
                orderFormJson.name = deliveryDetailsUI.name.val();
                if (settings.showAccountNumber) {
                    orderFormJson.accountNumber = deliveryDetailsUI.accountNumber.val();
                } else {
                    orderFormJson.accountNumber = "";
                }
                orderFormJson.phone = deliveryDetailsUI.phone.val();
                if (settings.showPONumber) {
                    orderFormJson.poNumber = deliveryDetailsUI.poNumber.val();
                } else {
                    orderFormJson.poNumber = "";
                }
                orderFormJson.email = deliveryDetailsUI.email.val();
                orderFormJson.companyName = deliveryDetailsUI.companyName.val();
                orderFormJson.customUserField1Name = deliveryDetailsUI.customUserFieldName.text();
                orderFormJson.customUserField1 = deliveryDetailsUI.customUserField.val();

                if (settings.showBillingDelivery) {
                    orderFormJson.billingAddress1 = deliveryDetailsUI.billingAddress1.val();
                    orderFormJson.billingAddress2 = deliveryDetailsUI.billingAddress2.val();
                    orderFormJson.billingCity = deliveryDetailsUI.billingCity.val();
                    orderFormJson.billingState = deliveryDetailsUI.billingState.val();
                    orderFormJson.billingPostCode = deliveryDetailsUI.billingPostCode.val();
                    orderFormJson.billingCountry = deliveryDetailsUI.billingCountry.val();

                    orderFormJson.deliveryAddress1 = deliveryDetailsUI.deliveryAddress1.val();
                    orderFormJson.deliveryAddress2 = deliveryDetailsUI.deliveryAddress2.val();
                    orderFormJson.deliveryCity = deliveryDetailsUI.deliveryCity.val();
                    orderFormJson.deliveryState = deliveryDetailsUI.deliveryState.val();
                    orderFormJson.deliveryPostCode = deliveryDetailsUI.deliveryPostCode.val();
                    orderFormJson.deliveryCountry = deliveryDetailsUI.deliveryCountry.val();
                } else {
                    orderFormJson.billingAddress1 = "";
                    orderFormJson.billingAddress2 = "";
                    orderFormJson.billingCity = "";
                    orderFormJson.billingState = "";
                    orderFormJson.billingPostCode = "";
                    orderFormJson.billingCountry = "";

                    orderFormJson.deliveryAddress1 = "";
                    orderFormJson.deliveryAddress2 = "";
                    orderFormJson.deliveryCity = "";
                    orderFormJson.deliveryState = "";
                    orderFormJson.deliveryPostCode = "";
                    orderFormJson.deliveryCountry = "";
                }

                orderFormJson.notes = deliveryDetailsUI.deliveryNotes.val();
            }

            var orderUrl = settings.submitToCustomUrl ? urlUtils.parseParameterisedUrl(settings.customUrl) : settings.sendOrderFormUrl;

            $.ajax({
                url: orderUrl,
                type: 'POST',
                dataType: "json",
                data: "json=" + encodeURIComponent(JSON.stringify(orderFormJson)),
                success: onSubmitOrderJson,
                error: onFailToSubmitOrderJson
            });
        };

        var onSubmitOrderJson = function(data) {
            var result = data.result;

            switch (result) {
                case "SUCCESS" :
                    hideWithoutSlide();
                    removeAllItems();
                    if (settings.submitToCustomUrl) {
                        if (settings.redirectUrl) {
                            var redirectUrl = urlUtils.parseParameterisedUrl(settings.redirectUrl);
                            if (data.token) {
                                redirectUrl += ((redirectUrl.indexOf('?') == -1) ? '?' : '&');
                                redirectUrl += 'token=' + data.token;
                            }
                            tools.openURL(redirectUrl, '_blank');
                        }
                    }
                    else {
                        toggleTableView();
                        messageBox.displayByCode('orderForm.success');
                    }
                    return;
                case "EMAILADDRESSFAILURE" :
                case "MISSINGDETAILSFAILURE" :
                    if (orderFormResponseMessage) {
                        orderFormResponseMessage.text(localisation.get(data.error));
                        orderFormResponseMessage.show();
                    }
                    return;
                default :
                    messageBox.displayByCode('orderForm.error');
                    return;
            }
        };

        var onFailToSubmitOrderJson = function() {
            hideWithoutSlide();
            messageBox.displayByCode('orderForm.genericError');
        };

        var updateShoppingCartButton = function(data) {
            if (window.yudu_commonSettings.toolbarLoaded)
                emitUpdateEvent(data);
            else
                events.subscribe(events.ALL, yudu_events.TOOLBAR.LOADED, function() {
                    emitUpdateEvent(data);
                });
        };

        var emitUpdateEvent = function(data) {
            events.emit(EMITTER_NAME, yudu_events.TOOLBAR.UPDATE_SHOPPING_CART_BUTTON, this, data);
        };

        /**
         * Downloads the shopping cart to CSV (an option enabled via Publisher) when the 'Download Cart to CSV' button
         * is pressed. The CSV data is created directly from the table in the order form DOM element an is sent in the
         * body of the POST request to Publisher which does the actual downloading. The reason for sending the request
         * to Publisher instead of downloading it here is to support older browsers such as IE.
         */
        var downloadCart = function() {
            var tableHeaders = [];
            orderFormTableHeading.find('.yudu_orderFormTableCell:not(.yudu_removeButton)').each(function() {
                tableHeaders.push($(this).text());
            });

            var tableBody = [tableHeaders.join()];
            form.find('.yudu_orderFormTableRow').each(function() {
                var row = [];
                $(this).find('.yudu_orderFormTableCell:not(.yudu_removeButton)').each(function() {
                    row.push($(this).text() || $(this).find('input').val());
                });
                tableBody.push(row.join());
            });

            $('#csvData').val(window.btoa(tableBody.join('\n')));
            $('#downloadCartForm').submit();
        };

        return {
            init: init,
            showForDuration: showForDuration,
            addItem: addItem
        };
    });
define('ui/rollover',['events', 'jquery', 'config', 'constants', 'resources', 'utils/tools', 'ui/orderForm', 'utils/statistics'],
    function(events, $, config, constants, resources, tools, orderForm, statistics) {

        var rolloverId = "yudu_rollover";
        var getRolloverId = "#" + rolloverId;

        var divContainer = null;
        var currentRolloverCode = null;
        var currentRolloverData = null;
        var currentRolloverSafeCode = null;
        var currentRolloverPageNumber = null;
        var lastOverlay = null;

        var arrow1 = null;
        var arrow2 = null;

        var productNameElement = "#productName";
        var productCodeElement = "#productCode";
        var productPriceElement = "#productPrice";
        var productDescriptionElement = "#productDescription";
        var productImageElement = "#productImage";
        var productStockLevelElement = "#productStockLevel";
        var productCancelButton = "#cancelButton";
        var productPurchaseButton = "#purchaseButton";

        var rolloverWidth = 300;
        var rolloverHeight = 350;

        var arrowLength = 15;
        var arrowWidth = 30;
        var borderRadius = 10;

        var aspectRatioMin = 0.75;
        var aspectRatioMax = 1.15;

        var ArrowPoint = {
            left: "left",
            top: "top",
            right: "right",
            bottom: "bottom",
            centre: "centre"
        };

        var getPointPosition = function(overlayPosition, pointPlace) {
            var pointX, pointY;

            if (pointPlace == ArrowPoint.centre || pointPlace == ArrowPoint.top || pointPlace == ArrowPoint.bottom) {
                var lowestX = Math.max(0, overlayPosition.x);
                var highestX = Math.min(config.canvasResizeWidth, overlayPosition.x + overlayPosition.w);
                pointX = tools.clamp(borderRadius, (highestX + lowestX - arrowWidth) / 2, config.canvasResizeWidth - borderRadius);
            }
            else if (pointPlace == ArrowPoint.left) {
                pointX = overlayPosition.x - arrowLength;
            }
            else {
                pointX = overlayPosition.x + overlayPosition.w - arrowLength;
            }

            if (pointPlace == ArrowPoint.centre || pointPlace == ArrowPoint.left || pointPlace == ArrowPoint.right) {
                var lowestY = Math.max(0, overlayPosition.y);
                var highestY = Math.min(config.canvasResizeHeight, overlayPosition.y + overlayPosition.h);
                pointY = tools.clamp(borderRadius, (highestY + lowestY - arrowWidth) / 2, config.canvasResizeHeight - borderRadius);
            }
            else if (pointPlace == ArrowPoint.top) {
                pointY = overlayPosition.y - arrowLength;
            }
            else {
                pointY = overlayPosition.y + overlayPosition.h - arrowLength;
            }
            return {x: Math.round(pointX), y: Math.round(pointY)};
        };

        var getBoxPosition = function(pointDirection, pointPosition) {
            var boxX, boxY;

            if (pointDirection == ArrowPoint.left || pointDirection == ArrowPoint.right) {
                var preferredRolloverY = tools.clamp(pointPosition.y - rolloverHeight + arrowWidth + borderRadius,
                    (config.canvasResizeHeight - rolloverHeight - arrowWidth) / 2,
                    pointPosition.y - arrowWidth - borderRadius);

                boxY = tools.clamp(0,preferredRolloverY,config.canvasResizeHeight - rolloverHeight);

                if (pointDirection == ArrowPoint.left)
                    boxX = pointPosition.x - rolloverWidth - 1;
                else
                    boxX = pointPosition.x + arrowLength + arrowLength;
            }
            else {
                var preferredRolloverX = tools.clamp(pointPosition.x - rolloverWidth + arrowWidth + borderRadius,
                    (config.canvasResizeWidth - rolloverWidth - arrowWidth) / 2,
                    pointPosition.x - borderRadius);

                boxX = tools.clamp(0,preferredRolloverX,config.canvasResizeWidth - rolloverWidth);

                if (pointDirection == ArrowPoint.top)
                    boxY = pointPosition.y - rolloverHeight - 1;
                else
                    boxY = pointPosition.y + arrowLength + arrowLength;
            }
            return {x:Math.round(boxX), y:Math.round(boxY)};
        };


        var buildRolloverSettings = function(overlay) {
            var width = rolloverWidth;
            var height = rolloverHeight;
            var fullScreenBorder = 10;

            function setToFullScreen() {
                width = config.canvasResizeWidth - 2 * fullScreenBorder;
                height = config.canvasResizeHeight - 2 * fullScreenBorder;

                if ( width / height < aspectRatioMin )
                    height = width / aspectRatioMin;
                else if (width / height > aspectRatioMax)
                    width = height * aspectRatioMax;

                var x = (config.canvasResizeWidth - width) / 2;
                var y = (config.canvasResizeHeight - height) / 2;

                var boxPosition = {x: x, y: y, width:width, height:height};
                return {box:boxPosition, point:false, fullScreen: true};
            }

            if (rolloverWidth > config.canvasResizeWidth * 0.75
             || rolloverHeight > config.canvasResizeHeight * 0.75
             || rolloverHeight * rolloverWidth > config.canvasResizeWidth * config.canvasResizeHeight * 0.3   ) {
                return setToFullScreen();
            }

            var screenRect = overlay.getScreenDimensions();
            var place = workoutRolloverPlacement(screenRect);

            if (!place)
                return setToFullScreen();

            var pointPosition = getPointPosition(screenRect, place.point);
            var boxPosition = getBoxPosition(place.direction, pointPosition);
            var boxShape = $.extend(boxPosition, {width:width, height:height});

            return {point:pointPosition, box: boxShape, direction: place.direction};
        };

        var moveRollover = function(overlay) {
            var settings = buildRolloverSettings(overlay);

            if (settings.fullScreen) {
                killRollover();
                return;
            }

            divContainer.style.left = settings.box.x + "px";
            divContainer.style.top = settings.box.y + "px";
            divContainer.style.width = settings.box.width+"px";
            divContainer.style.height = settings.box.height+"px";

            if (settings.point)
                addArrows(settings.direction, settings.point.x, settings.point.y);
        };

        var activateRollover = function(overlay, rolloverData) {

            lastOverlay = overlay;

            if (currentRolloverCode != null) {
                if (currentRolloverCode == overlay.productCode) {
                    moveRollover(overlay);
                    return;
                }
                killRollover();
            }

            currentRolloverCode = overlay.productCode;
            currentRolloverSafeCode = overlay.safeProductCode;
            currentRolloverPageNumber = overlay.pageNumber;

            var settings = buildRolloverSettings(overlay);

            divContainer = document.createElement("div");
            divContainer.className = "yudu_rollover";
            divContainer.style.borderRadius = borderRadius + "px";
            divContainer.style.left = settings.box.x + "px";
            divContainer.style.top = settings.box.y + "px";
            divContainer.style.width = settings.box.width+"px";
            divContainer.style.height = settings.box.height+"px";

            var iframe = document.createElement("iframe");
            iframe.id = rolloverId;
            iframe.src = constants.rolloverTemplate;
            iframe.style.width = settings.box.width+"px";
            iframe.style.height = settings.box.height+"px";

            currentRolloverData = rolloverData;

            $(divContainer).append(iframe);
            $("#yudu_reader").append(divContainer);

            if (settings.point)
                addArrows(settings.direction, settings.point.x, settings.point.y);

            $(iframe).on('load', function() {onRolloverLoaded();})
        };

        var getScreenSpaceArrowOptions = function(x,y,w,h,forcePoint) {
            var checks = [
                {point: ArrowPoint.left, score: x - rolloverWidth, outOf: config.canvasResizeWidth},
                {point: ArrowPoint.right, score: (config.canvasResizeWidth - (x + w)) - rolloverWidth, outOf: config.canvasResizeWidth},
                {point: ArrowPoint.top, score: y - rolloverHeight, outOf: config.canvasResizeHeight},
                {point: ArrowPoint.bottom, score: (config.canvasResizeHeight - (y + h)) - rolloverHeight, outOf: config.canvasResizeHeight}
            ];

            var bestDirection = null;
            var bestSpareScore = 0;
            for (var i = 0, m = checks.length ; i < m ; i++) {
                var score = checks[i].score / checks[i].outOf;
                if (score > bestSpareScore) {
                    bestDirection = checks[i].point;
                    bestSpareScore = score;
                }
            }

            if (!bestDirection)
                return null;

            return {direction: bestDirection, point: forcePoint ? forcePoint : bestDirection};
        };

        var workoutRolloverPlacement = function(screenRect) {
            // check if offscreen
            if (screenRect.x > config.canvasResizeWidth
             || screenRect.y > config.canvasResizeHeight
             || screenRect.x < - screenRect.w
             || screenRect.y < - screenRect.h)
                return null;

             // First see where we have space for it
            var placement = getScreenSpaceArrowOptions(screenRect.x, screenRect.y, screenRect.w, screenRect.h);

            if (!placement)
                return getScreenSpaceArrowOptions(screenRect.x + screenRect.w / 2, screenRect.y + screenRect.h / 2, 0, 0, ArrowPoint.centre);

            return placement;
        };

        var buildArrow = function(x, y, direction, colour) {
            colour = colour || "#000";

            var arrow = document.createElement("div");
            arrow.className = "yudu_arrow";

            $(arrow).css({
                "left": x + "px",
                "top": y + "px",
                "border-width": arrowLength+"px"
            });

            // because firefox
            switch (direction) {
                case ArrowPoint.bottom:
                    arrow.style.borderBottomColor = colour;
                    break;
                case ArrowPoint.top:
                    arrow.style.borderTopColor = colour;
                    break;
                case ArrowPoint.left:
                    arrow.style.borderLeftColor = colour;
                    break;
                case ArrowPoint.right:
                    arrow.style.borderRightColor = colour;
                    break;
            }

            return arrow;
        };

        var addArrows = function(side, x, y) {

            if (arrow1)
                $(arrow1).remove();

            if (arrow2)
                $(arrow2).remove();

            var arrow1x = x, arrow2x = x;
            var arrow1y = y, arrow2y = y;

            var fillColour = $(divContainer).css("background-color");

            switch (side) {
                case ArrowPoint.right:
                    arrow1x += 1;
                    arrow2x += 2;
                    break;
                case ArrowPoint.left:
                    arrow2x -= 1;
                    break;
                case ArrowPoint.bottom:
                    arrow1y += 1;
                    arrow2y += 2;
                    break;
                case ArrowPoint.top:
                    arrow1y += 1;
                    break;
            }

            arrow1 = buildArrow(arrow1x, arrow1y, side);
            arrow2 = buildArrow(arrow2x, arrow2y, side, fillColour);

            $("#yudu_reader").append(arrow1);
            $("#yudu_reader").append(arrow2);
        };

        var onRolloverLoaded = function() {
            var iframeContents = $(getRolloverId).contents();

            if (currentRolloverData.name)
                iframeContents.find(productNameElement).text(currentRolloverData.name);

            iframeContents.find(productCodeElement).text(currentRolloverCode);

            if (currentRolloverData.price) {
                var numberForm = Number(currentRolloverData.price);
                var amount;

                if (isNaN(numberForm))
                    amount = currentRolloverData.price;
                else
                    amount = String(numberForm.toFixed(2));

                if (resources.yuduBook.orderForm && resources.yuduBook.orderForm.currency)
                    amount = resources.yuduBook.orderForm.currency + "" + amount;

                iframeContents.find(productPriceElement).text(amount);
            }

            if (currentRolloverData.stock_level)
                iframeContents.find(productStockLevelElement).html(currentRolloverData.stock_level);

            if (currentRolloverData.desc)
                iframeContents.find(productDescriptionElement).html(currentRolloverData.desc);

            if (currentRolloverData.image) {
                var imageContainer = iframeContents.find(productImageElement);
                var image = new Image();
                image.src = currentRolloverData.image;
                imageContainer.append(image);
            }

            var cancelButton = iframeContents.find(productCancelButton);
            cancelButton.bind("click touch", killRollover);

            var purchaseButton = iframeContents.find(productPurchaseButton);
            purchaseButton.bind("click touch", onPurchaseButtonClicked);

            if (document.getElementById(rolloverId).contentWindow.instantiated) {
                document.getElementById(rolloverId).contentWindow.instantiated();
            }
        };

        var onPurchaseButtonClicked = function() {
            if (!currentRolloverData)
                return;

            if (currentRolloverData.url) {
                statistics.action({
                    actionType: statistics.events.overlay_productCode,
                    pageNumber: currentRolloverPageNumber,
                    productCode: currentRolloverSafeCode,
                    extraInfo: currentRolloverData.url
                });
                tools.openURL(currentRolloverData.url, true);
            }
            else if (config.orderFormEnabled) {
                statistics.action({
                    actionType: statistics.events.overlay_productCode,
                    pageNumber: currentRolloverPageNumber,
                    productCode: currentRolloverSafeCode,
                    extraInfo: "Cart"
                });
                orderForm.addItem(currentRolloverCode);
            }
        };

        var killRollover = function() {
            if (divContainer)
                $(divContainer).remove();
            if (arrow1)
                $(arrow1).remove();
            if (arrow2)
                $(arrow2).remove();
            divContainer = arrow1 = arrow2 = currentRolloverCode = currentRolloverData = lastOverlay = null;
        };

        var updatePosition = function() {
            if (lastOverlay)
                moveRollover(lastOverlay);
            else
                killRollover();
        };

        events.subscribe(events.ALL, events.DRAG, killRollover, false);
        events.subscribe(events.ALL, events.TAP, killRollover, false);
        events.subscribe(events.ALL, events.RESIZE, killRollover, false);
        events.subscribe(events.ALL, events.PAGE_CHANGED, killRollover, false);
        events.subscribe(events.ALL, events.ZOOM, killRollover, false);
        events.subscribe(events.ALL, events.TWO_UP_CHANGED, killRollover, false);
        events.subscribe(events.ALL, events.FIT_CHANGED, killRollover, false);
        events.subscribe(events.ALL, events.SHIFTER_SPRINGING, updatePosition, false);


        return {
            activateRollover: activateRollover,
            killRollover: killRollover,

            _private: {
                ArrowPoint: ArrowPoint,
                workoutRolloverPlacement: workoutRolloverPlacement,
                getScreenSpaceArrowOptions: getScreenSpaceArrowOptions
            }
        };

    });

define('model/productOverlay',['events', 'config', 'resources', 'model/overlay', 'ui/rollover', 'utils/tools', 'ui/orderForm', 'utils/statistics'],
    function(events, config, resources, overlay, rollover, tools, orderForm, statistics) {

        var EMITTER_NAME = "productOverlay";



        var ProductOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.productCode = info["@t"];
            this.safeProductCode = this.productCode.trim().replace(/ /g, "_").replace(/\./g, "_").toLowerCase();

            this.rectColour = config.productOverlayColour;
            this.defaultAlpha = config.transparentProductOverlays ? 0 : config.overlayAlpha;

            this.isRollover = resources.rollovers && !!resources.rollovers[this.safeProductCode];
            this.isProductLink = !this.isRollover && resources.priceList && resources.priceList[this.safeProductCode] && !!resources.priceList[this.safeProductCode].url;
            this.isProductOrderForm = !this.isRollover && resources.priceList && resources.priceList[this.safeProductCode] && !!resources.priceList[this.safeProductCode].price && config.orderFormEnabled;
            this.isValid = this.isRollover || this.isProductLink || this.isProductOrderForm;

            // Create a visual representation, the hit area and bind some events.
            this.init = function() {
                this.createRectAndHitArea();
                return this.rect;
            };

            this.mouseIn = function() {
                this.isMouseIn = true;
                this.fadeIn();
                if (this.isRollover && !resources.yuduBook.settings.rolloversAppearOnClick) {
                    rollover.activateRollover(this, resources.rollovers[this.safeProductCode]);
                }
            };

            // When overlay is clicked.
            this.clicked = function() {
                if (this.isProductLink) {
                    statistics.action({
                        actionType: statistics.events.overlay_productCode,
                        pageNumber: this.pageNumber,
                        productCode: this.safeProductCode,
                        extraInfo: resources.priceList[this.safeProductCode].url
                    });
                    tools.openURL(resources.priceList[this.safeProductCode].url, true);
                    return;
                }
                if (this.isProductOrderForm) {
                    statistics.action({
                        actionType: statistics.events.overlay_productCode,
                        pageNumber: this.pageNumber,
                        productCode: this.safeProductCode,
                        extraInfo: "Cart"
                    });
                    orderForm.addItem(this.productCode);
                    return;
                }
                if (this.isRollover) {
                    statistics.action({
                        actionType: statistics.events.overlay_productCode,
                        pageNumber: this.pageNumber,
                        productCode: this.safeProductCode,
                        extraInfo: "Rollover"
                    });
                    rollover.activateRollover(this, resources.rollovers[this.safeProductCode]);
                }
            };

        };
        ProductOverlay.prototype = overlay.Overlay.prototype;

        return {
            ProductOverlay: ProductOverlay,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('model/contentOverlay',['events', 'constants', 'config', 'model/overlay', 'utils/tools', 'utils/encryptedResourceFetchingUtils'],
    function(events, constants, config, overlay, tools, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "contentOverlay";

        var ContentOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            var self = this;
            this.triggerableId = info["@id"];
            this.triggerTargetId = info["@toId"];
            this.triggerAlternateContentSrc = info["@trAltCntnt"];
            this.transparent = info["@transparent"] == 1;
            this.showAlternateContent = false;
            this.gif = null;

            this.rectColour = config.contentOverlayColour;

            this.init = function() {
                this.createRectAndHitArea();
                if (this.transparent) {
                    this.rect.alpha = 0;
                    this.flash = this.fadeIn = this.fadeOut = function() {};
                }
                return this.rect;
            };

            this.clicked = function() {
                if (this.triggerTargetId && this.rect.visible) {
                    if (this.triggerAlternateContentSrc) {
                        this.toggleContent();
                    }
                    events.emit(EMITTER_NAME, events.TRIGGER, this, {pageNumber: this.pageNumber, triggerTargetId: this.triggerTargetId});
                }
            };

            this.toggleContent = function() {
                this.showAlternateContent = !this.showAlternateContent;
                if (this.showAlternateContent) {
                    this.createImageContainer(this.triggerAlternateContentSrc);
                    this.flash = this.fadeIn = this.fadeOut = function() {};
                }
                else {
                    this.createRectAndHitArea();
                    if (this.transparent) {
                        this.rect.alpha = 0;
                        this.flash = this.fadeIn = this.fadeOut = function() {};
                    }
                    else {
                        this.flash = overlay.Overlay.prototype.flash;
                        this.fadeIn = overlay.Overlay.prototype.fadeIn;
                        this.fadeOut = overlay.Overlay.prototype.fadeOut;
                    }
                }
            };

            this.createImageContainer = function (source) {
                var isGif = source.split('.').pop() === 'gif';
                this.rect = new createjs.Container();
                var createImage = events.callback(this, function(processedSource) {
                    this.image = new createjs.Bitmap(processedSource);
                    this.image.image.onload = events.callback(this, function () { self.rescaleImage(isGif) });
                });
                encryptedResourceFetchingUtils.useResourceAsCallbackArgument(source, createImage);
            };

            this.rescaleImage = function(isGif) {
                if (isGif) {
                    this.rescaleGif();
                } else {
                    this.rescaleStaticImage();
                }
            };

            this.rescaleGif = function() {
                this.gif = $('#' + this.id + 'gif')[0];
                if (!this.gif) {
                    this.gif = document.createElement('img');
                    this.gif.id = this.id + 'gif';
                    this.gif.src = this.image.image.src;
                    this.gif.pointerEvents = 'none';
                    $('#yudu_overlays')[0].appendChild(this.gif);
                }

                var position = this.getScreenDimensions();
                $(this.gif).css({
                    position: "absolute",
                    left: position.x * config.pixelDensity + "px",
                    top: position.y * config.pixelDensity + "px",
                    width: position.w * config.pixelDensity + "px",
                    height: position.h * config.pixelDensity + "px",
                });
            };

            this.rescaleStaticImage = function() {
                this.image.scaleX = this.width / this.image.image.width;
                this.image.scaleY = this.height / this.image.image.height;
                this.image.set({x: this.x, y: this.y});
                this.rect.addChild(this.image);
            };

            this.handleTap = function(tapPoint) {
                if (this.rect.visible) {
                    return overlay.Overlay.prototype.handleTap.call(this, tapPoint);
                }
                return false;
            };

            this.triggerToggle = function() {
                this.rect.visible = !this.rect.visible;
                this.triggerAutoPlay();
            };

            this.triggerOff = function() {
                this.rect.visible = false;
            };

            this.checkIfEventShouldDisableMedia = function(event, optionalElement) {
                /*
                 Checking if a video is fullscreen fixes the problem on iOS where if you fullscreen a video and then
                 rotate the screen (specifically: trigger a TWO_UP_CHANGED event) the video goes black due to the
                 $(this.domElement).hide(); in this.disableMedia (but the audio keeps playing).
                 Unsurprisingly this also doesn't work on IE - on the surface I tested it on, rather than just
                 only playing the audio like iOS it simply showed a black screen that you couldn't get out of! Magical.

                 Checking if there is an element fullscreen means we can allow fullscreen youtube videos to rotate and
                 continue to play. This doesn't unfortunately work on iOS though as they haven't implemented the fullscreen
                 API properly yet.
                 */
                return !(this.showingPlaceHolder || tools.isElementFullScreen(optionalElement) || event.type == events.SHOWHIDE_TOOLBAR ||
                    (event.type == events.TRIGGER && this.rect.visible && this.triggerableId == event.data.triggerTargetId));
            };
        };

        return {
            ContentOverlay: ContentOverlay,
            EMITTER_NAME: EMITTER_NAME
        };
    });
define('ui/customControls',['events', 'config', 'resources'],
function(events, config, resources) {
    var CustomControls = function(mediaElement, parent, overlayWidth) {

        this.init = function() {
            this.rawControlsHeight = 25;
            this.rawFontSize = 10;
            this.rawFontMarginTop = 7;
            this.rawProgressMarginTop = 0.5;
            this.rawCharacterWidth = 5;

            this.parent = parent;
            this.mediaElement = mediaElement;
            this.mediaElement.controls = false;
            this.overlayWidth = overlayWidth;
            
            this.createDOM();
            this.resizeControls();
            this.addCallbacks();
        };

        this.createDOM = function(){
                this.mediaDiv = document.createElement('div');
                this.mediaDiv.className = "media-wrapper";
                this.mediaDiv.appendChild(this.mediaElement)

                this.controlsDiv = document.createElement('div');
                this.controlsDiv.className = "custom-controls";

                if (resources.yuduBook.settings.androidVideoControlsStyle === "INTERNAL") {
                    this.controlsDiv.classList.add("custom-controls-internal");
                }

                this.playpause = document.createElement("button");
                this.playpause.className = "play-button";
                this.playpause.setAttribute("data-state", "playing");
                this.controlsDiv.appendChild(this.playpause);

                this.currentTime = document.createElement("div");
                this.currentTime.className = "time";
                this.controlsDiv.appendChild(this.currentTime);

                this.maxTime = document.createElement("div");
                this.maxTime.className = "time";
                this.controlsDiv.appendChild(this.maxTime);

                this.progressDiv = document.createElement('div');
                this.progressDiv.className = "progress";
                this.progress = document.createElement("progress");
                this.progressDiv.appendChild(this.progress);
                this.progress.className = "progress-bar";
                this.progress.setAttribute("value", "0");
                this.progress.setAttribute("min", "0");
                this.controlsDiv.appendChild(this.progressDiv);

                this.mute = document.createElement("button");
                this.mute.className = "mute-button";
                this.mute.setAttribute("data-state", "notMuted");
                this.controlsDiv.appendChild(this.mute);

                this.parent.appendChild(this.mediaDiv);
                this.parent.appendChild(this.controlsDiv);
            };

        this.resizeControls = function(){
            var controlsHeight = this.densityConvertedPixels(this.rawControlsHeight);
            var fontSize = this.densityConvertedPixels(this.rawFontSize);
            var fontMarginTop = this.densityConvertedPixels(this.rawFontMarginTop);
            var progressMarginTop = this.densityConvertedPixels(this.rawProgressMarginTop);

            this.mediaDiv.style.height = 'calc(100% - ' + controlsHeight + ')';
            this.controlsDiv.style.height = controlsHeight;
            this.playpause.style.height = controlsHeight;
            this.playpause.style.width = controlsHeight;
            this.mute.style.height = controlsHeight;
            this.mute.style.width = controlsHeight;
            this.currentTime.style.height = controlsHeight;
            this.currentTime.style.fontSize = fontSize;
            this.currentTime.style.marginTop = fontMarginTop;
            this.maxTime.style.height = controlsHeight;
            this.maxTime.style.fontSize = fontSize;
            this.maxTime.style.marginTop = fontMarginTop;
            this.progressDiv.style.height = controlsHeight;
            this.progressDiv.style.marginTop = progressMarginTop;

            this.resizeVariableControls();
        };

        this.resizeVariableControls = function(){
            var timeWidth = (this.maxTime.innerHTML.length > 5 ? this.maxTime.innerHTML.length :5) * this.rawCharacterWidth;
            this.currentTime.style.width = this.densityConvertedPixels(timeWidth);
            this.maxTime.style.width = this.densityConvertedPixels(timeWidth);

            //if the space left for the progress bar is less than the width of two buttons, it isn't usable. Hide it
            if (this.overlayWidth - 2 * this.rawControlsHeight -2 * timeWidth < 2 * this.rawControlsHeight) {
                this.progressDiv.style.width = '0px';
            } else {
                this.progressDiv.style.width = 'calc(99% - ' + this.densityConvertedPixels(2* this.rawControlsHeight + 2 * timeWidth) + ')';
            }
        };

        this.densityConvertedPixels = function(x){
            return x * config.pixelDensity + 'px';
        };

        this.addCallbacks = function(){
            events.yuduAddEventListener(this.playpause, 'click', events.callback(this, this.onPlayPause));
            events.yuduAddEventListener(this.mute, 'click', events.callback(this, this.onMute));
            events.yuduAddEventListener(this.progress, 'click', events.callback(this, this.setProgress));
            events.yuduAddEventListener(this.mediaElement, 'loadedmetadata', events.callback(this, this.setProgressMax));
            events.yuduAddEventListener(this.mediaElement, 'timeupdate', events.callback(this, this.updateProgress));
            events.yuduAddEventListener(this.mediaElement, 'play', events.callback(this, this.changePlayPauseButtonState));
            events.yuduAddEventListener(this.mediaElement, 'pause', events.callback(this, this.changePlayPauseButtonState));
        };

        this.onPlayPause = function(){
            if (this.mediaElement.paused || this.mediaElement.stopped) {
                this.mediaElement.play();
            }
            else {
                this.mediaElement.pause();
            }
        };

        this.onMute = function(){
            this.mediaElement.muted = !this.mediaElement.muted;
            if (this.mediaElement.muted){
                this.mute.setAttribute("data-state", "muted");
            } else {
                this.mute.setAttribute("data-state", "notMuted");
            }
        };

        this.setProgressMax = function(){
            this.progress.setAttribute("max", this.mediaElement.duration);
            this.maxTime.innerHTML = " " + this.parseTime(this.mediaElement.duration);
            this.resizeVariableControls();
        };

        this.updateProgress = function(){
            if (!this.progress.getAttribute('max')) {
                this.setProgressMax();
            }
            this.progress.setAttribute("value", this.mediaElement.currentTime);
            this.currentTime.innerHTML = this.parseTime(this.mediaElement.currentTime) + "/";
        };

        this.setProgress = function(e) {
            var pos = e.offsetX / this.progress.offsetWidth;
            this.mediaElement.currentTime = pos * this.mediaElement.duration;
        };

        this.changePlayPauseButtonState = function() {
            if (this.mediaElement.paused || this.mediaElement.ended) {
                this.playpause.setAttribute('data-state', 'notPlaying');
            }
            else {
                this.playpause.setAttribute('data-state', 'playing');
            }
        };

        this.parseTime = function(time){
            var hours = parseInt(time / 3600, 10) || 0;
            var minutes = parseInt((time / 60) % 60, 10) || 0;
            var seconds = parseInt(time % 60, 10) || 0;

            seconds = (seconds < 10? "0" : "") + seconds.toString();
            minutes = (hours > 0 && minutes < 10? "0" : "") + minutes.toString() + ":";
            hours = (hours > 0? hours.toString() + ":" : "");

            return  hours + minutes + seconds;
        };

        this.init();
    };

    return {
        CustomControls: CustomControls
    };
});
define('model/audioOverlay',['events', 'constants', 'config', 'model/contentOverlay','utils/tools', 'ui/customControls'],
    function(events, constants, config, contentOverlay, tools, customControls) {


        var EMITTER_NAME = "audioOverlay";


        var AudioOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            contentOverlay.ContentOverlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.src = info["@t"];
            this.autoPlay = info["@ap"] == "1";

            this.beenPlayed = false;
            this.showingPlaceHolder = true;

            this.init = function() {
                this.subscribeToInteractionEvents(events.callback(this, this.handleInteraction));
                events.subscribe(events.ALL, events.SHIFTER_ZOOMING, events.callback(this, this.handleInteraction), false);
                this.setMinWidth(constants.minAudioVideoWidth);
                this.createMediaPlaceHolder();

                // OMG FIREFOX. WHAT HAPPENED TO YOU!!!!
                events.subscribe(events.ALL, events.RESIZE, events.callback(this, this.reposition), false);

                if (this.triggerableId) {
                    this.rect.visible = false;
                }

                return this.rect;
            };

            this.onPlay = function() {
                this.beenPlayed = true;
            };

            this.triggerAutoPlay = function() {
                if (this.autoPlay && this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.flash = this.fadeIn = this.fadeOut = this.toggleContent = function() {};

            this.clicked = function() {
                if (this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.enableMedia = function() {
                if (!this.showingPlaceHolder)
                    return;

                this.background.visible = false;
                this.button.visible = false;

                if (!this.domElement) {
                    // Currently iOS wont "hide" an audio element with display:none.
                    // If you wrap it in a div, and do it on that however. It's fine.
                    this.domElement = document.createElement('div');
                    this.audioElement = this.createDOMMediaElement('audio', this.src);
                    $(this.audioElement).css({width:"100%", height:"100%"});
                    this.interactiveOverlayContainer.appendChild(this.domElement);

                    if (tools.deviceType.isAndroid()){
                        new customControls.CustomControls(this.audioElement, this.domElement, this.getScreenDimensions().w);
                    } else {
                        this.domElement.appendChild(this.audioElement);
                    }
                }


                $(this.domElement).show();
                this.showingPlaceHolder = false;

                this.reposition();

                if (this.audioElement.readyState <= 2)
                    this.audioElement.load();
                this.audioElement.play();
                events.emit(events.ALL, events.MEDIA_TOGGLED);
            };

            this.disableMedia = function(event) {
                if (this.showingPlaceHolder || (event.type == events.TRIGGER && this.triggerableId == event.data.triggerTargetId && this.rect.visible))
                    return;

                if (event.type === events.TRIGGER && this.triggerableId !== event.data.triggerTargetId) {
                    this.audioElement.pause();
                    return;
                }

                this.background.visible = true;
                this.button.visible = true;
                this.audioElement.pause();
                $(this.domElement).hide();
                this.showingPlaceHolder = true;
                events.emit(events.ALL, events.MEDIA_TOGGLED);
            };

            this.handleInteraction = function(event) {
                if (event.type === events.PAGE_CHANGED || event.type === events.TRIGGER) {
                    this.disableMedia(event);
                    return;
                }

                if (this.showingPlaceHolder) {
                    return;
                }

                this.reposition();
            };

            this.reposition = function() {
                if (this.showingPlaceHolder)
                    return;

                var position = this.getScreenDimensions();

                $(this.domElement).css({
                    position: "absolute",
                    left: position.x * config.pixelDensity + "px",
                    top: position.y * config.pixelDensity + "px",
                    width: position.w * config.pixelDensity + "px",
                    height: position.h * config.pixelDensity + "px"
                });
            };

            this.triggerToggle = function() {
                this.rect.visible = !this.rect.visible;
                this.triggerAutoPlay();
            };

            this.triggerOff = function() {
                this.rect.visible = false;
            };
        };

        return {
            AudioOverlay: AudioOverlay
        };
    });
define('model/videoOverlay',['events', 'constants', 'config', 'resources', 'model/contentOverlay',
            'utils/tools', 'utils/statistics', 'ui/customControls'],
    function(events, constants, config, resources, contentOverlay,
             tools, statistics, customControls) {

        var EMITTER_NAME = "videoOverlay";
        var modulePrepared = false;
        var milestones = {
            absolute: 0,
            percentage: 0,
            finish: false
        };
        var milestonesEnabled = true;

        /**
         * Prepare the module for creating overlays
         * Initialises settings consistent between all overlays
         * Cannot be run during module initialisation due to dependencies on other modules
         *  that require for example the yuduBook to be loaded (not available during module initialisation)
         */
        var prepareModule = function() {
            var milestoneSettings;
            if (statistics.settings.eventSettings &&
                    statistics.settings.eventSettings[statistics.events.video_milestone_reached]) {
                milestoneSettings = statistics.settings.eventSettings[statistics.events.video_milestone_reached];
            }
            if (statistics.eventOverrides[statistics.events.video_milestone_reached]) {
                milestonesEnabled = false;
            }
            if (milestonesEnabled && milestoneSettings) {
                if (milestoneSettings.absolute) {
                    var absoluteMilestone = parseInt(milestoneSettings.absolute);
                    if (!isNaN(absoluteMilestone) && absoluteMilestone > 0) {
                        milestones.absolute = absoluteMilestone;
                    }
                }
                if (milestoneSettings.percentage) {
                    var percentMilestone = parseInt(milestoneSettings.percentage);
                    if (!isNaN(percentMilestone) && percentMilestone > 0) {
                        milestones.percentInt = percentMilestone;
                        milestones.percentage = percentMilestone / 100;
                        // if the milestone is a factor of 100, then it also tracks the "video finished" event
                        milestones.finish = 100 % percentMilestone == 0;
                    }
                }
            }
            modulePrepared = true;
        };


        var VideoOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            contentOverlay.ContentOverlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            if (!modulePrepared) { prepareModule(); }
            this.src = info["@t"];
            this.filename = info["@n"];
            this.altSrc = info["@altt"];
            this.altFilename = info["@altn"];
            this.autoPlay = info["@ap"] == "1";

            this.beenPlayed = false;
            this.duration = 0;
            this.lastProgress = 0;
            this.lastProgressWasPaused = true; // all videos start paused
            this.milestonePercentConverted = -1;

            this.domElement = false;
            this.showingPlaceHolder = true;

            /**
             * Inits the overlay by adding a video to the document
             */
            this.init = function() {
                this.setMinWidth(constants.minAudioVideoWidth);
                this.createMediaPlaceHolder();

                // OMG FIREFOX. WHAT HAPPENED TO YOU!!!!
                events.subscribe(events.ALL, events.RESIZE, events.callback(this, this.reposition), false);

                if (this.triggerableId) {
                    this.rect.visible = false;
                }

                return this.rect;
            };

            this.onPlay = function() {
                if (!this.beenPlayed) {
                    this.trackEvent({ actionType: statistics.events.video_watched });
                    this.beenPlayed = true;
                } else {
                    this.trackEvent({ actionType: statistics.events.video_resumed });
                }
            };

            this.triggerAutoPlay = function() {
                if (this.autoPlay && this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.flash = this.fadeIn = this.fadeOut = this.toggleContent = function() {};

            this.clicked = function() {
                if (this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.enableMedia = function() {
                if (!this.showingPlaceHolder)
                    return;

                this.background.visible = false;
                this.button.visible = false;

                if (!this.domElement) {
                    this.videoElement = this.createDOMMediaElement('video', this.src, this.altSrc);
                    // Need to use the "timeupdate" event to track whether a video has finished
                    events.yuduAddEventListener(this.videoElement, 'timeupdate',
                            events.callback(this, this.checkMilestoneProgress));
                    // If this is a Metro app
                    if(tools.deviceType.isMetro()) {
                        // Make videos reload once finished, because on Metro they often break upon completion
                        // and can't be replayed.
                        var func = function () { this.videoElement.load(); };
                        events.yuduAddEventListener(this.videoElement, "ended", events.callback(this, func), false);
                    }

                    if (tools.deviceType.isAndroid()){
                        this.domElement = document.createElement('div');
                        new customControls.CustomControls(this.videoElement, this.domElement, this.getScreenDimensions().w);
                    } else {
                        this.domElement = this.videoElement;
                    }
                    this.interactiveOverlayContainer.appendChild(this.domElement);
                    this.subscribeToInteractionEvents(events.callback(this, function(event) {
                        if (this.checkIfEventShouldDisableMedia(event, this.videoElement)) {
                            this.disableMedia();
                        }
                    }));
                }

                $(this.domElement).show();
                this.showingPlaceHolder = false;

                this.reposition();

                if (this.videoElement.readyState <= 2)
                    this.videoElement.load();
                this.videoElement.play();
            };

            this.disableMedia = function() {
                this.background.visible = true;
                this.button.visible = true;
                this.videoElement.pause();
                $(this.domElement).hide();
                this.showingPlaceHolder = true;
            };

            this.checkMilestoneProgress = function(event) {
                var newProgress = this.videoElement.currentTime;
                // update the duration cache to detect finished videos and aid milestone calculations
                if (this.duration != this.domElement.duration) {
                    this.updateVideoMetadataCache();
                }
                // sanity checks
                if (this.videoElement.paused) {
                    // videos seem to pause automatically on completion, which must be handled here since `ended`
                    //  is fired on seeking as well as playing, with no obvious way to distinguish between the two.
                    if (!this.lastProgressWasPaused && this.lastProgress < this.duration
                            && newProgress == this.duration) {
                        // require that the video was previously playing, and has now reached the end of the video
                        if (milestones.finish) {
                            this.trackEvent({
                                actionType: statistics.events.video_milestone_reached,
                                extraInfo: '100%'
                            });
                        }
                        this.trackEvent({ actionType: statistics.events.video_finished });
                        // note that this still does not catch milestones that fall between a video completion and the
                        //  `timeupdate` event that precedes it.
                    }
                    // otherwise, assume the player is seeking and ignore the event
                    this.lastProgress = newProgress;
                    this.lastProgressWasPaused = true;
                    return;
                } else {
                    this.lastProgressWasPaused = false;
                }
                if (newProgress <= this.lastProgress) {
                    // timestamp has decreased: must have seeked backwards
                    this.lastProgress = newProgress;
                    return;
                }
                // milestone calculations
                if (milestones.absolute > 0) {
                    this.checkIfTimestampHasCrossedMultipleOfBoundary(this.lastProgress, newProgress,
                            milestones.absolute, true);
                }
                if (milestones.percentage > 0) {
                    if (this.milestonePercentConverted > 0) {
                        // having updated the metadata cache, only calculate if the (absolute) converted percent milestone is now positive
                        this.checkIfTimestampHasCrossedMultipleOfBoundary(this.lastProgress, newProgress,
                                this.milestonePercentConverted, false);
                    }
                }
                this.lastProgress = newProgress;
            };

            this.checkIfTimestampHasCrossedMultipleOfBoundary = function(oldT, newT, boundaryT, wasAbsolute) {
                if (oldT <= 0 || newT <= 0 || boundaryT <= 0) {
                    return false;
                }
                var oldProgressModulo = oldT % boundaryT;
                var newProgressModulo = newT % boundaryT;
                if (newProgressModulo < oldProgressModulo) {
                    // new timestamp has crossed an absolute timestamp boundary
                    var multiple = Math.floor(newT / boundaryT);
                    var milestone;
                    if (wasAbsolute) {
                        milestone = '' + (multiple * milestones.absolute) + 's';
                    } else {
                        milestone = '' + (multiple * milestones.percentInt) + '%';
                    }
                    this.trackEvent({
                        actionType: statistics.events.video_milestone_reached,
                        extraInfo: milestone
                    });
                    return true;
                }
                return false;
            };

            this.updateVideoMetadataCache = function() {
                this.duration = this.videoElement.duration;
                if (milestones.percentage > 0) {
                    this.milestonePercentConverted = milestones.percentage * this.duration;
                }
            };

            this.reposition = function() {
                if (this.showingPlaceHolder)
                    return;

                var position = this.getScreenDimensions();
                this.videoElement.width = position.w * config.pixelDensity;
                this.videoElement.height = position.h * config.pixelDensity;

                $(this.domElement).css({
                    position: "absolute",
                    left: position.x * config.pixelDensity + "px",
                    top: position.y * config.pixelDensity + "px"
                });
            };

            this.trackEvent = function(eventDetails) {
                if (!eventDetails.extraInfo) {
                    eventDetails.extraInfo = this.src;
                } else {
                    eventDetails.src = this.src;
                }
                eventDetails.pageNumber = this.pageNumber;
                eventDetails.videoName = this.filename;
                statistics.action(eventDetails);
            };

            this.triggerToggle = function() {
                this.rect.visible = !this.rect.visible;
                this.triggerAutoPlay();
            };

            this.triggerOff = function() {
                this.rect.visible = false;
            };
        };

        return {
            VideoOverlay: VideoOverlay
        };
    });

define('model/imageOverlay',['events', 'constants', 'config', 'model/contentOverlay', 'model/overlay'],
    function(events, constants, config, contentOverlay, overlay) {


        var EMITTER_NAME = "imageOverlay";


        var ImageOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            contentOverlay.ContentOverlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.src = info["@t"];

            this.image = null;

            this.init = function() {
                if (this.src.split('.').pop() === 'gif') {
                    events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, function() {
                        this.gif.style.display = shifter.isPageShowing(pageNumber) ? '' : 'none';
                    }), false);
                    events.subscribe(events.ALL, events.READER_TICK_STAGE_UPDATE, events.callback(this, function() {
                        this.rescaleImage(true)
                    }), false);
                }

                this.createImageContainer(this.src);

                if (this.triggerableId) {
                    this.rect.visible = false;
                }

                return this.rect;
            };

            this.flash = this.fadeIn = this.fadeOut = function() {};

            this.handleTap = function(tapPoint) {
                if (this.triggerTargetId && this.rect.visible) {
                    return overlay.Overlay.prototype.handleTap.call(this, tapPoint);
                }
                return false;
            };

            this.toggleContent = function() {
                this.showAlternateContent = !this.showAlternateContent;
                this.showAlternateContent ? this.createImageContainer(this.triggerAlternateContentSrc) : this.createImageContainer(this.src);
            };

            this.triggerToggle = function() {
                this.rect.visible = !this.rect.visible;
                this.triggerAutoPlay();
            };

            this.triggerOff = function() {
                this.rect.visible = false;
            };
        };

        return {
            ImageOverlay: ImageOverlay
        };
    });
define('ui/uiTools',['jquery', 'config', 'constants', 'events', 'shared/utils/appUtils', 'shared/utils/stringUtils', 'utils/tools'],
    function($, config, constants, events, appUtils, stringUtils, tools) {

        var EMITTER_NAME = 'uiTools';

        var lightbox;
        var iframeIdCount = 0;
        var sizeMessageId = '[scaleIframe]'; // used for onPage html overlays
        var scaleLightboxMessageId = '[scaleLightboxIframe]'; // used for html lightbox overlays
        var passOnResizeMessageId = '[passOnResize]'; // used to inform iframe of parent's resize event
            // this is necessary as, at least on iOS, the iframe is never itself resized
            // so resize listeners within a child window's context will never trigger.
        var clickBackId = '[clickOccur]';
        var nativePrefix = appUtils.nativeWrapperPrefixPrototcol;
        var nativeWinPrefix = appUtils.nativeWindowsAdditionalPrefixPrototcol;

        var resizeLightboxHandler = null;

        var currentLightboxHider = null;
        var hideLightboxHandler = function(){
            if (currentLightboxHider != null && typeof currentLightboxHider  == 'function') {
                currentLightboxHider();
            }
        };
        events.subscribe(events.ALL, events.CLOSE_LIGHTBOX, hideLightboxHandler, true);

        var scrollbarWidth = null;

        var getScrollbarWidth = function () {
            var outer = document.createElement("div");
            outer.style.visibility = "hidden";
            outer.style.width = "100px";
            outer.style.msOverflowStyle = "scrollbar";

            document.body.appendChild(outer);

            var widthNoScroll = outer.offsetWidth;
            // Force scrollbars
            outer.style.overflow = "scroll";

            // Add inner div
            var inner = document.createElement("div");
            inner.style.width = "100%";
            outer.appendChild(inner);

            var widthWithScroll = inner.offsetWidth;

            // Remove divs
            outer.parentNode.removeChild(outer);

            return widthNoScroll - widthWithScroll;
        };

        var setScrollbarWidth = function () {
            scrollbarWidth = getScrollbarWidth();
        };

        var createThrobber = function(width, height, parent) {
            var container = document.createElement("div");

            // When using percentage values for size, some browsers round fractional pixels differently depending on
            // the html element, which can lead to seeing fake borders, so we need to round ourselves.
            if ((width.indexOf("%") > 0 || height.indexOf("%") >= 0) && parent) {
                events.subscribe(events.ALL, events.RESIZE, function(){
                    onResize(container, width, height, parent);
                }, true);
                onResize(container, width, height, parent);
            }
            else {
                container.style.width = width;
                container.style.height = height;
            }

            var throbberWrapper = document.createElement("div");
            throbberWrapper.className = "yudu_throbberWrapper";
            container.appendChild(throbberWrapper);

            var throbber = document.createElement("ul");
            for (var i = 0; i < 8; i++) {
                throbber.appendChild(document.createElement("li"));
            }
            throbber.className = "yudu_throbber";
            throbberWrapper.appendChild(throbber);

            return container;
        };

        var onResize = function(element, width, height, parent) {
            if (width.indexOf("%") > 0) {
                $(element).width(Math.floor(parseInt(width) * (config.isDesktop ? parent.width() : config.canvasResizeWidth) / 100) + "px");
            }
            if (height.indexOf("%") > 0) {
                $(element).height(Math.floor(parseInt(height) * (config.isDesktop ? parent.height() : config.canvasResizeHeight) / 100) + "px");
            }
            if (resizeLightboxHandler) {
                resizeLightboxHandler();
            }
            passOnResizeMessage(element);
        };

        var resetIframeLink = function (iframe, originalHref) {
            iframe.contentWindow.location.assign(originalHref);
        };

        // If we are in an app and in an iframe, and we are trying to navigate to a link that has the query string
        // yuduBrowser=inapp, then we let the app handle the link and set the iframe to its previous location.
        var handleInAppBrowserLink = function (newLocationHref, iframe, originalHref) {
            // if this is an android app, then we need to pass the new link to it, therefore we send it to the window
            // itself so that it can be intercepted by the app.
            if (tools.deviceType.isAndroid()) {
                top.location.assign(newLocationHref);
            }
            // set the iframe to its previous location
            resetIframeLink(iframe, originalHref);
        };

        var createIframe = function(args) {
            var width = typeof args.width != 'undefined' ? args.width : '100%';
            var height = typeof args.height != 'undefined' ? args.height : '100%';
            var iframeElement = document.createElement("iframe");

            var argsCallback;

            if (typeof args.callback != 'undefined') {
                argsCallback = function () {
                    args.callback();
                };
            }

            var callbacks = function () {
                if (argsCallback) {
                    argsCallback();
                }
                // if we are in an app, we add a callback for when the user 'clicks' on an iframe, in an effort to
                // intercept the location change of the iframe
                if (tools.isThisAnApp()) {
                    events.yuduOn(
                        $(iframeElement).contents().find("body"),
                        config.clickAction,
                        events.callback(this, checkForLocationChange)
                    );
                }
            };

            // add all the callbacks, including the interceptor
            $(iframeElement).on('load', callbacks);

            // This function is a callback for when the user 'clicks' on an overlay, and it is meant to listen for a
            // location change on the iframe.
            var checkForLocationChange = function () {
                var originalLocation = this.contentWindow.location;
                var originalHref = originalLocation.href;
                var self = this;
                var numberOfIterations = 0;
                var maxNumberOfIterations = 100;
                var checkingInterval = 10;

                // set an interval that checks for a location change every checkingInterval in milliseconds, as many as
                // maxNumberOfIterations times. If the location has changed, then we call handleInAppBrowserLink
                var interval = setInterval(function () {
                        numberOfIterations += 1;
                        var frameWindow = self.contentWindow;
                        var newLocation = frameWindow ? frameWindow.location : null;
                        var newLocationHref = newLocation ? newLocation.href : null;
                        if (newLocationHref && originalHref !== newLocationHref
                                && newLocation.search.indexOf("yuduBrowser=inapp") !== -1) {
                            clearInterval(interval);
                            handleInAppBrowserLink(newLocationHref, self, originalHref);
                        } else if (numberOfIterations > maxNumberOfIterations) {
                            clearInterval(interval);
                        }
                }.bind(self, originalHref),
                checkingInterval
                );
            };

            iframeElement.src = typeof args.src != 'undefined' ? args.src : 'about:blank';
            if (typeof args.bgColour != 'undefined') {
                iframeElement.style.backgroundColor = "#" + args.bgColour;
            }
            // if not specified, default "interaction enabled" to `false`
            var interactionEnabled = typeof args.interactionEnabled != 'undefined' && args.interactionEnabled;
            // if not specified, default "support iOS scrolling" to `true` - it must be explicitly disabled
            var supportIosScrolling = typeof args.supportIosScrolling == 'undefined' || args.supportIosScrolling;

            // Setting iframe width and height doesn't work on mobile Safari, so we need (ugly) workaround.
            // If iframes behave oddly it might be that Apple changed this.
            var userAgent = navigator.userAgent;
            if (userAgent.match(/(iPad|iPhone|iPod)/g)) {
                iframeElement.style.width = "100%";
                iframeElement.style.height = "100%";

                // Need an extra div to prevent elastic scroll on body
                var iframeWrapper = document.createElement("div");
                iframeWrapper.style.height = "100%";
                // Key setting
                iframeWrapper.style.overflowY = "auto";
                iframeWrapper.appendChild(iframeElement);

                var iOSIframeContainer = document.createElement("div");
                iOSIframeContainer.style.width = width;
                iOSIframeContainer.style.height = height;
                iOSIframeContainer.style.overflow = interactionEnabled ? "auto" : "hidden";
                if (supportIosScrolling) {
                    iOSIframeContainer.style.WebkitOverflowScrolling = "touch";
                }
                iOSIframeContainer.appendChild(iframeWrapper);

                var iOSVersion = parseInt(/OS (\d+)/.exec(userAgent)[1]);
                if (iOSVersion > 6) {
                    attemptCommunicationWithIframeContent(iOSIframeContainer, null);
                }

                return iOSIframeContainer;
            }
            else {
                iframeElement.style.width = width;
                iframeElement.style.height = height;
                attemptCommunicationWithIframeContent(iframeElement, null);
                return iframeElement;
            }
        };

        var hideIframeScrollBars = function(iframeElement) {
            // Even though the interaction div stops user from scrolling in the iframe, it makes sense to hide the
            // scroll bars. Also, on Android devices there are a few seconds when the user can scroll through the
            // div (???); overflow=hidden on iframe fixes this.
            iframeElement.style.overflow = "hidden";
            // The above doesn't work on Chrome, so we need to use scrolling=no.
            iframeElement.scrolling = "no";
            // And of course, IE :D
            iframeElement.frameBorder = "0";
        };

        var attemptCommunicationWithIframeContent = function(element, message){
            if (element.id == "") {
                element.id = 'iframeElem' + iframeIdCount++;
            }

            var nonNullMessage = message;
            if (!message) {
                nonNullMessage = sizeMessageId + element.id + ':' + (scrollbarWidth + 2);
            }

            var iframe = element.tagName.toLowerCase() == "iframe" ? element : $('iframe', $(element))[0];

            try {
                iframe.contentWindow.postMessage(nonNullMessage, '*');
            } catch (e) {
                $(iframe).on('load', function() {
                    iframe.contentWindow.postMessage(nonNullMessage, '*');
                });
            }
        };

        var passOnResizeMessage = function(element) {
            var containerElement = $(element);
            var contentElement;
            if (1 > containerElement.children().length) { return; }
            contentElement = containerElement.children('.yudu_lightboxContent');
            if (1 == contentElement.length) {
                attemptCommunicationWithIframeContent(contentElement[0], passOnResizeMessageId);
            }
        };

        var shouldUseHighRes = function() {
            return config.pixelDensity >= 1.5;
        };

        /**
         * Creates an iframe lightbox with content pointing to specified address
         * @param lightboxParams - hash containing a combination of the following:
         *      w: lightbox width % (number). Defaults to 80 if not specified.
         *      h: lightbox height % (number). Defaults to 80 if not specified.
         *      callback: executes on lightbox launch (function)
         *      closeCallback: executes on lightbox close (function)
         *      src: address of lightbox content (string)
         *      interactionEnabled: (boolean)
         *      addCloseButton: (boolean)
         *      bgColour: background colour (string)
         *      animated: (boolean)
         * @returns {*}
         */
        var createIframeLightbox = function(lightboxParams) {
            var w = $.isNumeric(lightboxParams.w) ? lightboxParams.w : 80;
            var h = $.isNumeric(lightboxParams.h) ? lightboxParams.h : 80;
            var closeCallback = typeof lightboxParams.closeCallback !== "function"
                ? function() {} : lightboxParams.closeCallback;

            if (!lightbox) {
                lightbox = document.getElementById("yudu_lightboxBackground");
                events.yuduOn($(lightbox), config.clickAction, function(event) {
                    hideLightbox(lightboxParams.animated, event);
                });
            }

            var contentContainer = createThrobber(w + "%", h + "%", $(lightbox));
            contentContainer.className = "yudu_lightboxContentContainer";
            if (lightboxParams.animated) {
                contentContainer.style.backgroundColor = "transparent";
                events.yuduOn($(contentContainer), config.clickAction, function(event) { hideLightbox(false, event); });
            }
            else {
                events.yuduOn($(contentContainer), config.clickAction, function(event) { event.stopPropagation(); });
            }

            var iframeArgs = {
                src: lightboxParams.src,
                interactionEnabled: lightboxParams.interactionEnabled,
                bgColour: lightboxParams.bgColour,
                supportIosScrolling: lightboxParams.supportIosScrolling
            };
            if (typeof lightboxParams.callback == "function") {
                iframeArgs.callback = lightboxParams.callback;
            }
            var content = createIframe(iframeArgs);

            content.className = "yudu_lightboxContent";
            contentContainer.appendChild(content);
            lightbox.appendChild(contentContainer);

            currentLightboxHider = function (event) {
                hideLightbox(lightboxParams.animated, event);
                closeCallback();
            };

            if (lightboxParams.addCloseButton) {
                var x = ((w + 100) / 2);
                var y = ((h + 100) / 2);

                var clb = createCloseButton(x, y, currentLightboxHider);
                $(lightbox).append(clb);
            }

            resizeLightboxHandler = function(){
                contentContainer.style.left = (((config.isDesktop ? $(lightbox).width() : config.canvasResizeWidth) - $(contentContainer).width()) / 2) + "px";
                contentContainer.style.top = (((config.isDesktop ? $(lightbox).height() : config.canvasResizeHeight) - $(contentContainer).height()) / 2) + "px";
            };

            resizeLightboxHandler();

            return lightbox;
        };

        // Close button is anchored by the bottom left of the image
        var createCloseButton = function(x, y, action) {
            var closeBox = $('<button type="button" class="closeControl" tabindex="-1" id="close"></button>');
            if (!config.isDesktop) { closeBox.addClass('touchControl'); }

            var iconPath = constants.toolbarIconBasePath + (shouldUseHighRes() ? constants.toolbarIconHighResPrefix : "") + "close" + constants.toolbarIconFileExtension;
            var size = "24px";
            closeBox.css({
                'background-image': 'url(' + iconPath + ')',
                'width': size,
                'height': size,
                'left': x + "%",
                'bottom': y + "%"
            });
            events.yuduOn(closeBox, config.clickAction, action);

            return closeBox;
        };

        var hideLightbox = function(animated, event) {
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }

            resizeLightboxHandler = null;
            currentLightboxHider = null;

            if (animated) {
                $(lightbox).fadeOut(500, function () {
                    lightbox.innerHTML = "";
                });
            }
            else {
                $(lightbox).hide();
                lightbox.innerHTML = "";
            }
        };

        var onMessageReceived = function(event) {
            if (typeof event.data !== 'string')
                return;

            var scaleLightbox = event.data.substr(0, scaleLightboxMessageId.length) == scaleLightboxMessageId;

            var applyScaleTransform = function(element, scale) {
                var transform = "scale(" + scale + ")";
                element.css("-webkit-transform", transform);
                element.css("-moz-transform", transform);
                element.css("-ms-transform", transform);
                element.css("-transform", transform);

                var origin = "0 0 0";
                element.css("-webkit-transform-origin", origin);
                element.css("-moz-transform-origin", origin);
                element.css("-ms-transform-origin", origin);
                element.css("-transform-origin", origin);
            };

            if (event.data == "hideLightbox") {
                hideLightbox(false);
            }
            else if (event.data == "hideLightboxAnimated") {
                hideLightbox(true);
            }
            else if (event.data == "finishedLoadingEditionList") {
                $('.yudu_lightboxContent', $(lightbox)).hide();
                $('.yudu_lightboxContent', $(lightbox)).css("visibility", "visible");
                $('.yudu_throbberWrapper', $(lightbox)).hide();
                $('.yudu_lightboxContent', $(lightbox)).fadeIn(500);
                events.yuduOn($('.yudu_lightboxContentContainer', $(lightbox)), config.clickAction,
                    function(event) { event.stopPropagation(); });
            }
            else if (stringUtils.startsWith(event.data, sizeMessageId) || scaleLightbox) {
                var messageData = processSizeMessage(event.data);

                if (messageData.width != 0) {
                    var element = $(messageData.iframe);
                    var currentWidth;
                    var currentHeight;

                    if (scaleLightbox) {
                        var containerElement = element.parents('.yudu_lightboxContentContainer');
                        currentWidth = containerElement.width();
                        currentHeight = containerElement.height();
                    } else {
                        currentWidth = element.width();
                        currentHeight = element.height();
                    }

                    var iframeElement = (element[0].tagName.toLowerCase() == "iframe") ? element : $('iframe', element);

                    var newWidth = messageData.width;
                    var scale = currentWidth / newWidth;
                    var newHeight = currentHeight / scale;
                    var heightDiff = messageData.height - newHeight;

                    if (heightDiff >= 0 && heightDiff <= scrollbarWidth) {
                        scale = currentHeight / messageData.height;
                        newWidth = currentWidth / scale;
                        newHeight = messageData.height;
                    }
                    else if (heightDiff > scrollbarWidth && iframeElement[0].scrolling != "no") {
                        scale = currentWidth / (messageData.width + scrollbarWidth);
                        newWidth = messageData.width + scrollbarWidth;
                        newHeight = currentHeight / scale;
                    }

                    element.width(newWidth);
                    element.height(newHeight);

                    applyScaleTransform(element, scale);
                }
            }
            else if (stringUtils.startsWith(event.data, clickBackId)) {
                var messageData = processClickMessage(event.data);
                // So....now we spoof a jsHammer tap event.
                // I KNOW!! LEAVE ME ALONE!

                if (!messageData.iframe)
                    return;

                var jQelement = $(messageData.iframe);
                var getRect = messageData.iframe.getBoundingClientRect();

                var x = getRect.left + getRect.width * messageData.x / jQelement.width();
                var y = getRect.top + getRect.height * messageData.y / jQelement.height();

                events.emit(EMITTER_NAME, events.TAP, this, {
                    center: {
                        pageX: x,
                        pageY: y
                    },
                    stopDetect: function() {}
                });
            } else if (stringUtils.startsWith(event.data, nativePrefix)
                    || stringUtils.startsWith(event.data, nativeWinPrefix + nativePrefix)) {
                var parsedMsg = appUtils.parseMessage(event.data);
                if (parsedMsg.prefix === 'yudu') {
                    if (parsedMsg.origin === appUtils.targets.articleView) {
                        events.emit(EMITTER_NAME, events.MESSAGE_RECEIVED_FROM_ARTICLE_VIEW, this, parsedMsg);
                    } else {
                        // TODO comms: placeholder for the communications refactor
                        // suggested improvements:
                        //  - move message handling elsewhere
                        //  - actually handle non-article-view messages (currently these messages are not subscribed to)
                        events.emit(EMITTER_NAME, events.YUDU_PREFIXED_MESSAGE_RECEIVED, this, parsedMsg);
                    }
                }
            }
        };

        var processSizeMessage = function(message) {
            var split = message.split(']')[1];
            var data = split.split(':');

            return {
                iframe: document.getElementById(data[0]),
                id:     data[0],
                width:  parseInt(data[1]),
                height: parseInt(data[2])
            };
        };

        var processClickMessage = function(message) {
            var data = message.substr(clickBackId.length).split(':');

            return {
                iframe: document.getElementById(data[0]),
                id:     data[0],
                x:      parseInt(data[1]),
                y:      parseInt(data[2])
            };
        };

        events.yuduAddEventListener(window, "message", onMessageReceived);

        var enableScrollingWithoutDocumentBouncing = function(element) {
            var scrollableElementTouchmoveLastY;
            element = $(element);
            events.yuduOn(element, "touchstart", function(event){
                scrollableElementTouchmoveLastY = event.originalEvent.touches[0].clientY;
            });
            events.yuduOn(element, "touchmove", function(event){
                var elementPaddingTop = parseInt(element.css('padding-top'));
                var elementPaddingBottom = parseInt(element.css('padding-bottom'));
                var currentY = event.originalEvent.touches[0].clientY;
                if (!((element.scrollTop() + element.height() + elementPaddingTop + elementPaddingBottom == element[0].scrollHeight && currentY < scrollableElementTouchmoveLastY)
                    || (element.scrollTop() == 0 && currentY > scrollableElementTouchmoveLastY))) {
                    event.stopPropagation();
                }
                scrollableElementTouchmoveLastY = currentY;
            });
            events.yuduOn(element, "touchend", function(){
                scrollableElementTouchmoveLastY = undefined;
            });
        };

        return {
            createThrobber: createThrobber,
            createIframe: createIframe,
            shouldUseHighRes: shouldUseHighRes,
            hideIframeScrollBars: hideIframeScrollBars,
            createIframeLightbox: createIframeLightbox,
            hideLightbox: hideLightbox,
            setScrollbarWidth: setScrollbarWidth,
            enableScrollingWithoutDocumentBouncing: enableScrollingWithoutDocumentBouncing
        };
    });

define('model/htmlOverlay',['resources', 'model/overlay', 'events', 'ui/uiTools', 'utils/tools', 'jquery'],
    function(resources, overlay, events, uiTools, tools, $) {

        var shifter = false;

        var HtmlOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.url = info["@url"];
            this.src = info["@src"];
            this.interactionEnabled = info["@interactionEnabled"] === "true";
            this.requiresUserCredentials = info["@requiresUserCredentials"] === "true";
            this.triggerableId = info["@id"];

            this.iframe = null;

            this.iframeAttached = false;
            this.lastMessage = null;

            this.extraQueryString = info["extraQueryString"];

            if (this.extraQueryString) {
                this.url = this.url ? tools.addQueryStringToURL(this.url, this.extraQueryString) : this.url;
                this.src = this.src ? tools.addQueryStringToURL(this.src, this.extraQueryString) : this.src;
            }

            this.isInDom = false;
            this.isActive = false;

            this.init = function() {
                events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, this.pageChanged), false);

                this.rect = new createjs.Container();
                this.rect.x = this.x;
                this.rect.y = this.y;

                this.isActive = false;
                this.isInDom = false;

                if (!this.triggerableId)
                    this.createHtmlContainer();

                return this.rect;
            };

            this.removeHtmlContent = function() {
                if (this.domElement) {
                    $(this.domElement).remove();
                    this.domElement = null;
                }

                if (this.rect) {
                    this.rect.removeAllChildren();
                }

                this.isActive = false;
                this.isInDom = false;
                this.iframe = null;
                this.iframeAttached = false;
                this.lastMessage = null;

                // This will never get called for on-page html overlays at present because on-page overlays
                // are never actually destroyed. This is because keeping them allows us to maintain state.
                // TODO: optimization: clean up on-page overlays when no longer needed
                this.unsubscribeFromSendCredentialsCallback();
            };

            this.receiveMessage = function(message) {
                //verify that the message we have received came from the iframe this htmlOverlay object is controlling
                if (message.source === this.iframe.contentWindow) {
                    if (message.data == 'overlayAttached') {
                        //send on the last message if there is one
                        if (this.lastMessage) {
                            this.iframe.contentWindow.postMessage(this.lastMessage, '*');
                            this.lastMessage = null;
                        }
                        //indicate that the overlay is attached ready to receive messages
                        this.iframeAttached = true;
                    }
                }
            };

            /**
             * Sends the user's credentials to a HTML overlay that has the 'requiresUserCredentials' attribute
             * set to true. An overlay that uses the credentials should contain a listener for message
             * with a 'messageName' of 'userCredentialsAvailable'. The event data will contain
             * properties 'username', 'password' and 'context' in addition to 'messageName'.
             * The property 'context' contains properties 'editionTitle', 'editionId' and 'editionCurrentPage'.
             * The overlay can also listen to a message with property 'messageName' of 'userCredentialsNotAvailable',
             * which will be sent if no valid credentials are available.
             */
            this.sendCredentials = function() {
                if (!this.requiresUserCredentials || !this.iframe.contentWindow) {
                    return;
                }

                var credentials = window.yudu_readerApi.getCredentials();
                var pageOffset = resources.yuduBook.settings.introPage ? 0 : 1;
                var context = {
                    editionTitle: resources.yuduBook.settings.name,
                    editionId: resources.yuduBook.settings.id,
                    editionCurrentPage: pageNumber + pageOffset
                };

                if (credentials.username && credentials.password) {
                    this.iframe.contentWindow.postMessage({
                        messageName: "userCredentialsAvailable",
                        username: credentials.username,
                        password: credentials.password,
                        context: context
                    }, '*');
                }
                else {
                    this.iframe.contentWindow.postMessage({
                        messageName: "userCredentialsNotAvailable"
                    }, '*');
                }
            };

            this.sendCredentialsCallback = events.callback(this, this.sendCredentials);

            this.unsubscribeFromSendCredentialsCallback = events.callback(this, function() {
                events.unsubscribe(events.ALL, events.PUBLIC_API_LOGIN_STATE_CHANGED, this.sendCredentialsCallback);
            });
            
            this.createHtmlContainer = function() {
                this.isActive = true;
                this.isInDom = false;

                //listen for when the iframe is ready
                events.yuduAddEventListener(window, 'message', events.callback(this, this.receiveMessage), false);

                this.domElement = uiTools.createThrobber(this.width + "px", this.height + "px");
                this.htmlContent = uiTools.createIframe({
                    width: this.width + "px",
                    height: this.height + "px",
                    callback: events.callback(this, function() {
                        setTimeout(events.callback(this, function(){
                            $('.yudu_throbberWrapper', $(this.domElement)).hide();
                            $(this.htmlContent).css("visibility", "visible");
                        }), 100);

                        // Send the credentials to the overlay on creation
                        this.sendCredentials();

                        // If the login details are updated after the overlay is created (like in wrapper-apps),
                        // subscribe to the change in login details, and then try to pass the credentials to the
                        // overlays again
                        events.subscribe(events.ALL, events.PUBLIC_API_LOGIN_STATE_CHANGED,
                            this.sendCredentialsCallback);
                    }),
                    src: this.url ? this.url : this.src,
                    interactionEnabled: this.interactionEnabled
                });
                $(this.htmlContent).css("visibility", "hidden");
                //find the iframe that just got created (on iOS the iframe is embedded in 2 divs, see createIframe())
                this.iframe = this.htmlContent.tagName.toLowerCase() == "iframe" ? this.htmlContent : $('iframe', $(this.htmlContent))[0];

                this.domElement.appendChild(this.htmlContent);

                if (!this.interactionEnabled) {
                    uiTools.hideIframeScrollBars($("iframe", this.domElement)[0]);
                }

                this.rect.addChildAt(new createjs.DOMElement(this.domElement));
                this.toggleVisibility();
            };

            this.pageChanged = function() {
                if (!this.isActive)
                    return;

                this.toggleVisibility();
            };

            this.sendMessage = function(message) {
                if (this.iframeAttached) {
                    this.iframe.contentWindow.postMessage(message, '*');
                } else {
                    this.lastMessage = message;
                }
            };

            this.toggleVisibility = function() {
                if (shifter.isPageShowing(pageNumber)) {
                    this.addToDom(true);
                    $(this.domElement).show();
                    this.sendMessage('overlayVisible');
                } else {
                    this.addToDom(false);
                    if (this.isInDom) {
                        $(this.domElement).hide();
                    }
                    this.sendMessage('overlayNotVisible');
                }
            };

            this.addToDom = function(force) {
                if (!this.isInDom && (force || shifter.isPageInTray(pageNumber))) {
                    this.isInDom = true;
                    this.interactionEnabled ? this.interactiveOverlayContainer.appendChild(this.domElement) : this.overlayContainer.appendChild(this.domElement);
                }
            };

            this.flash = this.fadeIn = this.fadeOut = function() {};

            this.handleTap = function(tapPoint) {
                return (this instanceof HtmlOverlay) ? false : overlay.Overlay.prototype.handleTap.call(this, tapPoint);
            };

            this.hide = function() {
                if (!this.rect || !this.isActive || !this.isInDom)
                    return;

                this.domElement.style.WebkitTransform = "translate(0px, -9999px)";
                this.domElement.style.transform = "translate(0px, -9999px)";
            };

            this.triggerToggle = function() {
                if (!this.rect)
                    return;

                if (this.isActive) {
                    if (this.isInDom)
                        this.removeHtmlContent();
                }
                else {
                    this.createHtmlContainer();
                }
            };

            this.triggerOff = function() {
                this.removeHtmlContent();
            };
        };

        return {
            HtmlOverlay: HtmlOverlay,
            setShifter: events.callback(this, function(aShifter) { shifter = aShifter; })
        };
    });

define('model/launchableHtmlOverlay',['events', 'config', 'model/overlay', 'model/htmlOverlay', 'ui/uiTools', 'utils/encryptedResourceFetchingUtils'],
    function(events, config, overlay, htmlOverlay, uiTools, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "launchableHtmlOverlay";

        var LaunchableHtmlOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            htmlOverlay.HtmlOverlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.imageSrc = info["@imageSrc"];
            this.hoverImageSrc = info["@hoverImageSrc"];

            this.rectColour = config.launchableHtmlOverlayColour;

            this.init = function() {
                if (this.imageSrc) {
                    this.createImageContainer();
                    if (this.hoverImageSrc) {
                        this.createHoverImageContainer();
                    }
                }
                else {
                    this.createRectAndHitArea();
                }
                return this.rect;
            };

            this.createImageContainer = function () {
                this.checkForContainer();
                var createImage = events.callback(this, function (processedSource) {
                    this.image = new createjs.Bitmap(processedSource);
                    this.image.image.onload = events.callback(this, this.rescaleImage, this.image, true);
                });
                encryptedResourceFetchingUtils.useResourceAsCallbackArgument(this.imageSrc, createImage);
            };

            this.createHoverImageContainer = function () {
                this.checkForContainer();
                var createHoverImage = events.callback(this, function (processedSource) {
                    this.hoverImage = new createjs.Bitmap(processedSource);
                    this.hoverImage.image.onload = events.callback(this, this.rescaleImage, this.hoverImage, false);
                });
                encryptedResourceFetchingUtils.useResourceAsCallbackArgument(this.hoverImageSrc, createHoverImage);
            };

            this.rescaleImage = function(image, visible) {
                image.scaleX = this.width / image.image.width;
                image.scaleY = this.height / image.image.height;
                image.set({x: this.x, y: this.y});
                this.rect.addChild(image);
                if (!visible) {
                    image.alpha = 0;
                }
            };

            this.checkForContainer = function() {
                if (!this.rect) {
                    this.rect = new createjs.Container();
                }
            };

            this.clicked = function() {
                this.showContent();
            };

            this.showContent = function() {
                this.createContent();
                $(this.domElement).show();
            };

            this.createContent = function() {
                var lightboxArgs = {
                    w: 80,
                    h: 80,
                    callback: events.callback(this, function(){
                        $('.yudu_throbberWrapper', $(this.domElement)).hide();
                        $('.yudu_lightboxContent', $(this.domElement)).css("visibility", "visible");

                        // Set the iframe here so that htmlOverlay.sendCredentials() will point to the correct iframe
                        this.iframe = $(this.domElement).find('iframe')[0];

                        // Send the credentials to the overlay on creation
                        this.sendCredentials();

                        // If the login details are updated after the overlay is created (like in wrapper-apps),
                        // subscribe to the change in login details, and then try to pass the credentials to the
                        // overlays again
                        events.subscribe(events.ALL, events.PUBLIC_API_LOGIN_STATE_CHANGED,
                            this.sendCredentialsCallback);
                    }),
                    src: this.url ? this.url : this.src,
                    interactionEnabled: this.interactionEnabled,
                    addCloseButton: true,
                    animated: false,
                    closeCallback: this.unsubscribeFromSendCredentialsCallback
                };

                this.domElement = uiTools.createIframeLightbox(lightboxArgs);

                if (!this.interactionEnabled)
                {
                    this.disableUserInteractionWithIframe("80%", "80%");
                    events.yuduOn($(this.cover), "click touchstart", events.callback(this, this.stopPropagation));
                    this.cover.style.position = "fixed";
                    this.cover.style.top = "10%";
                    this.cover.style.right = "10%";
                }
                if (this.cover) {
                    this.domElement.appendChild(this.cover);
                }
            };

            this.disableUserInteractionWithIframe = function(width, height) {
                uiTools.hideIframeScrollBars($("iframe", this.domElement)[0]);

                this.cover = document.createElement("div");
                this.cover.style.width = width;
                this.cover.style.height = height;
                // We need to give it a background colour to make it respond to events in IE.
                this.cover.style.opacity = "0";
                this.cover.style.backgroundColor = "black";
            };

            this.flash = function() {
                if (!this.imageSrc) {
                    overlay.Overlay.prototype.flash.call(this);
                }
            };

            this.fadeIn = function() {
                if (!this.imageSrc) {
                    overlay.Overlay.prototype.fadeIn.call(this);
                } else if (this.hoverImageSrc) {
                    events.emit(EMITTER_NAME, events.LAUNCHABLE_HTML_HOVER_ACTION, this, { id: id });
                    this.hoverImage.alpha = 1;
                    this.image.alpha = 0;
                }
            };

            this.fadeOut = function() {
                if (!this.imageSrc) {
                    overlay.Overlay.prototype.fadeOut.call(this);
                } else if (this.hoverImageSrc) {
                    events.emit(EMITTER_NAME, events.LAUNCHABLE_HTML_HOVER_ACTION, this, { id: id });
                    this.hoverImage.alpha = 0;
                    this.image.alpha = 1;
                }
            };

            this.stopPropagation = function(event) {
                event.stopPropagation();
                event.preventDefault();
            };
        };

        return {
            LaunchableHtmlOverlay: LaunchableHtmlOverlay
        };
    });

define('model/urlContentOverlay',['events', 'constants', 'config', 'model/contentOverlay', 'ui/uiTools', 'utils/tools', 'jquery'],
    function(events, constants, config, contentOverlay, uiTools, tools, $) {

        var iframeIdCounter = 0;

        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        $('head').append(tag);

        var UrlContentOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            contentOverlay.ContentOverlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.src = "https://www.youtube.com/embed/" + (tools.getYouTubeUrlPattern().exec(info["@t"]))[1] + "?enablejsapi=1";
            this.autoPlay = info["@ap"] == "1";

            this.domElement = false;
            this.showingPlaceHolder = true;
            this.beenPlayed = false;
            this.loaded = false;

            this.init = function() {
                this.subscribeToInteractionEvents(events.callback(this, function(event) {
                    if (this.checkIfEventShouldDisableMedia(event)) {
                        this.disableMedia();
                    }
                }));
                this.setMinWidth(constants.minAudioVideoWidth);
                this.createMediaPlaceHolder();

                events.subscribe(events.ALL, events.RESIZE, events.callback(this, this.reposition), false);

                if (this.triggerableId) {
                    this.rect.visible = false;
                }

                return this.rect;
            };

            this.flash = this.fadeIn = this.fadeOut = this.toggleContent = function() {};

            this.clicked = function() {
                if (this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.enableMedia = function() {
                if (!this.showingPlaceHolder)
                    return;

                this.background.visible = false;
                this.button.visible = false;

                if (!this.domElement) {
                    this.createHtmlContainer();
                }
                if (this.domElement.parentNode != this.interactiveOverlayContainer) {
                    this.interactiveOverlayContainer.appendChild(this.domElement);
                    if (config.isDesktop) {
                        this.player = new YT.Player(this.iframeId, {
                            events: {
                                'onReady': events.callback(this, this.onPlayerReady)
                            }
                        });
                    }
                }
                else {
                    $(this.domElement).show();
                }
                this.showingPlaceHolder = false;
                if (this.loaded && config.isDesktop) {
                    this.player.playVideo();
                }

                this.reposition();
            };

            this.createHtmlContainer = function() {
                this.domElement = uiTools.createThrobber(this.width + "px", this.height + "px");
                this.htmlContent = uiTools.createIframe({
                    callback: events.callback(this, function() {
                        $('.yudu_throbberWrapper', $(this.domElement)).hide();
                        $(this.htmlContent).show();
                    }),
                    src: this.src,
                    interactionEnabled: true,
                    bgColour: "FFFFFF"
                });
                this.htmlContent.style.display = "none";
                this.domElement.appendChild(this.htmlContent);

                this.iframeId = "YTvideo" + iframeIdCounter++;
                $('iframe', this.domElement).attr("id", this.iframeId);
            };

            this.onPlayerReady = function() {
                this.beenPlayed = true;
                this.loaded = true;
                if (config.isDesktop) {
                    this.player.playVideo();
                }
            };

            this.disableMedia = function() {
                this.background.visible = true;
                this.button.visible = true;

                if (this.loaded && config.isDesktop) {
                    this.player.pauseVideo();
                }
                if (!config.isDesktop) {
                    this.interactiveOverlayContainer.removeChild(this.domElement);
                }
                else {
                    $(this.domElement).hide();
                }
                this.showingPlaceHolder = true;
            };

            this.reposition = function() {
                if (this.showingPlaceHolder)
                    return;

                var position = this.getScreenDimensions();
                this.domElement.style.width = (position.w * config.pixelDensity) + "px";
                this.domElement.style.height = (position.h * config.pixelDensity) + "px";

                $(this.domElement).css({
                    position: "absolute",
                    left: position.x * config.pixelDensity + "px",
                    top: position.y * config.pixelDensity + "px"
                });
            };

            this.triggerAutoPlay = function() {
                if (this.autoPlay && this.rect.visible) {
                    this.enableMedia();
                }
            };

            this.triggerToggle = function() {
                this.rect.visible = !this.rect.visible;
                this.triggerAutoPlay();
            };

            this.triggerOff = function() {
                this.rect.visible = false;
            };
        };

        return {
            UrlContentOverlay: UrlContentOverlay
        };
    });
define('controllers/tray',['config', 'constants', 'easel', 'events', 'utils/tools', 'fetching/fetchHandler', 'resources'],
    function(config, constants, createjs, events, tools, fetchHandler, resources) {

        var EMITTER_NAME = "tray";

        var maximumLevelExtraZoom = 2;
        var scalingAllowedBeyondZoomStates = 2;
        var maxFakePageBars = 40;

        var touchStateGate = 20;


        var TrayStates = {
            default: "default",
            pinching: "pinch",
            interstitial: "inters",
            zooming: "zoom"
        };


        var Tray = function() {
            var self = this;
            this.pages = [];
            this.fakePages = [];
            this.container = new createjs.Container();
            this.length = 0;

            this.currentZoomStateIndex = 0;
            this.zoomStates = null;
            this.basePage = null;

            this.state = TrayStates.default;

            this.isCentre = false;

            this.touchState = null;


            this.setPages = function(pageA, pageB) {
                if (!pageA) {
                    this.empty();
                    return;
                }

                if (this.matchPages(pageA, pageB)) {
                    return;
                }

                this.mapOverPages(function(page) {
                    page.overlayLevel.hide();
                });

                this.basePage = pageA.getPageNumber();
                this.currentZoomStateIndex = 0;
                this.pages = [pageA];

                this.container.removeAllChildren();

                if (pageB) {
                    this.length = 2;
                    this.pages.push(pageB);
                    this.container.addChild(pageB.getContainer());
                    pageA.resetAlignments(createjs.Alignment.RIGHT);
                    pageA.overlayLevel.getContainer().mask = null;
                    pageA.overlayLevel.setOverlaysHitArea(pageA.page.width, pageA.page.height);
                    pageB.resetAlignments(createjs.Alignment.LEFT);
                }
                else {
                    this.length = 1;
                    pageA.resetAlignments(createjs.Alignment.CENTRE);
                }

                this.container.addChild(pageA.getContainer());

                this.updateZoomStates();

                var zoomLevel = this.zoomStates[this.currentZoomStateIndex];
                this.mapOverPages(function(page) {
                    page.prepareZoomLevel(zoomLevel.z);
                });

                if (pageB && resources.yuduBook.settings.centreShadowEnabled) {
                    var pageHeight = zoomLevel.height;
                    var shadowWidth = resources.yuduBook.settings.centreShadowWidth;

                    var centreShadow = new createjs.Shape().set({x: -(shadowWidth / 2), y: -(pageHeight / 2)});
                    centreShadow.graphics.beginFill("#000").drawRect(0, 0, shadowWidth, pageHeight);
                    centreShadow.alpha = resources.yuduBook.settings.centreShadowAlpha / 100;
                    var centreShadowBlurFilter = new createjs.BlurFilter(shadowWidth, 0, 1);
                    centreShadow.filters = [centreShadowBlurFilter];
                    centreShadow.cache(0, 0, shadowWidth, pageHeight);
                    this.container.addChild(centreShadow);
                }

                this.resnapSize();
                this.loadAllUnfetched();
                this.defaultState();
            };

            this.load = function() {
                if (this.isEmpty())
                    return;
                fetchHandler.newRequests();
                var zoomLevel = this.zoomStates[this.currentZoomStateIndex];
                this.mapOverPages(function(page) {
                    page.zoomLevels[zoomLevel.z].load();
                });
            };

            this.setIsCentre = function(isCentre) {
                this.isCentre = isCentre;
            };

            this.loadAllUnfetched = function() {
                if (this.isEmpty() || !this.isCentre)
                    return;

                var zoomLevel = this.zoomStates[this.currentZoomStateIndex];

                fetchHandler.newRequests();
                this.mapOverPages(function(page) {
                    fetchHandler.loadTiles(page.zoomLevels[zoomLevel.z], false, true);
                });
            };

            this.isStateChangeAllowed = function(oldState, newState) {
                if (oldState == TrayStates.default || newState == TrayStates.default)
                    return true;

                if (newState == TrayStates.zooming)
                    return true;

                if (newState == TrayStates.pinching && oldState == TrayStates.interstitial)
                    return true;

                return false;
            };

            this.defaultState = function() {
                this.state = TrayStates.default;
                this.touchState = null;
            };

            this.tryChangeState = function(newState) {
                if (this.state == newState)
                    return true;

                if (!this.isStateChangeAllowed(this.state, newState))
                    return false;

                this.state = newState;
                return true;
            };

            this.getLowestZoomStateZ = function() {
                return this.zoomStates ? this.zoomStates[0].z : 0;
            };

            this.getBasePage = function() {
                return this.basePage;
            };

            this.generateRawStates = function() {
                var zoomLevelCount = this.pages[0].zoomLevelCount;

                var rawStates = [];
                for (var i = 0, m = zoomLevelCount; i < m; i++) {
                    var rawSize = this.getRawContentSizeAtZoomLevel(i);
                    rawStates.push({z: i, scale: 1, width: rawSize.width, height: rawSize.height});
                }
                return rawStates;
            };

            this.findLowestFittingZoomLevel = function(rawStates) {
                // find lowest size bigger than the screen.
                var z = 0;
                if (config.fitOnlyWidth) {
                    while (rawStates[z].width < config.width && z < rawStates.length - 1)
                        z++;
                }
                else {
                    while (rawStates[z].height < config.height && rawStates[z].width < config.width && z < rawStates.length - 1)
                        z++;
                }
                return z;
            };

            this.applyMinMaxZoomLevels = function(zooms, smallestAllowedWidth, largestAllowedWidth) {
                for (var i = 0, m = zooms.length; i < m; i++) {
                    zooms[i].minScale = smallestAllowedWidth / zooms[i].width;
                    zooms[i].maxScale = largestAllowedWidth / zooms[i].width;
                }
                return zooms
            };

            this.generateZoomStates = function() {
                if (!this.pages.length || !this.pages[0]) {
                    return null;
                }

                var zooms = [];
                var rawStates = this.generateRawStates();

                var z = this.findLowestFittingZoomLevel(rawStates);

                var rawState = rawStates[z];
                var lowestScale = config.width / rawState.width;
                if (!config.fitOnlyWidth)
                    lowestScale = Math.min(lowestScale, config.height / rawState.height);

                var smallestAllowedWidth = rawState.width * lowestScale / scalingAllowedBeyondZoomStates;

                zooms.push({z: z, scale: lowestScale, width: rawState.width, height: rawState.height});

                if (lowestScale >= 0.9) // if the lowest scale is almost the full scale. Skip it!
                    z += 1;

                for (var i = z, m = rawStates.length; i < m; i++) {
                    rawState = rawStates[i];
                    zooms.push(rawState);
                }
                if (!config.disableExtraZoom){
                    zooms.push({z: rawState.z, scale: maximumLevelExtraZoom, width: rawState.width, height: rawState.height});
                }

                var largestAllowedWidth = rawState.width * maximumLevelExtraZoom * scalingAllowedBeyondZoomStates;
                return this.applyMinMaxZoomLevels(zooms, smallestAllowedWidth, largestAllowedWidth);
            };


            this.getRawContentSizeAtZoomLevel = function(z) {
                var maxHeight = 0;
                var totalWidth = 0;

                this.mapOverPages(function(page) {
                    var zoomLevel = page.zoomLevels[z].zoomLevel;
                    maxHeight = Math.max(maxHeight, zoomLevel.height);
                    totalWidth += zoomLevel.width;
                });

                return {width: totalWidth, height: maxHeight};
            };

            this.reposition = function(x) {
                this.container.x = x;
            };

            this.empty = function() {
                this.length = 0;
                this.basePage = null;
                this.zoomStates = null;
                this.mapOverPages(function(page) {
                    page.overlayLevel.hide();
                });
                this.pages = [];
                this.container.removeAllChildren();
            };

            this.show = function() {
                this.container.visible = true;
            };

            this.hide = function() {
                this.container.visible = false;
            };

            this.updateZoomStates = function() {
                this.zoomStates = this.generateZoomStates();
            };

            /**
             * Performs a zoom in the given direction on the current zoom level
             * @param direction when scaled = 0 an integer indicating number of levels to zoom
             * (positive = in, negative = out), when scaled = 1 the gesture scale.
             * @param x the x coordinate of the zoom centre
             * @param y the y coordinate of the zoom centre
             */
            this.zoom = function(direction, x, y, handleComplete) {
                // Get appropriate new zoom state.
                var newZoomIndex = Math.max(0, Math.min(this.currentZoomStateIndex + direction, this.zoomStates.length - 1));
                if (newZoomIndex != this.currentZoomStateIndex) {
                    this.zoomTo(newZoomIndex, x, y, undefined, handleComplete);
                    return;
                }

                if (typeof handleComplete !== 'undefined') {
                    handleComplete();
                }
            };

            this.zoomScale = function(scale, x, y) {
                if (!this.tryChangeState(TrayStates.pinching))
                    return;

                var pinchCentreX = (x - (config.width / 2) - this.container.x) / this.container.scaleX;
                var pinchCentreY = (y - (config.height / 2) - this.container.y) / this.container.scaleY;

                var zoomState = this.zoomStates[this.currentZoomStateIndex];
                this.container.scaleX = this.container.scaleY = Math.max(zoomState.minScale, Math.min(scale, zoomState.maxScale));

                var resPoint = this.container.localToGlobal(pinchCentreX, pinchCentreY);
                var newPosX = this.container.x + (x - resPoint.x);
                var newPosY = this.container.y + (y - resPoint.y);

                var boundX = config.width * 0.4 + zoomState.width * 0.5 * this.container.scaleX;
                var boundY = config.height * 0.4 + zoomState.height * 0.5 * this.container.scaleY;

                // this.container.x = Math.max(-boundX, Math.min(newPosX, boundX));
                // this.container.y = Math.max(-boundY, Math.min(newPosY, boundY));

                this.container.x = newPosX;
                this.container.y = newPosY;
            };

            this.zoomResolve = function(x, y) {
                var currentWidth = this.zoomStates[this.currentZoomStateIndex].width * this.container.scaleX;

                // Detect fluid scale end point at higher zoom level.
                if (this.currentZoomStateIndex >= this.zoomStates.length - 2) {
                    if (currentWidth >= this.zoomStates[this.currentZoomStateIndex].width && this.container.scaleX <= maximumLevelExtraZoom) {
                        this.tryChangeState(TrayStates.interstitial);
                        return;
                    }
                }

                var newZoomStateIndex = 0;
                var bestDiff = -100;
                // find best zoom state to move to:
                for (var i = 0, m = this.zoomStates.length; i < m; i++) {
                    var zState = this.zoomStates[i];
                    var actualWidth = zState.width * zState.scale;

                    var sizeDiff = Math.abs(actualWidth - currentWidth);
                    if (bestDiff < 0 || bestDiff > sizeDiff) {
                        bestDiff = sizeDiff;
                        newZoomStateIndex = i;
                    }
                    // early out once we are bigger (assume sizes are ordered ASC)
                    if (actualWidth > currentWidth) {
                        break;
                    }
                }

                this.zoomTo(newZoomStateIndex, x, y, true);
            };

            this.areAnyPagesAnimating = function() {
                this.checkOverPages(function(page) {
                    return createjs.Tween.hasActiveTweens(page.getContainer())
                });
            };

            this.stopTweens = function() {
                createjs.Tween.removeTweens(this.container);
            };

            this.zoomTo = function(newZoomStateIndex, x, y, force, handleComplete) {
                if (!this.zoomStates)
                    return;

                if (this.state == TrayStates.zooming && !force) {
                    return;
                }

                if (!this.tryChangeState(TrayStates.zooming)) {
                    return;
                }

                var currentZoomState = this.zoomStates[this.currentZoomStateIndex];
                var newZoomState = this.zoomStates[newZoomStateIndex];

                var animScale = (newZoomState.width * newZoomState.scale) / (currentZoomState.width);

                var changingZoomLevel = newZoomState.z != currentZoomState.z;
                var changingScale = animScale != this.container.scale;

                if (!changingZoomLevel && !changingScale) {
                    return false;
                }

                var pinchCentreX = (x - (config.width / 2) - this.container.x) / this.container.scaleX;
                var pinchCentreY = (y - (config.height / 2) - this.container.y) / this.container.scaleY;
                var resultantPositionX = this.container.x - (pinchCentreX * (animScale - this.container.scaleX));
                var resultantPositionY = this.container.y - (pinchCentreY * (animScale - this.container.scaleY));

                var boundPosition = this.boundPosition(resultantPositionX, resultantPositionY, newZoomState);

                // If we're changing zoomLevels - start getting it ready.
                if (changingZoomLevel) {
                    this.anticipatoryLoad(this.zoomStates[newZoomStateIndex],
                        boundPosition.x - this.container.x,
                        boundPosition.y - this.container.y);
                }

                //create a tween to transition us smoothly between the current and the new level
                createjs.Tween
                    .get(this.container)
                    .to({scaleX: animScale, scaleY: animScale, x: boundPosition.x, y: boundPosition.y}, constants.swapTweenTime, createjs.Ease.cubicInOut)
                    .call(function(z) {
                        this.defaultState();
                        this.currentZoomStateIndex = z;
                        this.resnapSize();
                        this.load();
                        if (typeof handleComplete !== 'undefined') {
                            handleComplete();
                        }
                    }, [newZoomStateIndex], this);
            };

            this.anticipatoryLoad = function(state, dx, dy) {
                fetchHandler.newRequests();
                this.mapOverPages(function(page) {
                    page.prepareZoomLevel(state.z);
                    page.zoomLevels[state.z].load(dx, dy);
                });
            };

            this.cancelTweens = function() {
                this.defaultState();
                createjs.Tween.removeTweens(this.container);
            };

            this.canDrag = function() {
                return (this.state != TrayStates.zooming && this.state != TrayStates.pinching);
            };

            this.resnapSize = function() {
                if (!this.zoomStates)
                    return;

                var currentState = this.zoomStates[this.currentZoomStateIndex];
                this.mapOverPages(function(page) {
                    page.endZoomOn(currentState.z);
                });

                this.setScale(currentState.scale);
            };

            this.setScale = function(scale) {
                this.defaultState();
                this.container.scaleX = this.container.scaleY = scale;
            };

            this.handleMove = function(dx, dy) {
                if (!this.touchState) {
                    this.touchState = { dx: dx,
                                        dy: dy,
                                        canPassX: false,
                                        canMove: false};
                }
                else {
                    this.touchState.dx += dx;
                    this.touchState.dy += dy;
                }

                if (this.touchState.canMove) {
                    var fullX = this.container.x + dx;

                    var resultantPosition = this.boundPosition(fullX, this.container.y + dy);
                    if (resultantPosition.x != this.container.x || resultantPosition.y != this.container.y) {
                        this.load();
                    }
                    this.container.x = resultantPosition.x;
                    this.container.y = resultantPosition.y;

                    return this.touchState.canPassX || !config.fitOnlyWidth ? fullX - this.container.x : 0;
                }

                if (this.touchState.dx * this.touchState.dx + this.touchState.dy * this.touchState.dy > touchStateGate) {
                    this.touchState.canMove = true;
                    this.touchState.canPassX = Math.abs(this.touchState.dx) > Math.abs(this.touchState.dy);
                }

                return 0;
            };

            this.moveEnd = function() {
                this.touchState = null;
            };

            this.setToTop = function() {
                var trayRect = this.getZoomBounds();
                var bounded = this.boundPosition(0, trayRect.height);
                this.container.y = bounded.y;
            };

            this.boundPosition = function(x, y, zoomState) {
                var halfWidth, halfHeight;
                if (zoomState) {
                    halfWidth = (zoomState.width * zoomState.scale) / 2;
                    halfHeight = (zoomState.height * zoomState.scale) / 2;
                } else {
                    var trayRect = this.getZoomBounds();
                    halfWidth = trayRect.width / 2;
                    halfHeight = trayRect.height / 2;
                }

                var xBound = halfWidth - Math.min(halfWidth, config.width / 2);
                var yBound = halfHeight - Math.min(halfHeight, config.height / 2);

                return {
                    x:  Math.max(-xBound, Math.min(x, xBound)),
                    y:  Math.max(-yBound, Math.min(y, yBound))
                }
            };

            this.getZoomBounds = function() {
                var zoomState = this.zoomStates[this.currentZoomStateIndex];
                var scale = this.state == TrayStates.interstitial ? this.container.scaleX : zoomState.scale;
                return {width: zoomState.width * scale, height: zoomState.height * scale};
            };

            this.resetZoom = function() {
                if (this.isEmpty() || !this.zoomStates)
                    return;

                this.cancelTweens();

                var currentState = this.zoomStates[0];
                this.mapOverPages(function(page) {
                    page.endZoomOn(currentState.z);
                });
                this.setScale(currentState.scale);
            };

            this.isEmpty = function() {
                return this.length == 0;
            };

            this.findPage = function(pageIndex) {
                for (var i = 0, m = this.pages.length; i < m; i++) {
                    if (this.pages[i].getPageNumber() == pageIndex) {
                        return this.pages[i];
                    }
                }
                return null;
            };

            this.hasPage = function(pageIndex) {
                if (this.findPage(pageIndex)) {
                    return true;
                }
                return false;
            };

            this.matchPages = function(pageA, pageB) {
                if (!pageA)
                    return this.isEmpty();

                if (!pageB)
                    return this.hasPage(pageA);

                return this.hasPage(pageA) && this.hasPage(pageB);
            };

            this.triggerShow = function() {
                this.mapOverPages(function(page) {
                    page.triggerShow();
                });
            };

            this.handleTap = function(tapPoint) {
                return this.checkOverPages(function(page) {
                    return page.handleTap(tapPoint);
                });
            };

            this.getScale = function() {
                return this.container.scaleX;
            };

            this.generateRandomGreyishColour = function() {
                var c = Math.floor(Math.random()*0x1F + 0xDB).toString(16);
                return '#' + c + c + c;
            };

            this.addFakePages = function(pageSkips) {
                if (!pageSkips || pageSkips < 0)
                    return 0;

                pageSkips = Math.min(maxFakePageBars, pageSkips);
                this.currentZoomStateIndex = 0;
                this.resnapSize();
                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                var shapes = [];

                var thickness = zoomState.width / Math.max(1, Math.log(pageSkips));
                var gap = thickness * 0.1;
                var endGap = thickness * 0.2;

                var startX = endGap + (config.width / 2) / zoomState.scale;
                var totalWidth = pageSkips * (thickness + gap) + endGap * 2;

                var height = zoomState.height;
                var y = -height / 2;

                for (var i = 0; i < pageSkips ; i++) {
                    var fakePage = new createjs.Shape();
                    var x = startX + i * (thickness + gap);
                    fakePage.graphics.beginFill(this.generateRandomGreyishColour()).drawRect(x, y, thickness, height);

                    shapes.push(fakePage);
                    this.container.addChild(fakePage);
                }

                this.fakePages = shapes;

                return totalWidth * zoomState.scale;
            };

            this.anim_fakePairToSingle = function(goLeft, handleComplete) {
                if (this.pages.length != 1)
                    return false;

                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                if (!zoomState)
                    return false;

                var page = this.pages[0].getContainer();
                page.x = goLeft ? -zoomState.width / 2 : zoomState.width / 2;

                createjs.Tween
                    .get(page, {override: true})
                    .to({x: 0}, constants.pageNumTransTime, createjs.Ease.cubicInOut)
                    .call(function() {
                        events.callback(self, self.applyMaskToOverlayContainer)();
                        if (typeof handleComplete !== 'undefined') {
                            handleComplete();
                        }
                    });
            };

            this.anim_fakeSingleToPair = function(goLeft, handleComplete) {
                if (this.pages.length != 2)
                    return false;

                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                if (!zoomState)
                    return false;

                var movingPage = goLeft ? 0 : 1;

                var page = this.pages[movingPage].getContainer();
                page.x = goLeft ? zoomState.width / 4 : -zoomState.width / 4;

                createjs.Tween
                    .get(page, {override: true})
                    .to({x: 0}, constants.pageNumTransTime, createjs.Ease.cubicInOut)
                    .call(handleComplete);
            };


            this.anim_fakeMoveToAdjacentTray = function(goLeft, handleComplete) {
                if (this.pages.length != 1)
                    return false;

                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                if (!zoomState)
                    return false;

                var page = this.pages[0].getContainer();
                var offset = (config.width) / zoomState.scale - zoomState.width / 2;
                page.x = goLeft ? offset : -offset;

                createjs.Tween
                    .get(page, {override: true})
                    .to({x: 0}, constants.pageNumTransTime, createjs.Ease.cubicInOut)
                    .call(function callback() {
                        events.callback(self, function() {self.pages[0].overlayLevel.hideAllTriggeredOverlaysAndRestoreTriggerMainContent(); self.applyMaskToOverlayContainer();})();
                        if (typeof handleComplete !== 'undefined') {
                            handleComplete();
                        }
                    });
            };

            this.anim_fakeMoveFromAdjacentTray = function(goLeft, handleComplete) {
                if (this.pages.length != 2)
                    return false;

                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                if (!zoomState)
                    return false;

                var movingPage = goLeft ? 0 : 1;
                var page = this.pages[movingPage].getContainer();
                var offset = (config.width) / zoomState.scale - zoomState.width / 2;
                page.x = goLeft ? -offset : offset;

                createjs.Tween
                    .get(page, {override: true})
                    .to({x: 0}, constants.pageNumTransTime, createjs.Ease.cubicInOut)
                    .call(handleComplete)
            };

            this.applyMaskToOverlayContainer = function() {
                if (this.pages.length > 0) {
                    this.pages[0].overlayLevel.getContainer().mask = this.pages[0].mask;
                    this.pages[0].overlayLevel.setOverlaysHitArea(this.pages[0].page.width, this.pages[0].page.height);
                }
            };

            this.applyMaskToOverlayContainerIfNecessary = function() {
                if (this.pages.length == 1 && !this.pages[0].overlayLevel.getContainer().mask) {
                    this.applyMaskToOverlayContainer();
                }
            };

            this.stopFakeAnimations = function() {
                this.mapOverPages(function(page) {
                    createjs.Tween.removeTweens(page.getContainer());
                });
                if (this.pages.length == 1) {
                    // Because animations were stopped, the callback functions don't get called, hence we need to apply
                    // the mask here.
                    this.applyMaskToOverlayContainer();
                }
            };

            this.anim_wobble = function(handleComplete) {
                var zoomState = this.zoomStates[this.currentZoomStateIndex];

                if (!zoomState)
                    return false;

                var splitTime = constants.pageNumTransTime / 5;
                var startOffset = zoomState.width / 10;

                this.mapOverPages(function(page) {
                    var pageContainer = page.getContainer();
                    createjs.Tween
                        .get(pageContainer, {override: true})
                        .to({x: startOffset}, splitTime, createjs.Ease.cubicInOut)
                        .to({x: -startOffset/2}, splitTime, createjs.Ease.cubicInOut)
                        .to({x: startOffset/5}, splitTime, createjs.Ease.cubicInOut)
                        .to({x: -startOffset/10}, splitTime, createjs.Ease.cubicInOut)
                        .to({x: 0}, splitTime, createjs.Ease.cubicInOut)
                        .call(handleComplete);
                });
            };

            this.anim_falseZoomIn = function(handleComplete) {
                var splitTime = constants.pageNumTransTime / 3;

                var startScale = this.container.scaleX;
                var peakScale = startScale * 0.9;
                createjs.Tween
                    .get(this.container)
                    .to({scaleX: peakScale, scaleY: peakScale}, splitTime, createjs.Ease.cubicInOut)
                    .to({scaleX: startScale, scaleY: startScale}, splitTime, createjs.Ease.cubicInOut)
                    .call(handleComplete);
            };

            this.removeFakePages = function() {
                for (var i = 0, m = this.fakePages.length; i < m ; i++) {
                    this.container.removeChild(this.fakePages.pop());
                }
            };

            this.containsEncryptedPage = function() {
                return this.checkOverPages(function(page) {
                    return page.encrypted;
                });
            };

            this.flashSearchOverlays = function() {
                this.mapOverPages(function(page) {
                    page.flashSearchOverlays();
                })
            };

            /**
             * Helper function that calls the specified callback function once for each page in the tray.
             * Pages will be passed sequentially in turn as arguments to the callback.
             * Remember that the callback will have a different scope, so calls to `this` may not react as
             *  expected - use `events.callback(this, function);` to remap the scope if necessary
             * @param callback ; should take one argument: the page
             */
            this.mapOverPages = function(callback) {
                for (var i = 0, m = this.pages.length ; i < m ; i++) {
                    callback(this.pages[i]);
                }
            };

            /**
             * Helper function that uses the specified callback function to determine whether any page in the tray
             *  satisfies the condition of the callback.
             * Pages will be passed sequentially in turn as arguments to the callback.
             * @param conditionalCallback ; should take one argument: the page; should return true/falsey only
             */
            this.checkOverPages = function(conditionalCallback) {
                for (var i = 0, m = this.pages.length ; i < m ; i++) {
                    if (conditionalCallback(this.pages[i]))
                        return true;
                }
                return false;
            };
        };


        return {
            Tray: Tray,
            EMITTER_NAME: EMITTER_NAME
        };
    });

/*!
* @license SoundJS
* Visit http://createjs.com/ for documentation, updates and examples.
*
* Copyright (c) 2011-2015 gskinner.com, inc.
*
* Distributed under the terms of the MIT license.
* http://www.opensource.org/licenses/mit-license.html
*
* This notice shall be included in all copies or substantial portions of the Software.
*/

/**!
 * SoundJS FlashAudioPlugin also includes swfobject (http://code.google.com/p/swfobject/)
 */

this.createjs=this.createjs||{},function(){var a=createjs.SoundJS=createjs.SoundJS||{};a.version="1.0.0",a.buildDate="Thu, 12 Oct 2017 16:34:05 GMT"}(),this.createjs=this.createjs||{},createjs.extend=function(a,b){"use strict";function c(){this.constructor=a}return c.prototype=b.prototype,a.prototype=new c},this.createjs=this.createjs||{},createjs.promote=function(a,b){"use strict";var c=a.prototype,d=Object.getPrototypeOf&&Object.getPrototypeOf(c)||c.__proto__;if(d){c[(b+="_")+"constructor"]=d.constructor;for(var e in d)c.hasOwnProperty(e)&&"function"==typeof d[e]&&(c[b+e]=d[e])}return a},this.createjs=this.createjs||{},createjs.deprecate=function(a,b){"use strict";return function(){var c="Deprecated property or method '"+b+"'. See docs for info.";return console&&(console.warn?console.warn(c):console.log(c)),a&&a.apply(this,arguments)}},this.createjs=this.createjs||{},createjs.indexOf=function(a,b){"use strict";for(var c=0,d=a.length;d>c;c++)if(b===a[c])return c;return-1},this.createjs=this.createjs||{},function(){"use strict";createjs.proxy=function(a,b){var c=Array.prototype.slice.call(arguments,2);return function(){return a.apply(b,Array.prototype.slice.call(arguments,0).concat(c))}}}(),this.createjs=this.createjs||{},function(){"use strict";function BrowserDetect(){throw"BrowserDetect cannot be instantiated"}var a=BrowserDetect.agent=window.navigator.userAgent;BrowserDetect.isWindowPhone=a.indexOf("IEMobile")>-1||a.indexOf("Windows Phone")>-1,BrowserDetect.isFirefox=a.indexOf("Firefox")>-1,BrowserDetect.isOpera=null!=window.opera,BrowserDetect.isChrome=a.indexOf("Chrome")>-1,BrowserDetect.isIOS=(a.indexOf("iPod")>-1||a.indexOf("iPhone")>-1||a.indexOf("iPad")>-1)&&!BrowserDetect.isWindowPhone,BrowserDetect.isAndroid=a.indexOf("Android")>-1&&!BrowserDetect.isWindowPhone,BrowserDetect.isBlackberry=a.indexOf("Blackberry")>-1,createjs.BrowserDetect=BrowserDetect}(),this.createjs=this.createjs||{},function(){"use strict";function EventDispatcher(){this._listeners=null,this._captureListeners=null}var a=EventDispatcher.prototype;EventDispatcher.initialize=function(b){b.addEventListener=a.addEventListener,b.on=a.on,b.removeEventListener=b.off=a.removeEventListener,b.removeAllEventListeners=a.removeAllEventListeners,b.hasEventListener=a.hasEventListener,b.dispatchEvent=a.dispatchEvent,b._dispatchEvent=a._dispatchEvent,b.willTrigger=a.willTrigger},a.addEventListener=function(a,b,c){var d;d=c?this._captureListeners=this._captureListeners||{}:this._listeners=this._listeners||{};var e=d[a];return e&&this.removeEventListener(a,b,c),e=d[a],e?e.push(b):d[a]=[b],b},a.on=function(a,b,c,d,e,f){return b.handleEvent&&(c=c||b,b=b.handleEvent),c=c||this,this.addEventListener(a,function(a){b.call(c,a,e),d&&a.remove()},f)},a.removeEventListener=function(a,b,c){var d=c?this._captureListeners:this._listeners;if(d){var e=d[a];if(e)for(var f=0,g=e.length;g>f;f++)if(e[f]==b){1==g?delete d[a]:e.splice(f,1);break}}},a.off=a.removeEventListener,a.removeAllEventListeners=function(a){a?(this._listeners&&delete this._listeners[a],this._captureListeners&&delete this._captureListeners[a]):this._listeners=this._captureListeners=null},a.dispatchEvent=function(a,b,c){if("string"==typeof a){var d=this._listeners;if(!(b||d&&d[a]))return!0;a=new createjs.Event(a,b,c)}else a.target&&a.clone&&(a=a.clone());try{a.target=this}catch(e){}if(a.bubbles&&this.parent){for(var f=this,g=[f];f.parent;)g.push(f=f.parent);var h,i=g.length;for(h=i-1;h>=0&&!a.propagationStopped;h--)g[h]._dispatchEvent(a,1+(0==h));for(h=1;i>h&&!a.propagationStopped;h++)g[h]._dispatchEvent(a,3)}else this._dispatchEvent(a,2);return!a.defaultPrevented},a.hasEventListener=function(a){var b=this._listeners,c=this._captureListeners;return!!(b&&b[a]||c&&c[a])},a.willTrigger=function(a){for(var b=this;b;){if(b.hasEventListener(a))return!0;b=b.parent}return!1},a.toString=function(){return"[EventDispatcher]"},a._dispatchEvent=function(a,b){var c,d,e=2>=b?this._captureListeners:this._listeners;if(a&&e&&(d=e[a.type])&&(c=d.length)){try{a.currentTarget=this}catch(f){}try{a.eventPhase=0|b}catch(f){}a.removed=!1,d=d.slice();for(var g=0;c>g&&!a.immediatePropagationStopped;g++){var h=d[g];h.handleEvent?h.handleEvent(a):h(a),a.removed&&(this.off(a.type,h,1==b),a.removed=!1)}}2===b&&this._dispatchEvent(a,2.1)},createjs.EventDispatcher=EventDispatcher}(),this.createjs=this.createjs||{},function(){"use strict";function Event(a,b,c){this.type=a,this.target=null,this.currentTarget=null,this.eventPhase=0,this.bubbles=!!b,this.cancelable=!!c,this.timeStamp=(new Date).getTime(),this.defaultPrevented=!1,this.propagationStopped=!1,this.immediatePropagationStopped=!1,this.removed=!1}var a=Event.prototype;a.preventDefault=function(){this.defaultPrevented=this.cancelable&&!0},a.stopPropagation=function(){this.propagationStopped=!0},a.stopImmediatePropagation=function(){this.immediatePropagationStopped=this.propagationStopped=!0},a.remove=function(){this.removed=!0},a.clone=function(){return new Event(this.type,this.bubbles,this.cancelable)},a.set=function(a){for(var b in a)this[b]=a[b];return this},a.toString=function(){return"[Event (type="+this.type+")]"},createjs.Event=Event}(),this.createjs=this.createjs||{},function(){"use strict";function ErrorEvent(a,b,c){this.Event_constructor("error"),this.title=a,this.message=b,this.data=c}var a=createjs.extend(ErrorEvent,createjs.Event);a.clone=function(){return new createjs.ErrorEvent(this.title,this.message,this.data)},createjs.ErrorEvent=createjs.promote(ErrorEvent,"Event")}(),this.createjs=this.createjs||{},function(){"use strict";function ProgressEvent(a,b){this.Event_constructor("progress"),this.loaded=a,this.total=null==b?1:b,this.progress=0==b?0:this.loaded/this.total}var a=createjs.extend(ProgressEvent,createjs.Event);a.clone=function(){return new createjs.ProgressEvent(this.loaded,this.total)},createjs.ProgressEvent=createjs.promote(ProgressEvent,"Event")}(window),this.createjs=this.createjs||{},function(){"use strict";function LoadItem(){this.src=null,this.type=null,this.id=null,this.maintainOrder=!1,this.callback=null,this.data=null,this.method=createjs.Methods.GET,this.values=null,this.headers=null,this.withCredentials=!1,this.mimeType=null,this.crossOrigin=null,this.loadTimeout=b.LOAD_TIMEOUT_DEFAULT}var a=LoadItem.prototype={},b=LoadItem;b.LOAD_TIMEOUT_DEFAULT=8e3,b.create=function(a){if("string"==typeof a){var c=new LoadItem;return c.src=a,c}if(a instanceof b)return a;if(a instanceof Object&&a.src)return null==a.loadTimeout&&(a.loadTimeout=b.LOAD_TIMEOUT_DEFAULT),a;throw new Error("Type not recognized.")},a.set=function(a){for(var b in a)this[b]=a[b];return this},createjs.LoadItem=b}(),this.createjs=this.createjs||{},function(){var a={};a.POST="POST",a.GET="GET",createjs.Methods=a}(),this.createjs=this.createjs||{},function(){var a={};a.BINARY="binary",a.CSS="css",a.FONT="font",a.FONTCSS="fontcss",a.IMAGE="image",a.JAVASCRIPT="javascript",a.JSON="json",a.JSONP="jsonp",a.MANIFEST="manifest",a.SOUND="sound",a.VIDEO="video",a.SPRITESHEET="spritesheet",a.SVG="svg",a.TEXT="text",a.XML="xml",createjs.Types=a}(),function(){var a={};a.a=function(){return a.el("a")},a.svg=function(){return a.el("svg")},a.object=function(){return a.el("object")},a.image=function(){return a.el("image")},a.img=function(){return a.el("img")},a.style=function(){return a.el("style")},a.link=function(){return a.el("link")},a.script=function(){return a.el("script")},a.audio=function(){return a.el("audio")},a.video=function(){return a.el("video")},a.text=function(a){return document.createTextNode(a)},a.el=function(a){return document.createElement(a)},createjs.Elements=a}(),function(){var a={container:null};a.appendToHead=function(b){a.getHead().appendChild(b)},a.appendToBody=function(b){if(null==a.container){a.container=document.createElement("div"),a.container.id="preloadjs-container";var c=a.container.style;c.visibility="hidden",c.position="absolute",c.width=a.container.style.height="10px",c.overflow="hidden",c.transform=c.msTransform=c.webkitTransform=c.oTransform="translate(-10px, -10px)",a.getBody().appendChild(a.container)}a.container.appendChild(b)},a.getHead=function(){return document.head||document.getElementsByTagName("head")[0]},a.getBody=function(){return document.body||document.getElementsByTagName("body")[0]},a.removeChild=function(a){a.parent&&a.parent.removeChild(a)},a.isImageTag=function(a){return a instanceof HTMLImageElement},a.isAudioTag=function(a){return window.HTMLAudioElement?a instanceof HTMLAudioElement:!1},a.isVideoTag=function(a){return window.HTMLVideoElement?a instanceof HTMLVideoElement:!1},createjs.DomUtils=a}(),function(){var a={};a.isBinary=function(a){switch(a){case createjs.Types.IMAGE:case createjs.Types.BINARY:return!0;default:return!1}},a.isText=function(a){switch(a){case createjs.Types.TEXT:case createjs.Types.JSON:case createjs.Types.MANIFEST:case createjs.Types.XML:case createjs.Types.CSS:case createjs.Types.SVG:case createjs.Types.JAVASCRIPT:case createjs.Types.SPRITESHEET:return!0;default:return!1}},a.getTypeByExtension=function(a){if(null==a)return createjs.Types.TEXT;switch(a.toLowerCase()){case"jpeg":case"jpg":case"gif":case"png":case"webp":case"bmp":return createjs.Types.IMAGE;case"ogg":case"mp3":case"webm":return createjs.Types.SOUND;case"mp4":case"webm":case"ts":return createjs.Types.VIDEO;case"json":return createjs.Types.JSON;case"xml":return createjs.Types.XML;case"css":return createjs.Types.CSS;case"js":return createjs.Types.JAVASCRIPT;case"svg":return createjs.Types.SVG;default:return createjs.Types.TEXT}},createjs.RequestUtils=a}(),function(){var a={};a.ABSOLUTE_PATT=/^(?:\w+:)?\/{2}/i,a.RELATIVE_PATT=/^[.\/]*?\//i,a.EXTENSION_PATT=/\/?[^\/]+\.(\w{1,5})$/i,a.parseURI=function(b){var c={absolute:!1,relative:!1,protocol:null,hostname:null,port:null,pathname:null,search:null,hash:null,host:null};if(null==b)return c;var d=createjs.Elements.a();d.href=b;for(var e in c)e in d&&(c[e]=d[e]);var f=b.indexOf("?");f>-1&&(b=b.substr(0,f));var g;return a.ABSOLUTE_PATT.test(b)?c.absolute=!0:a.RELATIVE_PATT.test(b)&&(c.relative=!0),(g=b.match(a.EXTENSION_PATT))&&(c.extension=g[1].toLowerCase()),c},a.formatQueryString=function(a,b){if(null==a)throw new Error("You must specify data.");var c=[];for(var d in a)c.push(d+"="+escape(a[d]));return b&&(c=c.concat(b)),c.join("&")},a.buildURI=function(a,b){if(null==b)return a;var c=[],d=a.indexOf("?");if(-1!=d){var e=a.slice(d+1);c=c.concat(e.split("&"))}return-1!=d?a.slice(0,d)+"?"+this.formatQueryString(b,c):a+"?"+this.formatQueryString(b,c)},a.isCrossDomain=function(a){var b=createjs.Elements.a();b.href=a.src;var c=createjs.Elements.a();c.href=location.href;var d=""!=b.hostname&&(b.port!=c.port||b.protocol!=c.protocol||b.hostname!=c.hostname);return d},a.isLocal=function(a){var b=createjs.Elements.a();return b.href=a.src,""==b.hostname&&"file:"==b.protocol},createjs.URLUtils=a}(),this.createjs=this.createjs||{},function(){"use strict";function AbstractLoader(a,b,c){this.EventDispatcher_constructor(),this.loaded=!1,this.canceled=!1,this.progress=0,this.type=c,this.resultFormatter=null,this._item=a?createjs.LoadItem.create(a):null,this._preferXHR=b,this._result=null,this._rawResult=null,this._loadedItems=null,this._tagSrcAttribute=null,this._tag=null}var a=createjs.extend(AbstractLoader,createjs.EventDispatcher),b=AbstractLoader;try{Object.defineProperties(b,{POST:{get:createjs.deprecate(function(){return createjs.Methods.POST},"AbstractLoader.POST")},GET:{get:createjs.deprecate(function(){return createjs.Methods.GET},"AbstractLoader.GET")},BINARY:{get:createjs.deprecate(function(){return createjs.Types.BINARY},"AbstractLoader.BINARY")},CSS:{get:createjs.deprecate(function(){return createjs.Types.CSS},"AbstractLoader.CSS")},FONT:{get:createjs.deprecate(function(){return createjs.Types.FONT},"AbstractLoader.FONT")},FONTCSS:{get:createjs.deprecate(function(){return createjs.Types.FONTCSS},"AbstractLoader.FONTCSS")},IMAGE:{get:createjs.deprecate(function(){return createjs.Types.IMAGE},"AbstractLoader.IMAGE")},JAVASCRIPT:{get:createjs.deprecate(function(){return createjs.Types.JAVASCRIPT},"AbstractLoader.JAVASCRIPT")},JSON:{get:createjs.deprecate(function(){return createjs.Types.JSON},"AbstractLoader.JSON")},JSONP:{get:createjs.deprecate(function(){return createjs.Types.JSONP},"AbstractLoader.JSONP")},MANIFEST:{get:createjs.deprecate(function(){return createjs.Types.MANIFEST},"AbstractLoader.MANIFEST")},SOUND:{get:createjs.deprecate(function(){return createjs.Types.SOUND},"AbstractLoader.SOUND")},VIDEO:{get:createjs.deprecate(function(){return createjs.Types.VIDEO},"AbstractLoader.VIDEO")},SPRITESHEET:{get:createjs.deprecate(function(){return createjs.Types.SPRITESHEET},"AbstractLoader.SPRITESHEET")},SVG:{get:createjs.deprecate(function(){return createjs.Types.SVG},"AbstractLoader.SVG")},TEXT:{get:createjs.deprecate(function(){return createjs.Types.TEXT},"AbstractLoader.TEXT")},XML:{get:createjs.deprecate(function(){return createjs.Types.XML},"AbstractLoader.XML")}})}catch(c){}a.getItem=function(){return this._item},a.getResult=function(a){return a?this._rawResult:this._result},a.getTag=function(){return this._tag},a.setTag=function(a){this._tag=a},a.load=function(){this._createRequest(),this._request.on("complete",this,this),this._request.on("progress",this,this),this._request.on("loadStart",this,this),this._request.on("abort",this,this),this._request.on("timeout",this,this),this._request.on("error",this,this);var a=new createjs.Event("initialize");a.loader=this._request,this.dispatchEvent(a),this._request.load()},a.cancel=function(){this.canceled=!0,this.destroy()},a.destroy=function(){this._request&&(this._request.removeAllEventListeners(),this._request.destroy()),this._request=null,this._item=null,this._rawResult=null,this._result=null,this._loadItems=null,this.removeAllEventListeners()},a.getLoadedItems=function(){return this._loadedItems},a._createRequest=function(){this._request=this._preferXHR?new createjs.XHRRequest(this._item):new createjs.TagRequest(this._item,this._tag||this._createTag(),this._tagSrcAttribute)},a._createTag=function(){return null},a._sendLoadStart=function(){this._isCanceled()||this.dispatchEvent("loadstart")},a._sendProgress=function(a){if(!this._isCanceled()){var b=null;"number"==typeof a?(this.progress=a,b=new createjs.ProgressEvent(this.progress)):(b=a,this.progress=a.loaded/a.total,b.progress=this.progress,(isNaN(this.progress)||1/0==this.progress)&&(this.progress=0)),this.hasEventListener("progress")&&this.dispatchEvent(b)}},a._sendComplete=function(){if(!this._isCanceled()){this.loaded=!0;var a=new createjs.Event("complete");a.rawResult=this._rawResult,null!=this._result&&(a.result=this._result),this.dispatchEvent(a)}},a._sendError=function(a){!this._isCanceled()&&this.hasEventListener("error")&&(null==a&&(a=new createjs.ErrorEvent("PRELOAD_ERROR_EMPTY")),this.dispatchEvent(a))},a._isCanceled=function(){return null==window.createjs||this.canceled?!0:!1},a.resultFormatter=null,a.handleEvent=function(a){switch(a.type){case"complete":this._rawResult=a.target._response;var b=this.resultFormatter&&this.resultFormatter(this);b instanceof Function?b.call(this,createjs.proxy(this._resultFormatSuccess,this),createjs.proxy(this._resultFormatFailed,this)):(this._result=b||this._rawResult,this._sendComplete());break;case"progress":this._sendProgress(a);break;case"error":this._sendError(a);break;case"loadstart":this._sendLoadStart();break;case"abort":case"timeout":this._isCanceled()||this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_"+a.type.toUpperCase()+"_ERROR"))}},a._resultFormatSuccess=function(a){this._result=a,this._sendComplete()},a._resultFormatFailed=function(a){this._sendError(a)},a.toString=function(){return"[PreloadJS AbstractLoader]"},createjs.AbstractLoader=createjs.promote(AbstractLoader,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function AbstractMediaLoader(a,b,c){this.AbstractLoader_constructor(a,b,c),this.resultFormatter=this._formatResult,this._tagSrcAttribute="src",this.on("initialize",this._updateXHR,this)}var a=createjs.extend(AbstractMediaLoader,createjs.AbstractLoader);a.load=function(){this._tag||(this._tag=this._createTag(this._item.src)),this._tag.preload="auto",this._tag.load(),this.AbstractLoader_load()},a._createTag=function(){},a._createRequest=function(){this._request=this._preferXHR?new createjs.XHRRequest(this._item):new createjs.MediaTagRequest(this._item,this._tag||this._createTag(),this._tagSrcAttribute)},a._updateXHR=function(a){a.loader.setResponseType&&a.loader.setResponseType("blob")},a._formatResult=function(a){if(this._tag.removeEventListener&&this._tag.removeEventListener("canplaythrough",this._loadedHandler),this._tag.onstalled=null,this._preferXHR){var b=window.URL||window.webkitURL,c=a.getResult(!0);a.getTag().src=b.createObjectURL(c)}return a.getTag()},createjs.AbstractMediaLoader=createjs.promote(AbstractMediaLoader,"AbstractLoader")}(),this.createjs=this.createjs||{},function(){"use strict";var AbstractRequest=function(a){this._item=a},a=createjs.extend(AbstractRequest,createjs.EventDispatcher);a.load=function(){},a.destroy=function(){},a.cancel=function(){},createjs.AbstractRequest=createjs.promote(AbstractRequest,"EventDispatcher")}(),this.createjs=this.createjs||{},function(){"use strict";function TagRequest(a,b,c){this.AbstractRequest_constructor(a),this._tag=b,this._tagSrcAttribute=c,this._loadedHandler=createjs.proxy(this._handleTagComplete,this),this._addedToDOM=!1}var a=createjs.extend(TagRequest,createjs.AbstractRequest);a.load=function(){this._tag.onload=createjs.proxy(this._handleTagComplete,this),this._tag.onreadystatechange=createjs.proxy(this._handleReadyStateChange,this),this._tag.onerror=createjs.proxy(this._handleError,this);var a=new createjs.Event("initialize");a.loader=this._tag,this.dispatchEvent(a),this._loadTimeout=setTimeout(createjs.proxy(this._handleTimeout,this),this._item.loadTimeout),this._tag[this._tagSrcAttribute]=this._item.src,null==this._tag.parentNode&&(createjs.DomUtils.appendToBody(this._tag),this._addedToDOM=!0)},a.destroy=function(){this._clean(),this._tag=null,this.AbstractRequest_destroy()},a._handleReadyStateChange=function(){clearTimeout(this._loadTimeout);var a=this._tag;("loaded"==a.readyState||"complete"==a.readyState)&&this._handleTagComplete()},a._handleError=function(){this._clean(),this.dispatchEvent("error")},a._handleTagComplete=function(){this._rawResult=this._tag,this._result=this.resultFormatter&&this.resultFormatter(this)||this._rawResult,this._clean(),this.dispatchEvent("complete")},a._handleTimeout=function(){this._clean(),this.dispatchEvent(new createjs.Event("timeout"))},a._clean=function(){this._tag.onload=null,this._tag.onreadystatechange=null,this._tag.onerror=null,this._addedToDOM&&null!=this._tag.parentNode&&this._tag.parentNode.removeChild(this._tag),clearTimeout(this._loadTimeout)},a._handleStalled=function(){},createjs.TagRequest=createjs.promote(TagRequest,"AbstractRequest")}(),this.createjs=this.createjs||{},function(){"use strict";function MediaTagRequest(a,b,c){this.AbstractRequest_constructor(a),this._tag=b,this._tagSrcAttribute=c,this._loadedHandler=createjs.proxy(this._handleTagComplete,this)}var a=createjs.extend(MediaTagRequest,createjs.TagRequest);a.load=function(){var a=createjs.proxy(this._handleStalled,this);this._stalledCallback=a;var b=createjs.proxy(this._handleProgress,this);this._handleProgress=b,this._tag.addEventListener("stalled",a),this._tag.addEventListener("progress",b),this._tag.addEventListener&&this._tag.addEventListener("canplaythrough",this._loadedHandler,!1),this.TagRequest_load()},a._handleReadyStateChange=function(){clearTimeout(this._loadTimeout);var a=this._tag;("loaded"==a.readyState||"complete"==a.readyState)&&this._handleTagComplete()},a._handleStalled=function(){},a._handleProgress=function(a){if(a&&!(a.loaded>0&&0==a.total)){var b=new createjs.ProgressEvent(a.loaded,a.total);this.dispatchEvent(b)}},a._clean=function(){this._tag.removeEventListener&&this._tag.removeEventListener("canplaythrough",this._loadedHandler),this._tag.removeEventListener("stalled",this._stalledCallback),this._tag.removeEventListener("progress",this._progressCallback),this.TagRequest__clean()},createjs.MediaTagRequest=createjs.promote(MediaTagRequest,"TagRequest")}(),this.createjs=this.createjs||{},function(){"use strict";function XHRRequest(a){this.AbstractRequest_constructor(a),this._request=null,this._loadTimeout=null,this._xhrLevel=1,this._response=null,this._rawResponse=null,this._canceled=!1,this._handleLoadStartProxy=createjs.proxy(this._handleLoadStart,this),this._handleProgressProxy=createjs.proxy(this._handleProgress,this),this._handleAbortProxy=createjs.proxy(this._handleAbort,this),this._handleErrorProxy=createjs.proxy(this._handleError,this),this._handleTimeoutProxy=createjs.proxy(this._handleTimeout,this),this._handleLoadProxy=createjs.proxy(this._handleLoad,this),this._handleReadyStateChangeProxy=createjs.proxy(this._handleReadyStateChange,this),!this._createXHR(a)}var a=createjs.extend(XHRRequest,createjs.AbstractRequest);XHRRequest.ACTIVEX_VERSIONS=["Msxml2.XMLHTTP.6.0","Msxml2.XMLHTTP.5.0","Msxml2.XMLHTTP.4.0","MSXML2.XMLHTTP.3.0","MSXML2.XMLHTTP","Microsoft.XMLHTTP"],a.getResult=function(a){return a&&this._rawResponse?this._rawResponse:this._response},a.cancel=function(){this.canceled=!0,this._clean(),this._request.abort()},a.load=function(){if(null==this._request)return void this._handleError();null!=this._request.addEventListener?(this._request.addEventListener("loadstart",this._handleLoadStartProxy,!1),this._request.addEventListener("progress",this._handleProgressProxy,!1),this._request.addEventListener("abort",this._handleAbortProxy,!1),this._request.addEventListener("error",this._handleErrorProxy,!1),this._request.addEventListener("timeout",this._handleTimeoutProxy,!1),this._request.addEventListener("load",this._handleLoadProxy,!1),this._request.addEventListener("readystatechange",this._handleReadyStateChangeProxy,!1)):(this._request.onloadstart=this._handleLoadStartProxy,this._request.onprogress=this._handleProgressProxy,this._request.onabort=this._handleAbortProxy,this._request.onerror=this._handleErrorProxy,this._request.ontimeout=this._handleTimeoutProxy,this._request.onload=this._handleLoadProxy,this._request.onreadystatechange=this._handleReadyStateChangeProxy),1==this._xhrLevel&&(this._loadTimeout=setTimeout(createjs.proxy(this._handleTimeout,this),this._item.loadTimeout));try{this._item.values?this._request.send(createjs.URLUtils.formatQueryString(this._item.values)):this._request.send()}catch(a){this.dispatchEvent(new createjs.ErrorEvent("XHR_SEND",null,a))}},a.setResponseType=function(a){"blob"===a&&(a=window.URL?"blob":"arraybuffer",this._responseType=a),this._request.responseType=a},a.getAllResponseHeaders=function(){return this._request.getAllResponseHeaders instanceof Function?this._request.getAllResponseHeaders():null},a.getResponseHeader=function(a){return this._request.getResponseHeader instanceof Function?this._request.getResponseHeader(a):null},a._handleProgress=function(a){if(a&&!(a.loaded>0&&0==a.total)){var b=new createjs.ProgressEvent(a.loaded,a.total);this.dispatchEvent(b)}},a._handleLoadStart=function(){clearTimeout(this._loadTimeout),this.dispatchEvent("loadstart")},a._handleAbort=function(a){this._clean(),this.dispatchEvent(new createjs.ErrorEvent("XHR_ABORTED",null,a))},a._handleError=function(a){this._clean(),this.dispatchEvent(new createjs.ErrorEvent(a.message))},a._handleReadyStateChange=function(){4==this._request.readyState&&this._handleLoad()},a._handleLoad=function(){if(!this.loaded){this.loaded=!0;var a=this._checkError();if(a)return void this._handleError(a);if(this._response=this._getResponse(),"arraybuffer"===this._responseType)try{this._response=new Blob([this._response])}catch(b){if(window.BlobBuilder=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder||window.MSBlobBuilder,"TypeError"===b.name&&window.BlobBuilder){var c=new BlobBuilder;c.append(this._response),this._response=c.getBlob()}}this._clean(),this.dispatchEvent(new createjs.Event("complete"))}},a._handleTimeout=function(a){this._clean(),this.dispatchEvent(new createjs.ErrorEvent("PRELOAD_TIMEOUT",null,a))},a._checkError=function(){var a=parseInt(this._request.status);return a>=400&&599>=a?new Error(a):0==a&&/^https?:/.test(location.protocol)?new Error(0):null},a._getResponse=function(){if(null!=this._response)return this._response;if(null!=this._request.response)return this._request.response;try{if(null!=this._request.responseText)return this._request.responseText}catch(a){}try{if(null!=this._request.responseXML)return this._request.responseXML}catch(a){}return null},a._createXHR=function(a){var b=createjs.URLUtils.isCrossDomain(a),c={},d=null;if(window.XMLHttpRequest)d=new XMLHttpRequest,b&&void 0===d.withCredentials&&window.XDomainRequest&&(d=new XDomainRequest);else{for(var e=0,f=s.ACTIVEX_VERSIONS.length;f>e;e++){var g=s.ACTIVEX_VERSIONS[e];try{d=new ActiveXObject(g);break}catch(h){}}if(null==d)return!1}null==a.mimeType&&createjs.RequestUtils.isText(a.type)&&(a.mimeType="text/plain; charset=utf-8"),a.mimeType&&d.overrideMimeType&&d.overrideMimeType(a.mimeType),this._xhrLevel="string"==typeof d.responseType?2:1;var i=null;if(i=a.method==createjs.Methods.GET?createjs.URLUtils.buildURI(a.src,a.values):a.src,d.open(a.method||createjs.Methods.GET,i,!0),b&&d instanceof XMLHttpRequest&&1==this._xhrLevel&&(c.Origin=location.origin),a.values&&a.method==createjs.Methods.POST&&(c["Content-Type"]="application/x-www-form-urlencoded"),b||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest"),a.headers)for(var j in a.headers)c[j]=a.headers[j];for(j in c)d.setRequestHeader(j,c[j]);return d instanceof XMLHttpRequest&&void 0!==a.withCredentials&&(d.withCredentials=a.withCredentials),this._request=d,!0},a._clean=function(){clearTimeout(this._loadTimeout),null!=this._request.removeEventListener?(this._request.removeEventListener("loadstart",this._handleLoadStartProxy),this._request.removeEventListener("progress",this._handleProgressProxy),this._request.removeEventListener("abort",this._handleAbortProxy),this._request.removeEventListener("error",this._handleErrorProxy),this._request.removeEventListener("timeout",this._handleTimeoutProxy),this._request.removeEventListener("load",this._handleLoadProxy),this._request.removeEventListener("readystatechange",this._handleReadyStateChangeProxy)):(this._request.onloadstart=null,this._request.onprogress=null,this._request.onabort=null,this._request.onerror=null,this._request.ontimeout=null,this._request.onload=null,this._request.onreadystatechange=null)},a.toString=function(){return"[PreloadJS XHRRequest]"},createjs.XHRRequest=createjs.promote(XHRRequest,"AbstractRequest")}(),this.createjs=this.createjs||{},function(){"use strict";function SoundLoader(a,b){this.AbstractMediaLoader_constructor(a,b,createjs.Types.SOUND),createjs.DomUtils.isAudioTag(a)?this._tag=a:createjs.DomUtils.isAudioTag(a.src)?this._tag=a:createjs.DomUtils.isAudioTag(a.tag)&&(this._tag=createjs.DomUtils.isAudioTag(a)?a:a.src),null!=this._tag&&(this._preferXHR=!1)}var a=createjs.extend(SoundLoader,createjs.AbstractMediaLoader),b=SoundLoader;b.canLoadItem=function(a){return a.type==createjs.Types.SOUND},a._createTag=function(a){var b=createjs.Elements.audio();return b.autoplay=!1,b.preload="none",b.src=a,b},createjs.SoundLoader=createjs.promote(SoundLoader,"AbstractMediaLoader")}(),this.createjs=this.createjs||{},function(){"use strict";var PlayPropsConfig=function(){this.interrupt=null,this.delay=null,this.offset=null,this.loop=null,this.volume=null,this.pan=null,this.startTime=null,this.duration=null},a=PlayPropsConfig.prototype={},b=PlayPropsConfig;b.create=function(a){if("string"==typeof a)return console&&(console.warn||console.log)("Deprecated behaviour. Sound.play takes a configuration object instead of individual arguments. See docs for info."),(new createjs.PlayPropsConfig).set({interrupt:a});if(null==a||a instanceof b||a instanceof Object)return(new createjs.PlayPropsConfig).set(a);if(null==a)throw new Error("PlayProps configuration not recognized.")},a.set=function(a){if(null!=a)for(var b in a)this[b]=a[b];return this},a.toString=function(){return"[PlayPropsConfig]"},createjs.PlayPropsConfig=b}(),this.createjs=this.createjs||{},function(){"use strict";function Sound(){throw"Sound cannot be instantiated"}function a(a,b){this.init(a,b)}var b=Sound;b.INTERRUPT_ANY="any",b.INTERRUPT_EARLY="early",b.INTERRUPT_LATE="late",b.INTERRUPT_NONE="none",b.PLAY_INITED="playInited",b.PLAY_SUCCEEDED="playSucceeded",b.PLAY_INTERRUPTED="playInterrupted",b.PLAY_FINISHED="playFinished",b.PLAY_FAILED="playFailed",b.SUPPORTED_EXTENSIONS=["mp3","ogg","opus","mpeg","wav","m4a","mp4","aiff","wma","mid"],b.EXTENSION_MAP={m4a:"mp4"},b.FILE_PATTERN=/^(?:(\w+:)\/{2}(\w+(?:\.\w+)*\/?))?([\/.]*?(?:[^?]+)?\/)?((?:[^\/?]+)\.(\w+))(?:\?(\S+)?)?$/,b.defaultInterruptBehavior=b.INTERRUPT_NONE,b.alternateExtensions=[],b.activePlugin=null,b._masterVolume=1,b._getMasterVolume=function(){return this._masterVolume},b.getVolume=createjs.deprecate(b._getMasterVolume,"Sound.getVolume"),b._setMasterVolume=function(a){if(null!=Number(a)&&(a=Math.max(0,Math.min(1,a)),b._masterVolume=a,!this.activePlugin||!this.activePlugin.setVolume||!this.activePlugin.setVolume(a)))for(var c=this._instances,d=0,e=c.length;e>d;d++)c[d].setMasterVolume(a)},b.setVolume=createjs.deprecate(b._setMasterVolume,"Sound.setVolume"),b._masterMute=!1,b._getMute=function(){return this._masterMute},b.getMute=createjs.deprecate(b._getMute,"Sound.getMute"),b._setMute=function(a){if(null!=a&&(this._masterMute=a,!this.activePlugin||!this.activePlugin.setMute||!this.activePlugin.setMute(a)))for(var b=this._instances,c=0,d=b.length;d>c;c++)b[c].setMasterMute(a)},b.setMute=createjs.deprecate(b._setMute,"Sound.setMute"),b._getCapabilities=function(){return null==b.activePlugin?null:b.activePlugin._capabilities},b.getCapabilities=createjs.deprecate(b._getCapabilities,"Sound.getCapabilities"),Object.defineProperties(b,{volume:{get:b._getMasterVolume,set:b._setMasterVolume},muted:{get:b._getMute,set:b._setMute},capabilities:{get:b._getCapabilities}}),b._pluginsRegistered=!1,b._lastID=0,b._instances=[],b._idHash={},b._preloadHash={},b._defaultPlayPropsHash={},b.addEventListener=null,b.removeEventListener=null,b.removeAllEventListeners=null,b.dispatchEvent=null,b.hasEventListener=null,b._listeners=null,createjs.EventDispatcher.initialize(b),b.getPreloadHandlers=function(){return{callback:createjs.proxy(b.initLoad,b),types:["sound"],extensions:b.SUPPORTED_EXTENSIONS}},b._handleLoadComplete=function(a){var c=a.target.getItem().src;if(b._preloadHash[c])for(var d=0,e=b._preloadHash[c].length;e>d;d++){var f=b._preloadHash[c][d];if(b._preloadHash[c][d]=!0,b.hasEventListener("fileload")){var a=new createjs.Event("fileload");a.src=f.src,a.id=f.id,a.data=f.data,a.sprite=f.sprite,b.dispatchEvent(a)}}},b._handleLoadError=function(a){var c=a.target.getItem().src;if(b._preloadHash[c])for(var d=0,e=b._preloadHash[c].length;e>d;d++){var f=b._preloadHash[c][d];if(b._preloadHash[c][d]=!1,b.hasEventListener("fileerror")){var a=new createjs.Event("fileerror");a.src=f.src,a.id=f.id,a.data=f.data,a.sprite=f.sprite,b.dispatchEvent(a)}}},b._registerPlugin=function(a){return a.isSupported()?(b.activePlugin=new a,!0):!1},b.registerPlugins=function(a){b._pluginsRegistered=!0;for(var c=0,d=a.length;d>c;c++)if(b._registerPlugin(a[c]))return!0;return!1},b.initializeDefaultPlugins=function(){return null!=b.activePlugin?!0:b._pluginsRegistered?!1:b.registerPlugins([createjs.WebAudioPlugin,createjs.HTMLAudioPlugin])?!0:!1},b.isReady=function(){return null!=b.activePlugin},b.initLoad=function(a){return"video"==a.type?!0:b._registerSound(a)},b._registerSound=function(c){if(!b.initializeDefaultPlugins())return!1;var d;if(c.src instanceof Object?(d=b._parseSrc(c.src),d.src=c.path+d.src):d=b._parsePath(c.src),null==d)return!1;
c.src=d.src,c.type="sound";var e=c.data,f=null;if(null!=e&&(isNaN(e.channels)?isNaN(e)||(f=parseInt(e)):f=parseInt(e.channels),e.audioSprite))for(var g,h=e.audioSprite.length;h--;)g=e.audioSprite[h],b._idHash[g.id]={src:c.src,startTime:parseInt(g.startTime),duration:parseInt(g.duration)},g.defaultPlayProps&&(b._defaultPlayPropsHash[g.id]=createjs.PlayPropsConfig.create(g.defaultPlayProps));null!=c.id&&(b._idHash[c.id]={src:c.src});var i=b.activePlugin.register(c);return a.create(c.src,f),null!=e&&isNaN(e)?c.data.channels=f||a.maxPerChannel():c.data=f||a.maxPerChannel(),i.type&&(c.type=i.type),c.defaultPlayProps&&(b._defaultPlayPropsHash[c.src]=createjs.PlayPropsConfig.create(c.defaultPlayProps)),i},b.registerSound=function(a,c,d,e,f){var g={src:a,id:c,data:d,defaultPlayProps:f};a instanceof Object&&a.src&&(e=c,g=a),g=createjs.LoadItem.create(g),g.path=e,null==e||g.src instanceof Object||(g.src=e+g.src);var h=b._registerSound(g);if(!h)return!1;if(b._preloadHash[g.src]||(b._preloadHash[g.src]=[]),b._preloadHash[g.src].push(g),1==b._preloadHash[g.src].length)h.on("complete",this._handleLoadComplete,this),h.on("error",this._handleLoadError,this),b.activePlugin.preload(h);else if(1==b._preloadHash[g.src][0])return!0;return g},b.registerSounds=function(a,b){var c=[];a.path&&(b?b+=a.path:b=a.path,a=a.manifest);for(var d=0,e=a.length;e>d;d++)c[d]=createjs.Sound.registerSound(a[d].src,a[d].id,a[d].data,b,a[d].defaultPlayProps);return c},b.removeSound=function(c,d){if(null==b.activePlugin)return!1;c instanceof Object&&c.src&&(c=c.src);var e;if(c instanceof Object?e=b._parseSrc(c):(c=b._getSrcById(c).src,e=b._parsePath(c)),null==e)return!1;c=e.src,null!=d&&(c=d+c);for(var f in b._idHash)b._idHash[f].src==c&&delete b._idHash[f];return a.removeSrc(c),delete b._preloadHash[c],b.activePlugin.removeSound(c),!0},b.removeSounds=function(a,b){var c=[];a.path&&(b?b+=a.path:b=a.path,a=a.manifest);for(var d=0,e=a.length;e>d;d++)c[d]=createjs.Sound.removeSound(a[d].src,b);return c},b.removeAllSounds=function(){b._idHash={},b._preloadHash={},a.removeAll(),b.activePlugin&&b.activePlugin.removeAllSounds()},b.loadComplete=function(a){if(!b.isReady())return!1;var c=b._parsePath(a);return a=c?b._getSrcById(c.src).src:b._getSrcById(a).src,void 0==b._preloadHash[a]?!1:1==b._preloadHash[a][0]},b._parsePath=function(a){"string"!=typeof a&&(a=a.toString());var c=a.match(b.FILE_PATTERN);if(null==c)return!1;for(var d=c[4],e=c[5],f=b.capabilities,g=0;!f[e];)if(e=b.alternateExtensions[g++],g>b.alternateExtensions.length)return null;a=a.replace("."+c[5],"."+e);var h={name:d,src:a,extension:e};return h},b._parseSrc=function(a){var c={name:void 0,src:void 0,extension:void 0},d=b.capabilities;for(var e in a)if(a.hasOwnProperty(e)&&d[e]){c.src=a[e],c.extension=e;break}if(!c.src)return!1;var f=c.src.lastIndexOf("/");return c.name=-1!=f?c.src.slice(f+1):c.src,c},b.play=function(a,c){var d=createjs.PlayPropsConfig.create(c),e=b.createInstance(a,d.startTime,d.duration),f=b._playInstance(e,d);return f||e._playFailed(),e},b.createInstance=function(c,d,e){if(!b.initializeDefaultPlugins())return new createjs.DefaultSoundInstance(c,d,e);var f=b._defaultPlayPropsHash[c];c=b._getSrcById(c);var g=b._parsePath(c.src),h=null;return null!=g&&null!=g.src?(a.create(g.src),null==d&&(d=c.startTime),h=b.activePlugin.create(g.src,d,e||c.duration),f=f||b._defaultPlayPropsHash[g.src],f&&h.applyPlayProps(f)):h=new createjs.DefaultSoundInstance(c,d,e),h.uniqueId=b._lastID++,h},b.stop=function(){for(var a=this._instances,b=a.length;b--;)a[b].stop()},b.setDefaultPlayProps=function(a,c){a=b._getSrcById(a),b._defaultPlayPropsHash[b._parsePath(a.src).src]=createjs.PlayPropsConfig.create(c)},b.getDefaultPlayProps=function(a){return a=b._getSrcById(a),b._defaultPlayPropsHash[b._parsePath(a.src).src]},b._playInstance=function(a,c){var d=b._defaultPlayPropsHash[a.src]||{};if(null==c.interrupt&&(c.interrupt=d.interrupt||b.defaultInterruptBehavior),null==c.delay&&(c.delay=d.delay||0),null==c.offset&&(c.offset=a.position),null==c.loop&&(c.loop=a.loop),null==c.volume&&(c.volume=a.volume),null==c.pan&&(c.pan=a.pan),0==c.delay){var e=b._beginPlaying(a,c);if(!e)return!1}else{var f=setTimeout(function(){b._beginPlaying(a,c)},c.delay);a.delayTimeoutId=f}return this._instances.push(a),!0},b._beginPlaying=function(b,c){if(!a.add(b,c.interrupt))return!1;var d=b._beginPlaying(c);if(!d){var e=createjs.indexOf(this._instances,b);return e>-1&&this._instances.splice(e,1),!1}return!0},b._getSrcById=function(a){return b._idHash[a]||{src:a}},b._playFinished=function(b){a.remove(b);var c=createjs.indexOf(this._instances,b);c>-1&&this._instances.splice(c,1)},createjs.Sound=Sound,a.channels={},a.create=function(b,c){var d=a.get(b);return null==d?(a.channels[b]=new a(b,c),!0):!1},a.removeSrc=function(b){var c=a.get(b);return null==c?!1:(c._removeAll(),delete a.channels[b],!0)},a.removeAll=function(){for(var b in a.channels)a.channels[b]._removeAll();a.channels={}},a.add=function(b,c){var d=a.get(b.src);return null==d?!1:d._add(b,c)},a.remove=function(b){var c=a.get(b.src);return null==c?!1:(c._remove(b),!0)},a.maxPerChannel=function(){return c.maxDefault},a.get=function(b){return a.channels[b]};var c=a.prototype;c.constructor=a,c.src=null,c.max=null,c.maxDefault=100,c.length=0,c.init=function(a,b){this.src=a,this.max=b||this.maxDefault,-1==this.max&&(this.max=this.maxDefault),this._instances=[]},c._get=function(a){return this._instances[a]},c._add=function(a,b){return this._getSlot(b,a)?(this._instances.push(a),this.length++,!0):!1},c._remove=function(a){var b=createjs.indexOf(this._instances,a);return-1==b?!1:(this._instances.splice(b,1),this.length--,!0)},c._removeAll=function(){for(var a=this.length-1;a>=0;a--)this._instances[a].stop()},c._getSlot=function(a){var b,c;if(a!=Sound.INTERRUPT_NONE&&(c=this._get(0),null==c))return!0;for(var d=0,e=this.max;e>d;d++){if(b=this._get(d),null==b)return!0;if(b.playState==Sound.PLAY_FINISHED||b.playState==Sound.PLAY_INTERRUPTED||b.playState==Sound.PLAY_FAILED){c=b;break}a!=Sound.INTERRUPT_NONE&&(a==Sound.INTERRUPT_EARLY&&b.position<c.position||a==Sound.INTERRUPT_LATE&&b.position>c.position)&&(c=b)}return null!=c?(c._interrupt(),this._remove(c),!0):!1},c.toString=function(){return"[Sound SoundChannel]"}}(),this.createjs=this.createjs||{},function(){"use strict";var AbstractSoundInstance=function(a,b,c,d){this.EventDispatcher_constructor(),this.src=a,this.uniqueId=-1,this.playState=null,this.delayTimeoutId=null,this._volume=1,Object.defineProperty(this,"volume",{get:this._getVolume,set:this._setVolume}),this.getVolume=createjs.deprecate(this._getVolume,"AbstractSoundInstance.getVolume"),this.setVolume=createjs.deprecate(this._setVolume,"AbstractSoundInstance.setVolume"),this._pan=0,Object.defineProperty(this,"pan",{get:this._getPan,set:this._setPan}),this.getPan=createjs.deprecate(this._getPan,"AbstractSoundInstance.getPan"),this.setPan=createjs.deprecate(this._setPan,"AbstractSoundInstance.setPan"),this._startTime=Math.max(0,b||0),Object.defineProperty(this,"startTime",{get:this._getStartTime,set:this._setStartTime}),this.getStartTime=createjs.deprecate(this._getStartTime,"AbstractSoundInstance.getStartTime"),this.setStartTime=createjs.deprecate(this._setStartTime,"AbstractSoundInstance.setStartTime"),this._duration=Math.max(0,c||0),Object.defineProperty(this,"duration",{get:this._getDuration,set:this._setDuration}),this.getDuration=createjs.deprecate(this._getDuration,"AbstractSoundInstance.getDuration"),this.setDuration=createjs.deprecate(this._setDuration,"AbstractSoundInstance.setDuration"),this._playbackResource=null,Object.defineProperty(this,"playbackResource",{get:this._getPlaybackResource,set:this._setPlaybackResource}),d!==!1&&d!==!0&&this._setPlaybackResource(d),this.getPlaybackResource=createjs.deprecate(this._getPlaybackResource,"AbstractSoundInstance.getPlaybackResource"),this.setPlaybackResource=createjs.deprecate(this._setPlaybackResource,"AbstractSoundInstance.setPlaybackResource"),this._position=0,Object.defineProperty(this,"position",{get:this._getPosition,set:this._setPosition}),this.getPosition=createjs.deprecate(this._getPosition,"AbstractSoundInstance.getPosition"),this.setPosition=createjs.deprecate(this._setPosition,"AbstractSoundInstance.setPosition"),this._loop=0,Object.defineProperty(this,"loop",{get:this._getLoop,set:this._setLoop}),this.getLoop=createjs.deprecate(this._getLoop,"AbstractSoundInstance.getLoop"),this.setLoop=createjs.deprecate(this._setLoop,"AbstractSoundInstance.setLoop"),this._muted=!1,Object.defineProperty(this,"muted",{get:this._getMuted,set:this._setMuted}),this.getMuted=createjs.deprecate(this._getMuted,"AbstractSoundInstance.getMuted"),this.setMuted=createjs.deprecate(this._setMuted,"AbstractSoundInstance.setMuted"),this._paused=!1,Object.defineProperty(this,"paused",{get:this._getPaused,set:this._setPaused}),this.getPaused=createjs.deprecate(this._getPaused,"AbstractSoundInstance.getPaused"),this.setPaused=createjs.deprecate(this._setPaused,"AbstractSoundInstance.setPaused")},a=createjs.extend(AbstractSoundInstance,createjs.EventDispatcher);a.play=function(a){var b=createjs.PlayPropsConfig.create(a);return this.playState==createjs.Sound.PLAY_SUCCEEDED?(this.applyPlayProps(b),void(this._paused&&this._setPaused(!1))):(this._cleanUp(),createjs.Sound._playInstance(this,b),this)},a.stop=function(){return this._position=0,this._paused=!1,this._handleStop(),this._cleanUp(),this.playState=createjs.Sound.PLAY_FINISHED,this},a.destroy=function(){this._cleanUp(),this.src=null,this.playbackResource=null,this.removeAllEventListeners()},a.applyPlayProps=function(a){return null!=a.offset&&this._setPosition(a.offset),null!=a.loop&&this._setLoop(a.loop),null!=a.volume&&this._setVolume(a.volume),null!=a.pan&&this._setPan(a.pan),null!=a.startTime&&(this._setStartTime(a.startTime),this._setDuration(a.duration)),this},a.toString=function(){return"[AbstractSoundInstance]"},a._getPaused=function(){return this._paused},a._setPaused=function(a){return a!==!0&&a!==!1||this._paused==a||1==a&&this.playState!=createjs.Sound.PLAY_SUCCEEDED?void 0:(this._paused=a,a?this._pause():this._resume(),clearTimeout(this.delayTimeoutId),this)},a._setVolume=function(a){return a==this._volume?this:(this._volume=Math.max(0,Math.min(1,a)),this._muted||this._updateVolume(),this)},a._getVolume=function(){return this._volume},a._setMuted=function(a){return a===!0||a===!1?(this._muted=a,this._updateVolume(),this):void 0},a._getMuted=function(){return this._muted},a._setPan=function(a){return a==this._pan?this:(this._pan=Math.max(-1,Math.min(1,a)),this._updatePan(),this)},a._getPan=function(){return this._pan},a._getPosition=function(){return this._paused||this.playState!=createjs.Sound.PLAY_SUCCEEDED||(this._position=this._calculateCurrentPosition()),this._position},a._setPosition=function(a){return this._position=Math.max(0,a),this.playState==createjs.Sound.PLAY_SUCCEEDED&&this._updatePosition(),this},a._getStartTime=function(){return this._startTime},a._setStartTime=function(a){return a==this._startTime?this:(this._startTime=Math.max(0,a||0),this._updateStartTime(),this)},a._getDuration=function(){return this._duration},a._setDuration=function(a){return a==this._duration?this:(this._duration=Math.max(0,a||0),this._updateDuration(),this)},a._setPlaybackResource=function(a){return this._playbackResource=a,0==this._duration&&this._playbackResource&&this._setDurationFromSource(),this},a._getPlaybackResource=function(){return this._playbackResource},a._getLoop=function(){return this._loop},a._setLoop=function(a){null!=this._playbackResource&&(0!=this._loop&&0==a?this._removeLooping(a):0==this._loop&&0!=a&&this._addLooping(a)),this._loop=a},a._sendEvent=function(a){var b=new createjs.Event(a);this.dispatchEvent(b)},a._cleanUp=function(){clearTimeout(this.delayTimeoutId),this._handleCleanUp(),this._paused=!1,createjs.Sound._playFinished(this)},a._interrupt=function(){this._cleanUp(),this.playState=createjs.Sound.PLAY_INTERRUPTED,this._sendEvent("interrupted")},a._beginPlaying=function(a){return this._setPosition(a.offset),this._setLoop(a.loop),this._setVolume(a.volume),this._setPan(a.pan),null!=a.startTime&&(this._setStartTime(a.startTime),this._setDuration(a.duration)),null!=this._playbackResource&&this._position<this._duration?(this._paused=!1,this._handleSoundReady(),this.playState=createjs.Sound.PLAY_SUCCEEDED,this._sendEvent("succeeded"),!0):(this._playFailed(),!1)},a._playFailed=function(){this._cleanUp(),this.playState=createjs.Sound.PLAY_FAILED,this._sendEvent("failed")},a._handleSoundComplete=function(){return this._position=0,0!=this._loop?(this._loop--,this._handleLoop(),void this._sendEvent("loop")):(this._cleanUp(),this.playState=createjs.Sound.PLAY_FINISHED,void this._sendEvent("complete"))},a._handleSoundReady=function(){},a._updateVolume=function(){},a._updatePan=function(){},a._updateStartTime=function(){},a._updateDuration=function(){},a._setDurationFromSource=function(){},a._calculateCurrentPosition=function(){},a._updatePosition=function(){},a._removeLooping=function(){},a._addLooping=function(){},a._pause=function(){},a._resume=function(){},a._handleStop=function(){},a._handleCleanUp=function(){},a._handleLoop=function(){},createjs.AbstractSoundInstance=createjs.promote(AbstractSoundInstance,"EventDispatcher"),createjs.DefaultSoundInstance=createjs.AbstractSoundInstance}(),this.createjs=this.createjs||{},function(){"use strict";var AbstractPlugin=function(){this._capabilities=null,this._loaders={},this._audioSources={},this._soundInstances={},this._volume=1,this._loaderClass,this._soundInstanceClass},a=AbstractPlugin.prototype;AbstractPlugin._capabilities=null,AbstractPlugin.isSupported=function(){return!0},a.register=function(a){var b=this._loaders[a.src];return b&&!b.canceled?this._loaders[a.src]:(this._audioSources[a.src]=!0,this._soundInstances[a.src]=[],b=new this._loaderClass(a),b.on("complete",this._handlePreloadComplete,this),this._loaders[a.src]=b,b)},a.preload=function(a){a.on("error",this._handlePreloadError,this),a.load()},a.isPreloadStarted=function(a){return null!=this._audioSources[a]},a.isPreloadComplete=function(a){return!(null==this._audioSources[a]||1==this._audioSources[a])},a.removeSound=function(a){if(this._soundInstances[a]){for(var b=this._soundInstances[a].length;b--;){var c=this._soundInstances[a][b];c.destroy()}delete this._soundInstances[a],delete this._audioSources[a],this._loaders[a]&&this._loaders[a].destroy(),delete this._loaders[a]}},a.removeAllSounds=function(){for(var a in this._audioSources)this.removeSound(a)},a.create=function(a,b,c){this.isPreloadStarted(a)||this.preload(this.register(a));var d=new this._soundInstanceClass(a,b,c,this._audioSources[a]);return this._soundInstances[a]&&this._soundInstances[a].push(d),d.setMasterVolume&&d.setMasterVolume(createjs.Sound.volume),d.setMasterMute&&d.setMasterMute(createjs.Sound.muted),d},a.setVolume=function(a){return this._volume=a,this._updateVolume(),!0},a.getVolume=function(){return this._volume},a.setMute=function(){return this._updateVolume(),!0},a.toString=function(){return"[AbstractPlugin]"},a._handlePreloadComplete=function(a){var b=a.target.getItem().src;this._audioSources[b]=a.result;for(var c=0,d=this._soundInstances[b].length;d>c;c++){var e=this._soundInstances[b][c];e.playbackResource=this._audioSources[b],this._soundInstances[b]=null}},a._handlePreloadError=function(){},a._updateVolume=function(){},createjs.AbstractPlugin=AbstractPlugin}(),this.createjs=this.createjs||{},function(){"use strict";function a(a){this.AbstractLoader_constructor(a,!0,createjs.Types.SOUND)}var b=createjs.extend(a,createjs.AbstractLoader);a.context=null,b.toString=function(){return"[WebAudioLoader]"},b._createRequest=function(){this._request=new createjs.XHRRequest(this._item,!1),this._request.setResponseType("arraybuffer")},b._sendComplete=function(){a.context.decodeAudioData(this._rawResult,createjs.proxy(this._handleAudioDecoded,this),createjs.proxy(this._sendError,this))},b._handleAudioDecoded=function(a){this._result=a,this.AbstractLoader__sendComplete()},createjs.WebAudioLoader=createjs.promote(a,"AbstractLoader")}(),this.createjs=this.createjs||{},function(){"use strict";function WebAudioSoundInstance(a,c,d,e){this.AbstractSoundInstance_constructor(a,c,d,e),this.gainNode=b.context.createGain(),this.panNode=b.context.createPanner(),this.panNode.panningModel=b._panningModel,this.panNode.connect(this.gainNode),this._updatePan(),this.sourceNode=null,this._soundCompleteTimeout=null,this._sourceNodeNext=null,this._playbackStartTime=0,this._endedHandler=createjs.proxy(this._handleSoundComplete,this)}var a=createjs.extend(WebAudioSoundInstance,createjs.AbstractSoundInstance),b=WebAudioSoundInstance;b.context=null,b._scratchBuffer=null,b.destinationNode=null,b._panningModel="equalpower",a.destroy=function(){this.AbstractSoundInstance_destroy(),this.panNode.disconnect(0),this.panNode=null,this.gainNode.disconnect(0),this.gainNode=null},a.toString=function(){return"[WebAudioSoundInstance]"},a._updatePan=function(){this.panNode.setPosition(this._pan,0,-.5)},a._removeLooping=function(){this._sourceNodeNext=this._cleanUpAudioNode(this._sourceNodeNext)},a._addLooping=function(){this.playState==createjs.Sound.PLAY_SUCCEEDED&&(this._sourceNodeNext=this._createAndPlayAudioNode(this._playbackStartTime,0))},a._setDurationFromSource=function(){this._duration=1e3*this.playbackResource.duration},a._handleCleanUp=function(){this.sourceNode&&this.playState==createjs.Sound.PLAY_SUCCEEDED&&(this.sourceNode=this._cleanUpAudioNode(this.sourceNode),this._sourceNodeNext=this._cleanUpAudioNode(this._sourceNodeNext)),0!=this.gainNode.numberOfOutputs&&this.gainNode.disconnect(0),clearTimeout(this._soundCompleteTimeout),this._playbackStartTime=0},a._cleanUpAudioNode=function(a){if(a){if(a.stop(0),a.disconnect(0),createjs.BrowserDetect.isIOS)try{a.buffer=b._scratchBuffer}catch(c){}a=null}return a},a._handleSoundReady=function(){this.gainNode.connect(b.destinationNode);var a=.001*this._duration,c=Math.min(.001*Math.max(0,this._position),a);this.sourceNode=this._createAndPlayAudioNode(b.context.currentTime-a,c),this._playbackStartTime=this.sourceNode.startTime-c,this._soundCompleteTimeout=setTimeout(this._endedHandler,1e3*(a-c)),0!=this._loop&&(this._sourceNodeNext=this._createAndPlayAudioNode(this._playbackStartTime,0))},a._createAndPlayAudioNode=function(a,c){var d=b.context.createBufferSource();d.buffer=this.playbackResource,d.connect(this.panNode);var e=.001*this._duration;return d.startTime=a+e,d.start(d.startTime,c+.001*this._startTime,e-c),d},a._pause=function(){this._position=1e3*(b.context.currentTime-this._playbackStartTime),this.sourceNode=this._cleanUpAudioNode(this.sourceNode),this._sourceNodeNext=this._cleanUpAudioNode(this._sourceNodeNext),0!=this.gainNode.numberOfOutputs&&this.gainNode.disconnect(0),clearTimeout(this._soundCompleteTimeout)},a._resume=function(){this._handleSoundReady()},a._updateVolume=function(){var a=this._muted?0:this._volume;a!=this.gainNode.gain.value&&(this.gainNode.gain.value=a)},a._calculateCurrentPosition=function(){return 1e3*(b.context.currentTime-this._playbackStartTime)},a._updatePosition=function(){this.sourceNode=this._cleanUpAudioNode(this.sourceNode),this._sourceNodeNext=this._cleanUpAudioNode(this._sourceNodeNext),clearTimeout(this._soundCompleteTimeout),this._paused||this._handleSoundReady()},a._handleLoop=function(){this._cleanUpAudioNode(this.sourceNode),this.sourceNode=this._sourceNodeNext,this._playbackStartTime=this.sourceNode.startTime,this._sourceNodeNext=this._createAndPlayAudioNode(this._playbackStartTime,0),this._soundCompleteTimeout=setTimeout(this._endedHandler,this._duration)},a._updateDuration=function(){this.playState==createjs.Sound.PLAY_SUCCEEDED&&(this._pause(),this._resume())},createjs.WebAudioSoundInstance=createjs.promote(WebAudioSoundInstance,"AbstractSoundInstance")}(),this.createjs=this.createjs||{},function(){"use strict";function WebAudioPlugin(){this.AbstractPlugin_constructor(),this._panningModel=b._panningModel,this.context=b.context,this.dynamicsCompressorNode=this.context.createDynamicsCompressor(),this.dynamicsCompressorNode.connect(this.context.destination),this.gainNode=this.context.createGain(),this.gainNode.connect(this.dynamicsCompressorNode),createjs.WebAudioSoundInstance.destinationNode=this.gainNode,this._capabilities=b._capabilities,this._loaderClass=createjs.WebAudioLoader,this._soundInstanceClass=createjs.WebAudioSoundInstance,this._addPropsToClasses()}var a=createjs.extend(WebAudioPlugin,createjs.AbstractPlugin),b=WebAudioPlugin;b._capabilities=null,b._panningModel="equalpower",b.context=null,b._scratchBuffer=null,b._unlocked=!1,b.DEFAULT_SAMPLE_RATE=44100,b.isSupported=function(){var a=createjs.BrowserDetect.isIOS||createjs.BrowserDetect.isAndroid||createjs.BrowserDetect.isBlackberry;return"file:"!=location.protocol||a||this._isFileXHRSupported()?(b._generateCapabilities(),null==b.context?!1:!0):!1},b.playEmptySound=function(){if(null!=b.context){var a=b.context.createBufferSource();a.buffer=b._scratchBuffer,a.connect(b.context.destination),a.start(0,0,0)}},b._isFileXHRSupported=function(){var a=!0,b=new XMLHttpRequest;try{b.open("GET","WebAudioPluginTest.fail",!1)}catch(c){return a=!1}b.onerror=function(){a=!1},b.onload=function(){a=404==this.status||200==this.status||0==this.status&&""!=this.response};try{b.send()}catch(c){a=!1}return a},b._generateCapabilities=function(){if(null==b._capabilities){var a=document.createElement("audio");if(null==a.canPlayType)return null;if(null==b.context&&(b.context=b._createAudioContext(),null==b.context))return null;null==b._scratchBuffer&&(b._scratchBuffer=b.context.createBuffer(1,1,22050)),b._compatibilitySetUp(),"ontouchstart"in window&&"running"!=b.context.state&&(b._unlock(),document.addEventListener("mousedown",b._unlock,!0),document.addEventListener("touchstart",b._unlock,!0),document.addEventListener("touchend",b._unlock,!0)),b._capabilities={panning:!0,volume:!0,tracks:-1};for(var c=createjs.Sound.SUPPORTED_EXTENSIONS,d=createjs.Sound.EXTENSION_MAP,e=0,f=c.length;f>e;e++){var g=c[e],h=d[g]||g;b._capabilities[g]="no"!=a.canPlayType("audio/"+g)&&""!=a.canPlayType("audio/"+g)||"no"!=a.canPlayType("audio/"+h)&&""!=a.canPlayType("audio/"+h)}b.context.destination.numberOfChannels<2&&(b._capabilities.panning=!1)}},b._createAudioContext=function(){var a=window.AudioContext||window.webkitAudioContext;if(null==a)return null;var c=new a;if(/(iPhone|iPad)/i.test(navigator.userAgent)&&c.sampleRate!==b.DEFAULT_SAMPLE_RATE){var d=c.createBuffer(1,1,b.DEFAULT_SAMPLE_RATE),e=c.createBufferSource();e.buffer=d,e.connect(c.destination),e.start(0),e.disconnect(),c.close(),c=new a}return c},b._compatibilitySetUp=function(){if(b._panningModel="equalpower",!b.context.createGain){b.context.createGain=b.context.createGainNode;var a=b.context.createBufferSource();a.__proto__.start=a.__proto__.noteGrainOn,a.__proto__.stop=a.__proto__.noteOff,b._panningModel=0}},b._unlock=function(){b._unlocked||(b.playEmptySound(),"running"==b.context.state&&(document.removeEventListener("mousedown",b._unlock,!0),document.removeEventListener("touchend",b._unlock,!0),document.removeEventListener("touchstart",b._unlock,!0),b._unlocked=!0))},a.toString=function(){return"[WebAudioPlugin]"},a._addPropsToClasses=function(){var a=this._soundInstanceClass;a.context=this.context,a._scratchBuffer=b._scratchBuffer,a.destinationNode=this.gainNode,a._panningModel=this._panningModel,this._loaderClass.context=this.context},a._updateVolume=function(){var a=createjs.Sound._masterMute?0:this._volume;a!=this.gainNode.gain.value&&(this.gainNode.gain.value=a)},createjs.WebAudioPlugin=createjs.promote(WebAudioPlugin,"AbstractPlugin")}(),this.createjs=this.createjs||{},function(){"use strict";function HTMLAudioTagPool(){throw"HTMLAudioTagPool cannot be instantiated"}function a(){this._tags=[]}var b=HTMLAudioTagPool;b._tags={},b._tagPool=new a,b._tagUsed={},b.get=function(a){var c=b._tags[a];return null==c?(c=b._tags[a]=b._tagPool.get(),c.src=a):b._tagUsed[a]?(c=b._tagPool.get(),c.src=a):b._tagUsed[a]=!0,c},b.set=function(a,c){c==b._tags[a]?b._tagUsed[a]=!1:b._tagPool.set(c)},b.remove=function(a){var c=b._tags[a];return null==c?!1:(b._tagPool.set(c),delete b._tags[a],delete b._tagUsed[a],!0)},b.getDuration=function(a){var c=b._tags[a];return null!=c&&c.duration?1e3*c.duration:0},createjs.HTMLAudioTagPool=HTMLAudioTagPool;var c=a.prototype;c.constructor=a,c.get=function(){var a;return a=0==this._tags.length?this._createTag():this._tags.pop(),null==a.parentNode&&document.body.appendChild(a),a},c.set=function(a){var b=createjs.indexOf(this._tags,a);-1==b&&(this._tags.src=null,this._tags.push(a))},c.toString=function(){return"[TagPool]"},c._createTag=function(){var a=document.createElement("audio");return a.autoplay=!1,a.preload="none",a}}(),this.createjs=this.createjs||{},function(){"use strict";function HTMLAudioSoundInstance(a,b,c,d){this.AbstractSoundInstance_constructor(a,b,c,d),this._audioSpriteStopTime=null,this._delayTimeoutId=null,this._endedHandler=createjs.proxy(this._handleSoundComplete,this),this._readyHandler=createjs.proxy(this._handleTagReady,this),this._stalledHandler=createjs.proxy(this._playFailed,this),this._audioSpriteEndHandler=createjs.proxy(this._handleAudioSpriteLoop,this),this._loopHandler=createjs.proxy(this._handleSoundComplete,this),c?this._audioSpriteStopTime=.001*(b+c):this._duration=createjs.HTMLAudioTagPool.getDuration(this.src)}var a=createjs.extend(HTMLAudioSoundInstance,createjs.AbstractSoundInstance);a.setMasterVolume=function(){this._updateVolume()},a.setMasterMute=function(){this._updateVolume()},a.toString=function(){return"[HTMLAudioSoundInstance]"},a._removeLooping=function(){null!=this._playbackResource&&(this._playbackResource.loop=!1,this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1))},a._addLooping=function(){null==this._playbackResource||this._audioSpriteStopTime||(this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1),this._playbackResource.loop=!0)},a._handleCleanUp=function(){var a=this._playbackResource;if(null!=a){a.pause(),a.loop=!1,a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED,this._endedHandler,!1),a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY,this._readyHandler,!1),a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED,this._stalledHandler,!1),a.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1),a.removeEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE,this._audioSpriteEndHandler,!1);try{a.currentTime=this._startTime}catch(b){}createjs.HTMLAudioTagPool.set(this.src,a),this._playbackResource=null}},a._beginPlaying=function(a){return this._playbackResource=createjs.HTMLAudioTagPool.get(this.src),this.AbstractSoundInstance__beginPlaying(a)},a._handleSoundReady=function(){if(4!==this._playbackResource.readyState){var a=this._playbackResource;return a.addEventListener(createjs.HTMLAudioPlugin._AUDIO_READY,this._readyHandler,!1),a.addEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED,this._stalledHandler,!1),a.preload="auto",void a.load()}this._updateVolume(),this._playbackResource.currentTime=.001*(this._startTime+this._position),this._audioSpriteStopTime?this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE,this._audioSpriteEndHandler,!1):(this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED,this._endedHandler,!1),0!=this._loop&&(this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1),this._playbackResource.loop=!0)),this._playbackResource.play()},a._handleTagReady=function(){this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_READY,this._readyHandler,!1),this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_STALLED,this._stalledHandler,!1),this._handleSoundReady()},a._pause=function(){this._playbackResource.pause()},a._resume=function(){this._playbackResource.play()},a._updateVolume=function(){if(null!=this._playbackResource){var a=this._muted||createjs.Sound._masterMute?0:this._volume*createjs.Sound._masterVolume;a!=this._playbackResource.volume&&(this._playbackResource.volume=a)}},a._calculateCurrentPosition=function(){return 1e3*this._playbackResource.currentTime-this._startTime},a._updatePosition=function(){this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1),this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._handleSetPositionSeek,!1);try{this._playbackResource.currentTime=.001*(this._position+this._startTime)}catch(a){this._handleSetPositionSeek(null)}},a._handleSetPositionSeek=function(){null!=this._playbackResource&&(this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._handleSetPositionSeek,!1),this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1))},a._handleAudioSpriteLoop=function(){this._playbackResource.currentTime<=this._audioSpriteStopTime||(this._playbackResource.pause(),0==this._loop?this._handleSoundComplete(null):(this._position=0,this._loop--,this._playbackResource.currentTime=.001*this._startTime,this._paused||this._playbackResource.play(),this._sendEvent("loop")))},a._handleLoop=function(){0==this._loop&&(this._playbackResource.loop=!1,this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_SEEKED,this._loopHandler,!1))},a._updateStartTime=function(){this._audioSpriteStopTime=.001*(this._startTime+this._duration),this.playState==createjs.Sound.PLAY_SUCCEEDED&&(this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED,this._endedHandler,!1),this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE,this._audioSpriteEndHandler,!1))},a._updateDuration=function(){this._audioSpriteStopTime=.001*(this._startTime+this._duration),this.playState==createjs.Sound.PLAY_SUCCEEDED&&(this._playbackResource.removeEventListener(createjs.HTMLAudioPlugin._AUDIO_ENDED,this._endedHandler,!1),this._playbackResource.addEventListener(createjs.HTMLAudioPlugin._TIME_UPDATE,this._audioSpriteEndHandler,!1))},a._setDurationFromSource=function(){this._duration=createjs.HTMLAudioTagPool.getDuration(this.src),this._playbackResource=null},createjs.HTMLAudioSoundInstance=createjs.promote(HTMLAudioSoundInstance,"AbstractSoundInstance")}(),this.createjs=this.createjs||{},function(){"use strict";function HTMLAudioPlugin(){this.AbstractPlugin_constructor(),this._capabilities=b._capabilities,this._loaderClass=createjs.SoundLoader,this._soundInstanceClass=createjs.HTMLAudioSoundInstance}var a=createjs.extend(HTMLAudioPlugin,createjs.AbstractPlugin),b=HTMLAudioPlugin;b.MAX_INSTANCES=30,b._AUDIO_READY="canplaythrough",b._AUDIO_ENDED="ended",b._AUDIO_SEEKED="seeked",b._AUDIO_STALLED="stalled",b._TIME_UPDATE="timeupdate",b._capabilities=null,b.isSupported=function(){return b._generateCapabilities(),null!=b._capabilities},b._generateCapabilities=function(){if(null==b._capabilities){var a=document.createElement("audio");if(null==a.canPlayType)return null;b._capabilities={panning:!1,volume:!0,tracks:-1};for(var c=createjs.Sound.SUPPORTED_EXTENSIONS,d=createjs.Sound.EXTENSION_MAP,e=0,f=c.length;f>e;e++){var g=c[e],h=d[g]||g;b._capabilities[g]="no"!=a.canPlayType("audio/"+g)&&""!=a.canPlayType("audio/"+g)||"no"!=a.canPlayType("audio/"+h)&&""!=a.canPlayType("audio/"+h)}}},a.register=function(a){var b=createjs.HTMLAudioTagPool.get(a.src),c=this.AbstractPlugin_register(a);return c.setTag(b),c},a.removeSound=function(a){this.AbstractPlugin_removeSound(a),createjs.HTMLAudioTagPool.remove(a)},a.create=function(a,b,c){var d=this.AbstractPlugin_create(a,b,c);return d.playbackResource=null,d},a.toString=function(){return"[HTMLAudioPlugin]"},a.setVolume=a.getVolume=a.setMute=null,createjs.HTMLAudioPlugin=createjs.promote(HTMLAudioPlugin,"AbstractPlugin")
}();
define("sound", ["easel"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.createjs.Sound;
    };
}(this)));

define('controllers/pageTurner',['constants', 'config', 'easel', 'sound'],
    function(constants, config, createjs, sound) {

        var DIRECTION = {
            PREVIOUS: 'previous',
            NEXT: 'next'
        };

        var PAGE_POSITION = {
            LEFT: 'left',
            RIGHT: 'right',
            MIDDLE: 'middle',
            BLANK: 'blank'
        };

        var CORNER = {
            TOP_LEFT: 0,
            TOP_RIGHT: 1,
            BOTTOM_LEFT: 2,
            BOTTOM_RIGHT: 3
        };

        // Values are chosen to allow bitwise testing with the CORNER constants.
        var SIDE = {
            RIGHT: 1,
            BOTTOM: 2
        };

        var createAnimation = function(currentTray, nextTray, currentPageIndex, direction) {
            var animation = new PageTurnAnimation();
            animation.setUpAnimation(currentTray, nextTray, currentPageIndex, direction);
            return animation;
        };

        var audioResources = {
            PageFlip: { src: 'pageFlip.mp3', loaded: false }
        };

        // Class to manage the page turn animation
        //
        // The animation is hard-coded to turn from the bottom corner of the page. The animation actually works from
        // any of the four corners, but the shadow effects were written later and only work with the bottom corners -
        // if for any reason you want a top corner turn animation, the shadow calculations will need to be updated
        // first!
        var PageTurnAnimation = function() {
            var self = this;
            var pageImages = {};
            var animating = false;
            var isRight = false;
            var isBottom = false;
            var corner = 0;
            var audioEnabled = null;
            var doIntroPageFadeOut = false;
            var DEFAULT_DURATION = 400;
            var DEFAULT_INTRO_PAGE_FADE_TIME = 200;
            var AUDIO_ID_PAGE_FLIP = "PageFlip";
            self.animationLayer = new createjs.Container();

            var sidewaysTranslation = {
                before: 0,
                during: 0
            };

            self.setUpAnimation = function(currentTray, nextTray, currentPageIndex, direction) {
                // Make bitmap replicas of the relevant pages:
                //   passive: the page to the side of the one we're turning
                //   current: the page we're turning
                //   overleaf: the page on the reverse of current (which will replace 'passive')
                //   next: the page revealed by the page turn
                //
                // This is fiddly because it depends not only on which direction we're going in, but also whether
                // there's one or two pages on the current or subsequent double page spread.
                if (currentTray.pages.length > 1) {
                    if (direction == DIRECTION.PREVIOUS) {
                        pageImages.current = createImageOfPage(currentTray.pages[0], PAGE_POSITION.LEFT);
                        pageImages.passive = createImageOfPage(currentTray.pages[1], PAGE_POSITION.RIGHT);
                    } else {
                        if (currentPageIndex == 0 && currentTray.pages[0].width != currentTray.pages[1].width) {
                            doIntroPageFadeOut = true;
                        }

                        pageImages.passive = createImageOfPage(currentTray.pages[0], PAGE_POSITION.LEFT, { introPageFadeOut: doIntroPageFadeOut} );
                        pageImages.current = createImageOfPage(currentTray.pages[1], PAGE_POSITION.RIGHT);
                    }
                } else {
                    pageImages.current = createImageOfPage(currentTray.pages[0], PAGE_POSITION.MIDDLE);
                    sidewaysTranslation.before = direction == DIRECTION.NEXT ? -1 : 1;
                    sidewaysTranslation.during = -sidewaysTranslation.before;
                }

                if (direction == DIRECTION.PREVIOUS) {
                    corner = CORNER.BOTTOM_LEFT;

                    if (nextTray.pages.length > 1) {
                        pageImages.overleaf = createImageOfPage(nextTray.pages[1], PAGE_POSITION.RIGHT, { useShadow: true });
                        pageImages.next = createImageOfPage(nextTray.pages[0], PAGE_POSITION.LEFT);
                    } else {
                        pageImages.overleaf = createImageOfPage(nextTray.pages[0], PAGE_POSITION.MIDDLE, { useShadow: true });
                        pageImages.next = createImageOfPage(nextTray.pages[0], PAGE_POSITION.BLANK);
                        sidewaysTranslation.during = -1;
                    }
                } else {
                    corner = CORNER.BOTTOM_RIGHT;

                    if (nextTray.pages.length > 1) {
                        pageImages.overleaf = createImageOfPage(nextTray.pages[0], PAGE_POSITION.LEFT, { useShadow: true });
                        pageImages.next = createImageOfPage(nextTray.pages[1], PAGE_POSITION.RIGHT);
                    } else {
                        pageImages.overleaf = createImageOfPage(nextTray.pages[0], PAGE_POSITION.MIDDLE, { useShadow: true });
                        pageImages.next = createImageOfPage(nextTray.pages[0], PAGE_POSITION.BLANK);
                        sidewaysTranslation.during = 1;
                    }
                }

                // Special case for when the edition has exactly two pages (and so is presented as a single page with
                // two sides). In this case the animated page needs to move twice as far to end in the right place.
                if (currentTray.pages.length == 1 && nextTray.pages.length == 1) {
                    sidewaysTranslation.during *= 2;
                }

                // Add the created images to the animation layer.
                if (pageImages.passive) {
                    self.animationLayer.addChild(pageImages.passive.container);
                }

                self.animationLayer.addChild(pageImages.current.container);
                self.animationLayer.addChild(pageImages.next.container);
                self.animationLayer.addChild(pageImages.overleaf.container);
            };

            // createImageOfPage
            //
            // Returns an object encapsulating i) a bitmap of the page supplied; ii) the createjs container for that
            // bitmap; iii) optionally, placeholder createjs.DisplayObjects to which shadow effects can be added
            // under / over the bitmap.
            //
            // The bitmap is provided with a container so that additional shapes can be easily added.
            var createImageOfPage = function(page, pagePosition, options) {
                if (!page.zoomLevels || page.zoomLevels.length == 0) return null;

                // The origin point for the page is halfway down it - hence the various adjustments for adding or
                // subtracting half the zoomLevel's height.
                var zoomLevel = page.zoomLevels[page.z].zoomLevelView;
                var root = zoomLevel.container.parent.parent;
                var width = zoomLevel.width;
                var height = 2 * zoomLevel.height;
                var originPoint = {x: 0, y: -(zoomLevel.height / 2)};

                if (pagePosition == PAGE_POSITION.LEFT) {
                    originPoint.x -= width;
                } else if (pagePosition == PAGE_POSITION.MIDDLE) {
                    originPoint.x -= width * 0.5;
                } else if (pagePosition == PAGE_POSITION.BLANK) {
                    // Intentionally capture an empty area of the right height and width.
                    originPoint.x -= width * 20;
                }

                root.cache(originPoint.x, originPoint.y, width, height);
                var copiedImage = new createjs.Bitmap(root.cacheCanvas);
                copiedImage.x = 0;
                copiedImage.y = -(zoomLevel.height / 2);
                root.uncache();

                var container = new createjs.Container();
                var overShadow = new createjs.Shape();
                var underShadow = new createjs.Shape();

                if (options && options.useShadow) {
                    container.addChild(underShadow);
                }
                container.addChild(copiedImage);
                if (options && options.useShadow) {
                    container.addChild(overShadow);
                }

                return {
                    page: copiedImage,
                    container: container,
                    overShadow: overShadow,
                    underShadow: underShadow,
                    fadeOut: (options && options.introPageFadeOut)
                };
            };

            this.start = function(onComplete) {
                isRight = (corner & SIDE.RIGHT) == SIDE.RIGHT;
                isBottom = (corner & SIDE.BOTTOM) == SIDE.BOTTOM;
                var sidewaysAdjustment = pageImages.current.page.image.width / 2;

                if (isRight) {
                    if (pageImages.passive) {
                        pageImages.passive.page.x = -pageImages.passive.page.image.width;
                    }

                    pageImages.overleaf.page.x = pageImages.overleaf.page.image.width;
                    pageImages.overleaf.overShadow.x = pageImages.overleaf.page.image.width;
                } else {
                    pageImages.overleaf.page.regX = pageImages.overleaf.page.image.width;
                    pageImages.overleaf.overShadow.regX = pageImages.overleaf.page.image.width;
                    pageImages.overleaf.page.x = -pageImages.overleaf.page.image.width;
                    pageImages.overleaf.overShadow.x = -pageImages.overleaf.page.image.width;
                    pageImages.current.page.x = -pageImages.current.page.image.width;
                    pageImages.next.page.x = -pageImages.next.page.image.width;
                }

                if (isBottom) {
                    pageImages.overleaf.page.regY = pageImages.overleaf.page.image.height / 2;
                    pageImages.overleaf.overShadow.regY = pageImages.overleaf.page.image.height / 2;
                    pageImages.overleaf.page.y = pageImages.overleaf.page.image.height / 4;
                    pageImages.overleaf.overShadow.y = pageImages.overleaf.page.image.height / 4;
                }

                if (sidewaysTranslation.before) {
                    pageImages.current.container.parent.x += (sidewaysTranslation.before * sidewaysAdjustment);
                }

                // Make sure page images are properly clipped before they're first drawn.
                applyMasksAndShadows();

                var options = {
                    totalTime: config.pageTurnDurationMs || DEFAULT_DURATION,
                    sidewaysTranslation: sidewaysTranslation
                };

                // If the pages do not match in size, the animation will look odd once the new page is turned over
                // on top of the passive page. To combat this, the passive page fades out before the animation.
                // Some editions have a small discrepancy in page size (< 10 pixels) which are not as visually
                // disruptive as the fade, so in these cases no fade is applied.
                if (pageImages.passive
                    && pageImages.passive.page.image.width - pageImages.current.page.image.width > 10) {
                    options.fadeOut = true;
                }

                if (pageImages.next && pageImages.next.page.image.width != pageImages.current.page.image.width) {
                    options.fadeIn = true;
                }

                var trackingPoints = getAnimationTrackingPoints(options.totalTime);
                animateToTrackingPoint(trackingPoints, options, onComplete);

                if (config.pageTurnAudioEnabled) {
                    self.ifAudioAvailableThenPlay(AUDIO_ID_PAGE_FLIP);
                }
            };

            var getAnimationTrackingPoints = function(totalTime) {
                // Calculate a set of data points to define the page turn motion. Each point is the position of
                // the leading page corner, relative to its starting point, as a fraction of the page width/height
                // (so independent of the direction - x=0 is the start, x=1 is the end).
                //
                // The numbers are calculated based on a Bezier curve from (0,0) to (1,0) with tracking points at
                // (0, 0.3) and (0.5, 0). The general formula is for a point (x,y) at time t is:
                // x = (1-t)((1-t)((1-t)x0+tx1)+t((1-t)x1+tx2))+t((1-t)((1-t)x1+tx2)+t((1-t)x2+tx3))
                // y = (1-t)((1-t)((1-t)y0+ty1)+t((1-t)y1+ty2))+t((1-t)((1-t)y1+ty2)+t((1-t)y2+ty3))
                // (where x0 and x3 are the start and end points, and x1 and x2 are the tracking points).
                //
                // However, instead of using the proper Bezier values, this just uses t for the x value, so that the
                // point moves across at a constant speed - in practice this looks nicer than following the curve
                // properly.
                //
                // Using a Bezier curve is of course massive overkill - an approximate 'best guess' series of points
                // looks almost as good. But might as well do it properly.
                //
                // To change the degree of vertical movement, adjust the y1 term (the higher it is, the more the
                // leading corner shifts away from the bottom edge).
                var trackingPoints = [];
                var numberOfAnimationSteps = 10;

                // Full formula:
                // y = (1-t)((1-t)((1-t)y0+ty1)+t((1-t)y1+ty2)) + t((1-t)((1-t)y1+ty2)+t((1-t)y2+ty3))
                //
                // Simplified formula, eliminating the terms that always evaluate to zero:
                // y = (1-t)((1-t)ty1+t(1-t)y1) + t((1-t)(1-t)y1)
                //
                for (var t = 0; t < 1; t += 1 / numberOfAnimationSteps) {
                    var tInv = 1-t;
                    var y1 = 0.3;
                    var y = (tInv * ((tInv*t*y1) + (t*tInv*y1))) + (t*(tInv*tInv*y1));
                    trackingPoints.push({x: t, y: y, time: 1});
                }

                var sumOfTimeSlices = trackingPoints.reduce(function(accumulator, point) { return accumulator + point.time; }, 0);

                // Now scale the idealised tracking points so they're relative to the page dimensions.
                return trackingPoints.map(function(point) {
                    return {
                        x: point.x * 2 * pageImages.current.page.image.width,
                        y: point.y * pageImages.current.page.image.height,
                        time: (point.time  / sumOfTimeSlices) * totalTime
                    };
                });
            };

            var relativeToAbsoluteY = function(relativeY) {
                var offset = isBottom ? ((pageImages.current.page.image.height / 2) - relativeY) : relativeY;
                return offset - (pageImages.current.page.image.height / 4);
            };

            var animateToTrackingPoint = function(trackingPoints, options, onComplete) {
                createjs.Ticker.addEventListener("tick", handleTick);
                animating = true;
                var pageTween = createjs.Tween.get(pageImages.overleaf.page);
                var sign = isRight ? 1 : -1;
                var fadeTime = Math.min(DEFAULT_INTRO_PAGE_FADE_TIME, options.totalTime);

                // Optional extra animation to fade out the intro page, when moving from the start of the edition to
                // the following pages.
                if (options.fadeOut) {
                    var fadeOutTween = createjs.Tween.get(pageImages.passive.container);
                    fadeOutTween.to({alpha: 0}, fadeTime, createjs.Ease.linear);
                }

                // Optional extra animation to fade in the intro page, when moving to the start of the edition.
                if (options.fadeIn) {
                    pageImages.next.container.alpha = 0;
                    var fadeInTween = createjs.Tween.get(pageImages.next.container);
                    fadeInTween.wait(options.totalTime - fadeTime).to({alpha: 1}, fadeTime, createjs.Ease.linear);
                }

                // If transitioning _to_ the front or back cover, if the cover will be displayed as a single page,
                // we also want to animate the entire layer to the side, so that the final page(s) are positioned in
                // the right place.
                // Unlike all the other tweens, this one uses a non-linear easing; it looks better for this animation
                // to be slightly 'delayed'.
                if (options.sidewaysTranslation.during) {
                    var containerTween = createjs.Tween.get(pageImages.current.container.parent);
                    containerTween.to({
                        x: pageImages.current.container.parent.x + (options.sidewaysTranslation.during * (pageImages.current.page.image.width / 2))
                    }, options.totalTime, createjs.Ease.quartIn);
                }

                // Now set up the main animation. This just animates the position and rotation of the 'overleaf' page
                // - everything else is handled by applyMasksAndShadows().
                var trackingPoint;
                for (var index = 0; index < trackingPoints.length; ++index) {
                    trackingPoint = trackingPoints[index];
                    var targetX = sign * (pageImages.current.page.image.width - trackingPoint.x);
                    var targetY = relativeToAbsoluteY(trackingPoint.y);

                    pageTween.to({
                            x: targetX,
                            y: targetY
                        },
                        trackingPoint.time,
                        createjs.Ease.linear);
                }

                pageTween
                    .wait(trackingPoint.time) // Wait for final animation step to complete
                    .call(function() {
                        // Animation complete - make sure the masks etc. are correct before finalising.
                        applyMasksAndShadows();
                        animating = false;
                        onComplete();
                    });
            };

            function handleTick(e) {
                if (!animating) return;
                applyMasksAndShadows();
            }

            // To make heads or tails of what's going on here, you probably want to read the info at
            // https://yiki.yudu.com/doku.php?id=idt:projects:html_reader:page_turn as a primer.
            function applyMasksAndShadows() {
                var pageDimensions = {width: pageImages.current.page.image.width, height: pageImages.current.page.image.height / 2};
                var origin = {x: 0, y: pageImages.next.page.image.height / 4 };
                var signX = isRight ? 1 : -1;
                var signY = isBottom? -1 : 1;

                var trackingY = (pageImages.current.page.image.height / 4) + (signY * pageImages.overleaf.page.y);
                var trackingPoint = {
                    x: pageDimensions.width - (signX * pageImages.overleaf.page.x),
                    y: trackingY
                };

                var geometries = self.getGeometries(trackingPoint);
                pageImages.overleaf.page.rotation = signX * signY * -geometries.pageRotationAngle.degrees;

                var cornerPoint = { x: isRight ? 0 : pageDimensions.width, y: isBottom ? pageDimensions.height : 0 };
                var foldLineTop = { x: cornerPoint.x, y: cornerPoint.y + (signY * geometries.maskDimensions.height) };
                var foldLineBottom = { x: cornerPoint.x + (signX * geometries.maskDimensions.width), y: cornerPoint.y };
                var percentProgress = geometries.maskDimensions.width / pageDimensions.width;

                // To draw a shadow under the turning page, create a shape of exactly the same size as the overleaf page
                // fragment, offset it by a fixed amount, and fill it with a transparent black.
                //
                // This uses coords relative to the frame not to the overleaf page, because it's easier to offset in
                // the desired direction that way.
                //
                // A more sophisticated shadow effect is possible either by applying a blur filter or by using the
                // built-in create.js Shadow class, but both of these are more computationally expensive (and therefore
                // slower) and are tricky to set up correctly. The blur fliter needs a cache() call to make it render,
                // which means accurately defining the bounds to operate on; the Shadow works great, except that then
                // the mask applied to the overleaf object needs to be adjusted to not clip it off, which is
                // non-trivial.
                var maxUnderShadowOffset = 15;
                var underShadowOffset = maxUnderShadowOffset * (1 - percentProgress);

                pageImages.overleaf.underShadow.graphics.clear();
                pageImages.overleaf.underShadow.graphics.beginFill('rgb(0,0,0,0.3)')
                    .moveTo(pageImages.overleaf.page.x - (signX * underShadowOffset), pageImages.overleaf.page.y)
                    .lineTo((isRight ? pageDimensions.width : 0) - foldLineBottom.x - (signX * underShadowOffset), foldLineBottom.y / 2)
                    .lineTo((isRight ? pageDimensions.width : (-2 * pageDimensions.width)) + foldLineTop.x - (signX * underShadowOffset), foldLineTop.y - (pageDimensions.height / 2))
                    .lineTo(pageImages.overleaf.page.x - (signX * underShadowOffset), pageImages.overleaf.page.y)
                    .endStroke();

                // Now draw the shadow on the turning (overleaf) page itself. This is done by drawing a linear
                // gradient on top of the page parallel to the line of the fold.
                // Coordinates are again relative to the frame not the page.
                // The gradient starts by spanning the full width of the overleaf area (which is initially zero
                // width) and decreases linearly to none of it at the point the animation completes; the darkness
                // of the shadow also decreases linearly.
                // We'd need to clip the shadow to prevent it spilling outside the overleaf area, but it's defined
                // such that it never does - except in the area beyond the top and bottom of the screen.
                var shadowOffsetDistance = percentProgress == 0 ?
                    geometries.maskDimensions.width :
                    geometries.maskDimensions.width * (1 - percentProgress);

                var shadowReferencePoint = translateAtAngle(
                    foldLineBottom,
                    new Angle().withDegrees(90 + (signX * geometries.primaryAngle.degrees)),
                    signX * -shadowOffsetDistance);

                var maxShadowIntensity = 0.6;
                var shadowIntensity = maxShadowIntensity * (1 - percentProgress);
                var shadowColour = "30,15,5";
                var shadowColourTransparent = "rgba(" + shadowColour + ",0)";
                var shadowColourOpaque = "rgba(" + shadowColour + "," + shadowIntensity + ")";

                pageImages.overleaf.overShadow.rotation = pageImages.overleaf.page.rotation;
                pageImages.overleaf.overShadow.x = pageImages.overleaf.page.x;
                pageImages.overleaf.overShadow.y = pageImages.overleaf.page.y;
                pageImages.overleaf.overShadow.graphics.clear();
                pageImages.overleaf.overShadow.graphics
                    .beginLinearGradientFill(
                        [shadowColourTransparent, shadowColourOpaque, shadowColourTransparent],
                        [0,0.2,1],
                        foldLineBottom.x, foldLineBottom.y,shadowReferencePoint.x, shadowReferencePoint.y)
                    .drawRect(0, 0, pageDimensions.width, pageDimensions.height);

                var isAnimatedPageInFinalPosition = geometries.maskDimensions.height === 0
                    && pageImages.overleaf.page.x !== signX * pageDimensions.width;
                var overleafMask = new createjs.Shape();
                // If the animated page is not in its final position, shape the mask as a triangle...
                if (!isAnimatedPageInFinalPosition) {
                    overleafMask.graphics
                        .moveTo(pageImages.overleaf.page.x, pageImages.overleaf.page.y)
                        .lineTo(pageImages.overleaf.page.x + (signX * geometries.maskOffset.x), signY * (-origin.y))
                        .lineTo((signX * pageDimensions.width), signY * (geometries.maskDimensions.height - origin.y))
                        .lineTo(pageImages.overleaf.page.x, pageImages.overleaf.page.y);
                }
                // ... otherwise shape the mask as a rectangle.
                else {
                    overleafMask.graphics
                        .moveTo(pageImages.overleaf.page.x, pageImages.overleaf.page.y)
                        .lineTo(pageImages.overleaf.page.x + signX * pageDimensions.width, pageImages.overleaf.page.y)
                        .lineTo(pageImages.overleaf.page.x + signX * pageDimensions.width, -pageImages.overleaf.page.y)
                        .lineTo( pageImages.overleaf.page.x, -pageImages.overleaf.page.y)
                        .lineTo( pageImages.overleaf.page.x, pageImages.overleaf.page.y);
                }

                var currentMask = new createjs.Shape();
                // If the animated page is not in its final position, apply the mask...
                if (!isAnimatedPageInFinalPosition) {
                    currentMask.graphics
                        .moveTo(0, signY * (-origin.y))
                        .lineTo(pageImages.overleaf.page.x + (signX * geometries.maskOffset.x), signY * (-origin.y))
                        .lineTo(pageImages.overleaf.page.x, pageImages.overleaf.page.y)
                        .lineTo((signX * pageDimensions.width), signY * (geometries.maskDimensions.height - origin.y))
                        .lineTo((signX * pageDimensions.width), signY * (origin.y))
                        .lineTo(0, signY * (origin.y))
                        .lineTo(0, signY * (-origin.y));
                }
                // ... otherwise don't show the snapshot of the current page.
                else {
                    pageImages.current.page.visible = false;
                }

                var nextMask = new createjs.Shape();
                // If the animated page is not in its final position, shape the mask as a triangle...
                if (!isAnimatedPageInFinalPosition) {
                    nextMask.graphics
                        .moveTo((signX * pageImages.next.page.image.width), signY * (-origin.y))
                        .lineTo(pageImages.overleaf.page.x + (signX * geometries.maskOffset.x), signY * (-origin.y))
                        .lineTo((signX * pageImages.next.page.image.width), signY * (geometries.maskDimensions.height - origin.y))
                        .lineTo((signX * pageImages.next.page.image.width), signY * (-origin.y));
                }
                // ... otherwise shape the mask as a rectangle.
                else {
                    nextMask.graphics
                        .moveTo((signX * pageImages.next.page.image.width), signY * (-origin.y))
                        .lineTo((signX * pageImages.next.page.image.width), signY * origin.y)
                        .lineTo(0, signY * origin.y)
                        .lineTo(0, signY * (-origin.y))
                        .lineTo((signX * pageImages.next.page.image.width), signY * (-origin.y));
                }

                pageImages.overleaf.page.mask = overleafMask;
                pageImages.current.page.mask = currentMask;
                pageImages.next.page.mask = nextMask;
            }

            // If audio playback is supported, execute the provided callback (after first loading in audio resources).
            self.ifAudioAvailableThenPlay = function(audioId) {
                // Check if we have audio support at all.
                if (audioEnabled == null) {
                    audioEnabled = createjs.Sound.initializeDefaultPlugins();
                }

                if (!audioEnabled || !audioResources[audioId]) return;

                var resource = audioResources[audioId];

                // Load resources if we don't already have them.
                //
                // Annoyingly, this must be done in response to user input _not_ during initialization - otherwise
                // it generates a warning in the dev console. That means the first time the audio plays, there
                // may be a slight delay while the sound file loads. If that's noticeable, it'll probably be worth
                // putting up with the warning message for the sake of pre-loading it properly.
                if (resource.loaded) {
                    createjs.Sound.play(audioId);
                } else {
                    createjs.Sound.addEventListener("fileload", function() {
                        resource.loaded = true;
                        createjs.Sound.play(audioId);
                    });
                    createjs.Sound.registerSounds([{id: audioId, src: resource.src}], constants.audioResourcesFolder);
                }
            };

            //region Geometry / maths helpers

            var Angle = function() {
                var self = this;
                self.degrees = 0;
                self.radians = 0;

                self.withDegrees = function(degrees) {
                    self.degrees = degrees;
                    self.radians = degrees / (180 / Math.PI)
                    return self;
                };

                self.withRadians = function(radians) {
                    self.radians = radians;
                    self.degrees = radians * (180 / Math.PI);
                    return self;
                };

                self.addDegrees = function(changeBy) {
                    return new Angle().withDegrees(self.degrees + changeBy);
                };

                return self;
            };

            self.getGeometries = function(trackingPoint) {
                var geometries = {};

                if (trackingPoint.x == 0) {
                    geometries.primaryAngle = new Angle().withDegrees(0);
                } else {
                    geometries.primaryAngle = new Angle().withRadians(Math.abs(Math.atan(-trackingPoint.y / trackingPoint.x)));
                }

                geometries.maskRotationAngle = new Angle().withDegrees(90 - geometries.primaryAngle.degrees);
                geometries.pageRotationAngle = new Angle().withDegrees(180 - (2 * geometries.maskRotationAngle.degrees));

                if (geometries.pageRotationAngle.radians == 0) {
                    geometries.maskOffset = {
                        x: 0,
                        y: 0
                    };
                } else {
                    var maskOffsetX = trackingPoint.y / Math.tan(geometries.pageRotationAngle.radians);
                    var maskOffsetY = ((trackingPoint.x - maskOffsetX) / Math.tan(geometries.primaryAngle.radians)) - trackingPoint.y;
                    geometries.maskOffset = {
                        x: maskOffsetX,
                        y: isNaN(maskOffsetY) ? 0 : maskOffsetY
                    };
                }

                var maskHeight = Math.tan(geometries.primaryAngle.radians) == 0 ?
                    0 :
                    ((trackingPoint.x - maskOffsetX) / Math.tan(geometries.primaryAngle.radians));
                geometries.maskDimensions = {
                    width: getHypoteneuse(geometries.maskOffset.x, trackingPoint.y),
                    height: maskHeight
                };

                return geometries;
            };

            var getHypoteneuse = function(a, b) {
                return Math.sqrt((a * a) + (b * b));
            };

            // Map a point to another point the specified distance away, along a line of the given angle.
            // The angle is relative to vertical (i.e. 30 degrees is a 1 o'clock position, 150 degrees is a 5 o'clock
            // position) - except that with a y co-ordinate system that increases downwards (like the canvas coords)
            // everything is mirrored vertically.
            // This all assumes a static reference frame - if the objects concerned are being rotated, the results may
            // be not what you expect!
            var translateAtAngle = function(point, angle, distance) {
                var translationX = Math.sin(angle.radians) * distance;
                var translationY = Math.cos(angle.radians) * distance;
                return { x: point.x + translationX, y: point.y + translationY };
            };

            //endregion
        };

        return {
            createAnimation: createAnimation,
            DIRECTION: DIRECTION
        };
    });

/**
* Created by alg on 17/03/2017.
* This module is responsible for controlling the page-mode of the Reader
*/
define('config/pageMode',['constants', 'config', 'events'],
function (constants, config, events) {
    var EMITTER_NAME = 'config/pageMode';
    var PAGE_MODES = {
        SINGLE_PAGE: 'SINGLE_PAGE', // only one page visible
        DOUBLE_PAGE: 'DOUBLE_PAGE' // two pages visible as per open book
    };

    var PageModeConfig = function PageModeConfig() {
        if (!(this instanceof PageModeConfig)) { return new PageModeConfig(); }
        var self = this;

        /**
         * Set the initial configuration based on the settings from the YUDU book
         * @param yuduBook {{}} for the edition
         */
        self.configureFromYuduBook = function(yuduBook) {
            var bookPageMode = yuduBook.settings.pageMode;
            config.twoPageMode = !(bookPageMode && bookPageMode == PAGE_MODES.SINGLE_PAGE);
            config.pageModeStopToggle = yuduBook.settings.pageModeStopToggle;
        };

        /**
         * Automatically reset the page mode to an appropriate setting based on the Reader's current configuration
         */
        self.autoSetTwoPageMode = function() {
            if (config.pageModeStopToggle) {
                // configured not to change page mode
                return;
            }
            // phones should default to single-page mode
            var shouldTwoPage = false;
            if (config.width > constants.maxPhoneWidth) {
                // desktops should use two-page mode if they are in a landscape orientation
                // note that `window.orientation` is not reliable
                shouldTwoPage = config.width > config.height;
            }
            self.setTwoPageMode(shouldTwoPage);
        };

        /**
         * Sets the current two-page mode to an explicit setting
         * @param twoPage {boolean} whether two-page mode should be enabled
         */
        self.setTwoPageMode = function(twoPage) {
            if (config.pageModeStopToggle) {
                // configured not to change page mode
                return;
            }
            // check if the setting will change, before applying the new value
            var twoUpChanged = config.twoPageMode != twoPage;
            config.twoPageMode = twoPage;
            if (twoUpChanged) {
                // alert any subscribers to the change
                events.emit(EMITTER_NAME, events.TWO_UP_CHANGED, this, {});
            }
        };

        /**
         * Helper that simply inverts the current two-page mode setting
         * Suitability checks for the inversion are deferred to the setter
         */
        self.togglePageMode = function() {
            self.setTwoPageMode(!config.twoPageMode);
        };
    };

    return new PageModeConfig();
});

define('controllers/shifter',['easel', 'config', 'constants', 'controllers/tray', 'controllers/pageTurner', 'events', 'fetching/fetchHandler', 'config/pageMode', 'jquery'],
    function(createjs, config, constants, trayModule, pageTurner, events, fetchHandler, pageMode, $) {

        var EMITTER_NAME = "shifter";

        var ShifterStates = {
            default: "default",
            // The state for animating between two-up mode enabled and disabled
            changingTwoPageMode: "changeTwoPageMode",
            // The state for animating between fitting one page to width nor not
            fittingWidth: "fitWidth",
            // The state for updating the stage after resizing the window
            resizing: 'resize',
            springing: "spring",
            skipping: "skip",
            dragging: "drag",
            zooming: "zoom",
            turning: "turn",
            syncingUgc: "syncUgc",
            addingNote: "addNote",
            togglingMedia: "toggleMedia"
        };

        var Shifter = function(pages) {
            var self = this;
            this.pages = pages;
            this.pageIndexOffset = config.hasIntroPage ? 0 : 1;
            this.container = new createjs.Container();
            var queuedActions = [];
            var overlayContainer = $("#yudu_overlays");
            var interactiveOverlayContainer = $("#yudu_interactiveOverlays");
            var objectsTemporarilyHidden = [];
            this.fadingTileIds = [];
            this.pagesAndZooms = {};

            this.fadingOverlayIds = [];
            this.fadingOutOverlayIds = [];
            this.flashingOverlayIds = [];
            this.draggingNote = false;
            this.displayingThumbnails = false;
            this.animatingHoverTransition = false;
            this.stopHoverTransitionAnimation = null;
            this.animatingTriggerAnimation = false;
            this.stopTriggerAnimation = null;

            this.trays = [];
            for (var i = 0; i < 3; i++) {
                var newTray = new trayModule.Tray();
                this.container.addChildAt(newTray.container, 0);
                this.trays.push(newTray);
            }

            this.velocityMax = 10000;
            this.velocityScale = 300;
            this.springCoefficient = -250;
            this.dampingCoefficient = -60;
            this.mass = 5;
            this.velocity = 0;
            this.displacement = 0;
            this.displacementScreen = 1000;
            this.displacementRatio = config.width / this.displacementScreen;
            this.triggerMarker = this.displacementScreen * 0.05;
            this.bounceVelocity = 1000;

            this.shouldFireUpdateEvent = false;

            this.currentPage = 0;
            this.initialPage = 0;

            this.lastDragData = null;
            this.lastZoomData = null;

            this.prevState = null;
            this.state = ShifterStates.default;

            this.initialised = false;

            this.init = function(pageIndex) {
                this.initialised = true;
                this.currentPage = pageIndex;
                this.initialPage = pageIndex;
                this.recentre();
                this.updateTrayLocation();
                this.repageAll();
                this.setLowestZoomLevel();
                this.updatePosition();
                this.tryChangeState(ShifterStates.default);
                events.subscribe(events.ALL, events.TILE_FADE_START, this.handleTileFadeStart);
                events.subscribe(events.ALL, events.TILE_FADE_END, this.handleTileFadeEnd);
                events.subscribe(events.ALL, events.OVERLAY_FADE_START, this.handleOverlayFadeStart);
                events.subscribe(events.ALL, events.OVERLAY_FADE_END, this.handleOverlayFadeEnd);
                events.subscribe(events.ALL, events.OVERLAY_FADE_OUT_START, this.handleOverlayFadeOutStart);
                events.subscribe(events.ALL, events.OVERLAY_FADE_OUT_END, this.handleOverlayFadeOutEnd);
                events.subscribe(events.ALL, events.OVERLAY_FLASH_START, this.handleOverlayFlashStart);
                events.subscribe(events.ALL, events.OVERLAY_FLASH_END, this.handleOverlayFlashEnd);
                events.subscribe(events.ALL, events.OVERLAY_TWEENS_REMOVED, this.handleOverlayTweensRemoved);
                events.subscribe(events.ALL, events.LAUNCHABLE_HTML_HOVER_ACTION,
                    this.handleLaunchableHtmlOverlayHoverAction);
                events.subscribe(events.ALL, events.OVERLAY_TWEENS_REMOVED, this.handleOverlayTweensRemoved);
                events.subscribe(events.ALL, events.TRIGGER, this.handleOverlayTrigger);
                events.subscribe(events.ALL, events.THUMBNAILS.TOGGLE_THUMBNAILS, this.handleThumbnailsToggled);
                events.subscribe(events.ALL, events.ZOOMLEVEL_TILESLOADED, this.handleTilesLoaded);
                events.subscribe(events.ALL, events.UGC_CHANGED, this.handleUgcChanged);
                events.subscribe(events.ALL, events.NOTE_ADDED, this.handleNoteAdded);
                events.subscribe(events.ALL, events.NOTE_DRAG_START, this.handleNoteDragStarted);
                events.subscribe(events.ALL, events.NOTE_MOVED, this.handleNoteMoved);
                events.subscribe(events.ALL, events.MEDIA_TOGGLED, this.handleMediaToggled);
            };

            this.handleTilesLoaded = function(event) {
                const pageNumber = event.data.pageNumber;
                const z = event.data.z;
                if (!self.pagesAndZooms[pageNumber]) {
                    self.pagesAndZooms[pageNumber] = [];
                }

                self.pagesAndZooms[pageNumber].push(z);
            };

            this.handleTileFadeStart = function(event) {
                self.fadingTileIds.push(event.data.id);
            };

            this.handleTileFadeEnd = function(event) {
                self.fadingTileIds = self.fadingTileIds.filter(function(id) {
                    return id !== event.data.id;
                });
            };

            this.handleOverlayFadeStart = function(event) {
                if (!self.fadingOverlayIds.includes(event.data.id)) {
                    self.fadingOverlayIds.push(event.data.id);
                }
            };

            this.handleOverlayFadeEnd = function(event) {
                self.fadingOverlayIds = self.fadingOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
            };

            this.handleOverlayFadeOutStart = function(event) {
                if (!self.fadingOutOverlayIds.includes(event.data.id)) {
                    self.fadingOutOverlayIds.push(event.data.id);
                }
            };

            this.handleOverlayFadeOutEnd = function(event) {
                self.fadingOutOverlayIds = self.fadingOutOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
            };

            this.handleOverlayFlashStart = function(event) {
                if (!self.flashingOverlayIds.includes(event.data.id)) {
                    self.flashingOverlayIds.push(event.data.id);
                }
            };

            this.handleOverlayFlashEnd = function(event) {
                self.flashingOverlayIds = self.flashingOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
            };

            this.handleLaunchableHtmlOverlayHoverAction = function() {
                clearTimeout(this.stopHoverTransitionAnimation);
                self.animatingHoverTransition = true;
                this.stopHoverTransitionAnimation = setTimeout(function() {
                    self.animatingHoverTransition = false;
                }, 500);
            };

            this.handleOverlayTrigger = function() {
                clearTimeout(this.stopTriggerAnimation);
                self.animatingTriggerAnimation = true;
                this.stopTriggerAnimation = setTimeout(function() {
                    self.animatingTriggerAnimation = false;
                }, 500);
            }

            this.handleOverlayTweensRemoved = function(event) {
                self.flashingOverlayIds = self.flashingOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
                self.fadingOverlayIds = self.fadingOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
                self.fadingOutOverlayIds = self.fadingOutOverlayIds.filter(function(id) {
                    return id !== event.data.id;
                });
            };

            this.handleNoteDragStarted = function() {
                self.draggingNote = true;
            };

            this.handleNoteMoved = function() {
                self.draggingNote = false;
            };

            this.handleUgcChanged = function() {
                self.tryChangeState(ShifterStates.syncingUgc);
            };

            this.handleNoteAdded = function () {
                self.tryChangeState(ShifterStates.addingNote);
            };

            this.handleMediaToggled = function () {
                self.tryChangeState(ShifterStates.togglingMedia);
            };

            this.handleThumbnailsToggled = function (event) {
                if (!event.data) {
                    return;
                }

                if (event.data.toggle) {
                    self.displayingThumbnails = !self.displayingThumbnails;
                } else {
                    self.displayingThumbnails = event.data.show;
                }
            };

            function handleComplete() {
                self.tryChangeState(ShifterStates.default);
            }

            this.isStateChangeAllowed = function(oldState, newState) {
                if (oldState == ShifterStates.default || newState == ShifterStates.default || newState == ShifterStates.changingTwoPageMode)
                    return true;

                if (newState == ShifterStates.dragging)
                    return (this.state == ShifterStates.springing);

                if (newState == ShifterStates.springing)
                    return (this.state == ShifterStates.dragging);

                if (newState === ShifterStates.resizing)
                    return (this.state === ShifterStates.changingTwoPageMode);

                return false;
            };

            this.defaultState = function() {
                this.state = ShifterStates.default;
            };

            this.tryChangeState = function(newState) {
                if (this.state == newState)
                    return true;

                if (!this.isStateChangeAllowed(this.state, newState))
                    return false;

                this.state = newState;
                return true;
            };

            this.setLowestZoomLevel = function() {
                var leftZoomZ = this.getLeftTray().getLowestZoomStateZ();
                var centreZoomZ = this.getCentreTray().getLowestZoomStateZ();
                var rightZoomZ = this.getRightTray().getLowestZoomStateZ();
                if (leftZoomZ == centreZoomZ) {
                    config.lowestZoomLevel = leftZoomZ;
                    return;
                }
                if (centreZoomZ == rightZoomZ) {
                    config.lowestZoomLevel = centreZoomZ;
                    return;
                }
                config.lowestZoomLevel = Math.min(leftZoomZ, rightZoomZ, centreZoomZ);
            };

            this.getBasePage = function() {
                var pageIndex = this.currentPage;
                return pageIndex ? pageIndex - ((pageIndex + this.pageIndexOffset) % this.getPagesPerTray()) : 0;
            };

            this.getPagesPerTray = function() {
                return config.twoPageMode ? 2 : 1;
            };

            this.setTray = function(tray, baseIndex) {
                if (baseIndex <= -this.getPagesPerTray() || baseIndex > this.getNumberOfPages() - 1) {
                    tray.empty();
                    return;
                }

                baseIndex = Math.max(baseIndex, 0);

                if (config.twoPageMode) {
                    if ((!config.hasIntroPage && baseIndex == 0) || baseIndex == this.getNumberOfPages() - 1) {
                        tray.setPages(this.getPage(baseIndex))
                    }
                    else {
                        tray.setPages(this.getPage(baseIndex), this.getPage(baseIndex + 1));
                    }
                    return;
                }

                tray.setPages(this.getPage(baseIndex));
            };

            this.performReveal = function() {
                this.getCentreTray().triggerShow();
            };

            this.goNextPageUnanimated = function() {
                this.goNextPage(true);
            };

            this.goNextPage = function(doNotAnimateFlag, doNotUsePageTurn) {
                if (this.isLastPage()) {
                    this.bouncePage(-this.bounceVelocity);
                    return false;
                }

                var usePageTurnAnimation = config.pageTurnEnabled && config.twoPageMode && config.userPreferences['pageTurn'] !== false && !doNotUsePageTurn;

                if (usePageTurnAnimation) {
                    // If zoomed in, animate out first.
                    if (self.getCentreTray().currentZoomStateIndex > 0) {
                        events.emit(EMITTER_NAME, events.ZOOM, this, {direction: -3, "scaled": false, "x": 0, "y": 0});
                        whenMovementComplete(function() {
                            self.goNextPage(doNotAnimateFlag);
                        });
                        return;
                    }

                    // Don't allow page change if we're currently mid-turn.
                    if (this.state == ShifterStates.turning || !this.tryChangeState(ShifterStates.turning)) {
                        return false;
                    }

                    doPageTurnAnimation(pageTurner.DIRECTION.NEXT, function() {
                        completePageChangeToNext(true);
                    });
                } else {
                    return completePageChangeToNext(doNotAnimateFlag);
                }
            };

            var completePageChangeToNext = function(doNotAnimateFlag) {
                self.moveTraysLeft(doNotAnimateFlag);
                var pageChangeEvent = self.changeCurrentPage(self.getCentreTray().getBasePage());
                self.setTray(self.getRightTray(), self.getBasePage() + self.getCentreTray().length);
                return completePageChange(pageChangeEvent);
            };

            var completePageChangeToPrevious = function(doNotAnimateFlag) {
                self.moveTraysRight(doNotAnimateFlag);
                var pageChangeEvent = self.changeCurrentPage(self.getCentreTray().getBasePage());
                var pagesInLeftTray = self.currentPage == 1 ? 1 : self.getPagesPerTray();
                self.setTray(self.getLeftTray(), self.getBasePage() - pagesInLeftTray);
                return completePageChange(pageChangeEvent);
            };

            var completePageChange = function(pageChangeEvent) {
                self.resetZoomLevels();
                self.getCentreTray().setToTop();
                events.emit(EMITTER_NAME, events.PAGE_CHANGED, this, pageChangeEvent);
                return true;
            };

            this.goPreviousPageUnanimated = function() {
                this.goPreviousPage(true);
            };

            this.goPreviousPage = function(doNotAnimateFlag, doNotUsePageTurn) {
                if (this.isFirstPage()) {
                    this.bouncePage(this.bounceVelocity);
                    return false;
                }

                var usePageTurnAnimation = config.pageTurnEnabled && config.twoPageMode && config.userPreferences['pageTurn'] !== false && !doNotUsePageTurn;

                if (usePageTurnAnimation) {
                    // If zoomed in, animate out first.
                    if (self.getCentreTray().currentZoomStateIndex > 0) {
                        events.emit(EMITTER_NAME, events.ZOOM, this, {direction: -3, "scaled": false, "x": 0, "y": 0});
                        whenMovementComplete(function() {
                            self.goPreviousPage(doNotAnimateFlag);
                        });
                        return;
                    }

                    // Don't allow page change if we're currently mid-turn.
                    if (this.state == ShifterStates.turning || !this.tryChangeState(ShifterStates.turning)) {
                        return false;
                    }

                    doPageTurnAnimation(pageTurner.DIRECTION.PREVIOUS, function() {
                        completePageChangeToPrevious(true);
                    });
                } else {
                    return completePageChangeToPrevious(doNotAnimateFlag);
                }
            };

            var doPageTurnAnimation = function(direction, onComplete) {
                var pageTurnAnimation = pageTurner.createAnimation(
                    self.getCentreTray(),
                    direction == pageTurner.DIRECTION.PREVIOUS ? self.getLeftTray() : self.getRightTray(),
                    self.currentPage,
                    direction);
                self.getCentreTray().container.addChild(pageTurnAnimation.animationLayer);

                // Temporarily hide the pages (the real, underlying pages not the bitmap copies we've just created).
                // This is because otherwise it's visible when turning to one of the cover pages.
                overlayContainer.hide();
                interactiveOverlayContainer.hide();

                for (var pageIndex = 0; pageIndex < self.getCentreTray().pages.length; ++pageIndex) {
                    var page = self.getCentreTray().pages[pageIndex];
                    for (var zoomLevelIndex = 0; zoomLevelIndex < page.zoomLevels.length; ++zoomLevelIndex) {
                        var zoomLevel = page.zoomLevels[zoomLevelIndex];
                        if (zoomLevel.zoomLevelView) {
                            hideDuringAnimation(zoomLevel.zoomLevelView.container.parent);
                        }
                    }
                }

                pageTurnAnimation.start(function () {
                    unhideAfterAnimation();
                    interactiveOverlayContainer.show();
                    overlayContainer.show();
                    self.getCentreTray().container.removeChild(pageTurnAnimation.animationLayer);
                    if (typeof onComplete == 'function') {
                        onComplete();
                        self.displacement = 0;
                    }
                    // Call resize to cover edge cases.
                    self.resize();
                });
            };

            var hideDuringAnimation = function(displayObject) {
                displayObject.visible = false;
                objectsTemporarilyHidden.push(displayObject);
            };

            var unhideAfterAnimation = function() {
                while (objectsTemporarilyHidden.length > 0) {
                    var displayObject = objectsTemporarilyHidden.pop();
                    displayObject.visible = true;
                }
            };

            var whenMovementComplete = function(callback) {
                queuedActions.push(callback);
            };

            var checkQueuedActions = function() {
                if (queuedActions.length == 0) return;

                // Only trigger the first queued action if there are multiple - this will be called again on the next
                // tick, if the shifter is still in a suitable state.
                var action = queuedActions.shift();
                action();
            };

            this.isLastPage = function() {
                return this.getBasePage() + this.getCentreTray().length > this.getNumberOfPages() - 1 || this.getRightTray().length == 0;
            };

            this.isFirstPage = function() {
                return this.getBasePage() == 0 || this.getLeftTray().length == 0;
            };

            this.bouncePage = function(velocity) {
                this.velocity = velocity;
                this.tryChangeState(ShifterStates.springing);
            };

            this.goToPage = function(pageIndex) {
                if (this.getCentreTray().hasPage(pageIndex))
                    return;

                if (this.getLeftTray().hasPage(pageIndex)) {
                    this.goPreviousPage();
                    return;
                }

                if (this.getRightTray().hasPage(pageIndex)) {
                    this.goNextPage();
                    return;
                }

                if (pageIndex > this.currentPage) {
                    this.skipToPageRight(pageIndex);
                }
                else {
                    this.skipToPageLeft(pageIndex);
                }
            };

            this.goToSnapPage = function(pageIndex) {
                this.stopAllTweens();
                var pageChangeEvent = this.changeCurrentPage(pageIndex);
                this.repageAll();
                this.clearFakePages();
                this.defaultState();
                this.updatePosition();
                this.recentre();
                events.emit(EMITTER_NAME, events.PAGE_CHANGED, this, pageChangeEvent);
            };

            this.skipToPageRight = function(pageIndex) {
                if (!this.tryChangeState(ShifterStates.skipping))
                    return;
                var pageDiff = pageIndex - this.currentPage - 1;
                var pageChangeEvent = this.changeCurrentPage(pageIndex);
                this.moveTraysLeft();
                this.setTray(this.getCentreTray(), pageIndex);

                this.resetZoomLevels();
                var fakePageWidth = this.getLeftTray().addFakePages(pageDiff);

                var xOffset = this.getXOffset() + fakePageWidth;
                this.getLeftTray().reposition(-xOffset);
                this.displacement = xOffset / this.displacementRatio;
                this.getCentreTray().setToTop();
                events.emit(EMITTER_NAME, events.PAGE_CHANGED, this, pageChangeEvent);
            };

            this.skipToPageLeft = function(pageIndex) {
                if (!this.tryChangeState(ShifterStates.skipping))
                    return;
                var pageDiff = this.currentPage - pageIndex - 1;
                var pageChangeEvent = this.changeCurrentPage(pageIndex);
                this.moveTraysRight();
                this.setTray(this.getCentreTray(), pageIndex);

                this.resetZoomLevels();
                var fakePageWidth = this.getCentreTray().addFakePages(pageDiff);

                var xOffset = this.getXOffset() + fakePageWidth;
                this.getRightTray().reposition(xOffset);
                this.displacement = -xOffset / this.displacementRatio;
                this.getCentreTray().setToTop();
                events.emit(EMITTER_NAME, events.PAGE_CHANGED, this, pageChangeEvent);
            };

            this.stopAllTweens = function() {
                for (var i = 0 , m = this.trays.length ; i < m ; i++) {
                    this.trays[i].stopTweens();
                }
            };

            this.moveTraysLeft = function(doNotAnimateFlag) {
                this.trays.push(this.trays.splice(0, 1)[0]);
                this.updateTrayLocation();
                this.container.addChildAt(this.container.getChildAt(2), 0);
                this.displacement = Math.min(this.displacement + this.displacementScreen, this.displacementScreen);
                this.shouldFireUpdateEvent = true;
                this.updatePosition();
                this.tryChangeState(doNotAnimateFlag ? ShifterStates.default : ShifterStates.springing);
            };

            this.moveTraysRight = function(doNotAnimateFlag) {
                this.trays.unshift(this.trays.pop());
                this.updateTrayLocation();
                this.container.addChild(this.container.getChildAt(0));
                this.displacement = Math.max(this.displacement - this.displacementScreen, -this.displacementScreen);
                this.shouldFireUpdateEvent = true;
                this.updatePosition();
                this.tryChangeState(doNotAnimateFlag ? ShifterStates.default : ShifterStates.springing);
            };

            this.getPage = function(pageIndex) {
                var page = this.pages[pageIndex];
                if (page.encrypted && config.decryptionKey) {
                    page.decrypt(config.decryptionKey);
                }
                if (!page.initialised) {
                    page.init();
                }
                return page;
            };

            this.updatePosition = function() {
                var xOffset = this.getXOffset();

                this.getLeftTray().reposition(-xOffset);
                this.getRightTray().reposition(xOffset);
                this.getCentreTray().reposition(0);
            };

            this.updateTrayLocation = function() {
                this.getLeftTray().setIsCentre(false);
                this.getRightTray().setIsCentre(false);
                this.getCentreTray().setIsCentre(true);
            };

            this.getXOffset = function() {
                return config.width;
            };

            this.getLeftTray = function() {
                return this.trays[0];
            };

            this.getCentreTray = function() {
                return this.trays[1];
            };

            this.getRightTray = function() {
                return this.trays[2];
            };

            this.repageLeftRightTrays = function() {
                var basePage = this.getBasePage();
                this.setTray(this.getRightTray(), basePage + this.getCentreTray().length);
                this.setTray(this.getLeftTray(), basePage - this.getPagesPerTray());
            };

            this.repageAll = function() {
                if(!this.initialised)
                    return;
                var basePage = this.getBasePage();
                this.setTray(this.getCentreTray(), basePage);
                this.setTray(this.getRightTray(), basePage + this.getCentreTray().length);
                this.setTray(this.getLeftTray(), basePage - this.getPagesPerTray());
            };

            this.resize = function() {
                this.tryChangeState(ShifterStates.resizing);
                this.stopAllFakeAnimations();
                this.recentre();
                this.updatePosition();
                this.container.x = 0;
                this.velocity = 0;
                this.displacement = 0;
                this.displacementRatio = config.width / this.displacementScreen;
                this.setLowestZoomLevel();
                this.repageAll();
            };

            this.recentre = function() {
                this.container.regX = -config.width / 2;
                this.container.regY = -config.height / 2;
                this.container.x = this.container.y = 0;
            };

            this.forceEndSkip = function() {
                this.recentre();
                this.updatePosition();
                this.clearFakePages();
                this.repageLeftRightTrays();
            };

            this.clearFakePages = function() {
                for (var i = 0 ; i < 3 ; i++) {
                    this.trays[i].removeFakePages();
                }
            };

            this.applyMaskToOverlayContainerIfNecessary = function() {
                this.getLeftTray().applyMaskToOverlayContainerIfNecessary();
                this.getCentreTray().applyMaskToOverlayContainerIfNecessary();
                this.getRightTray().applyMaskToOverlayContainerIfNecessary();
            };

            this.handleDragStart = function(event) {
                if (!this.getCentreTray().canDrag() || !this.tryChangeState(ShifterStates.dragging))
                    return;

                this.lastDragData = {x: event.data.deltaX, y: event.data.deltaY};
            };

            this.handleDrag = function(event) {
                if (this.state != ShifterStates.dragging)
                    return;

                this.lastZoomData = null;

                var dx = (event.data.deltaX - this.lastDragData.x) * config.pixelDensity;
                var dy = (event.data.deltaY - this.lastDragData.y) * config.pixelDensity;

                this.lastDragData = {x: event.data.deltaX, y: event.data.deltaY};

                // shifter takes priority if offcenter
                if ((dx > 0 && this.container.x < 0) || (dx < 0 && this.container.x > 0)) {
                    var newX = this.container.x + dx;
                    this.container.x = Math.max(-config.width, Math.min(newX, config.width));
                    return;
                }

                var remainder = dx;
                if (!this.getCentreTray().isEmpty()) {
                    remainder = this.getCentreTray().handleMove(dx, dy);
                }

                var newX = this.container.x + remainder;
                this.container.x = Math.max(-config.width, Math.min(newX, config.width));
            };

            this.handleDragEnd = function(event) {
                if (this.state != ShifterStates.dragging || !this.lastDragData) {
                    this.lastDragData = null;
                    return;
                }

                this.tryChangeState(ShifterStates.springing);

                this.lastDragData = null;
                this.velocity = 0;
                this.displacement = this.container.x / this.displacementRatio;

                if (event) {
                    var speed = Math.min(event.data.velocityX * this.velocityScale, this.velocityMax);
                    this.velocity = (Math.abs(event.data.angle) < 90 ? speed : -speed);
                }

                if (!this.getCentreTray().isEmpty()) {
                    this.getCentreTray().moveEnd();
                }

                // If the drag was far / fast enough, change page.
                // (Never use the page turn animation for this, since it doesn't make visual sense - always use the
                // traditional slide animation instead.)
                var settleOn = Math.round((this.container.x + this.velocity) / this.getXOffset());

                if (settleOn < 0) {
                    this.goNextPage(false, true);
                }
                else if (settleOn > 0) {
                    this.goPreviousPage(false, true);
                }
            };

            this.update = function(timeSinceLastFrame) {
                if (this.state === ShifterStates.zooming) {
                    events.emit(EMITTER_NAME, events.SHIFTER_ZOOMING, this, {});
                }

                var isSameStateAsLastUpdate = this.prevState == this.state;
                this.prevState = this.state;
                if (this.state != ShifterStates.skipping && this.state != ShifterStates.springing) {
                    if (this.state == ShifterStates.default) {
                        checkQueuedActions();
                        return this.fadingTileIds.length !== 0
                            || this.fadingOverlayIds.length !== 0
                            || this.fadingOutOverlayIds.length !== 0
                            || this.flashingOverlayIds.length !== 0
                            || this.draggingNote
                            || this.displayingThumbnails
                            || this.animatingHoverTransition
                            || this.animatingTriggerAnimation
                            || !isSameStateAsLastUpdate;
                    }

                    if (this.state == ShifterStates.resizing
                        || this.state == ShifterStates.fittingWidth
                        || this.state == ShifterStates.syncingUgc
                        || this.state == ShifterStates.addingNote
                        || this.state == ShifterStates.togglingMedia
                    ) {
                        this.tryChangeState(ShifterStates.default);
                    }

                    return true;
                }

                var ticked = 0;
                do {
                    var acceleration = ((this.springCoefficient * this.displacement) + (this.dampingCoefficient * this.velocity)) / this.mass;
                    this.velocity += acceleration / constants.fps;
                    this.displacement += this.velocity / constants.fps;
                    ticked += constants.tickTimeMs;
                } while (ticked < timeSinceLastFrame);

                var absDisplacement = Math.abs(this.displacement);

                if (this.shouldFireUpdateEvent && absDisplacement < this.triggerMarker) {
                    this.repageAll();
                    this.updatePosition();
                    this.clearFakePages();
                    this.applyMaskToOverlayContainerIfNecessary();
                    this.shouldFireUpdateEvent = false;
                    this.tryChangeState(ShifterStates.springing);
                }

                if (absDisplacement < 1 && Math.abs(this.velocity) < 1) {
                    this.performReveal();
                    this.defaultState();
                    this.displacement = 0;
                    this.velocity = 0;
                }

                this.container.x = Math.round(this.displacement * this.displacementRatio);
                if (this.state != ShifterStates.default)
                    events.emit(EMITTER_NAME, events.SHIFTER_SPRINGING, this, {});

                return true;
            };

            this.zoom = function(event) {
                if (this.state != ShifterStates.default
                    && this.state != ShifterStates.springing)
                    return;

                this.tryChangeState(ShifterStates.zooming);
                this.getCentreTray().zoom(event.data.direction, event.data.x, event.data.y, handleComplete);
            };

            this.zoomScale = function(event) {
                if (!this.tryChangeState(ShifterStates.zooming))
                    return;

                var x = event.data.x;
                var y = event.data.y;

                if (event.data.end) {
                    this.zoomScaleEnd(x, y);
                    return;
                }

                if (!this.lastZoomData) {
                    this.lastZoomData = {page: this.getCentreTray().getBasePage(), startScale: this.getCentreTray().getScale(), startPinchScale: event.data.scale, x: x, y: y};
                    return;
                }

                var scale = event.data.scale * this.lastZoomData.startScale;
                this.getCentreTray().zoomScale(scale, x, y);
                this.lastZoomData.x = x;
                this.lastZoomData.y = y;
            };

            this.zoomScaleEnd = function(x, y) {
                if (!this.lastZoomData || this.lastZoomData.page != this.getCentreTray().getBasePage()) {
                    this.defaultState();
                    this.lastZoomData = null;
                    return;
                }

                if (!x || !y) {
                    x = this.lastZoomData.x;
                    y = this.lastZoomData.y;
                }
                this.getCentreTray().zoomResolve(x, y);

                this.defaultState();
                this.lastZoomData = null;
            };

            this.resetZoomLevels = function() {
                for (var i = 0; i < 3; i++) {
                    this.trays[i].resetZoom();
                }
            };

            this.emptyAll = function() {
                for (var i = 0; i < 3; i++) {
                    this.trays[i].empty();
                }
            };

            this.snapNewPageMode = function() {
                var pagesPerTray = this.getPagesPerTray();
                var basePage = this.getBasePage();

                // First, we need to apply mask to LHS page of left and right trays if switching to one up mode
                if (pagesPerTray == 1) {
                    this.getLeftTray().applyMaskToOverlayContainer();
                    this.getRightTray().applyMaskToOverlayContainer();
                }

                this.emptyAll();

                this.setTray(this.getLeftTray(), basePage - pagesPerTray);
                this.setTray(this.getCentreTray(), basePage);
                this.setTray(this.getRightTray(), basePage + this.getCentreTray().length);

                this.updatePosition();
                this.recentre();
                this.setLowestZoomLevel();
            };

            this.newFit = function() {
                this.tryChangeState(ShifterStates.fittingWidth);
                this.emptyAll();

                var pagesPerTray = this.getPagesPerTray();
                var basePage = this.getBasePage();

                this.setTray(this.getLeftTray(), basePage - pagesPerTray);
                this.setTray(this.getCentreTray(), basePage);
                this.setTray(this.getRightTray(), basePage + this.getCentreTray().length);

                this.updatePosition();
                this.getCentreTray().setToTop();
                this.recentre();
                this.setLowestZoomLevel();
            };

            this.willNewFitHaveVisibleEffect = function() {
                var traySize = this.getCentreTray().getZoomBounds();

                if (traySize.width > config.width * 0.9 && traySize.width < config.width * 1.1)
                    return false;

                return true;
            };

            this.triggerFalseZoom = function() {
                this.getCentreTray().anim_falseZoomIn(handleComplete);
            };

            this.newTwoPageMode = function() {
                this.tryChangeState(ShifterStates.changingTwoPageMode);

                var wasAnimating = this.areAnyPagesAnimating();
                this.snapNewPageMode();

                var pagesPerTray = this.getPagesPerTray();
                var goLeft = this.currentPage % 2 == this.pageIndexOffset;

                var pageNumber = this.getCentreTray().getBasePage();

                if ((pageNumber == 0 && !config.hasIntroPage) || pageNumber == this.getNumberOfPages() - 1) {
                    this.getCentreTray().anim_wobble(handleComplete);
                    return;
                }

                if (wasAnimating) {
                    this.stopAllFakeAnimations();
                    return;
                }

                if (pagesPerTray == 1) {
                    this.getCentreTray().anim_fakePairToSingle(goLeft, handleComplete);
                    if (goLeft)
                        this.getRightTray().anim_fakeMoveToAdjacentTray(!goLeft, handleComplete);
                    else
                        this.getLeftTray().anim_fakeMoveToAdjacentTray(!goLeft, handleComplete);
                    return;
                }

                if (pagesPerTray == 2) {
                    this.getCentreTray().anim_fakeSingleToPair(goLeft, handleComplete);
                    this.getCentreTray().anim_fakeMoveFromAdjacentTray(!goLeft, handleComplete);
                }

                //check that the fit to width setting is correct still
                if (!this.willNewFitHaveVisibleEffect()) {
                    config.setFitOnlyWidth(false);
                }
            };

            this.areAnyPagesAnimating = function() {
                for (var i = 0, m = this.trays.length ; i < m ; i++) {
                    if (this.trays[i].areAnyPagesAnimating())
                        return true;
                }
                return false;
            };

            this.stopAllFakeAnimations = function() {
                for (var i = 0, m = this.trays.length ; i < m ; i++) {
                    this.trays[i].stopFakeAnimations();
                }
            };

            this.getCurrentPage = function() {
                var tray = this.getCentreTray();
                if (tray.isEmpty()) {
                    return null;
                }
                return tray.findPage(this.currentPage);
            };

            this.handleTap = function(tapPoint) {
                if (this.state != ShifterStates.default)
                    return false;
                return this.getCentreTray().handleTap(tapPoint);
            };

            this.changeCurrentPage = function(pageIndex) {
                var eventObject = {oldPage: this.currentPage};

                if (config.twoPageMode && (this.currentPage != 0 || config.hasIntroPage) && this.currentPage + 1 < this.getNumberOfPages())
                    eventObject.oldPage2 = this.currentPage + 1;

                this.currentPage = pageIndex;

                eventObject.page = pageIndex;

                if (config.twoPageMode && (this.currentPage != 0 || config.hasIntroPage) && pageIndex + 1 < this.getNumberOfPages())
                    eventObject.page2 = pageIndex + 1;

                return eventObject;
            };

            this.getCurrentPageNumber = function() {
                return this.currentPage;
            };

            this.getNumberOfPages = function() {
                return this.pages.length;
            };

            this.loggedIn = function() {
                this.repageAll();
                this.resize();
            };

            this.isPageShowing = function(pageNumber) {
                var checkSecondPage = config.twoPageMode &&
                    (config.hasIntroPage || this.getCurrentPageNumber() > 0) &&
                    this.getCurrentPageNumber() < this.getNumberOfPages();
                return this.getCurrentPageNumber() == pageNumber || (checkSecondPage && this.getCurrentPageNumber() + 1 == pageNumber);
            };

            this.isPageInTray = function(pageNumber) {
                return this.getLeftTray().hasPage(pageNumber) ||
                    this.getCentreTray().hasPage(pageNumber) ||
                    this.getRightTray().hasPage(pageNumber);
            };

            events.subscribe(events.ALL, events.DRAG, events.callback(this, this.handleDrag), false);
            events.subscribe(events.ALL, events.DRAG_END, events.callback(this, this.handleDragEnd), false);
            events.subscribe(events.ALL, events.DRAG_START, events.callback(this, this.handleDragStart), false);
            events.subscribe(events.ALL, events.ZOOM, events.callback(this, this.zoom), false);
            events.subscribe(events.ALL, events.ZOOM_SCALE, events.callback(this, this.zoomScale), false);
            events.subscribe(events.ALL, events.RESIZE, events.callback(this, this.resize), false);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, events.callback(this, this.newTwoPageMode), false);
            events.subscribe(events.ALL, events.FIT_CHANGED, events.callback(this, this.newFit), false);
            events.subscribe(events.ALL, events.LOGIN_SUCCESS, events.callback(this, this.loggedIn), false);
        };

        return {
            Shifter: Shifter,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('model/phoneOverlay',['events', 'config', 'model/overlay', 'utils/statistics', 'utils/tools'],
    function(events, config, overlay, statistics, tools) {

        var PhoneOverlay = function(x, y, width, height, zIndex, info, pageNumber, id) {
            overlay.Overlay.call(this, x, y, width, height, zIndex, info, pageNumber, id);

            this.contactNumber = info["@t"];

            this.rectColour = config.phoneOverlayColour;

            /**
             * Inits the overlay by creating a visual representation, the hit area and binding some events.
             */
            this.init = function() {
                this.createRectAndHitArea();
                return this.rect;
            };

            /**
             * Listener that is triggered when this overlay is clicked on.
             */
            this.clicked = function() {
                tools.openURL("tel:" + this.contactNumber, false);
            };
        };
        PhoneOverlay.prototype = overlay.Overlay.prototype;

        return {
            PhoneOverlay: PhoneOverlay
        };
    });

define('controllers/overlayController',['model/webLinkOverlay', 'views/overlayView', 'model/emailLinkOverlay', 'model/pageLinkOverlay',
        'model/productOverlay', 'model/audioOverlay', 'model/videoOverlay', 'model/imageOverlay',
        'model/htmlOverlay', 'model/launchableHtmlOverlay', 'model/contentOverlay', 'model/urlContentOverlay',
        'model/overlay', 'events', 'constants', 'resources', 'config', 'controllers/shifter', 'utils/tools', 'model/phoneOverlay'],
    function(webLinkOverlay, overlayView, emailLinkOverlay, pageLinkOverlay, productOverlay, audioOverlay, videoOverlay,
             imageOverlay, htmlOverlay, launchableHtmlOverlay, contentOverlay, urlContentOverlay, overlay, events,
             constants, resources, config, shifter, tools, phoneOverlay) {

        /**
         * Class that controls an overlay level for a page
         * @constructor
         */
        var OverlayController = function(pageNumber) {
            this.initialised = false;
            this.maxOverlayId = 1;

            this.pageNumber = pageNumber;

            this.overlays = [];
            this.launchableOverlays = [];

            this.overlayView = new overlayView.OverlayView();

            /**
             * Initialises the overlays from the given object.
             * @param overlays
             */
            this.init = function(overlays) {
                events.subscribe(contentOverlay.EMITTER_NAME, events.TRIGGER, events.callback(this, this.toggleTargetVisibilityAndTriggerContent));
                events.subscribe(shifter.EMITTER_NAME, events.PAGE_CHANGED, events.callback(this, this.hideAllTriggeredOverlaysIfPageChanged));

                for (var type in overlays) {
                    switch (type) {
                        case "ol":
                            this.createOverlays(webLinkOverlay.WebLinkOverlay, overlays.ol);
                            break;
                        case "e":
                            this.createOverlays(emailLinkOverlay.EmailLinkOverlay, overlays.e);
                            break;
                        case "pn":
                            this.createOverlays(phoneOverlay.PhoneOverlay, overlays.pn);
                            break;
                        case "il":
                            this.createOverlays(pageLinkOverlay.PageLinkOverlay, overlays.il);
                            break;
                        case "pc":
                            if (resources.priceList || resources.rollovers) {
                                this.createOverlays(productOverlay.ProductOverlay, overlays.pc);
                            }
                            break;
                        case "a":
                            this.createOverlays(audioOverlay.AudioOverlay, overlays.a);
                            break;
                        case "v":
                            this.createOverlays(videoOverlay.VideoOverlay, overlays.v);
                            break;
                        case "i":
                            this.createOverlays(imageOverlay.ImageOverlay, overlays.i);
                            break;
                        case "html":
                            this.createOverlays(htmlOverlay.HtmlOverlay, overlays.html);
                            break;
                        case "lHtml":
                            this.createOverlays(launchableHtmlOverlay.LaunchableHtmlOverlay, overlays.lHtml, this.launchableOverlays);
                            break;
                        case "trigger":
                            this.createOverlays(contentOverlay.ContentOverlay, overlays.trigger);
                            break;
                        case "c":
                            this.createUrlContentOverlays(overlays.c);
                            break;
                        default:
                            continue;
                    }
                }
                this.reorderOverlaysByZIndex();
                //add the overlays to the container
                for (var i = 0, l = this.overlays.length; i < l; i++) {
                    this.overlayView.addOverlay(this.overlays[i].init());
                }
            };

            this.toggleTargetVisibilityAndTriggerContent = function(event) {
                if (event.data.pageNumber != this.pageNumber) {
                    return;
                }

                for (var i = 0; i < this.overlays.length; i++) {
                    if (this.overlays[i].triggerableId == event.data.triggerTargetId) {
                        this.overlays[i].triggerToggle();
                    }
                    // TODO: move this into the overlay class.
                    if (this.overlays[i] == event.target) {
                        this.overlayView.replaceOverlay(this.overlays[i].rect, i);
                    }
                }
            };

            this.hideAllTriggeredOverlaysIfPageChanged = function(event) {
                if (event.data.oldPage != this.pageNumber && event.data.oldPage2 != this.pageNumber) {
                    return;
                }

                this.hideAllTriggeredOverlaysAndRestoreTriggerMainContent();
            };

            this.hideAllTriggeredOverlaysAndRestoreTriggerMainContent = function() {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (this.overlays[i].triggerTargetId && this.overlays[i].showAlternateContent) {
                        this.overlays[i].toggleContent();
                        // TODO: move this into the overlay class.
                        this.overlayView.replaceOverlay(this.overlays[i].rect, i);
                    }

                    if (this.overlays[i].triggerableId) {
                        this.overlays[i].triggerOff();
                    }
                }
            };

            this.createUrlContentOverlays = function(overlays) {
                overlays = (overlays instanceof Array) ? overlays : [overlays];
                for (var i = 0; i < overlays.length; i++) {
                    var contentType = tools.getContentTypeFromUrl(overlays[i]["@t"]);
                    switch (contentType) {
                        case constants.urlContentOverlayTypes.youTube:
                            this.createOverlays(urlContentOverlay.UrlContentOverlay, overlays[i]);
                            break;
                        case constants.urlContentOverlayTypes.image:
                            this.createOverlays(imageOverlay.ImageOverlay, overlays[i]);
                            break;
                        case constants.urlContentOverlayTypes.video:
                            this.createOverlays(videoOverlay.VideoOverlay, overlays[i]);
                            break;
                        case constants.urlContentOverlayTypes.audio:
                            this.createOverlays(audioOverlay.AudioOverlay, overlays[i]);
                            break;
                    }
                }
            };

            /**
             * Creates overlays of a given type with the given information.
             * @param constructor the constructor for all the overlays provided in the overlays parameter
             * @param overlays the info about the overlays
             * @additionalArray an additional array to store the overlays in if necessary
             */
            this.createOverlays = function(constructor, overlays, additionalArray) {
                overlays = (overlays instanceof Array) ? overlays : [overlays];
                for (var i = 0; i < overlays.length; i++) {
                    var dimensions = overlays[i]["#text"].split(",");
                    var overlay = new constructor(dimensions[0], dimensions[1], dimensions[2], dimensions[3], overlays[i]["@z"], overlays[i], this.pageNumber, this.pageNumber + "-" + this.maxOverlayId);
                    this.maxOverlayId++;
                    if (overlay.isValid) {
                        this.overlays.push(overlay);
                        if (!!additionalArray) {
                            additionalArray.push(overlay);
                        }
                    }
                }
            };

            this.reorderOverlaysByZIndex = function() {
                this.overlays.sort(overlay.Overlay.zIndexComparator);
            };

            // Called when the page is now visible
            this.pageReady = function() {
                this.flashOverlays();
                this.triggerAutoPlayMedia();
            };


            this.triggerAutoPlayMedia = function() {
                for (var i = 0; i < this.overlays.length; i++) {
                    this.overlays[i].triggerAutoPlay();
                }
            };


            /**
             * Briefly flashes the overlays if they are not already being flashed
             */
            this.flashOverlays = function() {
                for (var i = 0; i < this.overlays.length; i++) {
                    this.overlays[i].flash(constants.pauseBeforeOverlayFlash);
                }
            };

            /**
             * Returns the container that the overlays for this controller are rendered to
             * @returns {container}
             */
            this.getContainer = function() {
                return this.overlayView.container;
            };

            /**
             * Given the zoom level we are currently at and the page we are on, scales the overlays
             * to fit so that they appear in the correct places and at the correct sizes.
             * @param zoomLevel the model object for the zoom level we are currently at
             * @param page the model object for the page these overlays are on
             */
            this.scaleOverlays = function(zoomLevel, page) {
                var scaleX = zoomLevel.width / page.width;
                var scaleY = zoomLevel.height / page.height;

                this.getContainer().set({scaleX: scaleX, scaleY: scaleY});
            };

            this.handleTap = function(tapPoint) {
                for (var i = this.overlays.length - 1; i >= 0; i--) {
                    if (this.overlays[i].handleTap(tapPoint))
                        return true;
                }
                return false;
            };

            this.handleMouseInteraction = function(event) {
                for (var i = this.overlays.length - 1; i >= 0; i--) {
                    if (this.handleOverlayMouseInteraction(event, this.overlays[i])) {
                        break;
                    }
                }
                for (var j = i - 1; j >= 0; j--) {
                    this.overlays[j].mouseOut();
                }
            };

            this.handleOverlayMouseInteraction = function(event, overlay) {
                if (overlay.intersect({x: event.pageX * config.pixelDensity, y: (event.pageY - config.readerYOffset) * config.pixelDensity}) &&
                    (!this.getContainer().mask ||
                    this.intersectWhenMaskApplied({x: event.pageX * config.pixelDensity, y: (event.pageY - config.readerYOffset) * config.pixelDensity}))) {
                    if (!overlay.isMouseIn) {
                        overlay.mouseIn();
                    }
                    return true;
                }
                if (overlay.isMouseIn) {
                    overlay.mouseOut();
                }
                return false;
            };

            this.intersectWhenMaskApplied = function(point) {
                if (!this.getContainer())
                    return false;

                point = {x: this.getContainer().globalToLocal(point.x, 0).x,
                    y: this.getContainer().globalToLocal(0, point.y).y};

                if (point.x > 0
                    && point.y > 0
                    && point.x < this.pageWidth
                    && point.y < this.pageHeight)
                    return true;

                return false;
            };

            this.hide = function () {
                for (var i = 0; i < this.overlays.length; i++) {
                    if (this.overlays[i] instanceof htmlOverlay.HtmlOverlay) {
                        this.overlays[i].hide();
                    }
                }
            };

            this.setOverlaysHitArea = function(pageW, pageH) {
                this.pageWidth = pageW;
                this.pageHeight = pageH;
                for (var i = 0, l = this.getContainer().getNumChildren(); i < l; i++) {
                    var hit = new createjs.Shape();
                    var hitWidth = this.getContainer().mask ?
                        Math.min(this.overlays[i].width, pageW - this.overlays[i].x) :
                        this.overlays[i].width;
                    var hitHeight = this.getContainer().mask ?
                        Math.min(this.overlays[i].height, pageH - this.overlays[i].y) :
                        this.overlays[i].height;
                    hit.graphics.beginFill("#000").drawRect(this.overlays[i].x, this.overlays[i].y, hitWidth, hitHeight);
                    this.getContainer().getChildAt(i).hitArea = hit;
                }
            }
        };

        return {
            OverlayController: OverlayController
        };
    });

var fabric=fabric||{version:"4.3.0"};if("undefined"!=typeof exports?exports.fabric=fabric:"function"==typeof define&&define.amd&&define('fabric',[],function(){return fabric}),"undefined"!=typeof document&&"undefined"!=typeof window)document instanceof("undefined"!=typeof HTMLDocument?HTMLDocument:Document)?fabric.document=document:fabric.document=document.implementation.createHTMLDocument(""),fabric.window=window;else{var jsdom=require("jsdom"),virtualWindow=new jsdom.JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"),{features:{FetchExternalResources:["img"]},resources:"usable"}).window;fabric.document=virtualWindow.document,fabric.jsdomImplForWrapper=require("jsdom/lib/jsdom/living/generated/utils").implForWrapper,fabric.nodeCanvas=require("jsdom/lib/jsdom/utils").Canvas,fabric.window=virtualWindow,DOMParser=fabric.window.DOMParser}function resizeCanvasIfNeeded(t){var e=t.targetCanvas,i=e.width,r=e.height,n=t.destinationWidth,s=t.destinationHeight;i===n&&r===s||(e.width=n,e.height=s)}function copyGLTo2DDrawImage(t,e){var i=t.canvas,r=e.targetCanvas,n=r.getContext("2d");n.translate(0,r.height),n.scale(1,-1);var s=i.height-r.height;n.drawImage(i,0,s,r.width,r.height,0,0,r.width,r.height)}function copyGLTo2DPutImageData(t,e){var i=e.targetCanvas.getContext("2d"),r=e.destinationWidth,n=e.destinationHeight,s=r*n*4,o=new Uint8Array(this.imageBuffer,0,s),a=new Uint8ClampedArray(this.imageBuffer,0,s);t.readPixels(0,0,r,n,t.RGBA,t.UNSIGNED_BYTE,o);var h=new ImageData(a,r,n);i.putImageData(h,0,0)}fabric.isTouchSupported="ontouchstart"in fabric.window||"ontouchstart"in fabric.document||fabric.window&&fabric.window.navigator&&0<fabric.window.navigator.maxTouchPoints,fabric.isLikelyNode="undefined"!=typeof Buffer&&"undefined"==typeof window,fabric.SHARED_ATTRIBUTES=["display","transform","fill","fill-opacity","fill-rule","opacity","stroke","stroke-dasharray","stroke-linecap","stroke-dashoffset","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","id","paint-order","vector-effect","instantiated_by_use","clip-path"],fabric.DPI=96,fabric.reNum="(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)",fabric.commaWsp="(?:\\s+,?\\s*|,\\s*)",fabric.rePathCommand=/([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,fabric.reNonWord=/[ \n\.,;!\?\-]/,fabric.fontPaths={},fabric.iMatrix=[1,0,0,1,0,0],fabric.svgNS="http://www.w3.org/2000/svg",fabric.perfLimitSizeTotal=2097152,fabric.maxCacheSideLimit=4096,fabric.minCacheSideLimit=256,fabric.charWidthsCache={},fabric.textureSize=2048,fabric.disableStyleCopyPaste=!1,fabric.enableGLFiltering=!0,fabric.devicePixelRatio=fabric.window.devicePixelRatio||fabric.window.webkitDevicePixelRatio||fabric.window.mozDevicePixelRatio||1,fabric.browserShadowBlurConstant=1,fabric.arcToSegmentsCache={},fabric.boundsOfCurveCache={},fabric.cachesBoundsOfCurve=!0,fabric.forceGLPutImageData=!1,fabric.initFilterBackend=function(){return fabric.enableGLFiltering&&fabric.isWebglSupported&&fabric.isWebglSupported(fabric.textureSize)?(console.log("max texture size: "+fabric.maxTextureSize),new fabric.WebglFilterBackend({tileSize:fabric.textureSize})):fabric.Canvas2dFilterBackend?new fabric.Canvas2dFilterBackend:void 0},"undefined"!=typeof document&&"undefined"!=typeof window&&(window.fabric=fabric),function(){function r(t,e){if(this.__eventListeners[t]){var i=this.__eventListeners[t];e?i[i.indexOf(e)]=!1:fabric.util.array.fill(i,!1)}}fabric.Observable={fire:function(t,e){if(!this.__eventListeners)return this;var i=this.__eventListeners[t];if(!i)return this;for(var r=0,n=i.length;r<n;r++)i[r]&&i[r].call(this,e||{});return this.__eventListeners[t]=i.filter(function(t){return!1!==t}),this},on:function(t,e){if(this.__eventListeners||(this.__eventListeners={}),1===arguments.length)for(var i in t)this.on(i,t[i]);else this.__eventListeners[t]||(this.__eventListeners[t]=[]),this.__eventListeners[t].push(e);return this},off:function(t,e){if(!this.__eventListeners)return this;if(0===arguments.length)for(t in this.__eventListeners)r.call(this,t);else if(1===arguments.length&&"object"==typeof t)for(var i in t)r.call(this,i,t[i]);else r.call(this,t,e);return this}}}(),fabric.Collection={_objects:[],add:function(){if(this._objects.push.apply(this._objects,arguments),this._onObjectAdded)for(var t=0,e=arguments.length;t<e;t++)this._onObjectAdded(arguments[t]);return this.renderOnAddRemove&&this.requestRenderAll(),this},insertAt:function(t,e,i){var r=this._objects;return i?r[e]=t:r.splice(e,0,t),this._onObjectAdded&&this._onObjectAdded(t),this.renderOnAddRemove&&this.requestRenderAll(),this},remove:function(){for(var t,e=this._objects,i=!1,r=0,n=arguments.length;r<n;r++)-1!==(t=e.indexOf(arguments[r]))&&(i=!0,e.splice(t,1),this._onObjectRemoved&&this._onObjectRemoved(arguments[r]));return this.renderOnAddRemove&&i&&this.requestRenderAll(),this},forEachObject:function(t,e){for(var i=this.getObjects(),r=0,n=i.length;r<n;r++)t.call(e,i[r],r,i);return this},getObjects:function(e){return void 0===e?this._objects.concat():this._objects.filter(function(t){return t.type===e})},item:function(t){return this._objects[t]},isEmpty:function(){return 0===this._objects.length},size:function(){return this._objects.length},contains:function(t){return-1<this._objects.indexOf(t)},complexity:function(){return this._objects.reduce(function(t,e){return t+=e.complexity?e.complexity():0},0)}},fabric.CommonMethods={_setOptions:function(t){for(var e in t)this.set(e,t[e])},_initGradient:function(t,e){!t||!t.colorStops||t instanceof fabric.Gradient||this.set(e,new fabric.Gradient(t))},_initPattern:function(t,e,i){!t||!t.source||t instanceof fabric.Pattern?i&&i():this.set(e,new fabric.Pattern(t,i))},_setObject:function(t){for(var e in t)this._set(e,t[e])},set:function(t,e){return"object"==typeof t?this._setObject(t):this._set(t,e),this},_set:function(t,e){this[t]=e},toggle:function(t){var e=this.get(t);return"boolean"==typeof e&&this.set(t,!e),this},get:function(t){return this[t]}},function(s){var d=Math.sqrt,g=Math.atan2,o=Math.pow,a=Math.PI/180,i=Math.PI/2;fabric.util={cos:function(t){if(0===t)return 1;switch(t<0&&(t=-t),t/i){case 1:case 3:return 0;case 2:return-1}return Math.cos(t)},sin:function(t){if(0===t)return 0;var e=1;switch(t<0&&(e=-1),t/i){case 1:return e;case 2:return 0;case 3:return-e}return Math.sin(t)},removeFromArray:function(t,e){var i=t.indexOf(e);return-1!==i&&t.splice(i,1),t},getRandomInt:function(t,e){return Math.floor(Math.random()*(e-t+1))+t},degreesToRadians:function(t){return t*a},radiansToDegrees:function(t){return t/a},rotatePoint:function(t,e,i){t.subtractEquals(e);var r=fabric.util.rotateVector(t,i);return new fabric.Point(r.x,r.y).addEquals(e)},rotateVector:function(t,e){var i=fabric.util.sin(e),r=fabric.util.cos(e);return{x:t.x*r-t.y*i,y:t.x*i+t.y*r}},transformPoint:function(t,e,i){return i?new fabric.Point(e[0]*t.x+e[2]*t.y,e[1]*t.x+e[3]*t.y):new fabric.Point(e[0]*t.x+e[2]*t.y+e[4],e[1]*t.x+e[3]*t.y+e[5])},makeBoundingBoxFromPoints:function(t,e){if(e)for(var i=0;i<t.length;i++)t[i]=fabric.util.transformPoint(t[i],e);var r=[t[0].x,t[1].x,t[2].x,t[3].x],n=fabric.util.array.min(r),s=fabric.util.array.max(r)-n,o=[t[0].y,t[1].y,t[2].y,t[3].y],a=fabric.util.array.min(o);return{left:n,top:a,width:s,height:fabric.util.array.max(o)-a}},invertTransform:function(t){var e=1/(t[0]*t[3]-t[1]*t[2]),i=[e*t[3],-e*t[1],-e*t[2],e*t[0]],r=fabric.util.transformPoint({x:t[4],y:t[5]},i,!0);return i[4]=-r.x,i[5]=-r.y,i},toFixed:function(t,e){return parseFloat(Number(t).toFixed(e))},parseUnit:function(t,e){var i=/\D{0,2}$/.exec(t),r=parseFloat(t);switch(e||(e=fabric.Text.DEFAULT_SVG_FONT_SIZE),i[0]){case"mm":return r*fabric.DPI/25.4;case"cm":return r*fabric.DPI/2.54;case"in":return r*fabric.DPI;case"pt":return r*fabric.DPI/72;case"pc":return r*fabric.DPI/72*12;case"em":return r*e;default:return r}},falseFunction:function(){return!1},getKlass:function(t,e){return t=fabric.util.string.camelize(t.charAt(0).toUpperCase()+t.slice(1)),fabric.util.resolveNamespace(e)[t]},getSvgAttributes:function(t){var e=["instantiated_by_use","style","id","class"];switch(t){case"linearGradient":e=e.concat(["x1","y1","x2","y2","gradientUnits","gradientTransform"]);break;case"radialGradient":e=e.concat(["gradientUnits","gradientTransform","cx","cy","r","fx","fy","fr"]);break;case"stop":e=e.concat(["offset","stop-color","stop-opacity"])}return e},resolveNamespace:function(t){if(!t)return fabric;var e,i=t.split("."),r=i.length,n=s||fabric.window;for(e=0;e<r;++e)n=n[i[e]];return n},loadImage:function(t,e,i,r){if(t){var n=fabric.util.createImage(),s=function(){e&&e.call(i,n,!1),n=n.onload=n.onerror=null};n.onload=s,n.onerror=function(){fabric.log("Error loading "+n.src),e&&e.call(i,null,!0),n=n.onload=n.onerror=null},0!==t.indexOf("data")&&null!=r&&(n.crossOrigin=r),"data:image/svg"===t.substring(0,14)&&(n.onload=null,fabric.util.loadImageInDom(n,s)),n.src=t}else e&&e.call(i,t)},loadImageInDom:function(t,e){var i=fabric.document.createElement("div");i.style.width=i.style.height="1px",i.style.left=i.style.top="-100%",i.style.position="absolute",i.appendChild(t),fabric.document.querySelector("body").appendChild(i),t.onload=function(){e(),i.parentNode.removeChild(i),i=null}},enlivenObjects:function(t,e,n,s){var o=[],i=0,r=(t=t||[]).length;function a(){++i===r&&e&&e(o.filter(function(t){return t}))}r?t.forEach(function(i,r){i&&i.type?fabric.util.getKlass(i.type,n).fromObject(i,function(t,e){e||(o[r]=t),s&&s(i,t,e),a()}):a()}):e&&e(o)},enlivenPatterns:function(t,e){function i(){++n===s&&e&&e(r)}var r=[],n=0,s=(t=t||[]).length;s?t.forEach(function(t,e){t&&t.source?new fabric.Pattern(t,function(t){r[e]=t,i()}):(r[e]=t,i())}):e&&e(r)},groupSVGElements:function(t,e,i){var r;return t&&1===t.length?t[0]:(e&&(e.width&&e.height?e.centerPoint={x:e.width/2,y:e.height/2}:(delete e.width,delete e.height)),r=new fabric.Group(t,e),void 0!==i&&(r.sourcePath=i),r)},populateWithProperties:function(t,e,i){if(i&&"[object Array]"===Object.prototype.toString.call(i))for(var r=0,n=i.length;r<n;r++)i[r]in t&&(e[i[r]]=t[i[r]])},drawDashedLine:function(t,e,i,r,n,s){var o=r-e,a=n-i,h=d(o*o+a*a),c=g(a,o),l=s.length,u=0,f=!0;for(t.save(),t.translate(e,i),t.moveTo(0,0),t.rotate(c),e=0;e<h;)h<(e+=s[u++%l])&&(e=h),t[f?"lineTo":"moveTo"](e,0),f=!f;t.restore()},createCanvasElement:function(){return fabric.document.createElement("canvas")},copyCanvasElement:function(t){var e=fabric.util.createCanvasElement();return e.width=t.width,e.height=t.height,e.getContext("2d").drawImage(t,0,0),e},toDataURL:function(t,e,i){return t.toDataURL("image/"+e,i)},createImage:function(){return fabric.document.createElement("img")},multiplyTransformMatrices:function(t,e,i){return[t[0]*e[0]+t[2]*e[1],t[1]*e[0]+t[3]*e[1],t[0]*e[2]+t[2]*e[3],t[1]*e[2]+t[3]*e[3],i?0:t[0]*e[4]+t[2]*e[5]+t[4],i?0:t[1]*e[4]+t[3]*e[5]+t[5]]},qrDecompose:function(t){var e=g(t[1],t[0]),i=o(t[0],2)+o(t[1],2),r=d(i),n=(t[0]*t[3]-t[2]*t[1])/r,s=g(t[0]*t[2]+t[1]*t[3],i);return{angle:e/a,scaleX:r,scaleY:n,skewX:s/a,skewY:0,translateX:t[4],translateY:t[5]}},calcRotateMatrix:function(t){if(!t.angle)return fabric.iMatrix.concat();var e=fabric.util.degreesToRadians(t.angle),i=fabric.util.cos(e),r=fabric.util.sin(e);return[i,r,-r,i,0,0]},calcDimensionsMatrix:function(t){var e=void 0===t.scaleX?1:t.scaleX,i=void 0===t.scaleY?1:t.scaleY,r=[t.flipX?-e:e,0,0,t.flipY?-i:i,0,0],n=fabric.util.multiplyTransformMatrices,s=fabric.util.degreesToRadians;return t.skewX&&(r=n(r,[1,0,Math.tan(s(t.skewX)),1],!0)),t.skewY&&(r=n(r,[1,Math.tan(s(t.skewY)),0,1],!0)),r},composeMatrix:function(t){var e=[1,0,0,1,t.translateX||0,t.translateY||0],i=fabric.util.multiplyTransformMatrices;return t.angle&&(e=i(e,fabric.util.calcRotateMatrix(t))),(1!==t.scaleX||1!==t.scaleY||t.skewX||t.skewY||t.flipX||t.flipY)&&(e=i(e,fabric.util.calcDimensionsMatrix(t))),e},resetObjectTransform:function(t){t.scaleX=1,t.scaleY=1,t.skewX=0,t.skewY=0,t.flipX=!1,t.flipY=!1,t.rotate(0)},saveObjectTransform:function(t){return{scaleX:t.scaleX,scaleY:t.scaleY,skewX:t.skewX,skewY:t.skewY,angle:t.angle,left:t.left,flipX:t.flipX,flipY:t.flipY,top:t.top}},isTransparent:function(t,e,i,r){0<r&&(r<e?e-=r:e=0,r<i?i-=r:i=0);var n,s=!0,o=t.getImageData(e,i,2*r||1,2*r||1),a=o.data.length;for(n=3;n<a&&!1!==(s=o.data[n]<=0);n+=4);return o=null,s},parsePreserveAspectRatioAttribute:function(t){var e,i="meet",r=t.split(" ");return r&&r.length&&("meet"!==(i=r.pop())&&"slice"!==i?(e=i,i="meet"):r.length&&(e=r.pop())),{meetOrSlice:i,alignX:"none"!==e?e.slice(1,4):"none",alignY:"none"!==e?e.slice(5,8):"none"}},clearFabricFontCache:function(t){(t=(t||"").toLowerCase())?fabric.charWidthsCache[t]&&delete fabric.charWidthsCache[t]:fabric.charWidthsCache={}},limitDimsByArea:function(t,e){var i=Math.sqrt(e*t),r=Math.floor(e/i);return{x:Math.floor(i),y:r}},capValue:function(t,e,i){return Math.max(t,Math.min(e,i))},findScaleToFit:function(t,e){return Math.min(e.width/t.width,e.height/t.height)},findScaleToCover:function(t,e){return Math.max(e.width/t.width,e.height/t.height)},matrixToSVG:function(t){return"matrix("+t.map(function(t){return fabric.util.toFixed(t,fabric.Object.NUM_FRACTION_DIGITS)}).join(" ")+")"},sizeAfterTransform:function(t,e,i){var r=t/2,n=e/2,s=[{x:-r,y:-n},{x:r,y:-n},{x:-r,y:n},{x:r,y:n}],o=fabric.util.calcDimensionsMatrix(i),a=fabric.util.makeBoundingBoxFromPoints(s,o);return{x:a.width,y:a.height}}}}("undefined"!=typeof exports?exports:this),function(){var E=Array.prototype.join,T={m:2,l:2,h:1,v:1,c:6,s:4,q:4,t:2,a:7},w={m:"l",M:"L"};function v(t,e,i,r,n,s,o){var a=Math.PI,h=o*a/180,c=fabric.util.sin(h),l=fabric.util.cos(h),u=0,f=0,d=-l*t*.5-c*e*.5,g=-l*e*.5+c*t*.5,p=(i=Math.abs(i))*i,v=(r=Math.abs(r))*r,m=g*g,b=d*d,_=p*v-p*m-v*b,y=0;if(_<0){var x=Math.sqrt(1-_/(p*v));i*=x,r*=x}else y=(n===s?-1:1)*Math.sqrt(_/(p*m+v*b));var C=y*i*g/r,S=-y*r*d/i,T=l*C-c*S+.5*t,w=c*C+l*S+.5*e,O=$(1,0,(d-C)/i,(g-S)/r),k=$((d-C)/i,(g-S)/r,(-d-C)/i,(-g-S)/r);0===s&&0<k?k-=2*a:1===s&&k<0&&(k+=2*a);for(var P,D,E,A,j,M,F,I,L,R,B,X,W,Y,z,H,G,U=Math.ceil(Math.abs(k/a*2)),N=[],V=k/U,q=8/3*Math.sin(V/4)*Math.sin(V/4)/Math.sin(V/2),K=O+V,J=0;J<U;J++)N[J]=(P=O,D=K,E=l,A=c,j=i,M=r,F=T,I=w,L=q,R=u,B=f,void 0,X=fabric.util.cos(P),W=fabric.util.sin(P),Y=fabric.util.cos(D),z=fabric.util.sin(D),["C",R+L*(-E*j*W-A*M*X),B+L*(-A*j*W+E*M*X),(H=E*j*Y-A*M*z+F)+L*(E*j*z+A*M*Y),(G=A*j*Y+E*M*z+I)+L*(A*j*z-E*M*Y),H,G]),u=N[J][5],f=N[J][6],O=K,K+=V;return N}function $(t,e,i,r){var n=Math.atan2(e,t),s=Math.atan2(r,i);return n<=s?s-n:2*Math.PI-(n-s)}function m(t,e,i,r,n,s,o,a){var h;if(fabric.cachesBoundsOfCurve&&(h=E.call(arguments),fabric.boundsOfCurveCache[h]))return fabric.boundsOfCurveCache[h];var c,l,u,f,d,g,p,v,m=Math.sqrt,b=Math.min,_=Math.max,y=Math.abs,x=[],C=[[],[]];l=6*t-12*i+6*n,c=-3*t+9*i-9*n+3*o,u=3*i-3*t;for(var S=0;S<2;++S)if(0<S&&(l=6*e-12*r+6*s,c=-3*e+9*r-9*s+3*a,u=3*r-3*e),y(c)<1e-12){if(y(l)<1e-12)continue;0<(f=-u/l)&&f<1&&x.push(f)}else(p=l*l-4*u*c)<0||(0<(d=(-l+(v=m(p)))/(2*c))&&d<1&&x.push(d),0<(g=(-l-v)/(2*c))&&g<1&&x.push(g));for(var T,w,O,k=x.length,P=k;k--;)T=(O=1-(f=x[k]))*O*O*t+3*O*O*f*i+3*O*f*f*n+f*f*f*o,C[0][k]=T,w=O*O*O*e+3*O*O*f*r+3*O*f*f*s+f*f*f*a,C[1][k]=w;C[0][P]=t,C[1][P]=e,C[0][P+1]=o,C[1][P+1]=a;var D=[{x:b.apply(null,C[0]),y:b.apply(null,C[1])},{x:_.apply(null,C[0]),y:_.apply(null,C[1])}];return fabric.cachesBoundsOfCurve&&(fabric.boundsOfCurveCache[h]=D),D}function d(t,e,i){for(var r=i[1],n=i[2],s=i[3],o=i[4],a=i[5],h=v(i[6]-t,i[7]-e,r,n,o,a,s),c=0,l=h.length;c<l;c++)h[c][1]+=t,h[c][2]+=e,h[c][3]+=t,h[c][4]+=e,h[c][5]+=t,h[c][6]+=e;return h}function f(t,e,i,r){return Math.sqrt((i-t)*(i-t)+(r-e)*(r-e))}function g(c,l,u,f,d,g,p,v){return function(t){var e,i,r,n,s=(n=t)*n*n,o=3*(r=t)*r*(1-r),a=3*(i=t)*(1-i)*(1-i),h=(1-(e=t))*(1-e)*(1-e);return{x:p*s+d*o+u*a+c*h,y:v*s+g*o+f*a+l*h}}}function p(a,h,c,l,u,f){return function(t){var e,i,r,n=(r=t)*r,s=2*(i=t)*(1-i),o=(1-(e=t))*(1-e);return{x:u*n+c*s+a*o,y:f*n+l*s+h*o}}}function b(t,e,i){var r,n,s={x:e,y:i},o=0;for(n=.01;n<=1;n+=.01)r=t(n),o+=f(s.x,s.y,r.x,r.y),s=r;return o}function h(t,e){for(var i,r,n=0,s=0,o=t.iterator,a={x:t.x,y:t.y},h=.01;s<e&&n<=1&&1e-4<h;)i=o(n),e<(r=f(a.x,a.y,i.x,i.y))+s?n-=h/=2:(a=i,n+=h,s+=r);return i}function c(t){for(var e,i,r,n=0,s=t.length,o=0,a=0,h=0,c=0,l=[],u=0;u<s;u++){switch(r={x:o,y:a,command:(e=t[u])[0]},e[0]){case"M":r.length=0,h=o=e[1],c=a=e[2];break;case"L":r.length=f(o,a,e[1],e[2]),o=e[1],a=e[2];break;case"C":i=g(o,a,e[1],e[2],e[3],e[4],e[5],e[6]),r.iterator=i,r.length=b(i,o,a),o=e[5],a=e[6];break;case"Q":i=p(o,a,e[1],e[2],e[3],e[4]),r.iterator=i,r.length=b(i,o,a),o=e[3],a=e[4];break;case"Z":case"z":r.destX=h,r.destY=c,r.length=f(o,a,h,c),o=h,a=c}n+=r.length,l.push(r)}return l.push({length:n,x:o,y:a}),l}fabric.util.parsePath=function(t){var e,i,r,n,s,o=[],a=[],h=fabric.rePathCommand,c="[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*",l="("+c+")"+fabric.commaWsp,u="([01])"+fabric.commaWsp+"?",f=new RegExp(l+"?"+l+"?"+l+u+u+l+"?("+c+")","g");if(!t||!t.match)return o;for(var d,g=0,p=(s=t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi)).length;g<p;g++){n=(e=s[g]).slice(1).trim(),a.length=0;var v=e.charAt(0);if(d=[v],"a"===v.toLowerCase())for(var m;m=f.exec(n);)for(var b=1;b<m.length;b++)a.push(m[b]);else for(;r=h.exec(n);)a.push(r[0]);b=0;for(var _=a.length;b<_;b++)i=parseFloat(a[b]),isNaN(i)||d.push(i);var y=T[v.toLowerCase()],x=w[v]||v;if(d.length-1>y)for(var C=1,S=d.length;C<S;C+=y)o.push([v].concat(d.slice(C,C+y))),v=x;else o.push(d)}return o},fabric.util.makePathSimpler=function(t){var e,i,r,n,s,o,a=0,h=0,c=t.length,l=0,u=0,f=[];for(i=0;i<c;++i){switch(r=!1,(e=t[i].slice(0))[0]){case"l":e[0]="L",e[1]+=a,e[2]+=h;case"L":a=e[1],h=e[2];break;case"h":e[1]+=a;case"H":e[0]="L",e[2]=h,a=e[1];break;case"v":e[1]+=h;case"V":e[0]="L",h=e[1],e[1]=a,e[2]=h;break;case"m":e[0]="M",e[1]+=a,e[2]+=h;case"M":a=e[1],h=e[2],l=e[1],u=e[2];break;case"c":e[0]="C",e[1]+=a,e[2]+=h,e[3]+=a,e[4]+=h,e[5]+=a,e[6]+=h;case"C":s=e[3],o=e[4],a=e[5],h=e[6];break;case"s":e[0]="S",e[1]+=a,e[2]+=h,e[3]+=a,e[4]+=h;case"S":"C"===n?(s=2*a-s,o=2*h-o):(s=a,o=h),a=e[3],h=e[4],e[0]="C",e[5]=e[3],e[6]=e[4],e[3]=e[1],e[4]=e[2],e[1]=s,e[2]=o,s=e[3],o=e[4];break;case"q":e[0]="Q",e[1]+=a,e[2]+=h,e[3]+=a,e[4]+=h;case"Q":s=e[1],o=e[2],a=e[3],h=e[4];break;case"t":e[0]="T",e[1]+=a,e[2]+=h;case"T":"Q"===n?(s=2*a-s,o=2*h-o):(s=a,o=h),e[0]="Q",a=e[1],h=e[2],e[1]=s,e[2]=o,e[3]=a,e[4]=h;break;case"a":e[0]="A",e[6]+=a,e[7]+=h;case"A":r=!0,f=f.concat(d(a,h,e)),a=e[6],h=e[7];break;case"z":case"Z":a=l,h=u}r||f.push(e),n=e[0]}return f},fabric.util.getPathSegmentsInfo=c,fabric.util.fromArcToBeziers=d,fabric.util.fromArcToBeizers=d,fabric.util.getBoundsOfCurve=m,fabric.util.getPointOnPath=function(t,e,i){i||(i=c(t));for(var r=0;0<e-i[r].length&&r<i.length-2;)e-=i[r].length,r++;var n=i[r],s=e/n.length,o=n.command,a=t[r];switch(o){case"M":return{x:n.x,y:n.y};case"Z":case"z":return new fabric.Point(n.x,n.y).lerp(new fabric.Point(n.destX,n.destY),s);case"L":return new fabric.Point(n.x,n.y).lerp(new fabric.Point(a[1],a[2]),s);case"C":case"Q":return h(n,e)}},fabric.util.getBoundsOfArc=function(t,e,i,r,n,s,o,a,h){for(var c,l=0,u=0,f=[],d=v(a-t,h-e,i,r,s,o,n),g=0,p=d.length;g<p;g++)c=m(l,u,d[g][1],d[g][2],d[g][3],d[g][4],d[g][5],d[g][6]),f.push({x:c[0].x+t,y:c[0].y+e}),f.push({x:c[1].x+t,y:c[1].y+e}),l=d[g][5],u=d[g][6];return f},fabric.util.drawArc=function(e,t,i,r){d(t,i,r=r.slice(0).unshift("X")).forEach(function(t){e.bezierCurveTo.apply(e,t.slice(1))})}}(),function(){var o=Array.prototype.slice;function i(t,e,i){if(t&&0!==t.length){var r=t.length-1,n=e?t[r][e]:t[r];if(e)for(;r--;)i(t[r][e],n)&&(n=t[r][e]);else for(;r--;)i(t[r],n)&&(n=t[r]);return n}}fabric.util.array={fill:function(t,e){for(var i=t.length;i--;)t[i]=e;return t},invoke:function(t,e){for(var i=o.call(arguments,2),r=[],n=0,s=t.length;n<s;n++)r[n]=i.length?t[n][e].apply(t[n],i):t[n][e].call(t[n]);return r},min:function(t,e){return i(t,e,function(t,e){return t<e})},max:function(t,e){return i(t,e,function(t,e){return e<=t})}}}(),function(){function o(t,e,i){if(i)if(!fabric.isLikelyNode&&e instanceof Element)t=e;else if(e instanceof Array){t=[];for(var r=0,n=e.length;r<n;r++)t[r]=o({},e[r],i)}else if(e&&"object"==typeof e)for(var s in e)"canvas"===s||"group"===s?t[s]=null:e.hasOwnProperty(s)&&(t[s]=o({},e[s],i));else t=e;else for(var s in e)t[s]=e[s];return t}fabric.util.object={extend:o,clone:function(t,e){return o({},t,e)}},fabric.util.object.extend(fabric.util,fabric.Observable)}(),function(){function n(t,e){var i=t.charCodeAt(e);if(isNaN(i))return"";if(i<55296||57343<i)return t.charAt(e);if(55296<=i&&i<=56319){if(t.length<=e+1)throw"High surrogate without following low surrogate";var r=t.charCodeAt(e+1);if(r<56320||57343<r)throw"High surrogate without following low surrogate";return t.charAt(e)+t.charAt(e+1)}if(0===e)throw"Low surrogate without preceding high surrogate";var n=t.charCodeAt(e-1);if(n<55296||56319<n)throw"Low surrogate without preceding high surrogate";return!1}fabric.util.string={camelize:function(t){return t.replace(/-+(.)?/g,function(t,e){return e?e.toUpperCase():""})},capitalize:function(t,e){return t.charAt(0).toUpperCase()+(e?t.slice(1):t.slice(1).toLowerCase())},escapeXml:function(t){return t.replace(/&/g,"&amp;").replace(/"/g,"&quot;").replace(/'/g,"&apos;").replace(/</g,"&lt;").replace(/>/g,"&gt;")},graphemeSplit:function(t){var e,i=0,r=[];for(i=0;i<t.length;i++)!1!==(e=n(t,i))&&r.push(e);return r}}}(),function(){var s=Array.prototype.slice,o=function(){},i=function(){for(var t in{toString:1})if("toString"===t)return!1;return!0}(),a=function(t,r,n){for(var e in r)e in t.prototype&&"function"==typeof t.prototype[e]&&-1<(r[e]+"").indexOf("callSuper")?t.prototype[e]=function(i){return function(){var t=this.constructor.superclass;this.constructor.superclass=n;var e=r[i].apply(this,arguments);if(this.constructor.superclass=t,"initialize"!==i)return e}}(e):t.prototype[e]=r[e],i&&(r.toString!==Object.prototype.toString&&(t.prototype.toString=r.toString),r.valueOf!==Object.prototype.valueOf&&(t.prototype.valueOf=r.valueOf))};function h(){}function c(t){for(var e=null,i=this;i.constructor.superclass;){var r=i.constructor.superclass.prototype[t];if(i[t]!==r){e=r;break}i=i.constructor.superclass.prototype}return e?1<arguments.length?e.apply(this,s.call(arguments,1)):e.call(this):console.log("tried to callSuper "+t+", method not found in prototype chain",this)}fabric.util.createClass=function(){var t=null,e=s.call(arguments,0);function i(){this.initialize.apply(this,arguments)}"function"==typeof e[0]&&(t=e.shift()),i.superclass=t,i.subclasses=[],t&&(h.prototype=t.prototype,i.prototype=new h,t.subclasses.push(i));for(var r=0,n=e.length;r<n;r++)a(i,e[r],t);return i.prototype.initialize||(i.prototype.initialize=o),(i.prototype.constructor=i).prototype.callSuper=c,i}}(),function(){var n=!!fabric.document.createElement("div").attachEvent,e=["touchstart","touchmove","touchend"];fabric.util.addListener=function(t,e,i,r){t&&t.addEventListener(e,i,!n&&r)},fabric.util.removeListener=function(t,e,i,r){t&&t.removeEventListener(e,i,!n&&r)},fabric.util.getPointer=function(t){var e,i,r=t.target,n=fabric.util.getScrollLeftTop(r),s=(i=(e=t).changedTouches)&&i[0]?i[0]:e;return{x:s.clientX+n.left,y:s.clientY+n.top}},fabric.util.isTouchEvent=function(t){return-1<e.indexOf(t.type)||"touch"===t.pointerType}}(),function(){var t=fabric.document.createElement("div"),e="string"==typeof t.style.opacity,i="string"==typeof t.style.filter,r=/alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,n=function(t){return t};e?n=function(t,e){return t.style.opacity=e,t}:i&&(n=function(t,e){var i=t.style;return t.currentStyle&&!t.currentStyle.hasLayout&&(i.zoom=1),r.test(i.filter)?(e=.9999<=e?"":"alpha(opacity="+100*e+")",i.filter=i.filter.replace(r,e)):i.filter+=" alpha(opacity="+100*e+")",t}),fabric.util.setStyle=function(t,e){var i=t.style;if(!i)return t;if("string"==typeof e)return t.style.cssText+=";"+e,-1<e.indexOf("opacity")?n(t,e.match(/opacity:\s*(\d?\.?\d*)/)[1]):t;for(var r in e)"opacity"===r?n(t,e[r]):i["float"===r||"cssFloat"===r?void 0===i.styleFloat?"cssFloat":"styleFloat":r]=e[r];return t}}(),function(){var e=Array.prototype.slice;var t,h,i,r,n=function(t){return e.call(t,0)};try{t=n(fabric.document.childNodes)instanceof Array}catch(t){}function s(t,e){var i=fabric.document.createElement(t);for(var r in e)"class"===r?i.className=e[r]:"for"===r?i.htmlFor=e[r]:i.setAttribute(r,e[r]);return i}function c(t){for(var e=0,i=0,r=fabric.document.documentElement,n=fabric.document.body||{scrollLeft:0,scrollTop:0};t&&(t.parentNode||t.host)&&((t=t.parentNode||t.host)===fabric.document?(e=n.scrollLeft||r.scrollLeft||0,i=n.scrollTop||r.scrollTop||0):(e+=t.scrollLeft||0,i+=t.scrollTop||0),1!==t.nodeType||"fixed"!==t.style.position););return{left:e,top:i}}t||(n=function(t){for(var e=new Array(t.length),i=t.length;i--;)e[i]=t[i];return e}),h=fabric.document.defaultView&&fabric.document.defaultView.getComputedStyle?function(t,e){var i=fabric.document.defaultView.getComputedStyle(t,null);return i?i[e]:void 0}:function(t,e){var i=t.style[e];return!i&&t.currentStyle&&(i=t.currentStyle[e]),i},i=fabric.document.documentElement.style,r="userSelect"in i?"userSelect":"MozUserSelect"in i?"MozUserSelect":"WebkitUserSelect"in i?"WebkitUserSelect":"KhtmlUserSelect"in i?"KhtmlUserSelect":"",fabric.util.makeElementUnselectable=function(t){return void 0!==t.onselectstart&&(t.onselectstart=fabric.util.falseFunction),r?t.style[r]="none":"string"==typeof t.unselectable&&(t.unselectable="on"),t},fabric.util.makeElementSelectable=function(t){return void 0!==t.onselectstart&&(t.onselectstart=null),r?t.style[r]="":"string"==typeof t.unselectable&&(t.unselectable=""),t},fabric.util.setImageSmoothing=function(t,e){t.imageSmoothingEnabled=t.imageSmoothingEnabled||t.webkitImageSmoothingEnabled||t.mozImageSmoothingEnabled||t.msImageSmoothingEnabled||t.oImageSmoothingEnabled,t.imageSmoothingEnabled=e},fabric.util.getById=function(t){return"string"==typeof t?fabric.document.getElementById(t):t},fabric.util.toArray=n,fabric.util.addClass=function(t,e){t&&-1===(" "+t.className+" ").indexOf(" "+e+" ")&&(t.className+=(t.className?" ":"")+e)},fabric.util.makeElement=s,fabric.util.wrapElement=function(t,e,i){return"string"==typeof e&&(e=s(e,i)),t.parentNode&&t.parentNode.replaceChild(e,t),e.appendChild(t),e},fabric.util.getScrollLeftTop=c,fabric.util.getElementOffset=function(t){var e,i,r=t&&t.ownerDocument,n={left:0,top:0},s={left:0,top:0},o={borderLeftWidth:"left",borderTopWidth:"top",paddingLeft:"left",paddingTop:"top"};if(!r)return s;for(var a in o)s[o[a]]+=parseInt(h(t,a),10)||0;return e=r.documentElement,void 0!==t.getBoundingClientRect&&(n=t.getBoundingClientRect()),i=c(t),{left:n.left+i.left-(e.clientLeft||0)+s.left,top:n.top+i.top-(e.clientTop||0)+s.top}},fabric.util.getNodeCanvas=function(t){var e=fabric.jsdomImplForWrapper(t);return e._canvas||e._image},fabric.util.cleanUpJsdomNode=function(t){if(fabric.isLikelyNode){var e=fabric.jsdomImplForWrapper(t);e&&(e._image=null,e._canvas=null,e._currentSrc=null,e._attributes=null,e._classList=null)}}}(),function(){function h(){}fabric.util.request=function(t,e){e||(e={});var i,r,n=e.method?e.method.toUpperCase():"GET",s=e.onComplete||function(){},o=new fabric.window.XMLHttpRequest,a=e.body||e.parameters;return o.onreadystatechange=function(){4===o.readyState&&(s(o),o.onreadystatechange=h)},"GET"===n&&(a=null,"string"==typeof e.parameters&&(i=t,r=e.parameters,t=i+(/\?/.test(i)?"&":"?")+r)),o.open(n,t,!0),"POST"!==n&&"PUT"!==n||o.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),o.send(a),o}}(),fabric.log=console.log,fabric.warn=console.warn,function(){function i(){return!1}function r(t,e,i,r){return-i*Math.cos(t/r*(Math.PI/2))+i+e}var t=fabric.window.requestAnimationFrame||fabric.window.webkitRequestAnimationFrame||fabric.window.mozRequestAnimationFrame||fabric.window.oRequestAnimationFrame||fabric.window.msRequestAnimationFrame||function(t){return fabric.window.setTimeout(t,1e3/60)},e=fabric.window.cancelAnimationFrame||fabric.window.clearTimeout;function m(){return t.apply(fabric.window,arguments)}fabric.util.animate=function(e){m(function(t){e||(e={});var o,a=t||+new Date,h=e.duration||500,c=a+h,l=e.onChange||i,u=e.abort||i,f=e.onComplete||i,d=e.easing||r,g="startValue"in e?e.startValue:0,p="endValue"in e?e.endValue:100,v=e.byValue||p-g;e.onStart&&e.onStart(),function t(e){o=e||+new Date;var i=c<o?h:o-a,r=i/h,n=d(i,g,v,h),s=Math.abs((n-g)/v);if(!u())return c<o?(l(p,1,1),void f(p,1,1)):(l(n,s,r),void m(t));f(p,1,1)}(a)})},fabric.util.requestAnimFrame=m,fabric.util.cancelAnimFrame=function(){return e.apply(fabric.window,arguments)}}(),function(){function h(t,e,i){var r="rgba("+parseInt(t[0]+i*(e[0]-t[0]),10)+","+parseInt(t[1]+i*(e[1]-t[1]),10)+","+parseInt(t[2]+i*(e[2]-t[2]),10);return r+=","+(t&&e?parseFloat(t[3]+i*(e[3]-t[3])):1),r+=")"}fabric.util.animateColor=function(t,e,i,n){var r=new fabric.Color(t).getSource(),s=new fabric.Color(e).getSource(),o=n.onComplete,a=n.onChange;n=n||{},fabric.util.animate(fabric.util.object.extend(n,{duration:i||500,startValue:r,endValue:s,byValue:s,easing:function(t,e,i,r){return h(e,i,n.colorEasing?n.colorEasing(t,r):1-Math.cos(t/r*(Math.PI/2)))},onComplete:function(t,e,i){if(o)return o(h(s,s,0),e,i)},onChange:function(t,e,i){if(a){if(Array.isArray(t))return a(h(t,t,0),e,i);a(t,e,i)}}}))}}(),function(){function o(t,e,i,r){return t<Math.abs(e)?(t=e,r=i/4):r=0===e&&0===t?i/(2*Math.PI)*Math.asin(1):i/(2*Math.PI)*Math.asin(e/t),{a:t,c:e,p:i,s:r}}function a(t,e,i){return t.a*Math.pow(2,10*(e-=1))*Math.sin((e*i-t.s)*(2*Math.PI)/t.p)}function n(t,e,i,r){return i-s(r-t,0,i,r)+e}function s(t,e,i,r){return(t/=r)<1/2.75?i*(7.5625*t*t)+e:t<2/2.75?i*(7.5625*(t-=1.5/2.75)*t+.75)+e:t<2.5/2.75?i*(7.5625*(t-=2.25/2.75)*t+.9375)+e:i*(7.5625*(t-=2.625/2.75)*t+.984375)+e}fabric.util.ease={easeInQuad:function(t,e,i,r){return i*(t/=r)*t+e},easeOutQuad:function(t,e,i,r){return-i*(t/=r)*(t-2)+e},easeInOutQuad:function(t,e,i,r){return(t/=r/2)<1?i/2*t*t+e:-i/2*(--t*(t-2)-1)+e},easeInCubic:function(t,e,i,r){return i*(t/=r)*t*t+e},easeOutCubic:function(t,e,i,r){return i*((t=t/r-1)*t*t+1)+e},easeInOutCubic:function(t,e,i,r){return(t/=r/2)<1?i/2*t*t*t+e:i/2*((t-=2)*t*t+2)+e},easeInQuart:function(t,e,i,r){return i*(t/=r)*t*t*t+e},easeOutQuart:function(t,e,i,r){return-i*((t=t/r-1)*t*t*t-1)+e},easeInOutQuart:function(t,e,i,r){return(t/=r/2)<1?i/2*t*t*t*t+e:-i/2*((t-=2)*t*t*t-2)+e},easeInQuint:function(t,e,i,r){return i*(t/=r)*t*t*t*t+e},easeOutQuint:function(t,e,i,r){return i*((t=t/r-1)*t*t*t*t+1)+e},easeInOutQuint:function(t,e,i,r){return(t/=r/2)<1?i/2*t*t*t*t*t+e:i/2*((t-=2)*t*t*t*t+2)+e},easeInSine:function(t,e,i,r){return-i*Math.cos(t/r*(Math.PI/2))+i+e},easeOutSine:function(t,e,i,r){return i*Math.sin(t/r*(Math.PI/2))+e},easeInOutSine:function(t,e,i,r){return-i/2*(Math.cos(Math.PI*t/r)-1)+e},easeInExpo:function(t,e,i,r){return 0===t?e:i*Math.pow(2,10*(t/r-1))+e},easeOutExpo:function(t,e,i,r){return t===r?e+i:i*(1-Math.pow(2,-10*t/r))+e},easeInOutExpo:function(t,e,i,r){return 0===t?e:t===r?e+i:(t/=r/2)<1?i/2*Math.pow(2,10*(t-1))+e:i/2*(2-Math.pow(2,-10*--t))+e},easeInCirc:function(t,e,i,r){return-i*(Math.sqrt(1-(t/=r)*t)-1)+e},easeOutCirc:function(t,e,i,r){return i*Math.sqrt(1-(t=t/r-1)*t)+e},easeInOutCirc:function(t,e,i,r){return(t/=r/2)<1?-i/2*(Math.sqrt(1-t*t)-1)+e:i/2*(Math.sqrt(1-(t-=2)*t)+1)+e},easeInElastic:function(t,e,i,r){var n=0;return 0===t?e:1==(t/=r)?e+i:(n||(n=.3*r),-a(o(i,i,n,1.70158),t,r)+e)},easeOutElastic:function(t,e,i,r){var n=0;if(0===t)return e;if(1==(t/=r))return e+i;n||(n=.3*r);var s=o(i,i,n,1.70158);return s.a*Math.pow(2,-10*t)*Math.sin((t*r-s.s)*(2*Math.PI)/s.p)+s.c+e},easeInOutElastic:function(t,e,i,r){var n=0;if(0===t)return e;if(2==(t/=r/2))return e+i;n||(n=r*(.3*1.5));var s=o(i,i,n,1.70158);return t<1?-.5*a(s,t,r)+e:s.a*Math.pow(2,-10*(t-=1))*Math.sin((t*r-s.s)*(2*Math.PI)/s.p)*.5+s.c+e},easeInBack:function(t,e,i,r,n){return void 0===n&&(n=1.70158),i*(t/=r)*t*((n+1)*t-n)+e},easeOutBack:function(t,e,i,r,n){return void 0===n&&(n=1.70158),i*((t=t/r-1)*t*((n+1)*t+n)+1)+e},easeInOutBack:function(t,e,i,r,n){return void 0===n&&(n=1.70158),(t/=r/2)<1?i/2*(t*t*((1+(n*=1.525))*t-n))+e:i/2*((t-=2)*t*((1+(n*=1.525))*t+n)+2)+e},easeInBounce:n,easeOutBounce:s,easeInOutBounce:function(t,e,i,r){return t<r/2?.5*n(2*t,0,i,r)+e:.5*s(2*t-r,0,i,r)+.5*i+e}}}(),function(t){"use strict";var C=t.fabric||(t.fabric={}),p=C.util.object.extend,f=C.util.object.clone,v=C.util.toFixed,S=C.util.parseUnit,h=C.util.multiplyTransformMatrices,m={cx:"left",x:"left",r:"radius",cy:"top",y:"top",display:"visible",visibility:"visible",transform:"transformMatrix","fill-opacity":"fillOpacity","fill-rule":"fillRule","font-family":"fontFamily","font-size":"fontSize","font-style":"fontStyle","font-weight":"fontWeight","letter-spacing":"charSpacing","paint-order":"paintFirst","stroke-dasharray":"strokeDashArray","stroke-dashoffset":"strokeDashOffset","stroke-linecap":"strokeLineCap","stroke-linejoin":"strokeLineJoin","stroke-miterlimit":"strokeMiterLimit","stroke-opacity":"strokeOpacity","stroke-width":"strokeWidth","text-decoration":"textDecoration","text-anchor":"textAnchor",opacity:"opacity","clip-path":"clipPath","clip-rule":"clipRule","vector-effect":"strokeUniform","image-rendering":"imageSmoothing"},b={stroke:"strokeOpacity",fill:"fillOpacity"},_="font-size",y="clip-path";function x(t,e,i,r){var n,s="[object Array]"===Object.prototype.toString.call(e);if("fill"!==t&&"stroke"!==t||"none"!==e){if("strokeUniform"===t)return"non-scaling-stroke"===e;if("strokeDashArray"===t)e="none"===e?null:e.replace(/,/g," ").split(/\s+/).map(parseFloat);else if("transformMatrix"===t)e=i&&i.transformMatrix?h(i.transformMatrix,C.parseTransformAttribute(e)):C.parseTransformAttribute(e);else if("visible"===t)e="none"!==e&&"hidden"!==e,i&&!1===i.visible&&(e=!1);else if("opacity"===t)e=parseFloat(e),i&&void 0!==i.opacity&&(e*=i.opacity);else if("textAnchor"===t)e="start"===e?"left":"end"===e?"right":"center";else if("charSpacing"===t)n=S(e,r)/r*1e3;else if("paintFirst"===t){var o=e.indexOf("fill"),a=e.indexOf("stroke");e="fill";-1<o&&-1<a&&a<o?e="stroke":-1===o&&-1<a&&(e="stroke")}else{if("href"===t||"xlink:href"===t||"font"===t)return e;if("imageSmoothing"===t)return"optimizeQuality"===e;n=s?e.map(S):S(e,r)}}else e="";return!s&&isNaN(n)?e:n}function e(t){return new RegExp("^("+t.join("|")+")\\b","i")}function T(t,e){var i,r,n,s,o=[];for(n=0,s=e.length;n<s;n++)i=e[n],r=t.getElementsByTagName(i),o=o.concat(Array.prototype.slice.call(r));return o}function w(t,e){var i,r=!0;return(i=n(t,e.pop()))&&e.length&&(r=function(t,e){var i,r=!0;for(;t.parentNode&&1===t.parentNode.nodeType&&e.length;)r&&(i=e.pop()),t=t.parentNode,r=n(t,i);return 0===e.length}(t,e)),i&&r&&0===e.length}function n(t,e){var i,r,n=t.nodeName,s=t.getAttribute("class"),o=t.getAttribute("id");if(i=new RegExp("^"+n,"i"),e=e.replace(i,""),o&&e.length&&(i=new RegExp("#"+o+"(?![a-zA-Z\\-]+)","i"),e=e.replace(i,"")),s&&e.length)for(r=(s=s.split(" ")).length;r--;)i=new RegExp("\\."+s[r]+"(?![a-zA-Z\\-]+)","i"),e=e.replace(i,"");return 0===e.length}function O(t,e){var i;if(t.getElementById&&(i=t.getElementById(e)),i)return i;var r,n,s,o=t.getElementsByTagName("*");for(n=0,s=o.length;n<s;n++)if(e===(r=o[n]).getAttribute("id"))return r}C.svgValidTagNamesRegEx=e(["path","circle","polygon","polyline","ellipse","rect","line","image","text"]),C.svgViewBoxElementsRegEx=e(["symbol","image","marker","pattern","view","svg"]),C.svgInvalidAncestorsRegEx=e(["pattern","defs","symbol","metadata","clipPath","mask","desc"]),C.svgValidParentsRegEx=e(["symbol","g","a","svg","clipPath","defs"]),C.cssRules={},C.gradientDefs={},C.clipPaths={},C.parseTransformAttribute=function(){function b(t,e,i){t[i]=Math.tan(C.util.degreesToRadians(e[0]))}var _=C.iMatrix,t=C.reNum,e=C.commaWsp,y="(?:"+("(?:(matrix)\\s*\\(\\s*("+t+")"+e+"("+t+")"+e+"("+t+")"+e+"("+t+")"+e+"("+t+")"+e+"("+t+")\\s*\\))")+"|"+("(?:(translate)\\s*\\(\\s*("+t+")(?:"+e+"("+t+"))?\\s*\\))")+"|"+("(?:(scale)\\s*\\(\\s*("+t+")(?:"+e+"("+t+"))?\\s*\\))")+"|"+("(?:(rotate)\\s*\\(\\s*("+t+")(?:"+e+"("+t+")"+e+"("+t+"))?\\s*\\))")+"|"+("(?:(skewX)\\s*\\(\\s*("+t+")\\s*\\))")+"|"+("(?:(skewY)\\s*\\(\\s*("+t+")\\s*\\))")+")",i=new RegExp("^\\s*(?:"+("(?:"+y+"(?:"+e+"*"+y+")*)")+"?)\\s*$"),r=new RegExp(y,"g");return function(t){var v=_.concat(),m=[];if(!t||t&&!i.test(t))return v;t.replace(r,function(t){var e,i,r,n,s,o,a,h,c,l,u,f,d=new RegExp(y).exec(t).filter(function(t){return!!t}),g=d[1],p=d.slice(2).map(parseFloat);switch(g){case"translate":f=p,(u=v)[4]=f[0],2===f.length&&(u[5]=f[1]);break;case"rotate":p[0]=C.util.degreesToRadians(p[0]),s=v,o=p,a=C.util.cos(o[0]),h=C.util.sin(o[0]),l=c=0,3===o.length&&(c=o[1],l=o[2]),s[0]=a,s[1]=h,s[2]=-h,s[3]=a,s[4]=c-(a*c-h*l),s[5]=l-(h*c+a*l);break;case"scale":e=v,r=(i=p)[0],n=2===i.length?i[1]:i[0],e[0]=r,e[3]=n;break;case"skewX":b(v,p,2);break;case"skewY":b(v,p,1);break;case"matrix":v=p}m.push(v.concat()),v=_.concat()});for(var e=m[0];1<m.length;)m.shift(),e=C.util.multiplyTransformMatrices(e,m[0]);return e}}();var k=new RegExp("^\\s*("+C.reNum+"+)\\s*,?\\s*("+C.reNum+"+)\\s*,?\\s*("+C.reNum+"+)\\s*,?\\s*("+C.reNum+"+)\\s*$");function P(t){if(C.svgViewBoxElementsRegEx.test(t.nodeName)){var e,i,r,n,s,o,a=t.getAttribute("viewBox"),h=1,c=1,l=t.getAttribute("width"),u=t.getAttribute("height"),f=t.getAttribute("x")||0,d=t.getAttribute("y")||0,g=t.getAttribute("preserveAspectRatio")||"",p=!a||!(a=a.match(k)),v=!l||!u||"100%"===l||"100%"===u,m=p&&v,b={},_="",y=0,x=0;if(b.width=0,b.height=0,b.toBeParsed=m,p&&(f||d)&&"#document"!==t.parentNode.nodeName&&(_=" translate("+S(f)+" "+S(d)+") ",s=(t.getAttribute("transform")||"")+_,t.setAttribute("transform",s),t.removeAttribute("x"),t.removeAttribute("y")),m)return b;if(p)return b.width=S(l),b.height=S(u),b;if(e=-parseFloat(a[1]),i=-parseFloat(a[2]),r=parseFloat(a[3]),n=parseFloat(a[4]),b.minX=e,b.minY=i,b.viewBoxWidth=r,b.viewBoxHeight=n,v?(b.width=r,b.height=n):(b.width=S(l),b.height=S(u),h=b.width/r,c=b.height/n),"none"!==(g=C.util.parsePreserveAspectRatioAttribute(g)).alignX&&("meet"===g.meetOrSlice&&(c=h=c<h?c:h),"slice"===g.meetOrSlice&&(c=h=c<h?h:c),y=b.width-r*h,x=b.height-n*h,"Mid"===g.alignX&&(y/=2),"Mid"===g.alignY&&(x/=2),"Min"===g.alignX&&(y=0),"Min"===g.alignY&&(x=0)),1===h&&1===c&&0===e&&0===i&&0===f&&0===d)return b;if((f||d)&&"#document"!==t.parentNode.nodeName&&(_=" translate("+S(f)+" "+S(d)+") "),s=_+" matrix("+h+" 0 0 "+c+" "+(e*h+y)+" "+(i*c+x)+") ","svg"===t.nodeName){for(o=t.ownerDocument.createElementNS(C.svgNS,"g");t.firstChild;)o.appendChild(t.firstChild);t.appendChild(o)}else(o=t).removeAttribute("x"),o.removeAttribute("y"),s=o.getAttribute("transform")+s;return o.setAttribute("transform",s),b}}function s(t,e){var i="xlink:href",r=O(t,e.getAttribute(i).substr(1));if(r&&r.getAttribute(i)&&s(t,r),["gradientTransform","x1","x2","y1","y2","gradientUnits","cx","cy","r","fx","fy"].forEach(function(t){r&&!e.hasAttribute(t)&&r.hasAttribute(t)&&e.setAttribute(t,r.getAttribute(t))}),!e.children.length)for(var n=r.cloneNode(!0);n.firstChild;)e.appendChild(n.firstChild);e.removeAttribute(i)}C.parseSVGDocument=function(t,i,e,r){if(t){!function(t){for(var e=T(t,["use","svg:use"]),i=0;e.length&&i<e.length;){var r,n,s,o,a=e[i],h=(a.getAttribute("xlink:href")||a.getAttribute("href")).substr(1),c=a.getAttribute("x")||0,l=a.getAttribute("y")||0,u=O(t,h).cloneNode(!0),f=(u.getAttribute("transform")||"")+" translate("+c+", "+l+")",d=e.length,g=C.svgNS;if(P(u),/^svg$/i.test(u.nodeName)){var p=u.ownerDocument.createElementNS(g,"g");for(n=0,o=(s=u.attributes).length;n<o;n++)r=s.item(n),p.setAttributeNS(g,r.nodeName,r.nodeValue);for(;u.firstChild;)p.appendChild(u.firstChild);u=p}for(n=0,o=(s=a.attributes).length;n<o;n++)"x"!==(r=s.item(n)).nodeName&&"y"!==r.nodeName&&"xlink:href"!==r.nodeName&&"href"!==r.nodeName&&("transform"===r.nodeName?f=r.nodeValue+" "+f:u.setAttribute(r.nodeName,r.nodeValue));u.setAttribute("transform",f),u.setAttribute("instantiated_by_use","1"),u.removeAttribute("id"),a.parentNode.replaceChild(u,a),e.length===d&&i++}}(t);var n,s,o=C.Object.__uid++,a=P(t),h=C.util.toArray(t.getElementsByTagName("*"));if(a.crossOrigin=r&&r.crossOrigin,a.svgUid=o,0===h.length&&C.isLikelyNode){var c=[];for(n=0,s=(h=t.selectNodes('//*[name(.)!="svg"]')).length;n<s;n++)c[n]=h[n];h=c}var l=h.filter(function(t){return P(t),C.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:",""))&&!function(t,e){for(;t&&(t=t.parentNode);)if(t.nodeName&&e.test(t.nodeName.replace("svg:",""))&&!t.getAttribute("instantiated_by_use"))return!0;return!1}(t,C.svgInvalidAncestorsRegEx)});if(!l||l&&!l.length)i&&i([],{});else{var u={};h.filter(function(t){return"clipPath"===t.nodeName.replace("svg:","")}).forEach(function(t){var e=t.getAttribute("id");u[e]=C.util.toArray(t.getElementsByTagName("*")).filter(function(t){return C.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:",""))})}),C.gradientDefs[o]=C.getGradientDefs(t),C.cssRules[o]=C.getCSSRules(t),C.clipPaths[o]=u,C.parseElements(l,function(t,e){i&&(i(t,a,e,h),delete C.gradientDefs[o],delete C.cssRules[o],delete C.clipPaths[o])},f(a),e,r)}}};var c=new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*("+C.reNum+"(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|"+C.reNum+"))?\\s+(.*)");p(C,{parseFontDeclaration:function(t,e){var i=t.match(c);if(i){var r=i[1],n=i[3],s=i[4],o=i[5],a=i[6];r&&(e.fontStyle=r),n&&(e.fontWeight=isNaN(parseFloat(n))?n:parseFloat(n)),s&&(e.fontSize=S(s)),a&&(e.fontFamily=a),o&&(e.lineHeight="normal"===o?1:o)}},getGradientDefs:function(t){var e,i=T(t,["linearGradient","radialGradient","svg:linearGradient","svg:radialGradient"]),r=0,n={};for(r=i.length;r--;)(e=i[r]).getAttribute("xlink:href")&&s(t,e),n[e.getAttribute("id")]=e;return n},parseAttributes:function(i,t,e){if(i){var r,n,s,o={};void 0===e&&(e=i.getAttribute("svgUid")),i.parentNode&&C.svgValidParentsRegEx.test(i.parentNode.nodeName)&&(o=C.parseAttributes(i.parentNode,t,e));var a=t.reduce(function(t,e){return(r=i.getAttribute(e))&&(t[e]=r),t},{}),h=p(function(t,e){var i={};for(var r in C.cssRules[e])if(w(t,r.split(" ")))for(var n in C.cssRules[e][r])i[n]=C.cssRules[e][r][n];return i}(i,e),C.parseStyleAttribute(i));a=p(a,h),h[y]&&i.setAttribute(y,h[y]),n=s=o.fontSize||C.Text.DEFAULT_SVG_FONT_SIZE,a[_]&&(a[_]=n=S(a[_],s));var c,l,u,f={};for(var d in a)l=x(c=(u=d)in m?m[u]:u,a[d],o,n),f[c]=l;f&&f.font&&C.parseFontDeclaration(f.font,f);var g=p(o,f);return C.svgValidParentsRegEx.test(i.nodeName)?g:function(t){for(var e in b)if(void 0!==t[b[e]]&&""!==t[e]){if(void 0===t[e]){if(!C.Object.prototype[e])continue;t[e]=C.Object.prototype[e]}if(0!==t[e].indexOf("url(")){var i=new C.Color(t[e]);t[e]=i.setAlpha(v(i.getAlpha()*t[b[e]],2)).toRgba()}}return t}(g)}},parseElements:function(t,e,i,r,n){new C.ElementsParser(t,e,i,r,n).parse()},parseStyleAttribute:function(t){var i,r,n,e={},s=t.getAttribute("style");return s&&("string"==typeof s?(i=e,s.replace(/;\s*$/,"").split(";").forEach(function(t){var e=t.split(":");r=e[0].trim().toLowerCase(),n=e[1].trim(),i[r]=n})):function(t,e){var i,r;for(var n in t)void 0!==t[n]&&(i=n.toLowerCase(),r=t[n],e[i]=r)}(s,e)),e},parsePointsAttribute:function(t){if(!t)return null;var e,i,r=[];for(e=0,i=(t=(t=t.replace(/,/g," ").trim()).split(/\s+/)).length;e<i;e+=2)r.push({x:parseFloat(t[e]),y:parseFloat(t[e+1])});return r},getCSSRules:function(t){var a,h,e=t.getElementsByTagName("style"),c={};for(a=0,h=e.length;a<h;a++){var i=e[a].textContent;""!==(i=i.replace(/\/\*[\s\S]*?\*\//g,"")).trim()&&i.match(/[^{]*\{[\s\S]*?\}/g).map(function(t){return t.trim()}).forEach(function(t){var e=t.match(/([\s\S]*?)\s*\{([^}]*)\}/),i={},r=e[2].trim().replace(/;$/,"").split(/\s*;\s*/);for(a=0,h=r.length;a<h;a++){var n=r[a].split(/\s*:\s*/),s=n[0],o=n[1];i[s]=o}(t=e[1]).split(",").forEach(function(t){""!==(t=t.replace(/^svg/i,"").trim())&&(c[t]?C.util.object.extend(c[t],i):c[t]=C.util.object.clone(i))})})}return c},loadSVGFromURL:function(t,n,i,r){t=t.replace(/^\n\s*/,"").trim(),new C.util.request(t,{method:"get",onComplete:function(t){var e=t.responseXML;if(!e||!e.documentElement)return n&&n(null),!1;C.parseSVGDocument(e.documentElement,function(t,e,i,r){n&&n(t,e,i,r)},i,r)}})},loadSVGFromString:function(t,n,e,i){var r=(new C.window.DOMParser).parseFromString(t.trim(),"text/xml");C.parseSVGDocument(r.documentElement,function(t,e,i,r){n(t,e,i,r)},e,i)}})}("undefined"!=typeof exports?exports:this),fabric.ElementsParser=function(t,e,i,r,n,s){this.elements=t,this.callback=e,this.options=i,this.reviver=r,this.svgUid=i&&i.svgUid||0,this.parsingOptions=n,this.regexUrl=/^url\(['"]?#([^'"]+)['"]?\)/g,this.doc=s},function(t){t.parse=function(){this.instances=new Array(this.elements.length),this.numElements=this.elements.length,this.createObjects()},t.createObjects=function(){var i=this;this.elements.forEach(function(t,e){t.setAttribute("svgUid",i.svgUid),i.createObject(t,e)})},t.findTag=function(t){return fabric[fabric.util.string.capitalize(t.tagName.replace("svg:",""))]},t.createObject=function(t,e){var i=this.findTag(t);if(i&&i.fromElement)try{i.fromElement(t,this.createCallback(e,t),this.options)}catch(t){fabric.log(t)}else this.checkIfDone()},t.createCallback=function(i,r){var n=this;return function(t){var e;n.resolveGradient(t,r,"fill"),n.resolveGradient(t,r,"stroke"),t instanceof fabric.Image&&t._originalElement&&(e=t.parsePreserveAspectRatioAttribute(r)),t._removeTransformMatrix(e),n.resolveClipPath(t,r),n.reviver&&n.reviver(r,t),n.instances[i]=t,n.checkIfDone()}},t.extractPropertyDefinition=function(t,e,i){var r=t[e],n=this.regexUrl;if(n.test(r)){n.lastIndex=0;var s=n.exec(r)[1];return n.lastIndex=0,fabric[i][this.svgUid][s]}},t.resolveGradient=function(t,e,i){var r=this.extractPropertyDefinition(t,i,"gradientDefs");if(r){var n=e.getAttribute(i+"-opacity"),s=fabric.Gradient.fromElement(r,t,n,this.options);t.set(i,s)}},t.createClipPathCallback=function(t,e){return function(t){t._removeTransformMatrix(),t.fillRule=t.clipRule,e.push(t)}},t.resolveClipPath=function(t,e){var i,r,n,s,o=this.extractPropertyDefinition(t,"clipPath","clipPaths");if(o){n=[],r=fabric.util.invertTransform(t.calcTransformMatrix());for(var a=o[0].parentNode,h=e;h.parentNode&&h.getAttribute("clip-path")!==t.clipPath;)h=h.parentNode;h.parentNode.appendChild(a);for(var c=0;c<o.length;c++)i=o[c],this.findTag(i).fromElement(i,this.createClipPathCallback(t,n),this.options);o=1===n.length?n[0]:new fabric.Group(n),s=fabric.util.multiplyTransformMatrices(r,o.calcTransformMatrix()),o.clipPath&&this.resolveClipPath(o,h);var l=fabric.util.qrDecompose(s);o.flipX=!1,o.flipY=!1,o.set("scaleX",l.scaleX),o.set("scaleY",l.scaleY),o.angle=l.angle,o.skewX=l.skewX,o.skewY=0,o.setPositionByOrigin({x:l.translateX,y:l.translateY},"center","center"),t.clipPath=o}else delete t.clipPath},t.checkIfDone=function(){0==--this.numElements&&(this.instances=this.instances.filter(function(t){return null!=t}),this.callback(this.instances,this.elements))}}(fabric.ElementsParser.prototype),function(t){"use strict";var e=t.fabric||(t.fabric={});function i(t,e){this.x=t,this.y=e}e.Point?e.warn("fabric.Point is already defined"):(e.Point=i).prototype={type:"point",constructor:i,add:function(t){return new i(this.x+t.x,this.y+t.y)},addEquals:function(t){return this.x+=t.x,this.y+=t.y,this},scalarAdd:function(t){return new i(this.x+t,this.y+t)},scalarAddEquals:function(t){return this.x+=t,this.y+=t,this},subtract:function(t){return new i(this.x-t.x,this.y-t.y)},subtractEquals:function(t){return this.x-=t.x,this.y-=t.y,this},scalarSubtract:function(t){return new i(this.x-t,this.y-t)},scalarSubtractEquals:function(t){return this.x-=t,this.y-=t,this},multiply:function(t){return new i(this.x*t,this.y*t)},multiplyEquals:function(t){return this.x*=t,this.y*=t,this},divide:function(t){return new i(this.x/t,this.y/t)},divideEquals:function(t){return this.x/=t,this.y/=t,this},eq:function(t){return this.x===t.x&&this.y===t.y},lt:function(t){return this.x<t.x&&this.y<t.y},lte:function(t){return this.x<=t.x&&this.y<=t.y},gt:function(t){return this.x>t.x&&this.y>t.y},gte:function(t){return this.x>=t.x&&this.y>=t.y},lerp:function(t,e){return void 0===e&&(e=.5),e=Math.max(Math.min(1,e),0),new i(this.x+(t.x-this.x)*e,this.y+(t.y-this.y)*e)},distanceFrom:function(t){var e=this.x-t.x,i=this.y-t.y;return Math.sqrt(e*e+i*i)},midPointFrom:function(t){return this.lerp(t)},min:function(t){return new i(Math.min(this.x,t.x),Math.min(this.y,t.y))},max:function(t){return new i(Math.max(this.x,t.x),Math.max(this.y,t.y))},toString:function(){return this.x+","+this.y},setXY:function(t,e){return this.x=t,this.y=e,this},setX:function(t){return this.x=t,this},setY:function(t){return this.y=t,this},setFromPoint:function(t){return this.x=t.x,this.y=t.y,this},swap:function(t){var e=this.x,i=this.y;this.x=t.x,this.y=t.y,t.x=e,t.y=i},clone:function(){return new i(this.x,this.y)}}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var f=t.fabric||(t.fabric={});function d(t){this.status=t,this.points=[]}f.Intersection?f.warn("fabric.Intersection is already defined"):(f.Intersection=d,f.Intersection.prototype={constructor:d,appendPoint:function(t){return this.points.push(t),this},appendPoints:function(t){return this.points=this.points.concat(t),this}},f.Intersection.intersectLineLine=function(t,e,i,r){var n,s=(r.x-i.x)*(t.y-i.y)-(r.y-i.y)*(t.x-i.x),o=(e.x-t.x)*(t.y-i.y)-(e.y-t.y)*(t.x-i.x),a=(r.y-i.y)*(e.x-t.x)-(r.x-i.x)*(e.y-t.y);if(0!==a){var h=s/a,c=o/a;0<=h&&h<=1&&0<=c&&c<=1?(n=new d("Intersection")).appendPoint(new f.Point(t.x+h*(e.x-t.x),t.y+h*(e.y-t.y))):n=new d}else n=new d(0===s||0===o?"Coincident":"Parallel");return n},f.Intersection.intersectLinePolygon=function(t,e,i){var r,n,s,o,a=new d,h=i.length;for(o=0;o<h;o++)r=i[o],n=i[(o+1)%h],s=d.intersectLineLine(t,e,r,n),a.appendPoints(s.points);return 0<a.points.length&&(a.status="Intersection"),a},f.Intersection.intersectPolygonPolygon=function(t,e){var i,r=new d,n=t.length;for(i=0;i<n;i++){var s=t[i],o=t[(i+1)%n],a=d.intersectLinePolygon(s,o,e);r.appendPoints(a.points)}return 0<r.points.length&&(r.status="Intersection"),r},f.Intersection.intersectPolygonRectangle=function(t,e,i){var r=e.min(i),n=e.max(i),s=new f.Point(n.x,r.y),o=new f.Point(r.x,n.y),a=d.intersectLinePolygon(r,s,t),h=d.intersectLinePolygon(s,n,t),c=d.intersectLinePolygon(n,o,t),l=d.intersectLinePolygon(o,r,t),u=new d;return u.appendPoints(a.points),u.appendPoints(h.points),u.appendPoints(c.points),u.appendPoints(l.points),0<u.points.length&&(u.status="Intersection"),u})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var c=t.fabric||(t.fabric={});function l(t){t?this._tryParsingColor(t):this.setSource([0,0,0,1])}function u(t,e,i){return i<0&&(i+=1),1<i&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t}c.Color?c.warn("fabric.Color is already defined."):(c.Color=l,c.Color.prototype={_tryParsingColor:function(t){var e;t in l.colorNameMap&&(t=l.colorNameMap[t]),"transparent"===t&&(e=[255,255,255,0]),e||(e=l.sourceFromHex(t)),e||(e=l.sourceFromRgb(t)),e||(e=l.sourceFromHsl(t)),e||(e=[0,0,0,1]),e&&this.setSource(e)},_rgbToHsl:function(t,e,i){t/=255,e/=255,i/=255;var r,n,s,o=c.util.array.max([t,e,i]),a=c.util.array.min([t,e,i]);if(s=(o+a)/2,o===a)r=n=0;else{var h=o-a;switch(n=.5<s?h/(2-o-a):h/(o+a),o){case t:r=(e-i)/h+(e<i?6:0);break;case e:r=(i-t)/h+2;break;case i:r=(t-e)/h+4}r/=6}return[Math.round(360*r),Math.round(100*n),Math.round(100*s)]},getSource:function(){return this._source},setSource:function(t){this._source=t},toRgb:function(){var t=this.getSource();return"rgb("+t[0]+","+t[1]+","+t[2]+")"},toRgba:function(){var t=this.getSource();return"rgba("+t[0]+","+t[1]+","+t[2]+","+t[3]+")"},toHsl:function(){var t=this.getSource(),e=this._rgbToHsl(t[0],t[1],t[2]);return"hsl("+e[0]+","+e[1]+"%,"+e[2]+"%)"},toHsla:function(){var t=this.getSource(),e=this._rgbToHsl(t[0],t[1],t[2]);return"hsla("+e[0]+","+e[1]+"%,"+e[2]+"%,"+t[3]+")"},toHex:function(){var t,e,i,r=this.getSource();return t=1===(t=r[0].toString(16)).length?"0"+t:t,e=1===(e=r[1].toString(16)).length?"0"+e:e,i=1===(i=r[2].toString(16)).length?"0"+i:i,t.toUpperCase()+e.toUpperCase()+i.toUpperCase()},toHexa:function(){var t,e=this.getSource();return t=1===(t=(t=Math.round(255*e[3])).toString(16)).length?"0"+t:t,this.toHex()+t.toUpperCase()},getAlpha:function(){return this.getSource()[3]},setAlpha:function(t){var e=this.getSource();return e[3]=t,this.setSource(e),this},toGrayscale:function(){var t=this.getSource(),e=parseInt((.3*t[0]+.59*t[1]+.11*t[2]).toFixed(0),10),i=t[3];return this.setSource([e,e,e,i]),this},toBlackWhite:function(t){var e=this.getSource(),i=(.3*e[0]+.59*e[1]+.11*e[2]).toFixed(0),r=e[3];return t=t||127,i=Number(i)<Number(t)?0:255,this.setSource([i,i,i,r]),this},overlayWith:function(t){t instanceof l||(t=new l(t));var e,i=[],r=this.getAlpha(),n=this.getSource(),s=t.getSource();for(e=0;e<3;e++)i.push(Math.round(.5*n[e]+.5*s[e]));return i[3]=r,this.setSource(i),this}},c.Color.reRGBa=/^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i,c.Color.reHSLa=/^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i,c.Color.reHex=/^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i,c.Color.colorNameMap={aliceblue:"#F0F8FF",antiquewhite:"#FAEBD7",aqua:"#00FFFF",aquamarine:"#7FFFD4",azure:"#F0FFFF",beige:"#F5F5DC",bisque:"#FFE4C4",black:"#000000",blanchedalmond:"#FFEBCD",blue:"#0000FF",blueviolet:"#8A2BE2",brown:"#A52A2A",burlywood:"#DEB887",cadetblue:"#5F9EA0",chartreuse:"#7FFF00",chocolate:"#D2691E",coral:"#FF7F50",cornflowerblue:"#6495ED",cornsilk:"#FFF8DC",crimson:"#DC143C",cyan:"#00FFFF",darkblue:"#00008B",darkcyan:"#008B8B",darkgoldenrod:"#B8860B",darkgray:"#A9A9A9",darkgrey:"#A9A9A9",darkgreen:"#006400",darkkhaki:"#BDB76B",darkmagenta:"#8B008B",darkolivegreen:"#556B2F",darkorange:"#FF8C00",darkorchid:"#9932CC",darkred:"#8B0000",darksalmon:"#E9967A",darkseagreen:"#8FBC8F",darkslateblue:"#483D8B",darkslategray:"#2F4F4F",darkslategrey:"#2F4F4F",darkturquoise:"#00CED1",darkviolet:"#9400D3",deeppink:"#FF1493",deepskyblue:"#00BFFF",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1E90FF",firebrick:"#B22222",floralwhite:"#FFFAF0",forestgreen:"#228B22",fuchsia:"#FF00FF",gainsboro:"#DCDCDC",ghostwhite:"#F8F8FF",gold:"#FFD700",goldenrod:"#DAA520",gray:"#808080",grey:"#808080",green:"#008000",greenyellow:"#ADFF2F",honeydew:"#F0FFF0",hotpink:"#FF69B4",indianred:"#CD5C5C",indigo:"#4B0082",ivory:"#FFFFF0",khaki:"#F0E68C",lavender:"#E6E6FA",lavenderblush:"#FFF0F5",lawngreen:"#7CFC00",lemonchiffon:"#FFFACD",lightblue:"#ADD8E6",lightcoral:"#F08080",lightcyan:"#E0FFFF",lightgoldenrodyellow:"#FAFAD2",lightgray:"#D3D3D3",lightgrey:"#D3D3D3",lightgreen:"#90EE90",lightpink:"#FFB6C1",lightsalmon:"#FFA07A",lightseagreen:"#20B2AA",lightskyblue:"#87CEFA",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#B0C4DE",lightyellow:"#FFFFE0",lime:"#00FF00",limegreen:"#32CD32",linen:"#FAF0E6",magenta:"#FF00FF",maroon:"#800000",mediumaquamarine:"#66CDAA",mediumblue:"#0000CD",mediumorchid:"#BA55D3",mediumpurple:"#9370DB",mediumseagreen:"#3CB371",mediumslateblue:"#7B68EE",mediumspringgreen:"#00FA9A",mediumturquoise:"#48D1CC",mediumvioletred:"#C71585",midnightblue:"#191970",mintcream:"#F5FFFA",mistyrose:"#FFE4E1",moccasin:"#FFE4B5",navajowhite:"#FFDEAD",navy:"#000080",oldlace:"#FDF5E6",olive:"#808000",olivedrab:"#6B8E23",orange:"#FFA500",orangered:"#FF4500",orchid:"#DA70D6",palegoldenrod:"#EEE8AA",palegreen:"#98FB98",paleturquoise:"#AFEEEE",palevioletred:"#DB7093",papayawhip:"#FFEFD5",peachpuff:"#FFDAB9",peru:"#CD853F",pink:"#FFC0CB",plum:"#DDA0DD",powderblue:"#B0E0E6",purple:"#800080",rebeccapurple:"#663399",red:"#FF0000",rosybrown:"#BC8F8F",royalblue:"#4169E1",saddlebrown:"#8B4513",salmon:"#FA8072",sandybrown:"#F4A460",seagreen:"#2E8B57",seashell:"#FFF5EE",sienna:"#A0522D",silver:"#C0C0C0",skyblue:"#87CEEB",slateblue:"#6A5ACD",slategray:"#708090",slategrey:"#708090",snow:"#FFFAFA",springgreen:"#00FF7F",steelblue:"#4682B4",tan:"#D2B48C",teal:"#008080",thistle:"#D8BFD8",tomato:"#FF6347",turquoise:"#40E0D0",violet:"#EE82EE",wheat:"#F5DEB3",white:"#FFFFFF",whitesmoke:"#F5F5F5",yellow:"#FFFF00",yellowgreen:"#9ACD32"},c.Color.fromRgb=function(t){return l.fromSource(l.sourceFromRgb(t))},c.Color.sourceFromRgb=function(t){var e=t.match(l.reRGBa);if(e){var i=parseInt(e[1],10)/(/%$/.test(e[1])?100:1)*(/%$/.test(e[1])?255:1),r=parseInt(e[2],10)/(/%$/.test(e[2])?100:1)*(/%$/.test(e[2])?255:1),n=parseInt(e[3],10)/(/%$/.test(e[3])?100:1)*(/%$/.test(e[3])?255:1);return[parseInt(i,10),parseInt(r,10),parseInt(n,10),e[4]?parseFloat(e[4]):1]}},c.Color.fromRgba=l.fromRgb,c.Color.fromHsl=function(t){return l.fromSource(l.sourceFromHsl(t))},c.Color.sourceFromHsl=function(t){var e=t.match(l.reHSLa);if(e){var i,r,n,s=(parseFloat(e[1])%360+360)%360/360,o=parseFloat(e[2])/(/%$/.test(e[2])?100:1),a=parseFloat(e[3])/(/%$/.test(e[3])?100:1);if(0===o)i=r=n=a;else{var h=a<=.5?a*(o+1):a+o-a*o,c=2*a-h;i=u(c,h,s+1/3),r=u(c,h,s),n=u(c,h,s-1/3)}return[Math.round(255*i),Math.round(255*r),Math.round(255*n),e[4]?parseFloat(e[4]):1]}},c.Color.fromHsla=l.fromHsl,c.Color.fromHex=function(t){return l.fromSource(l.sourceFromHex(t))},c.Color.sourceFromHex=function(t){if(t.match(l.reHex)){var e=t.slice(t.indexOf("#")+1),i=3===e.length||4===e.length,r=8===e.length||4===e.length,n=i?e.charAt(0)+e.charAt(0):e.substring(0,2),s=i?e.charAt(1)+e.charAt(1):e.substring(2,4),o=i?e.charAt(2)+e.charAt(2):e.substring(4,6),a=r?i?e.charAt(3)+e.charAt(3):e.substring(6,8):"FF";return[parseInt(n,16),parseInt(s,16),parseInt(o,16),parseFloat((parseInt(a,16)/255).toFixed(2))]}},c.Color.fromSource=function(t){var e=new l;return e.setSource(t),e})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var l=t.fabric||(t.fabric={}),o=["e","se","s","sw","w","nw","n","ne","e"],s=["ns","nesw","ew","nwse"],n={},f="left",d="top",g="right",p="bottom",h="center",T={top:p,bottom:d,left:g,right:f,center:h},v=l.util.radiansToDegrees,w=Math.sign||function(t){return(0<t)-(t<0)||+t};function a(t,e){var i=t.angle+v(Math.atan2(e.y,e.x))+360;return Math.round(i%360/45)}function O(t,e){var i=e.transform.target,r=i.canvas,n=l.util.object.clone(e);n.target=i,r&&r.fire("object:"+t,n),i.fire(t,e)}function k(t,e){var i=e.canvas,r=t[i.uniScaleKey];return i.uniformScaling&&!r||!i.uniformScaling&&r}function P(t){return t.originX===h&&t.originY===h}function D(t,e,i){var r=t.lockScalingX,n=t.lockScalingY;return!(!r||!n)||(!(e||!r&&!n||!i)||(!(!r||"x"!==e)||!(!n||"y"!==e)))}function E(t,e,i,r){return{e:t,transform:e,pointer:{x:i,y:r}}}function c(h){return function(t,e,i,r){var n=e.target,s=n.getCenterPoint(),o=n.translateToOriginPoint(s,e.originX,e.originY),a=h(t,e,i,r);return n.setPositionByOrigin(o,e.originX,e.originY),a}}function A(t,e,i,r,n){var s=t.target,o=s.controls[t.corner],a=s.canvas.getZoom(),h=s.padding/a,c=s.toLocalPoint(new l.Point(r,n),e,i);return c.x>=h&&(c.x-=h),c.x<=-h&&(c.x+=h),c.y>=h&&(c.y-=h),c.y<=h&&(c.y+=h),c.x-=o.offsetX,c.y-=o.offsetY,c}function m(t){return t.flipX&&!t.flipY||!t.flipX&&t.flipY}function b(t,e,i,r,n){if(0!==t[e]){var s=n/t._getTransformedDimensions()[r]*t[i];t.set(i,s)}}function u(t,e,i,r){var n,s=e.target,o=s._getTransformedDimensions(0,s.skewY),a=A(e,e.originX,e.originY,i,r),h=Math.abs(2*a.x)-o.x,c=s.skewX;h<2?n=0:(n=v(Math.atan2(h/s.scaleX,o.y/s.scaleY)),e.originX===f&&e.originY===p&&(n=-n),e.originX===g&&e.originY===d&&(n=-n),m(s)&&(n=-n));var l=c!==n;if(l){var u=s._getTransformedDimensions().y;s.set("skewX",n),b(s,"skewY","scaleY","y",u),O("skewing",E(t,e,i,r))}return l}function _(t,e,i,r){var n,s=e.target,o=s._getTransformedDimensions(s.skewX,0),a=A(e,e.originX,e.originY,i,r),h=Math.abs(2*a.y)-o.y,c=s.skewY;h<2?n=0:(n=v(Math.atan2(h/s.scaleY,o.x/s.scaleX)),e.originX===f&&e.originY===p&&(n=-n),e.originX===g&&e.originY===d&&(n=-n),m(s)&&(n=-n));var l=c!==n;if(l){var u=s._getTransformedDimensions().x;s.set("skewY",n),b(s,"skewX","scaleX","x",u),O("skewing",E(t,e,i,r))}return l}function y(t,e,i,r,n){n=n||{};var s,o,a,h,c,l,u=e.target,f=u.lockScalingX,d=u.lockScalingY,g=n.by,p=k(t,u),v=D(u,g,p),m=e.gestureScale;if(v)return!1;if(m)o=e.scaleX*m,a=e.scaleY*m;else{if(s=A(e,e.originX,e.originY,i,r),c="y"!==g?w(s.x):1,l="x"!==g?w(s.y):1,e.signX||(e.signX=c),e.signY||(e.signY=l),u.lockScalingFlip&&(e.signX!==c||e.signY!==l))return!1;if(h=u._getTransformedDimensions(),p&&!g){var b,_=Math.abs(s.x)+Math.abs(s.y),y=e.original,x=_/(Math.abs(h.x*y.scaleX/u.scaleX)+Math.abs(h.y*y.scaleY/u.scaleY));o=y.scaleX*x,a=y.scaleY*x}else o=Math.abs(s.x*u.scaleX/h.x),a=Math.abs(s.y*u.scaleY/h.y);P(e)&&(o*=2,a*=2),e.signX!==c&&"y"!==g&&(e.originX=T[e.originX],o*=-1,e.signX=c),e.signY!==l&&"x"!==g&&(e.originY=T[e.originY],a*=-1,e.signY=l)}var C=u.scaleX,S=u.scaleY;return g?("x"===g&&u.set("scaleX",o),"y"===g&&u.set("scaleY",a)):(!f&&u.set("scaleX",o),!d&&u.set("scaleY",a)),(b=C!==u.scaleX||S!==u.scaleY)&&O("scaling",E(t,e,i,r)),b}n.scaleCursorStyleHandler=function(t,e,i){var r=k(t,i),n="";if(0!==e.x&&0===e.y?n="x":0===e.x&&0!==e.y&&(n="y"),D(i,n,r))return"not-allowed";var s=a(i,e);return o[s]+"-resize"},n.skewCursorStyleHandler=function(t,e,i){var r="not-allowed";if(0!==e.x&&i.lockSkewingY)return r;if(0!==e.y&&i.lockSkewingX)return r;var n=a(i,e)%4;return s[n]+"-resize"},n.scaleSkewCursorStyleHandler=function(t,e,i){return t[i.canvas.altActionKey]?n.skewCursorStyleHandler(t,e,i):n.scaleCursorStyleHandler(t,e,i)},n.rotationWithSnapping=c(function(t,e,i,r){var n=e,s=n.target,o=s.translateToOriginPoint(s.getCenterPoint(),n.originX,n.originY);if(s.lockRotation)return!1;var a,h=Math.atan2(n.ey-o.y,n.ex-o.x),c=Math.atan2(r-o.y,i-o.x),l=v(c-h+n.theta);if(0<s.snapAngle){var u=s.snapAngle,f=s.snapThreshold||u,d=Math.ceil(l/u)*u,g=Math.floor(l/u)*u;Math.abs(l-g)<f?l=g:Math.abs(l-d)<f&&(l=d)}return l<0&&(l=360+l),l%=360,a=s.angle!==l,s.angle=l,a&&O("rotating",E(t,e,i,r)),a}),n.scalingEqually=c(function(t,e,i,r){return y(t,e,i,r)}),n.scalingX=c(function(t,e,i,r){return y(t,e,i,r,{by:"x"})}),n.scalingY=c(function(t,e,i,r){return y(t,e,i,r,{by:"y"})}),n.scalingYOrSkewingX=function(t,e,i,r){return t[e.target.canvas.altActionKey]?n.skewHandlerX(t,e,i,r):n.scalingY(t,e,i,r)},n.scalingXOrSkewingY=function(t,e,i,r){return t[e.target.canvas.altActionKey]?n.skewHandlerY(t,e,i,r):n.scalingX(t,e,i,r)},n.changeWidth=c(function(t,e,i,r){var n,s=e.target,o=A(e,e.originX,e.originY,i,r),a=s.strokeWidth/(s.strokeUniform?s.scaleX:1),h=P(e)?2:1,c=s.width,l=Math.abs(o.x*h/s.scaleX)-a;return s.set("width",Math.max(l,0)),(n=c!==l)&&O("resizing",E(t,e,i,r)),n}),n.skewHandlerX=function(t,e,i,r){var n,s=e.target,o=s.skewX,a=e.originY;return!s.lockSkewingX&&(0===o?n=0<A(e,h,h,i,r).x?f:g:(0<o&&(n=a===d?f:g),o<0&&(n=a===d?g:f),m(s)&&(n=n===f?g:f)),e.originX=n,c(u)(t,e,i,r))},n.skewHandlerY=function(t,e,i,r){var n,s=e.target,o=s.skewY,a=e.originX;return!s.lockSkewingY&&(0===o?n=0<A(e,h,h,i,r).y?d:p:(0<o&&(n=a===f?d:p),o<0&&(n=a===f?p:d),m(s)&&(n=n===d?p:d)),e.originY=n,c(_)(t,e,i,r))},n.dragHandler=function(t,e,i,r){var n=e.target,s=i-e.offsetX,o=r-e.offsetY,a=!n.get("lockMovementX")&&n.left!==s,h=!n.get("lockMovementY")&&n.top!==o;return a&&n.set("left",s),h&&n.set("top",o),(a||h)&&O("moving",E(t,e,i,r)),a||h},n.scaleOrSkewActionName=function(t,e,i){var r=t[i.canvas.altActionKey];return 0===e.x?r?"skewX":"scaleY":0===e.y?r?"skewY":"scaleX":void 0},n.rotationStyleHandler=function(t,e,i){return i.lockRotation?"not-allowed":e.cursorStyle},n.fireEvent=O,n.wrapWithFixedAnchor=c,n.getLocalPoint=A,l.controlsUtils=n}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),f=e.util.degreesToRadians,i=e.controlsUtils;i.renderCircleControl=function(t,e,i,r,n){r=r||{};var s,o=this.sizeX||r.cornerSize||n.cornerSize,a=this.sizeY||r.cornerSize||n.cornerSize,h=void 0!==r.transparentCorners?r.transparentCorners:this.transparentCorners,c=h?"stroke":"fill",l=!h&&(r.cornerStrokeColor||n.cornerStrokeColor),u=e,f=i;t.save(),t.fillStyle=r.cornerColor||n.cornerColor,t.strokeStyle=r.cornerStrokeColor||n.cornerStrokeColor,a<o?(s=o,t.scale(1,a/o),f=i*o/a):o<a?(s=a,t.scale(o/a,1),u=e*a/o):s=o,t.lineWidth=1,t.beginPath(),t.arc(u,f,s/2,0,2*Math.PI,!1),t[c](),l&&t.stroke(),t.restore()},i.renderSquareControl=function(t,e,i,r,n){r=r||{};var s=this.sizeX||r.cornerSize||n.cornerSize,o=this.sizeY||r.cornerSize||n.cornerSize,a=void 0!==r.transparentCorners?r.transparentCorners:n.transparentCorners,h=a?"stroke":"fill",c=!a&&(r.cornerStrokeColor||n.cornerStrokeColor),l=s/2,u=o/2;t.save(),t.fillStyle=r.cornerColor||n.cornerColor,t.strokeStyle=r.strokeCornerColor||n.strokeCornerColor,t.lineWidth=1,t.translate(e,i),t.rotate(f(n.angle)),t[h+"Rect"](-l,-u,s,o),c&&t.strokeRect(-l,-u,s,o),t.restore()}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var p=t.fabric||(t.fabric={});p.Control=function(t){for(var e in t)this[e]=t[e]},p.Control.prototype={visible:!0,actionName:"scale",angle:0,x:0,y:0,offsetX:0,offsetY:0,sizeX:null,sizeY:null,touchSizeX:null,touchSizeY:null,cursorStyle:"crosshair",withConnection:!1,actionHandler:function(){},mouseDownHandler:function(){},mouseUpHandler:function(){},getActionHandler:function(){return this.actionHandler},getMouseDownHandler:function(){return this.mouseDownHandler},getMouseUpHandler:function(){return this.mouseUpHandler},cursorStyleHandler:function(t,e){return e.cursorStyle},getActionName:function(t,e){return e.actionName},getVisibility:function(t,e){var i=t._controlsVisibility;return i&&void 0!==i[e]?i[e]:this.visible},setVisibility:function(t){this.visible=t},positionHandler:function(t,e){return p.util.transformPoint({x:this.x*t.x+this.offsetX,y:this.y*t.y+this.offsetY},e)},calcCornerCoords:function(t,e,i,r,n){var s,o,a,h,c=n?this.touchSizeX:this.sizeX,l=n?this.touchSizeY:this.sizeY;if(c&&l&&c!==l){var u=Math.atan2(l,c),f=Math.sqrt(c*c+l*l)/2,d=u-p.util.degreesToRadians(t),g=Math.PI/2-u-p.util.degreesToRadians(t);s=f*p.util.cos(d),o=f*p.util.sin(d),a=f*p.util.cos(g),h=f*p.util.sin(g)}else{f=.7071067812*(c&&l?c:e);d=p.util.degreesToRadians(45-t);s=a=f*p.util.cos(d),o=h=f*p.util.sin(d)}return{tl:{x:i-h,y:r-a},tr:{x:i+s,y:r-o},bl:{x:i-s,y:r+o},br:{x:i+h,y:r+a}}},render:function(t,e,i,r,n){switch((r=r||{}).cornerStyle||n.cornerStyle){case"circle":p.controlsUtils.renderCircleControl.call(this,t,e,i,r,n);break;default:p.controlsUtils.renderSquareControl.call(this,t,e,i,r,n)}}}}("undefined"!=typeof exports?exports:this),function(){function C(t,e){var i,r,n,s,o=t.getAttribute("style"),a=t.getAttribute("offset")||0;if(a=(a=parseFloat(a)/(/%$/.test(a)?100:1))<0?0:1<a?1:a,o){var h=o.split(/\s*;\s*/);for(""===h[h.length-1]&&h.pop(),s=h.length;s--;){var c=h[s].split(/\s*:\s*/),l=c[0].trim(),u=c[1].trim();"stop-color"===l?i=u:"stop-opacity"===l&&(n=u)}}return i||(i=t.getAttribute("stop-color")||"rgb(0,0,0)"),n||(n=t.getAttribute("stop-opacity")),r=(i=new fabric.Color(i)).getAlpha(),n=isNaN(parseFloat(n))?1:parseFloat(n),n*=r*e,{offset:a,color:i.toRgb(),opacity:n}}var m=fabric.util.object.clone;fabric.Gradient=fabric.util.createClass({offsetX:0,offsetY:0,gradientTransform:null,gradientUnits:"pixels",type:"linear",initialize:function(e){e||(e={}),e.coords||(e.coords={});var t,i=this;Object.keys(e).forEach(function(t){i[t]=e[t]}),this.id?this.id+="_"+fabric.Object.__uid++:this.id=fabric.Object.__uid++,t={x1:e.coords.x1||0,y1:e.coords.y1||0,x2:e.coords.x2||0,y2:e.coords.y2||0},"radial"===this.type&&(t.r1=e.coords.r1||0,t.r2=e.coords.r2||0),this.coords=t,this.colorStops=e.colorStops.slice()},addColorStop:function(t){for(var e in t){var i=new fabric.Color(t[e]);this.colorStops.push({offset:parseFloat(e),color:i.toRgb(),opacity:i.getAlpha()})}return this},toObject:function(t){var e={type:this.type,coords:this.coords,colorStops:this.colorStops,offsetX:this.offsetX,offsetY:this.offsetY,gradientUnits:this.gradientUnits,gradientTransform:this.gradientTransform?this.gradientTransform.concat():this.gradientTransform};return fabric.util.populateWithProperties(this,e,t),e},toSVG:function(t,e){var i,r,n,s,o=m(this.coords,!0),a=(e=e||{},m(this.colorStops,!0)),h=o.r1>o.r2,c=this.gradientTransform?this.gradientTransform.concat():fabric.iMatrix.concat(),l=-this.offsetX,u=-this.offsetY,f=!!e.additionalTransform,d="pixels"===this.gradientUnits?"userSpaceOnUse":"objectBoundingBox";if(a.sort(function(t,e){return t.offset-e.offset}),"objectBoundingBox"===d?(l/=t.width,u/=t.height):(l+=t.width/2,u+=t.height/2),"path"===t.type&&"percentage"!==this.gradientUnits&&(l-=t.pathOffset.x,u-=t.pathOffset.y),c[4]-=l,c[5]-=u,s='id="SVGID_'+this.id+'" gradientUnits="'+d+'"',s+=' gradientTransform="'+(f?e.additionalTransform+" ":"")+fabric.util.matrixToSVG(c)+'" ',"linear"===this.type?n=["<linearGradient ",s,' x1="',o.x1,'" y1="',o.y1,'" x2="',o.x2,'" y2="',o.y2,'">\n']:"radial"===this.type&&(n=["<radialGradient ",s,' cx="',h?o.x1:o.x2,'" cy="',h?o.y1:o.y2,'" r="',h?o.r1:o.r2,'" fx="',h?o.x2:o.x1,'" fy="',h?o.y2:o.y1,'">\n']),"radial"===this.type){if(h)for((a=a.concat()).reverse(),i=0,r=a.length;i<r;i++)a[i].offset=1-a[i].offset;var g=Math.min(o.r1,o.r2);if(0<g){var p=g/Math.max(o.r1,o.r2);for(i=0,r=a.length;i<r;i++)a[i].offset+=p*(1-a[i].offset)}}for(i=0,r=a.length;i<r;i++){var v=a[i];n.push("<stop ",'offset="',100*v.offset+"%",'" style="stop-color:',v.color,void 0!==v.opacity?";stop-opacity: "+v.opacity:";",'"/>\n')}return n.push("linear"===this.type?"</linearGradient>\n":"</radialGradient>\n"),n.join("")},toLive:function(t){var e,i,r,n=fabric.util.object.clone(this.coords);if(this.type){for("linear"===this.type?e=t.createLinearGradient(n.x1,n.y1,n.x2,n.y2):"radial"===this.type&&(e=t.createRadialGradient(n.x1,n.y1,n.r1,n.x2,n.y2,n.r2)),i=0,r=this.colorStops.length;i<r;i++){var s=this.colorStops[i].color,o=this.colorStops[i].opacity,a=this.colorStops[i].offset;void 0!==o&&(s=new fabric.Color(s).setAlpha(o).toRgba()),e.addColorStop(a,s)}return e}}}),fabric.util.object.extend(fabric.Gradient,{fromElement:function(t,e,i,r){var n=parseFloat(i)/(/%$/.test(i)?100:1);n=n<0?0:1<n?1:n,isNaN(n)&&(n=1);var s,o,a,h,c,l,u,f,d,g,p,v=t.getElementsByTagName("stop"),m="userSpaceOnUse"===t.getAttribute("gradientUnits")?"pixels":"percentage",b=t.getAttribute("gradientTransform")||"",_=[],y=0,x=0;for("linearGradient"===t.nodeName||"LINEARGRADIENT"===t.nodeName?(s="linear",o={x1:(l=t).getAttribute("x1")||0,y1:l.getAttribute("y1")||0,x2:l.getAttribute("x2")||"100%",y2:l.getAttribute("y2")||0}):(s="radial",o={x1:(c=t).getAttribute("fx")||c.getAttribute("cx")||"50%",y1:c.getAttribute("fy")||c.getAttribute("cy")||"50%",r1:0,x2:c.getAttribute("cx")||"50%",y2:c.getAttribute("cy")||"50%",r2:c.getAttribute("r")||"50%"}),a=v.length;a--;)_.push(C(v[a],n));return h=fabric.parseTransformAttribute(b),u=o,f=r,d=m,Object.keys(u).forEach(function(t){"Infinity"===(g=u[t])?p=1:"-Infinity"===g?p=0:(p=parseFloat(u[t],10),"string"==typeof g&&/^(\d+\.\d+)%|(\d+)%$/.test(g)&&(p*=.01,"pixels"===d&&("x1"!==t&&"x2"!==t&&"r2"!==t||(p*=f.viewBoxWidth||f.width),"y1"!==t&&"y2"!==t||(p*=f.viewBoxHeight||f.height)))),u[t]=p}),"pixels"===m&&(y=-e.left,x=-e.top),new fabric.Gradient({id:t.getAttribute("id"),type:s,coords:o,colorStops:_,gradientUnits:m,gradientTransform:h,offsetX:y,offsetY:x})}})}(),function(){"use strict";var n=fabric.util.toFixed;fabric.Pattern=fabric.util.createClass({repeat:"repeat",offsetX:0,offsetY:0,crossOrigin:"",patternTransform:null,initialize:function(t,i){if(t||(t={}),this.id=fabric.Object.__uid++,this.setOptions(t),!t.source||t.source&&"string"!=typeof t.source)i&&i(this);else{var r=this;this.source=fabric.util.createImage(),fabric.util.loadImage(t.source,function(t,e){r.source=t,i&&i(r,e)},null,this.crossOrigin)}},toObject:function(t){var e,i,r=fabric.Object.NUM_FRACTION_DIGITS;return"string"==typeof this.source.src?e=this.source.src:"object"==typeof this.source&&this.source.toDataURL&&(e=this.source.toDataURL()),i={type:"pattern",source:e,repeat:this.repeat,crossOrigin:this.crossOrigin,offsetX:n(this.offsetX,r),offsetY:n(this.offsetY,r),patternTransform:this.patternTransform?this.patternTransform.concat():null},fabric.util.populateWithProperties(this,i,t),i},toSVG:function(t){var e="function"==typeof this.source?this.source():this.source,i=e.width/t.width,r=e.height/t.height,n=this.offsetX/t.width,s=this.offsetY/t.height,o="";return"repeat-x"!==this.repeat&&"no-repeat"!==this.repeat||(r=1,s&&(r+=Math.abs(s))),"repeat-y"!==this.repeat&&"no-repeat"!==this.repeat||(i=1,n&&(i+=Math.abs(n))),e.src?o=e.src:e.toDataURL&&(o=e.toDataURL()),'<pattern id="SVGID_'+this.id+'" x="'+n+'" y="'+s+'" width="'+i+'" height="'+r+'">\n<image x="0" y="0" width="'+e.width+'" height="'+e.height+'" xlink:href="'+o+'"></image>\n</pattern>\n'},setOptions:function(t){for(var e in t)this[e]=t[e]},toLive:function(t){var e=this.source;if(!e)return"";if(void 0!==e.src){if(!e.complete)return"";if(0===e.naturalWidth||0===e.naturalHeight)return""}return t.createPattern(e,this.repeat)}})}(),function(t){"use strict";var o=t.fabric||(t.fabric={}),a=o.util.toFixed;o.Shadow?o.warn("fabric.Shadow is already defined."):(o.Shadow=o.util.createClass({color:"rgb(0,0,0)",blur:0,offsetX:0,offsetY:0,affectStroke:!1,includeDefaultValues:!0,nonScaling:!1,initialize:function(t){for(var e in"string"==typeof t&&(t=this._parseShadow(t)),t)this[e]=t[e];this.id=o.Object.__uid++},_parseShadow:function(t){var e=t.trim(),i=o.Shadow.reOffsetsAndBlur.exec(e)||[];return{color:(e.replace(o.Shadow.reOffsetsAndBlur,"")||"rgb(0,0,0)").trim(),offsetX:parseInt(i[1],10)||0,offsetY:parseInt(i[2],10)||0,blur:parseInt(i[3],10)||0}},toString:function(){return[this.offsetX,this.offsetY,this.blur,this.color].join("px ")},toSVG:function(t){var e=40,i=40,r=o.Object.NUM_FRACTION_DIGITS,n=o.util.rotateVector({x:this.offsetX,y:this.offsetY},o.util.degreesToRadians(-t.angle)),s=new o.Color(this.color);return t.width&&t.height&&(e=100*a((Math.abs(n.x)+this.blur)/t.width,r)+20,i=100*a((Math.abs(n.y)+this.blur)/t.height,r)+20),t.flipX&&(n.x*=-1),t.flipY&&(n.y*=-1),'<filter id="SVGID_'+this.id+'" y="-'+i+'%" height="'+(100+2*i)+'%" x="-'+e+'%" width="'+(100+2*e)+'%" >\n\t<feGaussianBlur in="SourceAlpha" stdDeviation="'+a(this.blur?this.blur/2:0,r)+'"></feGaussianBlur>\n\t<feOffset dx="'+a(n.x,r)+'" dy="'+a(n.y,r)+'" result="oBlur" ></feOffset>\n\t<feFlood flood-color="'+s.toRgb()+'" flood-opacity="'+s.getAlpha()+'"/>\n\t<feComposite in2="oBlur" operator="in" />\n\t<feMerge>\n\t\t<feMergeNode></feMergeNode>\n\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n\t</feMerge>\n</filter>\n'},toObject:function(){if(this.includeDefaultValues)return{color:this.color,blur:this.blur,offsetX:this.offsetX,offsetY:this.offsetY,affectStroke:this.affectStroke,nonScaling:this.nonScaling};var e={},i=o.Shadow.prototype;return["color","blur","offsetX","offsetY","affectStroke","nonScaling"].forEach(function(t){this[t]!==i[t]&&(e[t]=this[t])},this),e}}),o.Shadow.reOffsetsAndBlur=/(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/)}("undefined"!=typeof exports?exports:this),function(){"use strict";if(fabric.StaticCanvas)fabric.warn("fabric.StaticCanvas is already defined.");else{var n=fabric.util.object.extend,t=fabric.util.getElementOffset,c=fabric.util.removeFromArray,a=fabric.util.toFixed,s=fabric.util.transformPoint,o=fabric.util.invertTransform,i=fabric.util.getNodeCanvas,r=fabric.util.createCanvasElement,e=new Error("Could not initialize `canvas` element");fabric.StaticCanvas=fabric.util.createClass(fabric.CommonMethods,{initialize:function(t,e){e||(e={}),this.renderAndResetBound=this.renderAndReset.bind(this),this.requestRenderAllBound=this.requestRenderAll.bind(this),this._initStatic(t,e)},backgroundColor:"",backgroundImage:null,overlayColor:"",overlayImage:null,includeDefaultValues:!0,stateful:!1,renderOnAddRemove:!0,controlsAboveOverlay:!1,allowTouchScrolling:!1,imageSmoothingEnabled:!0,viewportTransform:fabric.iMatrix.concat(),backgroundVpt:!0,overlayVpt:!0,enableRetinaScaling:!0,vptCoords:{},skipOffscreen:!0,clipPath:void 0,_initStatic:function(t,e){var i=this.requestRenderAllBound;this._objects=[],this._createLowerCanvas(t),this._initOptions(e),this.interactive||this._initRetinaScaling(),e.overlayImage&&this.setOverlayImage(e.overlayImage,i),e.backgroundImage&&this.setBackgroundImage(e.backgroundImage,i),e.backgroundColor&&this.setBackgroundColor(e.backgroundColor,i),e.overlayColor&&this.setOverlayColor(e.overlayColor,i),this.calcOffset()},_isRetinaScaling:function(){return 1!==fabric.devicePixelRatio&&this.enableRetinaScaling},getRetinaScaling:function(){return this._isRetinaScaling()?fabric.devicePixelRatio:1},_initRetinaScaling:function(){if(this._isRetinaScaling()){var t=fabric.devicePixelRatio;this.__initRetinaScaling(t,this.lowerCanvasEl,this.contextContainer),this.upperCanvasEl&&this.__initRetinaScaling(t,this.upperCanvasEl,this.contextTop)}},__initRetinaScaling:function(t,e,i){e.setAttribute("width",this.width*t),e.setAttribute("height",this.height*t),i.scale(t,t)},calcOffset:function(){return this._offset=t(this.lowerCanvasEl),this},setOverlayImage:function(t,e,i){return this.__setBgOverlayImage("overlayImage",t,e,i)},setBackgroundImage:function(t,e,i){return this.__setBgOverlayImage("backgroundImage",t,e,i)},setOverlayColor:function(t,e){return this.__setBgOverlayColor("overlayColor",t,e)},setBackgroundColor:function(t,e){return this.__setBgOverlayColor("backgroundColor",t,e)},__setBgOverlayImage:function(r,t,n,s){return"string"==typeof t?fabric.util.loadImage(t,function(t,e){if(t){var i=new fabric.Image(t,s);(this[r]=i).canvas=this}n&&n(t,e)},this,s&&s.crossOrigin):(s&&t.setOptions(s),(this[r]=t)&&(t.canvas=this),n&&n(t,!1)),this},__setBgOverlayColor:function(t,e,i){return this[t]=e,this._initGradient(e,t),this._initPattern(e,t,i),this},_createCanvasElement:function(){var t=r();if(!t)throw e;if(t.style||(t.style={}),void 0===t.getContext)throw e;return t},_initOptions:function(t){var e=this.lowerCanvasEl;this._setOptions(t),this.width=this.width||parseInt(e.width,10)||0,this.height=this.height||parseInt(e.height,10)||0,this.lowerCanvasEl.style&&(e.width=this.width,e.height=this.height,e.style.width=this.width+"px",e.style.height=this.height+"px",this.viewportTransform=this.viewportTransform.slice())},_createLowerCanvas:function(t){t&&t.getContext?this.lowerCanvasEl=t:this.lowerCanvasEl=fabric.util.getById(t)||this._createCanvasElement(),fabric.util.addClass(this.lowerCanvasEl,"lower-canvas"),this.interactive&&this._applyCanvasStyle(this.lowerCanvasEl),this.contextContainer=this.lowerCanvasEl.getContext("2d")},getWidth:function(){return this.width},getHeight:function(){return this.height},setWidth:function(t,e){return this.setDimensions({width:t},e)},setHeight:function(t,e){return this.setDimensions({height:t},e)},setDimensions:function(t,e){var i;for(var r in e=e||{},t)i=t[r],e.cssOnly||(this._setBackstoreDimension(r,t[r]),i+="px",this.hasLostContext=!0),e.backstoreOnly||this._setCssDimension(r,i);return this._isCurrentlyDrawing&&this.freeDrawingBrush&&this.freeDrawingBrush._setBrushStyles(),this._initRetinaScaling(),this.calcOffset(),e.cssOnly||this.requestRenderAll(),this},_setBackstoreDimension:function(t,e){return this.lowerCanvasEl[t]=e,this.upperCanvasEl&&(this.upperCanvasEl[t]=e),this.cacheCanvasEl&&(this.cacheCanvasEl[t]=e),this[t]=e,this},_setCssDimension:function(t,e){return this.lowerCanvasEl.style[t]=e,this.upperCanvasEl&&(this.upperCanvasEl.style[t]=e),this.wrapperEl&&(this.wrapperEl.style[t]=e),this},getZoom:function(){return this.viewportTransform[0]},setViewportTransform:function(t){var e,i,r,n=this._activeObject;for(this.viewportTransform=t,i=0,r=this._objects.length;i<r;i++)(e=this._objects[i]).group||e.setCoords(!0);return n&&n.setCoords(),this.calcViewportBoundaries(),this.renderOnAddRemove&&this.requestRenderAll(),this},zoomToPoint:function(t,e){var i=t,r=this.viewportTransform.slice(0);t=s(t,o(this.viewportTransform)),r[0]=e,r[3]=e;var n=s(t,r);return r[4]+=i.x-n.x,r[5]+=i.y-n.y,this.setViewportTransform(r)},setZoom:function(t){return this.zoomToPoint(new fabric.Point(0,0),t),this},absolutePan:function(t){var e=this.viewportTransform.slice(0);return e[4]=-t.x,e[5]=-t.y,this.setViewportTransform(e)},relativePan:function(t){return this.absolutePan(new fabric.Point(-t.x-this.viewportTransform[4],-t.y-this.viewportTransform[5]))},getElement:function(){return this.lowerCanvasEl},_onObjectAdded:function(t){this.stateful&&t.setupState(),t._set("canvas",this),t.setCoords(),this.fire("object:added",{target:t}),t.fire("added")},_onObjectRemoved:function(t){this.fire("object:removed",{target:t}),t.fire("removed"),delete t.canvas},clearContext:function(t){return t.clearRect(0,0,this.width,this.height),this},getContext:function(){return this.contextContainer},clear:function(){return this._objects.length=0,this.backgroundImage=null,this.overlayImage=null,this.backgroundColor="",this.overlayColor="",this._hasITextHandlers&&(this.off("mouse:up",this._mouseUpITextHandler),this._iTextInstances=null,this._hasITextHandlers=!1),this.clearContext(this.contextContainer),this.fire("canvas:cleared"),this.renderOnAddRemove&&this.requestRenderAll(),this},renderAll:function(){var t=this.contextContainer;return this.renderCanvas(t,this._objects),this},renderAndReset:function(){this.isRendering=0,this.renderAll()},requestRenderAll:function(){return this.isRendering||(this.isRendering=fabric.util.requestAnimFrame(this.renderAndResetBound)),this},calcViewportBoundaries:function(){var t={},e=this.width,i=this.height,r=o(this.viewportTransform);return t.tl=s({x:0,y:0},r),t.br=s({x:e,y:i},r),t.tr=new fabric.Point(t.br.x,t.tl.y),t.bl=new fabric.Point(t.tl.x,t.br.y),this.vptCoords=t},cancelRequestedRender:function(){this.isRendering&&(fabric.util.cancelAnimFrame(this.isRendering),this.isRendering=0)},renderCanvas:function(t,e){var i=this.viewportTransform,r=this.clipPath;this.cancelRequestedRender(),this.calcViewportBoundaries(),this.clearContext(t),fabric.util.setImageSmoothing(t,this.imageSmoothingEnabled),this.fire("before:render",{ctx:t}),this._renderBackground(t),t.save(),t.transform(i[0],i[1],i[2],i[3],i[4],i[5]),this._renderObjects(t,e),t.restore(),!this.controlsAboveOverlay&&this.interactive&&this.drawControls(t),r&&(r.canvas=this,r.shouldCache(),r._transformDone=!0,r.renderCache({forClipping:!0}),this.drawClipPathOnCanvas(t)),this._renderOverlay(t),this.controlsAboveOverlay&&this.interactive&&this.drawControls(t),this.fire("after:render",{ctx:t})},drawClipPathOnCanvas:function(t){var e=this.viewportTransform,i=this.clipPath;t.save(),t.transform(e[0],e[1],e[2],e[3],e[4],e[5]),t.globalCompositeOperation="destination-in",i.transform(t),t.scale(1/i.zoomX,1/i.zoomY),t.drawImage(i._cacheCanvas,-i.cacheTranslationX,-i.cacheTranslationY),t.restore()},_renderObjects:function(t,e){var i,r;for(i=0,r=e.length;i<r;++i)e[i]&&e[i].render(t)},_renderBackgroundOrOverlay:function(t,e){var i=this[e+"Color"],r=this[e+"Image"],n=this.viewportTransform,s=this[e+"Vpt"];if(i||r){if(i){t.save(),t.beginPath(),t.moveTo(0,0),t.lineTo(this.width,0),t.lineTo(this.width,this.height),t.lineTo(0,this.height),t.closePath(),t.fillStyle=i.toLive?i.toLive(t,this):i,s&&t.transform(n[0],n[1],n[2],n[3],n[4],n[5]),t.transform(1,0,0,1,i.offsetX||0,i.offsetY||0);var o=i.gradientTransform||i.patternTransform;o&&t.transform(o[0],o[1],o[2],o[3],o[4],o[5]),t.fill(),t.restore()}r&&(t.save(),s&&t.transform(n[0],n[1],n[2],n[3],n[4],n[5]),r.render(t),t.restore())}},_renderBackground:function(t){this._renderBackgroundOrOverlay(t,"background")},_renderOverlay:function(t){this._renderBackgroundOrOverlay(t,"overlay")},getCenter:function(){return{top:this.height/2,left:this.width/2}},centerObjectH:function(t){return this._centerObject(t,new fabric.Point(this.getCenter().left,t.getCenterPoint().y))},centerObjectV:function(t){return this._centerObject(t,new fabric.Point(t.getCenterPoint().x,this.getCenter().top))},centerObject:function(t){var e=this.getCenter();return this._centerObject(t,new fabric.Point(e.left,e.top))},viewportCenterObject:function(t){var e=this.getVpCenter();return this._centerObject(t,e)},viewportCenterObjectH:function(t){var e=this.getVpCenter();return this._centerObject(t,new fabric.Point(e.x,t.getCenterPoint().y)),this},viewportCenterObjectV:function(t){var e=this.getVpCenter();return this._centerObject(t,new fabric.Point(t.getCenterPoint().x,e.y))},getVpCenter:function(){var t=this.getCenter(),e=o(this.viewportTransform);return s({x:t.left,y:t.top},e)},_centerObject:function(t,e){return t.setPositionByOrigin(e,"center","center"),t.setCoords(),this.renderOnAddRemove&&this.requestRenderAll(),this},toDatalessJSON:function(t){return this.toDatalessObject(t)},toObject:function(t){return this._toObjectMethod("toObject",t)},toDatalessObject:function(t){return this._toObjectMethod("toDatalessObject",t)},_toObjectMethod:function(t,e){var i=this.clipPath,r={version:fabric.version,objects:this._toObjects(t,e)};return i&&(r.clipPath=this._toObject(this.clipPath,t,e)),n(r,this.__serializeBgOverlay(t,e)),fabric.util.populateWithProperties(this,r,e),r},_toObjects:function(e,i){return this._objects.filter(function(t){return!t.excludeFromExport}).map(function(t){return this._toObject(t,e,i)},this)},_toObject:function(t,e,i){var r;this.includeDefaultValues||(r=t.includeDefaultValues,t.includeDefaultValues=!1);var n=t[e](i);return this.includeDefaultValues||(t.includeDefaultValues=r),n},__serializeBgOverlay:function(t,e){var i={},r=this.backgroundImage,n=this.overlayImage;return this.backgroundColor&&(i.background=this.backgroundColor.toObject?this.backgroundColor.toObject(e):this.backgroundColor),this.overlayColor&&(i.overlay=this.overlayColor.toObject?this.overlayColor.toObject(e):this.overlayColor),r&&!r.excludeFromExport&&(i.backgroundImage=this._toObject(r,t,e)),n&&!n.excludeFromExport&&(i.overlayImage=this._toObject(n,t,e)),i},svgViewportTransformation:!0,toSVG:function(t,e){t||(t={}),t.reviver=e;var i=[];return this._setSVGPreamble(i,t),this._setSVGHeader(i,t),this.clipPath&&i.push('<g clip-path="url(#'+this.clipPath.clipPathId+')" >\n'),this._setSVGBgOverlayColor(i,"background"),this._setSVGBgOverlayImage(i,"backgroundImage",e),this._setSVGObjects(i,e),this.clipPath&&i.push("</g>\n"),this._setSVGBgOverlayColor(i,"overlay"),this._setSVGBgOverlayImage(i,"overlayImage",e),i.push("</svg>"),i.join("")},_setSVGPreamble:function(t,e){e.suppressPreamble||t.push('<?xml version="1.0" encoding="',e.encoding||"UTF-8",'" standalone="no" ?>\n','<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ','"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n')},_setSVGHeader:function(t,e){var i,r=e.width||this.width,n=e.height||this.height,s='viewBox="0 0 '+this.width+" "+this.height+'" ',o=fabric.Object.NUM_FRACTION_DIGITS;e.viewBox?s='viewBox="'+e.viewBox.x+" "+e.viewBox.y+" "+e.viewBox.width+" "+e.viewBox.height+'" ':this.svgViewportTransformation&&(i=this.viewportTransform,s='viewBox="'+a(-i[4]/i[0],o)+" "+a(-i[5]/i[3],o)+" "+a(this.width/i[0],o)+" "+a(this.height/i[3],o)+'" '),t.push("<svg ",'xmlns="http://www.w3.org/2000/svg" ','xmlns:xlink="http://www.w3.org/1999/xlink" ','version="1.1" ','width="',r,'" ','height="',n,'" ',s,'xml:space="preserve">\n',"<desc>Created with Fabric.js ",fabric.version,"</desc>\n","<defs>\n",this.createSVGFontFacesMarkup(),this.createSVGRefElementsMarkup(),this.createSVGClipPathMarkup(e),"</defs>\n")},createSVGClipPathMarkup:function(t){var e=this.clipPath;return e?(e.clipPathId="CLIPPATH_"+fabric.Object.__uid++,'<clipPath id="'+e.clipPathId+'" >\n'+this.clipPath.toClipPathSVG(t.reviver)+"</clipPath>\n"):""},createSVGRefElementsMarkup:function(){var s=this;return["background","overlay"].map(function(t){var e=s[t+"Color"];if(e&&e.toLive){var i=s[t+"Vpt"],r=s.viewportTransform,n={width:s.width/(i?r[0]:1),height:s.height/(i?r[3]:1)};return e.toSVG(n,{additionalTransform:i?fabric.util.matrixToSVG(r):""})}}).join("")},createSVGFontFacesMarkup:function(){var t,e,i,r,n,s,o,a,h="",c={},l=fabric.fontPaths,u=[];for(this._objects.forEach(function t(e){u.push(e),e._objects&&e._objects.forEach(t)}),o=0,a=u.length;o<a;o++)if(e=(t=u[o]).fontFamily,-1!==t.type.indexOf("text")&&!c[e]&&l[e]&&(c[e]=!0,t.styles))for(n in i=t.styles)for(s in r=i[n])!c[e=r[s].fontFamily]&&l[e]&&(c[e]=!0);for(var f in c)h+=["\t\t@font-face {\n","\t\t\tfont-family: '",f,"';\n","\t\t\tsrc: url('",l[f],"');\n","\t\t}\n"].join("");return h&&(h=['\t<style type="text/css">',"<![CDATA[\n",h,"]]>","</style>\n"].join("")),h},_setSVGObjects:function(t,e){var i,r,n,s=this._objects;for(r=0,n=s.length;r<n;r++)(i=s[r]).excludeFromExport||this._setSVGObject(t,i,e)},_setSVGObject:function(t,e,i){t.push(e.toSVG(i))},_setSVGBgOverlayImage:function(t,e,i){this[e]&&!this[e].excludeFromExport&&this[e].toSVG&&t.push(this[e].toSVG(i))},_setSVGBgOverlayColor:function(t,e){var i=this[e+"Color"],r=this.viewportTransform,n=this.width,s=this.height;if(i)if(i.toLive){var o=i.repeat,a=fabric.util.invertTransform(r),h=this[e+"Vpt"]?fabric.util.matrixToSVG(a):"";t.push('<rect transform="'+h+" translate(",n/2,",",s/2,')"',' x="',i.offsetX-n/2,'" y="',i.offsetY-s/2,'" ','width="',"repeat-y"===o||"no-repeat"===o?i.source.width:n,'" height="',"repeat-x"===o||"no-repeat"===o?i.source.height:s,'" fill="url(#SVGID_'+i.id+')"',"></rect>\n")}else t.push('<rect x="0" y="0" width="100%" height="100%" ','fill="',i,'"',"></rect>\n")},sendToBack:function(t){if(!t)return this;var e,i,r,n=this._activeObject;if(t===n&&"activeSelection"===t.type)for(e=(r=n._objects).length;e--;)i=r[e],c(this._objects,i),this._objects.unshift(i);else c(this._objects,t),this._objects.unshift(t);return this.renderOnAddRemove&&this.requestRenderAll(),this},bringToFront:function(t){if(!t)return this;var e,i,r,n=this._activeObject;if(t===n&&"activeSelection"===t.type)for(r=n._objects,e=0;e<r.length;e++)i=r[e],c(this._objects,i),this._objects.push(i);else c(this._objects,t),this._objects.push(t);return this.renderOnAddRemove&&this.requestRenderAll(),this},sendBackwards:function(t,e){if(!t)return this;var i,r,n,s,o,a=this._activeObject,h=0;if(t===a&&"activeSelection"===t.type)for(o=a._objects,i=0;i<o.length;i++)r=o[i],0+h<(n=this._objects.indexOf(r))&&(s=n-1,c(this._objects,r),this._objects.splice(s,0,r)),h++;else 0!==(n=this._objects.indexOf(t))&&(s=this._findNewLowerIndex(t,n,e),c(this._objects,t),this._objects.splice(s,0,t));return this.renderOnAddRemove&&this.requestRenderAll(),this},_findNewLowerIndex:function(t,e,i){var r,n;if(i)for(n=(r=e)-1;0<=n;--n){if(t.intersectsWithObject(this._objects[n])||t.isContainedWithinObject(this._objects[n])||this._objects[n].isContainedWithinObject(t)){r=n;break}}else r=e-1;return r},bringForward:function(t,e){if(!t)return this;var i,r,n,s,o,a=this._activeObject,h=0;if(t===a&&"activeSelection"===t.type)for(i=(o=a._objects).length;i--;)r=o[i],(n=this._objects.indexOf(r))<this._objects.length-1-h&&(s=n+1,c(this._objects,r),this._objects.splice(s,0,r)),h++;else(n=this._objects.indexOf(t))!==this._objects.length-1&&(s=this._findNewUpperIndex(t,n,e),c(this._objects,t),this._objects.splice(s,0,t));return this.renderOnAddRemove&&this.requestRenderAll(),this},_findNewUpperIndex:function(t,e,i){var r,n,s;if(i)for(n=(r=e)+1,s=this._objects.length;n<s;++n){if(t.intersectsWithObject(this._objects[n])||t.isContainedWithinObject(this._objects[n])||this._objects[n].isContainedWithinObject(t)){r=n;break}}else r=e+1;return r},moveTo:function(t,e){return c(this._objects,t),this._objects.splice(e,0,t),this.renderOnAddRemove&&this.requestRenderAll()},dispose:function(){return this.isRendering&&(fabric.util.cancelAnimFrame(this.isRendering),this.isRendering=0),this.forEachObject(function(t){t.dispose&&t.dispose()}),this._objects=[],this.backgroundImage&&this.backgroundImage.dispose&&this.backgroundImage.dispose(),this.backgroundImage=null,this.overlayImage&&this.overlayImage.dispose&&this.overlayImage.dispose(),this.overlayImage=null,this._iTextInstances=null,this.contextContainer=null,fabric.util.cleanUpJsdomNode(this.lowerCanvasEl),this.lowerCanvasEl=void 0,this},toString:function(){return"#<fabric.Canvas ("+this.complexity()+"): { objects: "+this._objects.length+" }>"}}),n(fabric.StaticCanvas.prototype,fabric.Observable),n(fabric.StaticCanvas.prototype,fabric.Collection),n(fabric.StaticCanvas.prototype,fabric.DataURLExporter),n(fabric.StaticCanvas,{EMPTY_JSON:'{"objects": [], "background": "white"}',supports:function(t){var e=r();if(!e||!e.getContext)return null;var i=e.getContext("2d");if(!i)return null;switch(t){case"setLineDash":return void 0!==i.setLineDash;default:return null}}}),fabric.StaticCanvas.prototype.toJSON=fabric.StaticCanvas.prototype.toObject,fabric.isLikelyNode&&(fabric.StaticCanvas.prototype.createPNGStream=function(){var t=i(this.lowerCanvasEl);return t&&t.createPNGStream()},fabric.StaticCanvas.prototype.createJPEGStream=function(t){var e=i(this.lowerCanvasEl);return e&&e.createJPEGStream(t)})}}(),fabric.BaseBrush=fabric.util.createClass({color:"rgb(0, 0, 0)",width:1,shadow:null,strokeLineCap:"round",strokeLineJoin:"round",strokeMiterLimit:10,strokeDashArray:null,_setBrushStyles:function(){var t=this.canvas.contextTop;t.strokeStyle=this.color,t.lineWidth=this.width,t.lineCap=this.strokeLineCap,t.miterLimit=this.strokeMiterLimit,t.lineJoin=this.strokeLineJoin,fabric.StaticCanvas.supports("setLineDash")&&t.setLineDash(this.strokeDashArray||[])},_saveAndTransform:function(t){var e=this.canvas.viewportTransform;t.save(),t.transform(e[0],e[1],e[2],e[3],e[4],e[5])},_setShadow:function(){if(this.shadow){var t=this.canvas,e=this.shadow,i=t.contextTop,r=t.getZoom();t&&t._isRetinaScaling()&&(r*=fabric.devicePixelRatio),i.shadowColor=e.color,i.shadowBlur=e.blur*r,i.shadowOffsetX=e.offsetX*r,i.shadowOffsetY=e.offsetY*r}},needsFullRender:function(){return new fabric.Color(this.color).getAlpha()<1||!!this.shadow},_resetShadow:function(){var t=this.canvas.contextTop;t.shadowColor="",t.shadowBlur=t.shadowOffsetX=t.shadowOffsetY=0}}),fabric.PencilBrush=fabric.util.createClass(fabric.BaseBrush,{decimate:.4,initialize:function(t){this.canvas=t,this._points=[]},_drawSegment:function(t,e,i){var r=e.midPointFrom(i);return t.quadraticCurveTo(e.x,e.y,r.x,r.y),r},onMouseDown:function(t,e){this.canvas._isMainEvent(e.e)&&(this._prepareForDrawing(t),this._captureDrawingPath(t),this._render())},onMouseMove:function(t,e){if(this.canvas._isMainEvent(e.e)&&this._captureDrawingPath(t)&&1<this._points.length)if(this.needsFullRender())this.canvas.clearContext(this.canvas.contextTop),this._render();else{var i=this._points,r=i.length,n=this.canvas.contextTop;this._saveAndTransform(n),this.oldEnd&&(n.beginPath(),n.moveTo(this.oldEnd.x,this.oldEnd.y)),this.oldEnd=this._drawSegment(n,i[r-2],i[r-1],!0),n.stroke(),n.restore()}},onMouseUp:function(t){return!this.canvas._isMainEvent(t.e)||(this.oldEnd=void 0,this._finalizeAndAddPath(),!1)},_prepareForDrawing:function(t){var e=new fabric.Point(t.x,t.y);this._reset(),this._addPoint(e),this.canvas.contextTop.moveTo(e.x,e.y)},_addPoint:function(t){return!(1<this._points.length&&t.eq(this._points[this._points.length-1])||(this._points.push(t),0))},_reset:function(){this._points=[],this._setBrushStyles(),this._setShadow()},_captureDrawingPath:function(t){var e=new fabric.Point(t.x,t.y);return this._addPoint(e)},_render:function(){var t,e,i=this.canvas.contextTop,r=this._points[0],n=this._points[1];if(this._saveAndTransform(i),i.beginPath(),2===this._points.length&&r.x===n.x&&r.y===n.y){var s=this.width/1e3;r=new fabric.Point(r.x,r.y),n=new fabric.Point(n.x,n.y),r.x-=s,n.x+=s}for(i.moveTo(r.x,r.y),t=1,e=this._points.length;t<e;t++)this._drawSegment(i,r,n),r=this._points[t],n=this._points[t+1];i.lineTo(r.x,r.y),i.stroke(),i.restore()},convertPointsToSVGPath:function(t){var e,i=[],r=this.width/1e3,n=new fabric.Point(t[0].x,t[0].y),s=new fabric.Point(t[1].x,t[1].y),o=t.length,a=1,h=0,c=2<o;for(c&&(a=t[2].x<s.x?-1:t[2].x===s.x?0:1,h=t[2].y<s.y?-1:t[2].y===s.y?0:1),i.push("M ",n.x-a*r," ",n.y-h*r," "),e=1;e<o;e++){if(!n.eq(s)){var l=n.midPointFrom(s);i.push("Q ",n.x," ",n.y," ",l.x," ",l.y," ")}n=t[e],e+1<t.length&&(s=t[e+1])}return c&&(a=n.x>t[e-2].x?1:n.x===t[e-2].x?0:-1,h=n.y>t[e-2].y?1:n.y===t[e-2].y?0:-1),i.push("L ",n.x+a*r," ",n.y+h*r),i},createPath:function(t){var e=new fabric.Path(t,{fill:null,stroke:this.color,strokeWidth:this.width,strokeLineCap:this.strokeLineCap,strokeMiterLimit:this.strokeMiterLimit,strokeLineJoin:this.strokeLineJoin,strokeDashArray:this.strokeDashArray});return this.shadow&&(this.shadow.affectStroke=!0,e.shadow=new fabric.Shadow(this.shadow)),e},decimatePoints:function(t,e){if(t.length<=2)return t;var i,r=this.canvas.getZoom(),n=Math.pow(e/r,2),s=t.length-1,o=t[0],a=[o];for(i=1;i<s;i++)n<=Math.pow(o.x-t[i].x,2)+Math.pow(o.y-t[i].y,2)&&(o=t[i],a.push(o));return 1===a.length&&a.push(new fabric.Point(a[0].x,a[0].y)),a},_finalizeAndAddPath:function(){this.canvas.contextTop.closePath(),this.decimate&&(this._points=this.decimatePoints(this._points,this.decimate));var t=this.convertPointsToSVGPath(this._points).join("");if("M 0 0 Q 0 0 0 0 L 0 0"!==t){var e=this.createPath(t);this.canvas.clearContext(this.canvas.contextTop),this.canvas.fire("before:path:created",{path:e}),this.canvas.add(e),this.canvas.requestRenderAll(),e.setCoords(),this._resetShadow(),this.canvas.fire("path:created",{path:e})}else this.canvas.requestRenderAll()}}),fabric.CircleBrush=fabric.util.createClass(fabric.BaseBrush,{width:10,initialize:function(t){this.canvas=t,this.points=[]},drawDot:function(t){var e=this.addPoint(t),i=this.canvas.contextTop;this._saveAndTransform(i),this.dot(i,e),i.restore()},dot:function(t,e){t.fillStyle=e.fill,t.beginPath(),t.arc(e.x,e.y,e.radius,0,2*Math.PI,!1),t.closePath(),t.fill()},onMouseDown:function(t){this.points.length=0,this.canvas.clearContext(this.canvas.contextTop),this._setShadow(),this.drawDot(t)},_render:function(){var t,e,i=this.canvas.contextTop,r=this.points;for(this._saveAndTransform(i),t=0,e=r.length;t<e;t++)this.dot(i,r[t]);i.restore()},onMouseMove:function(t){this.needsFullRender()?(this.canvas.clearContext(this.canvas.contextTop),this.addPoint(t),this._render()):this.drawDot(t)},onMouseUp:function(){var t,e,i=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=!1;var r=[];for(t=0,e=this.points.length;t<e;t++){var n=this.points[t],s=new fabric.Circle({radius:n.radius,left:n.x,top:n.y,originX:"center",originY:"center",fill:n.fill});this.shadow&&(s.shadow=new fabric.Shadow(this.shadow)),r.push(s)}var o=new fabric.Group(r);o.canvas=this.canvas,this.canvas.fire("before:path:created",{path:o}),this.canvas.add(o),this.canvas.fire("path:created",{path:o}),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderOnAddRemove=i,this.canvas.requestRenderAll()},addPoint:function(t){var e=new fabric.Point(t.x,t.y),i=fabric.util.getRandomInt(Math.max(0,this.width-20),this.width+20)/2,r=new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0,100)/100).toRgba();return e.radius=i,e.fill=r,this.points.push(e),e}}),fabric.SprayBrush=fabric.util.createClass(fabric.BaseBrush,{width:10,density:20,dotWidth:1,dotWidthVariance:1,randomOpacity:!1,optimizeOverlapping:!0,initialize:function(t){this.canvas=t,this.sprayChunks=[]},onMouseDown:function(t){this.sprayChunks.length=0,this.canvas.clearContext(this.canvas.contextTop),this._setShadow(),this.addSprayChunk(t),this.render(this.sprayChunkPoints)},onMouseMove:function(t){this.addSprayChunk(t),this.render(this.sprayChunkPoints)},onMouseUp:function(){var t=this.canvas.renderOnAddRemove;this.canvas.renderOnAddRemove=!1;for(var e=[],i=0,r=this.sprayChunks.length;i<r;i++)for(var n=this.sprayChunks[i],s=0,o=n.length;s<o;s++){var a=new fabric.Rect({width:n[s].width,height:n[s].width,left:n[s].x+1,top:n[s].y+1,originX:"center",originY:"center",fill:this.color});e.push(a)}this.optimizeOverlapping&&(e=this._getOptimizedRects(e));var h=new fabric.Group(e);this.shadow&&h.set("shadow",new fabric.Shadow(this.shadow)),this.canvas.fire("before:path:created",{path:h}),this.canvas.add(h),this.canvas.fire("path:created",{path:h}),this.canvas.clearContext(this.canvas.contextTop),this._resetShadow(),this.canvas.renderOnAddRemove=t,this.canvas.requestRenderAll()},_getOptimizedRects:function(t){var e,i,r,n={};for(i=0,r=t.length;i<r;i++)n[e=t[i].left+""+t[i].top]||(n[e]=t[i]);var s=[];for(e in n)s.push(n[e]);return s},render:function(t){var e,i,r=this.canvas.contextTop;for(r.fillStyle=this.color,this._saveAndTransform(r),e=0,i=t.length;e<i;e++){var n=t[e];void 0!==n.opacity&&(r.globalAlpha=n.opacity),r.fillRect(n.x,n.y,n.width,n.width)}r.restore()},_render:function(){var t,e,i=this.canvas.contextTop;for(i.fillStyle=this.color,this._saveAndTransform(i),t=0,e=this.sprayChunks.length;t<e;t++)this.render(this.sprayChunks[t]);i.restore()},addSprayChunk:function(t){this.sprayChunkPoints=[];var e,i,r,n,s=this.width/2;for(n=0;n<this.density;n++){e=fabric.util.getRandomInt(t.x-s,t.x+s),i=fabric.util.getRandomInt(t.y-s,t.y+s),r=this.dotWidthVariance?fabric.util.getRandomInt(Math.max(1,this.dotWidth-this.dotWidthVariance),this.dotWidth+this.dotWidthVariance):this.dotWidth;var o=new fabric.Point(e,i);o.width=r,this.randomOpacity&&(o.opacity=fabric.util.getRandomInt(0,100)/100),this.sprayChunkPoints.push(o)}this.sprayChunks.push(this.sprayChunkPoints)}}),fabric.PatternBrush=fabric.util.createClass(fabric.PencilBrush,{getPatternSrc:function(){var t=fabric.util.createCanvasElement(),e=t.getContext("2d");return t.width=t.height=25,e.fillStyle=this.color,e.beginPath(),e.arc(10,10,10,0,2*Math.PI,!1),e.closePath(),e.fill(),t},getPatternSrcFunction:function(){return String(this.getPatternSrc).replace("this.color",'"'+this.color+'"')},getPattern:function(){return this.canvas.contextTop.createPattern(this.source||this.getPatternSrc(),"repeat")},_setBrushStyles:function(){this.callSuper("_setBrushStyles"),this.canvas.contextTop.strokeStyle=this.getPattern()},createPath:function(t){var e=this.callSuper("createPath",t),i=e._getLeftTopCoords().scalarAdd(e.strokeWidth/2);return e.stroke=new fabric.Pattern({source:this.source||this.getPatternSrcFunction(),offsetX:-i.x,offsetY:-i.y}),e}}),function(){var c=fabric.util.getPointer,u=fabric.util.degreesToRadians,h=Math.abs,l=fabric.StaticCanvas.supports("setLineDash"),f=fabric.util.isTouchEvent;for(var t in fabric.Canvas=fabric.util.createClass(fabric.StaticCanvas,{initialize:function(t,e){e||(e={}),this.renderAndResetBound=this.renderAndReset.bind(this),this.requestRenderAllBound=this.requestRenderAll.bind(this),this._initStatic(t,e),this._initInteractive(),this._createCacheCanvas()},uniformScaling:!0,uniScaleKey:"shiftKey",centeredScaling:!1,centeredRotation:!1,centeredKey:"altKey",altActionKey:"shiftKey",interactive:!0,selection:!0,selectionKey:"shiftKey",altSelectionKey:null,selectionColor:"rgba(100, 100, 255, 0.3)",selectionDashArray:[],selectionBorderColor:"rgba(255, 255, 255, 0.3)",selectionLineWidth:1,selectionFullyContained:!1,hoverCursor:"move",moveCursor:"move",defaultCursor:"default",freeDrawingCursor:"crosshair",rotationCursor:"crosshair",notAllowedCursor:"not-allowed",containerClass:"canvas-container",perPixelTargetFind:!1,targetFindTolerance:0,skipTargetFind:!1,isDrawingMode:!1,preserveObjectStacking:!1,snapAngle:0,snapThreshold:null,stopContextMenu:!1,fireRightClick:!1,fireMiddleClick:!1,targets:[],_hoveredTarget:null,_hoveredTargets:[],_initInteractive:function(){this._currentTransform=null,this._groupSelector=null,this._initWrapperElement(),this._createUpperCanvas(),this._initEventListeners(),this._initRetinaScaling(),this.freeDrawingBrush=fabric.PencilBrush&&new fabric.PencilBrush(this),this.calcOffset()},_chooseObjectsToRender:function(){var t,e,i,r=this.getActiveObjects();if(0<r.length&&!this.preserveObjectStacking){e=[],i=[];for(var n=0,s=this._objects.length;n<s;n++)t=this._objects[n],-1===r.indexOf(t)?e.push(t):i.push(t);1<r.length&&(this._activeObject._objects=i),e.push.apply(e,i)}else e=this._objects;return e},renderAll:function(){!this.contextTopDirty||this._groupSelector||this.isDrawingMode||(this.clearContext(this.contextTop),this.contextTopDirty=!1),this.hasLostContext&&this.renderTopLayer(this.contextTop);var t=this.contextContainer;return this.renderCanvas(t,this._chooseObjectsToRender()),this},renderTopLayer:function(t){t.save(),this.isDrawingMode&&this._isCurrentlyDrawing&&(this.freeDrawingBrush&&this.freeDrawingBrush._render(),this.contextTopDirty=!0),this.selection&&this._groupSelector&&(this._drawSelection(t),this.contextTopDirty=!0),t.restore()},renderTop:function(){var t=this.contextTop;return this.clearContext(t),this.renderTopLayer(t),this.fire("after:render"),this},_normalizePointer:function(t,e){var i=t.calcTransformMatrix(),r=fabric.util.invertTransform(i),n=this.restorePointerVpt(e);return fabric.util.transformPoint(n,r)},isTargetTransparent:function(t,e,i){if(t.shouldCache()&&t._cacheCanvas&&t!==this._activeObject){var r=this._normalizePointer(t,{x:e,y:i}),n=Math.max(t.cacheTranslationX+r.x*t.zoomX,0),s=Math.max(t.cacheTranslationY+r.y*t.zoomY,0);return fabric.util.isTransparent(t._cacheContext,Math.round(n),Math.round(s),this.targetFindTolerance)}var o=this.contextCache,a=t.selectionBackgroundColor,h=this.viewportTransform;return t.selectionBackgroundColor="",this.clearContext(o),o.save(),o.transform(h[0],h[1],h[2],h[3],h[4],h[5]),t.render(o),o.restore(),t===this._activeObject&&t._renderControls(o,{hasBorders:!1,transparentCorners:!1},{hasBorders:!1}),t.selectionBackgroundColor=a,fabric.util.isTransparent(o,e,i,this.targetFindTolerance)},_isSelectionKeyPressed:function(e){return"[object Array]"===Object.prototype.toString.call(this.selectionKey)?!!this.selectionKey.find(function(t){return!0===e[t]}):e[this.selectionKey]},_shouldClearSelection:function(t,e){var i=this.getActiveObjects(),r=this._activeObject;return!e||e&&r&&1<i.length&&-1===i.indexOf(e)&&r!==e&&!this._isSelectionKeyPressed(t)||e&&!e.evented||e&&!e.selectable&&r&&r!==e},_shouldCenterTransform:function(t,e,i){var r;if(t)return"scale"===e||"scaleX"===e||"scaleY"===e||"resizing"===e?r=this.centeredScaling||t.centeredScaling:"rotate"===e&&(r=this.centeredRotation||t.centeredRotation),r?!i:i},_getOriginFromCorner:function(t,e){var i={x:t.originX,y:t.originY};return"ml"===e||"tl"===e||"bl"===e?i.x="right":"mr"!==e&&"tr"!==e&&"br"!==e||(i.x="left"),"tl"===e||"mt"===e||"tr"===e?i.y="bottom":"bl"!==e&&"mb"!==e&&"br"!==e||(i.y="top"),i},_getActionFromCorner:function(t,e,i,r){if(!e||!t)return"drag";var n=r.controls[e];return n.getActionName(i,n,r)},_setupCurrentTransform:function(t,e,i){if(e){var r=this.getPointer(t),n=e.__corner,s=e.controls[n],o=i&&n?s.getActionHandler(t,e,s):fabric.controlsUtils.dragHandler,a=this._getActionFromCorner(i,n,t,e),h=this._getOriginFromCorner(e,n),c=t[this.centeredKey],l={target:e,action:a,actionHandler:o,corner:n,scaleX:e.scaleX,scaleY:e.scaleY,skewX:e.skewX,skewY:e.skewY,offsetX:r.x-e.left,offsetY:r.y-e.top,originX:h.x,originY:h.y,ex:r.x,ey:r.y,lastX:r.x,lastY:r.y,theta:u(e.angle),width:e.width*e.scaleX,shiftKey:t.shiftKey,altKey:c,original:fabric.util.saveObjectTransform(e)};this._shouldCenterTransform(e,a,c)&&(l.originX="center",l.originY="center"),l.original.originX=h.x,l.original.originY=h.y,this._currentTransform=l,this._beforeTransform(t)}},setCursor:function(t){this.upperCanvasEl.style.cursor=t},_drawSelection:function(t){var e=this._groupSelector,i=e.left,r=e.top,n=h(i),s=h(r);if(this.selectionColor&&(t.fillStyle=this.selectionColor,t.fillRect(e.ex-(0<i?0:-i),e.ey-(0<r?0:-r),n,s)),this.selectionLineWidth&&this.selectionBorderColor)if(t.lineWidth=this.selectionLineWidth,t.strokeStyle=this.selectionBorderColor,1<this.selectionDashArray.length&&!l){var o=e.ex+.5-(0<i?0:n),a=e.ey+.5-(0<r?0:s);t.beginPath(),fabric.util.drawDashedLine(t,o,a,o+n,a,this.selectionDashArray),fabric.util.drawDashedLine(t,o,a+s-1,o+n,a+s-1,this.selectionDashArray),fabric.util.drawDashedLine(t,o,a,o,a+s,this.selectionDashArray),fabric.util.drawDashedLine(t,o+n-1,a,o+n-1,a+s,this.selectionDashArray),t.closePath(),t.stroke()}else fabric.Object.prototype._setLineDash.call(this,t,this.selectionDashArray),t.strokeRect(e.ex+.5-(0<i?0:n),e.ey+.5-(0<r?0:s),n,s)},findTarget:function(t,e){if(!this.skipTargetFind){var i,r,n=this.getPointer(t,!0),s=this._activeObject,o=this.getActiveObjects(),a=f(t);if(this.targets=[],1<o.length&&!e&&s===this._searchPossibleTargets([s],n))return s;if(1===o.length&&s._findTargetCorner(n,a))return s;if(1===o.length&&s===this._searchPossibleTargets([s],n)){if(!this.preserveObjectStacking)return s;i=s,r=this.targets,this.targets=[]}var h=this._searchPossibleTargets(this._objects,n);return t[this.altSelectionKey]&&h&&i&&h!==i&&(h=i,this.targets=r),h}},_checkTarget:function(t,e,i){if(e&&e.visible&&e.evented&&(e.containsPoint(t)||e._findTargetCorner(t))){if(!this.perPixelTargetFind&&!e.perPixelTargetFind||e.isEditing)return!0;if(!this.isTargetTransparent(e,i.x,i.y))return!0}},_searchPossibleTargets:function(t,e){for(var i,r,n=t.length;n--;){var s=t[n],o=s.group?this._normalizePointer(s.group,e):e;if(this._checkTarget(o,s,e)){(i=t[n]).subTargetCheck&&i instanceof fabric.Group&&(r=this._searchPossibleTargets(i._objects,e))&&this.targets.push(r);break}}return i},restorePointerVpt:function(t){return fabric.util.transformPoint(t,fabric.util.invertTransform(this.viewportTransform))},getPointer:function(t,e){if(this._absolutePointer&&!e)return this._absolutePointer;if(this._pointer&&e)return this._pointer;var i,r=c(t),n=this.upperCanvasEl,s=n.getBoundingClientRect(),o=s.width||0,a=s.height||0;o&&a||("top"in s&&"bottom"in s&&(a=Math.abs(s.top-s.bottom)),"right"in s&&"left"in s&&(o=Math.abs(s.right-s.left))),this.calcOffset(),r.x=r.x-this._offset.left,r.y=r.y-this._offset.top,e||(r=this.restorePointerVpt(r));var h=this.getRetinaScaling();return 1!==h&&(r.x/=h,r.y/=h),i=0===o||0===a?{width:1,height:1}:{width:n.width/o,height:n.height/a},{x:r.x*i.width,y:r.y*i.height}},_createUpperCanvas:function(){var t=this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/,""),e=this.lowerCanvasEl,i=this.upperCanvasEl;i?i.className="":(i=this._createCanvasElement(),this.upperCanvasEl=i),fabric.util.addClass(i,"upper-canvas "+t),this.wrapperEl.appendChild(i),this._copyCanvasStyle(e,i),this._applyCanvasStyle(i),this.contextTop=i.getContext("2d")},_createCacheCanvas:function(){this.cacheCanvasEl=this._createCanvasElement(),this.cacheCanvasEl.setAttribute("width",this.width),this.cacheCanvasEl.setAttribute("height",this.height),this.contextCache=this.cacheCanvasEl.getContext("2d")},_initWrapperElement:function(){this.wrapperEl=fabric.util.wrapElement(this.lowerCanvasEl,"div",{class:this.containerClass}),fabric.util.setStyle(this.wrapperEl,{width:this.width+"px",height:this.height+"px",position:"relative"}),fabric.util.makeElementUnselectable(this.wrapperEl)},_applyCanvasStyle:function(t){var e=this.width||t.width,i=this.height||t.height;fabric.util.setStyle(t,{position:"absolute",width:e+"px",height:i+"px",left:0,top:0,"touch-action":this.allowTouchScrolling?"manipulation":"none","-ms-touch-action":this.allowTouchScrolling?"manipulation":"none"}),t.width=e,t.height=i,fabric.util.makeElementUnselectable(t)},_copyCanvasStyle:function(t,e){e.style.cssText=t.style.cssText},getSelectionContext:function(){return this.contextTop},getSelectionElement:function(){return this.upperCanvasEl},getActiveObject:function(){return this._activeObject},getActiveObjects:function(){var t=this._activeObject;return t?"activeSelection"===t.type&&t._objects?t._objects.slice(0):[t]:[]},_onObjectRemoved:function(t){t===this._activeObject&&(this.fire("before:selection:cleared",{target:t}),this._discardActiveObject(),this.fire("selection:cleared",{target:t}),t.fire("deselected")),t===this._hoveredTarget&&(this._hoveredTarget=null,this._hoveredTargets=[]),this.callSuper("_onObjectRemoved",t)},_fireSelectionEvents:function(e,t){var i=!1,r=this.getActiveObjects(),n=[],s=[],o={e:t};e.forEach(function(t){-1===r.indexOf(t)&&(i=!0,t.fire("deselected",o),s.push(t))}),r.forEach(function(t){-1===e.indexOf(t)&&(i=!0,t.fire("selected",o),n.push(t))}),0<e.length&&0<r.length?(o.selected=n,o.deselected=s,o.updated=n[0]||s[0],o.target=this._activeObject,i&&this.fire("selection:updated",o)):0<r.length?(o.selected=n,o.target=this._activeObject,this.fire("selection:created",o)):0<e.length&&(o.deselected=s,this.fire("selection:cleared",o))},setActiveObject:function(t,e){var i=this.getActiveObjects();return this._setActiveObject(t,e),this._fireSelectionEvents(i,e),this},_setActiveObject:function(t,e){return this._activeObject!==t&&(!!this._discardActiveObject(e,t)&&(!t.onSelect({e:e})&&(this._activeObject=t,!0)))},_discardActiveObject:function(t,e){var i=this._activeObject;if(i){if(i.onDeselect({e:t,object:e}))return!1;this._activeObject=null}return!0},discardActiveObject:function(t){var e=this.getActiveObjects(),i=this.getActiveObject();return e.length&&this.fire("before:selection:cleared",{target:i,e:t}),this._discardActiveObject(t),this._fireSelectionEvents(e,t),this},dispose:function(){var t=this.wrapperEl;return this.removeListeners(),t.removeChild(this.upperCanvasEl),t.removeChild(this.lowerCanvasEl),this.contextCache=null,this.contextTop=null,["upperCanvasEl","cacheCanvasEl"].forEach(function(t){fabric.util.cleanUpJsdomNode(this[t]),this[t]=void 0}.bind(this)),t.parentNode&&t.parentNode.replaceChild(this.lowerCanvasEl,this.wrapperEl),delete this.wrapperEl,fabric.StaticCanvas.prototype.dispose.call(this),this},clear:function(){return this.discardActiveObject(),this.clearContext(this.contextTop),this.callSuper("clear")},drawControls:function(t){var e=this._activeObject;e&&e._renderControls(t)},_toObject:function(t,e,i){var r=this._realizeGroupTransformOnObject(t),n=this.callSuper("_toObject",t,e,i);return this._unwindGroupTransformOnObject(t,r),n},_realizeGroupTransformOnObject:function(e){if(e.group&&"activeSelection"===e.group.type&&this._activeObject===e.group){var i={};return["angle","flipX","flipY","left","scaleX","scaleY","skewX","skewY","top"].forEach(function(t){i[t]=e[t]}),this._activeObject.realizeTransform(e),i}return null},_unwindGroupTransformOnObject:function(t,e){e&&t.set(e)},_setSVGObject:function(t,e,i){var r=this._realizeGroupTransformOnObject(e);this.callSuper("_setSVGObject",t,e,i),this._unwindGroupTransformOnObject(e,r)},setViewportTransform:function(t){this.renderOnAddRemove&&this._activeObject&&this._activeObject.isEditing&&this._activeObject.clearContextTop(),fabric.StaticCanvas.prototype.setViewportTransform.call(this,t)}}),fabric.StaticCanvas)"prototype"!==t&&(fabric.Canvas[t]=fabric.StaticCanvas[t])}(),function(){var r=fabric.util.addListener,n=fabric.util.removeListener,s={passive:!1};function u(t,e){return t.button&&t.button===e-1}fabric.util.object.extend(fabric.Canvas.prototype,{mainTouchId:null,_initEventListeners:function(){this.removeListeners(),this._bindEvents(),this.addOrRemove(r,"add")},_getEventPrefix:function(){return this.enablePointerEvents?"pointer":"mouse"},addOrRemove:function(t,e){var i=this.upperCanvasEl,r=this._getEventPrefix();t(fabric.window,"resize",this._onResize),t(i,r+"down",this._onMouseDown),t(i,r+"move",this._onMouseMove,s),t(i,r+"out",this._onMouseOut),t(i,r+"enter",this._onMouseEnter),t(i,"wheel",this._onMouseWheel),t(i,"contextmenu",this._onContextMenu),t(i,"dblclick",this._onDoubleClick),t(i,"dragover",this._onDragOver),t(i,"dragenter",this._onDragEnter),t(i,"dragleave",this._onDragLeave),t(i,"drop",this._onDrop),this.enablePointerEvents||t(i,"touchstart",this._onTouchStart,s),"undefined"!=typeof eventjs&&e in eventjs&&(eventjs[e](i,"gesture",this._onGesture),eventjs[e](i,"drag",this._onDrag),eventjs[e](i,"orientation",this._onOrientationChange),eventjs[e](i,"shake",this._onShake),eventjs[e](i,"longpress",this._onLongPress))},removeListeners:function(){this.addOrRemove(n,"remove");var t=this._getEventPrefix();n(fabric.document,t+"up",this._onMouseUp),n(fabric.document,"touchend",this._onTouchEnd,s),n(fabric.document,t+"move",this._onMouseMove,s),n(fabric.document,"touchmove",this._onMouseMove,s)},_bindEvents:function(){this.eventsBound||(this._onMouseDown=this._onMouseDown.bind(this),this._onTouchStart=this._onTouchStart.bind(this),this._onMouseMove=this._onMouseMove.bind(this),this._onMouseUp=this._onMouseUp.bind(this),this._onTouchEnd=this._onTouchEnd.bind(this),this._onResize=this._onResize.bind(this),this._onGesture=this._onGesture.bind(this),this._onDrag=this._onDrag.bind(this),this._onShake=this._onShake.bind(this),this._onLongPress=this._onLongPress.bind(this),this._onOrientationChange=this._onOrientationChange.bind(this),this._onMouseWheel=this._onMouseWheel.bind(this),this._onMouseOut=this._onMouseOut.bind(this),this._onMouseEnter=this._onMouseEnter.bind(this),this._onContextMenu=this._onContextMenu.bind(this),this._onDoubleClick=this._onDoubleClick.bind(this),this._onDragOver=this._onDragOver.bind(this),this._onDragEnter=this._simpleEventHandler.bind(this,"dragenter"),this._onDragLeave=this._simpleEventHandler.bind(this,"dragleave"),this._onDrop=this._simpleEventHandler.bind(this,"drop"),this.eventsBound=!0)},_onGesture:function(t,e){this.__onTransformGesture&&this.__onTransformGesture(t,e)},_onDrag:function(t,e){this.__onDrag&&this.__onDrag(t,e)},_onMouseWheel:function(t){this.__onMouseWheel(t)},_onMouseOut:function(e){var i=this._hoveredTarget;this.fire("mouse:out",{target:i,e:e}),this._hoveredTarget=null,i&&i.fire("mouseout",{e:e});var r=this;this._hoveredTargets.forEach(function(t){r.fire("mouse:out",{target:i,e:e}),t&&i.fire("mouseout",{e:e})}),this._hoveredTargets=[],this._iTextInstances&&this._iTextInstances.forEach(function(t){t.isEditing&&t.hiddenTextarea.focus()})},_onMouseEnter:function(t){this._currentTransform||this.findTarget(t)||(this.fire("mouse:over",{target:null,e:t}),this._hoveredTarget=null,this._hoveredTargets=[])},_onOrientationChange:function(t,e){this.__onOrientationChange&&this.__onOrientationChange(t,e)},_onShake:function(t,e){this.__onShake&&this.__onShake(t,e)},_onLongPress:function(t,e){this.__onLongPress&&this.__onLongPress(t,e)},_onDragOver:function(t){t.preventDefault();var e=this._simpleEventHandler("dragover",t);this._fireEnterLeaveEvents(e,t)},_onContextMenu:function(t){return this.stopContextMenu&&(t.stopPropagation(),t.preventDefault()),!1},_onDoubleClick:function(t){this._cacheTransformEventData(t),this._handleEvent(t,"dblclick"),this._resetTransformEventData(t)},getPointerId:function(t){var e=t.changedTouches;return e?e[0]&&e[0].identifier:this.enablePointerEvents?t.pointerId:-1},_isMainEvent:function(t){return!0===t.isPrimary||!1!==t.isPrimary&&("touchend"===t.type&&0===t.touches.length||(!t.changedTouches||t.changedTouches[0].identifier===this.mainTouchId))},_onTouchStart:function(t){t.preventDefault(),null===this.mainTouchId&&(this.mainTouchId=this.getPointerId(t)),this.__onMouseDown(t),this._resetTransformEventData();var e=this.upperCanvasEl,i=this._getEventPrefix();r(fabric.document,"touchend",this._onTouchEnd,s),r(fabric.document,"touchmove",this._onMouseMove,s),n(e,i+"down",this._onMouseDown)},_onMouseDown:function(t){this.__onMouseDown(t),this._resetTransformEventData();var e=this.upperCanvasEl,i=this._getEventPrefix();n(e,i+"move",this._onMouseMove,s),r(fabric.document,i+"up",this._onMouseUp),r(fabric.document,i+"move",this._onMouseMove,s)},_onTouchEnd:function(t){if(!(0<t.touches.length)){this.__onMouseUp(t),this._resetTransformEventData(),this.mainTouchId=null;var e=this._getEventPrefix();n(fabric.document,"touchend",this._onTouchEnd,s),n(fabric.document,"touchmove",this._onMouseMove,s);var i=this;this._willAddMouseDown&&clearTimeout(this._willAddMouseDown),this._willAddMouseDown=setTimeout(function(){r(i.upperCanvasEl,e+"down",i._onMouseDown),i._willAddMouseDown=0},400)}},_onMouseUp:function(t){this.__onMouseUp(t),this._resetTransformEventData();var e=this.upperCanvasEl,i=this._getEventPrefix();this._isMainEvent(t)&&(n(fabric.document,i+"up",this._onMouseUp),n(fabric.document,i+"move",this._onMouseMove,s),r(e,i+"move",this._onMouseMove,s))},_onMouseMove:function(t){!this.allowTouchScrolling&&t.preventDefault&&t.preventDefault(),this.__onMouseMove(t)},_onResize:function(){this.calcOffset()},_shouldRender:function(t){var e=this._activeObject;return!!(!!e!=!!t||e&&t&&e!==t)||(e&&e.isEditing,!1)},__onMouseUp:function(t){var e,i=this._currentTransform,r=this._groupSelector,n=!1,s=!r||0===r.left&&0===r.top;if(this._cacheTransformEventData(t),e=this._target,this._handleEvent(t,"up:before"),u(t,3))this.fireRightClick&&this._handleEvent(t,"up",3,s);else{if(u(t,2))return this.fireMiddleClick&&this._handleEvent(t,"up",2,s),void this._resetTransformEventData();if(this.isDrawingMode&&this._isCurrentlyDrawing)this._onMouseUpInDrawingMode(t);else if(this._isMainEvent(t)){if(i&&(this._finalizeCurrentTransform(t),n=i.actionPerformed),!s){var o=e===this._activeObject;this._maybeGroupObjects(t),n||(n=this._shouldRender(e)||!o&&e===this._activeObject)}if(e){var a=e._findTargetCorner(this.getPointer(t,!0),fabric.util.isTouchEvent(t)),h=e.controls[a],c=h&&h.getMouseUpHandler(t,e,h);if(c){var l=this.getPointer(t);c(t,i,l.x,l.y)}e.isMoving=!1}this._setCursorFromEvent(t,e),this._handleEvent(t,"up",1,s),this._groupSelector=null,this._currentTransform=null,e&&(e.__corner=0),n?this.requestRenderAll():s||this.renderTop()}}},_simpleEventHandler:function(t,e){var i=this.findTarget(e),r=this.targets,n={e:e,target:i,subTargets:r};if(this.fire(t,n),i&&i.fire(t,n),!r)return i;for(var s=0;s<r.length;s++)r[s].fire(t,n);return i},_handleEvent:function(t,e,i,r){var n=this._target,s=this.targets||[],o={e:t,target:n,subTargets:s,button:i||1,isClick:r||!1,pointer:this._pointer,absolutePointer:this._absolutePointer,transform:this._currentTransform};"up"===e&&(o.currentTarget=this.findTarget(t),o.currentSubTargets=this.targets),this.fire("mouse:"+e,o),n&&n.fire("mouse"+e,o);for(var a=0;a<s.length;a++)s[a].fire("mouse"+e,o)},_finalizeCurrentTransform:function(t){var e,i=this._currentTransform,r=i.target,n={e:t,target:r,transform:i,action:i.action};r._scaling&&(r._scaling=!1),r.setCoords(),(i.actionPerformed||this.stateful&&r.hasStateChanged())&&(i.actionPerformed&&(e=this._addEventOptions(n,i),this._fire(e,n)),this._fire("modified",n))},_addEventOptions:function(t,e){var i,r;switch(e.action){case"scaleX":i="scaled",r="x";break;case"scaleY":i="scaled",r="y";break;case"skewX":i="skewed",r="x";break;case"skewY":i="skewed",r="y";break;case"scale":i="scaled",r="equally";break;case"rotate":i="rotated";break;case"drag":i="moved"}return t.by=r,i},_onMouseDownInDrawingMode:function(t){this._isCurrentlyDrawing=!0,this.getActiveObject()&&this.discardActiveObject(t).requestRenderAll();var e=this.getPointer(t);this.freeDrawingBrush.onMouseDown(e,{e:t,pointer:e}),this._handleEvent(t,"down")},_onMouseMoveInDrawingMode:function(t){if(this._isCurrentlyDrawing){var e=this.getPointer(t);this.freeDrawingBrush.onMouseMove(e,{e:t,pointer:e})}this.setCursor(this.freeDrawingCursor),this._handleEvent(t,"move")},_onMouseUpInDrawingMode:function(t){var e=this.getPointer(t);this._isCurrentlyDrawing=this.freeDrawingBrush.onMouseUp({e:t,pointer:e}),this._handleEvent(t,"up")},__onMouseDown:function(t){this._cacheTransformEventData(t),this._handleEvent(t,"down:before");var e=this._target;if(u(t,3))this.fireRightClick&&this._handleEvent(t,"down",3);else if(u(t,2))this.fireMiddleClick&&this._handleEvent(t,"down",2);else if(this.isDrawingMode)this._onMouseDownInDrawingMode(t);else if(this._isMainEvent(t)&&!this._currentTransform){var i=this._pointer;this._previousPointer=i;var r=this._shouldRender(e),n=this._shouldGroup(t,e);if(this._shouldClearSelection(t,e)?this.discardActiveObject(t):n&&(this._handleGrouping(t,e),e=this._activeObject),!this.selection||e&&(e.selectable||e.isEditing||e===this._activeObject)||(this._groupSelector={ex:i.x,ey:i.y,top:0,left:0}),e){var s=e===this._activeObject;e.selectable&&this.setActiveObject(e,t);var o=e._findTargetCorner(this.getPointer(t,!0),fabric.util.isTouchEvent(t));if(e.__corner=o,e===this._activeObject&&(o||!n)){this._setupCurrentTransform(t,e,s);var a=e.controls[o],h=(i=this.getPointer(t),a&&a.getMouseDownHandler(t,e,a));h&&h(t,this._currentTransform,i.x,i.y)}}this._handleEvent(t,"down"),(r||n)&&this.requestRenderAll()}},_resetTransformEventData:function(){this._target=null,this._pointer=null,this._absolutePointer=null},_cacheTransformEventData:function(t){this._resetTransformEventData(),this._pointer=this.getPointer(t,!0),this._absolutePointer=this.restorePointerVpt(this._pointer),this._target=this._currentTransform?this._currentTransform.target:this.findTarget(t)||null},_beforeTransform:function(t){var e=this._currentTransform;this.stateful&&e.target.saveState(),this.fire("before:transform",{e:t,transform:e})},__onMouseMove:function(t){var e,i;if(this._handleEvent(t,"move:before"),this._cacheTransformEventData(t),this.isDrawingMode)this._onMouseMoveInDrawingMode(t);else if(this._isMainEvent(t)){var r=this._groupSelector;r?(i=this._pointer,r.left=i.x-r.ex,r.top=i.y-r.ey,this.renderTop()):this._currentTransform?this._transformObject(t):(e=this.findTarget(t)||null,this._setCursorFromEvent(t,e),this._fireOverOutEvents(e,t)),this._handleEvent(t,"move"),this._resetTransformEventData()}},_fireOverOutEvents:function(t,e){var i=this._hoveredTarget,r=this._hoveredTargets,n=this.targets,s=Math.max(r.length,n.length);this.fireSyntheticInOutEvents(t,e,{oldTarget:i,evtOut:"mouseout",canvasEvtOut:"mouse:out",evtIn:"mouseover",canvasEvtIn:"mouse:over"});for(var o=0;o<s;o++)this.fireSyntheticInOutEvents(n[o],e,{oldTarget:r[o],evtOut:"mouseout",evtIn:"mouseover"});this._hoveredTarget=t,this._hoveredTargets=this.targets.concat()},_fireEnterLeaveEvents:function(t,e){var i=this._draggedoverTarget,r=this._hoveredTargets,n=this.targets,s=Math.max(r.length,n.length);this.fireSyntheticInOutEvents(t,e,{oldTarget:i,evtOut:"dragleave",evtIn:"dragenter"});for(var o=0;o<s;o++)this.fireSyntheticInOutEvents(n[o],e,{oldTarget:r[o],evtOut:"dragleave",evtIn:"dragenter"});this._draggedoverTarget=t},fireSyntheticInOutEvents:function(t,e,i){var r,n,s,o=i.oldTarget,a=o!==t,h=i.canvasEvtIn,c=i.canvasEvtOut;a&&(r={e:e,target:t,previousTarget:o},n={e:e,target:o,nextTarget:t}),s=t&&a,o&&a&&(c&&this.fire(c,n),o.fire(i.evtOut,n)),s&&(h&&this.fire(h,r),t.fire(i.evtIn,r))},__onMouseWheel:function(t){this._cacheTransformEventData(t),this._handleEvent(t,"wheel"),this._resetTransformEventData()},_transformObject:function(t){var e=this.getPointer(t),i=this._currentTransform;i.reset=!1,i.target.isMoving=!0,i.shiftKey=t.shiftKey,i.altKey=t[this.centeredKey],this._performTransformAction(t,i,e),i.actionPerformed&&this.requestRenderAll()},_performTransformAction:function(t,e,i){var r=i.x,n=i.y,s=e.action,o=!1,a=e.actionHandler;a&&(o=a(t,e,r,n)),"drag"===s&&o&&this.setCursor(e.target.moveCursor||this.moveCursor),e.actionPerformed=e.actionPerformed||o},_fire:fabric.controlsUtils.fireEvent,_setCursorFromEvent:function(t,e){if(!e)return this.setCursor(this.defaultCursor),!1;var i=e.hoverCursor||this.hoverCursor,r=this._activeObject&&"activeSelection"===this._activeObject.type?this._activeObject:null,n=(!r||!r.contains(e))&&e._findTargetCorner(this.getPointer(t,!0));n?this.setCursor(this.getCornerCursor(n,e,t)):(e.subTargetCheck&&this.targets.concat().reverse().map(function(t){i=t.hoverCursor||i}),this.setCursor(i))},getCornerCursor:function(t,e,i){var r=e.controls[t];return r.cursorStyleHandler(i,r,e)}})}(),function(){var f=Math.min,d=Math.max;fabric.util.object.extend(fabric.Canvas.prototype,{_shouldGroup:function(t,e){var i=this._activeObject;return i&&this._isSelectionKeyPressed(t)&&e&&e.selectable&&this.selection&&(i!==e||"activeSelection"===i.type)&&!e.onSelect({e:t})},_handleGrouping:function(t,e){var i=this._activeObject;i.__corner||(e!==i||(e=this.findTarget(t,!0))&&e.selectable)&&(i&&"activeSelection"===i.type?this._updateActiveSelection(e,t):this._createActiveSelection(e,t))},_updateActiveSelection:function(t,e){var i=this._activeObject,r=i._objects.slice(0);i.contains(t)?(i.removeWithUpdate(t),this._hoveredTarget=t,this._hoveredTargets=this.targets.concat(),1===i.size()&&this._setActiveObject(i.item(0),e)):(i.addWithUpdate(t),this._hoveredTarget=i,this._hoveredTargets=this.targets.concat()),this._fireSelectionEvents(r,e)},_createActiveSelection:function(t,e){var i=this.getActiveObjects(),r=this._createGroup(t);this._hoveredTarget=r,this._setActiveObject(r,e),this._fireSelectionEvents(i,e)},_createGroup:function(t){var e=this._objects,i=e.indexOf(this._activeObject)<e.indexOf(t)?[this._activeObject,t]:[t,this._activeObject];return this._activeObject.isEditing&&this._activeObject.exitEditing(),new fabric.ActiveSelection(i,{canvas:this})},_groupSelectedObjects:function(t){var e,i=this._collectObjects(t);1===i.length?this.setActiveObject(i[0],t):1<i.length&&(e=new fabric.ActiveSelection(i.reverse(),{canvas:this}),this.setActiveObject(e,t))},_collectObjects:function(e){for(var t,i=[],r=this._groupSelector.ex,n=this._groupSelector.ey,s=r+this._groupSelector.left,o=n+this._groupSelector.top,a=new fabric.Point(f(r,s),f(n,o)),h=new fabric.Point(d(r,s),d(n,o)),c=!this.selectionFullyContained,l=r===s&&n===o,u=this._objects.length;u--&&!((t=this._objects[u])&&t.selectable&&t.visible&&(c&&t.intersectsWithRect(a,h)||t.isContainedWithinRect(a,h)||c&&t.containsPoint(a)||c&&t.containsPoint(h))&&(i.push(t),l)););return 1<i.length&&(i=i.filter(function(t){return!t.onSelect({e:e})})),i},_maybeGroupObjects:function(t){this.selection&&this._groupSelector&&this._groupSelectedObjects(t),this.setCursor(this.defaultCursor),this._groupSelector=null}})}(),fabric.util.object.extend(fabric.StaticCanvas.prototype,{toDataURL:function(t){t||(t={});var e=t.format||"png",i=t.quality||1,r=(t.multiplier||1)*(t.enableRetinaScaling?this.getRetinaScaling():1),n=this.toCanvasElement(r,t);return fabric.util.toDataURL(n,e,i)},toCanvasElement:function(t,e){t=t||1;var i=((e=e||{}).width||this.width)*t,r=(e.height||this.height)*t,n=this.getZoom(),s=this.width,o=this.height,a=n*t,h=this.viewportTransform,c=(h[4]-(e.left||0))*t,l=(h[5]-(e.top||0))*t,u=this.interactive,f=[a,0,0,a,c,l],d=this.enableRetinaScaling,g=fabric.util.createCanvasElement(),p=this.contextTop;return g.width=i,g.height=r,this.contextTop=null,this.enableRetinaScaling=!1,this.interactive=!1,this.viewportTransform=f,this.width=i,this.height=r,this.calcViewportBoundaries(),this.renderCanvas(g.getContext("2d"),this._objects),this.viewportTransform=h,this.width=s,this.height=o,this.calcViewportBoundaries(),this.interactive=u,this.enableRetinaScaling=d,this.contextTop=p,g}}),fabric.util.object.extend(fabric.StaticCanvas.prototype,{loadFromJSON:function(t,i,e){if(t){var r="string"==typeof t?JSON.parse(t):fabric.util.object.clone(t),n=this,s=r.clipPath,o=this.renderOnAddRemove;return this.renderOnAddRemove=!1,delete r.clipPath,this._enlivenObjects(r.objects,function(e){n.clear(),n._setBgOverlay(r,function(){s?n._enlivenObjects([s],function(t){n.clipPath=t[0],n.__setupCanvas.call(n,r,e,o,i)}):n.__setupCanvas.call(n,r,e,o,i)})},e),this}},__setupCanvas:function(t,e,i,r){var n=this;e.forEach(function(t,e){n.insertAt(t,e)}),this.renderOnAddRemove=i,delete t.objects,delete t.backgroundImage,delete t.overlayImage,delete t.background,delete t.overlay,this._setOptions(t),this.renderAll(),r&&r()},_setBgOverlay:function(t,e){var i={backgroundColor:!1,overlayColor:!1,backgroundImage:!1,overlayImage:!1};if(t.backgroundImage||t.overlayImage||t.background||t.overlay){var r=function(){i.backgroundImage&&i.overlayImage&&i.backgroundColor&&i.overlayColor&&e&&e()};this.__setBgOverlay("backgroundImage",t.backgroundImage,i,r),this.__setBgOverlay("overlayImage",t.overlayImage,i,r),this.__setBgOverlay("backgroundColor",t.background,i,r),this.__setBgOverlay("overlayColor",t.overlay,i,r)}else e&&e()},__setBgOverlay:function(e,t,i,r){var n=this;if(!t)return i[e]=!0,void(r&&r());"backgroundImage"===e||"overlayImage"===e?fabric.util.enlivenObjects([t],function(t){n[e]=t[0],i[e]=!0,r&&r()}):this["set"+fabric.util.string.capitalize(e,!0)](t,function(){i[e]=!0,r&&r()})},_enlivenObjects:function(t,e,i){t&&0!==t.length?fabric.util.enlivenObjects(t,function(t){e&&e(t)},null,i):e&&e([])},_toDataURL:function(e,i){this.clone(function(t){i(t.toDataURL(e))})},_toDataURLWithMultiplier:function(e,i,r){this.clone(function(t){r(t.toDataURLWithMultiplier(e,i))})},clone:function(e,t){var i=JSON.stringify(this.toJSON(t));this.cloneWithoutData(function(t){t.loadFromJSON(i,function(){e&&e(t)})})},cloneWithoutData:function(t){var e=fabric.util.createCanvasElement();e.width=this.width,e.height=this.height;var i=new fabric.Canvas(e);this.backgroundImage?(i.setBackgroundImage(this.backgroundImage.src,function(){i.renderAll(),t&&t(i)}),i.backgroundImageOpacity=this.backgroundImageOpacity,i.backgroundImageStretch=this.backgroundImageStretch):t&&t(i)}}),function(t){"use strict";var x=t.fabric||(t.fabric={}),e=x.util.object.extend,o=x.util.object.clone,r=x.util.toFixed,i=x.util.string.capitalize,a=x.util.degreesToRadians,n=x.StaticCanvas.supports("setLineDash"),s=!x.isLikelyNode;x.Object||(x.Object=x.util.createClass(x.CommonMethods,{type:"object",originX:"left",originY:"top",top:0,left:0,width:0,height:0,scaleX:1,scaleY:1,flipX:!1,flipY:!1,opacity:1,angle:0,skewX:0,skewY:0,cornerSize:13,touchCornerSize:24,transparentCorners:!0,hoverCursor:null,moveCursor:null,padding:0,borderColor:"rgb(178,204,255)",borderDashArray:null,cornerColor:"rgb(178,204,255)",cornerStrokeColor:null,cornerStyle:"rect",cornerDashArray:null,centeredScaling:!1,centeredRotation:!0,fill:"rgb(0,0,0)",fillRule:"nonzero",globalCompositeOperation:"source-over",backgroundColor:"",selectionBackgroundColor:"",stroke:null,strokeWidth:1,strokeDashArray:null,strokeDashOffset:0,strokeLineCap:"butt",strokeLineJoin:"miter",strokeMiterLimit:4,shadow:null,borderOpacityWhenMoving:.4,borderScaleFactor:1,minScaleLimit:0,selectable:!0,evented:!0,visible:!0,hasControls:!0,hasBorders:!0,perPixelTargetFind:!1,includeDefaultValues:!0,lockMovementX:!1,lockMovementY:!1,lockRotation:!1,lockScalingX:!1,lockScalingY:!1,lockSkewingX:!1,lockSkewingY:!1,lockScalingFlip:!1,excludeFromExport:!1,objectCaching:s,statefullCache:!1,noScaleCache:!0,strokeUniform:!1,dirty:!0,__corner:0,paintFirst:"fill",stateProperties:"top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),cacheProperties:"fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),colorProperties:"fill stroke backgroundColor".split(" "),clipPath:void 0,inverted:!1,absolutePositioned:!1,initialize:function(t){t&&this.setOptions(t)},_createCacheCanvas:function(){this._cacheProperties={},this._cacheCanvas=x.util.createCanvasElement(),this._cacheContext=this._cacheCanvas.getContext("2d"),this._updateCacheCanvas(),this.dirty=!0},_limitCacheSize:function(t){var e=x.perfLimitSizeTotal,i=t.width,r=t.height,n=x.maxCacheSideLimit,s=x.minCacheSideLimit;if(i<=n&&r<=n&&i*r<=e)return i<s&&(t.width=s),r<s&&(t.height=s),t;var o=i/r,a=x.util.limitDimsByArea(o,e),h=x.util.capValue,c=h(s,a.x,n),l=h(s,a.y,n);return c<i&&(t.zoomX/=i/c,t.width=c,t.capped=!0),l<r&&(t.zoomY/=r/l,t.height=l,t.capped=!0),t},_getCacheCanvasDimensions:function(){var t=this.getTotalObjectScaling(),e=this._getTransformedDimensions(0,0),i=e.x*t.scaleX/this.scaleX,r=e.y*t.scaleY/this.scaleY;return{width:i+2,height:r+2,zoomX:t.scaleX,zoomY:t.scaleY,x:i,y:r}},_updateCacheCanvas:function(){var t=this.canvas;if(this.noScaleCache&&t&&t._currentTransform){var e=t._currentTransform.target,i=t._currentTransform.action;if(this===e&&i.slice&&"scale"===i.slice(0,5))return!1}var r,n,s=this._cacheCanvas,o=this._limitCacheSize(this._getCacheCanvasDimensions()),a=x.minCacheSideLimit,h=o.width,c=o.height,l=o.zoomX,u=o.zoomY,f=h!==this.cacheWidth||c!==this.cacheHeight,d=this.zoomX!==l||this.zoomY!==u,g=f||d,p=0,v=0,m=!1;if(f){var b=this._cacheCanvas.width,_=this._cacheCanvas.height,y=b<h||_<c;m=y||(h<.9*b||c<.9*_)&&a<b&&a<_,y&&!o.capped&&(a<h||a<c)&&(p=.1*h,v=.1*c)}return!!g&&(m?(s.width=Math.ceil(h+p),s.height=Math.ceil(c+v)):(this._cacheContext.setTransform(1,0,0,1,0,0),this._cacheContext.clearRect(0,0,s.width,s.height)),r=o.x/2,n=o.y/2,this.cacheTranslationX=Math.round(s.width/2-r)+r,this.cacheTranslationY=Math.round(s.height/2-n)+n,this.cacheWidth=h,this.cacheHeight=c,this._cacheContext.translate(this.cacheTranslationX,this.cacheTranslationY),this._cacheContext.scale(l,u),this.zoomX=l,this.zoomY=u,!0)},setOptions:function(t){this._setOptions(t),this._initGradient(t.fill,"fill"),this._initGradient(t.stroke,"stroke"),this._initPattern(t.fill,"fill"),this._initPattern(t.stroke,"stroke")},transform:function(t){var e=this.group&&!this.group._transformDone||this.group&&this.canvas&&t===this.canvas.contextTop,i=this.calcTransformMatrix(!e);t.transform(i[0],i[1],i[2],i[3],i[4],i[5])},toObject:function(t){var e=x.Object.NUM_FRACTION_DIGITS,i={type:this.type,version:x.version,originX:this.originX,originY:this.originY,left:r(this.left,e),top:r(this.top,e),width:r(this.width,e),height:r(this.height,e),fill:this.fill&&this.fill.toObject?this.fill.toObject():this.fill,stroke:this.stroke&&this.stroke.toObject?this.stroke.toObject():this.stroke,strokeWidth:r(this.strokeWidth,e),strokeDashArray:this.strokeDashArray?this.strokeDashArray.concat():this.strokeDashArray,strokeLineCap:this.strokeLineCap,strokeDashOffset:this.strokeDashOffset,strokeLineJoin:this.strokeLineJoin,strokeMiterLimit:r(this.strokeMiterLimit,e),scaleX:r(this.scaleX,e),scaleY:r(this.scaleY,e),angle:r(this.angle,e),flipX:this.flipX,flipY:this.flipY,opacity:r(this.opacity,e),shadow:this.shadow&&this.shadow.toObject?this.shadow.toObject():this.shadow,visible:this.visible,backgroundColor:this.backgroundColor,fillRule:this.fillRule,paintFirst:this.paintFirst,globalCompositeOperation:this.globalCompositeOperation,skewX:r(this.skewX,e),skewY:r(this.skewY,e)};return this.clipPath&&(i.clipPath=this.clipPath.toObject(t),i.clipPath.inverted=this.clipPath.inverted,i.clipPath.absolutePositioned=this.clipPath.absolutePositioned),x.util.populateWithProperties(this,i,t),this.includeDefaultValues||(i=this._removeDefaultValues(i)),i},toDatalessObject:function(t){return this.toObject(t)},_removeDefaultValues:function(e){var i=x.util.getKlass(e.type).prototype;return i.stateProperties.forEach(function(t){"left"!==t&&"top"!==t&&(e[t]===i[t]&&delete e[t],"[object Array]"===Object.prototype.toString.call(e[t])&&"[object Array]"===Object.prototype.toString.call(i[t])&&0===e[t].length&&0===i[t].length&&delete e[t])}),e},toString:function(){return"#<fabric."+i(this.type)+">"},getObjectScaling:function(){var t=x.util.qrDecompose(this.calcTransformMatrix());return{scaleX:Math.abs(t.scaleX),scaleY:Math.abs(t.scaleY)}},getTotalObjectScaling:function(){var t=this.getObjectScaling(),e=t.scaleX,i=t.scaleY;if(this.canvas){var r=this.canvas.getZoom(),n=this.canvas.getRetinaScaling();e*=r*n,i*=r*n}return{scaleX:e,scaleY:i}},getObjectOpacity:function(){var t=this.opacity;return this.group&&(t*=this.group.getObjectOpacity()),t},_set:function(t,e){var i="scaleX"===t||"scaleY"===t,r=this[t]!==e,n=!1;return i&&(e=this._constrainScale(e)),"scaleX"===t&&e<0?(this.flipX=!this.flipX,e*=-1):"scaleY"===t&&e<0?(this.flipY=!this.flipY,e*=-1):"shadow"!==t||!e||e instanceof x.Shadow?"dirty"===t&&this.group&&this.group.set("dirty",e):e=new x.Shadow(e),this[t]=e,r&&(n=this.group&&this.group.isOnACache(),-1<this.cacheProperties.indexOf(t)?(this.dirty=!0,n&&this.group.set("dirty",!0)):n&&-1<this.stateProperties.indexOf(t)&&this.group.set("dirty",!0)),this},setOnGroup:function(){},getViewportTransform:function(){return this.canvas&&this.canvas.viewportTransform?this.canvas.viewportTransform:x.iMatrix.concat()},isNotVisible:function(){return 0===this.opacity||!this.width&&!this.height&&0===this.strokeWidth||!this.visible},render:function(t){this.isNotVisible()||this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(t.save(),this._setupCompositeOperation(t),this.drawSelectionBackground(t),this.transform(t),this._setOpacity(t),this._setShadow(t,this),this.shouldCache()?(this.renderCache(),this.drawCacheOnCanvas(t)):(this._removeCacheCanvas(),this.dirty=!1,this.drawObject(t),this.objectCaching&&this.statefullCache&&this.saveState({propertySet:"cacheProperties"})),t.restore())},renderCache:function(t){t=t||{},this._cacheCanvas||this._createCacheCanvas(),this.isCacheDirty()&&(this.statefullCache&&this.saveState({propertySet:"cacheProperties"}),this.drawObject(this._cacheContext,t.forClipping),this.dirty=!1)},_removeCacheCanvas:function(){this._cacheCanvas=null,this.cacheWidth=0,this.cacheHeight=0},hasStroke:function(){return this.stroke&&"transparent"!==this.stroke&&0!==this.strokeWidth},hasFill:function(){return this.fill&&"transparent"!==this.fill},needsItsOwnCache:function(){return!("stroke"!==this.paintFirst||!this.hasFill()||!this.hasStroke()||"object"!=typeof this.shadow)||!!this.clipPath},shouldCache:function(){return this.ownCaching=this.needsItsOwnCache()||this.objectCaching&&(!this.group||!this.group.isOnACache()),this.ownCaching},willDrawShadow:function(){return!!this.shadow&&(0!==this.shadow.offsetX||0!==this.shadow.offsetY)},drawClipPathOnCache:function(t){var e=this.clipPath;if(t.save(),e.inverted?t.globalCompositeOperation="destination-out":t.globalCompositeOperation="destination-in",e.absolutePositioned){var i=x.util.invertTransform(this.calcTransformMatrix());t.transform(i[0],i[1],i[2],i[3],i[4],i[5])}e.transform(t),t.scale(1/e.zoomX,1/e.zoomY),t.drawImage(e._cacheCanvas,-e.cacheTranslationX,-e.cacheTranslationY),t.restore()},drawObject:function(t,e){var i=this.fill,r=this.stroke;e?(this.fill="black",this.stroke="",this._setClippingProperties(t)):this._renderBackground(t),this._render(t),this._drawClipPath(t),this.fill=i,this.stroke=r},_drawClipPath:function(t){var e=this.clipPath;e&&(e.canvas=this.canvas,e.shouldCache(),e._transformDone=!0,e.renderCache({forClipping:!0}),this.drawClipPathOnCache(t))},drawCacheOnCanvas:function(t){t.scale(1/this.zoomX,1/this.zoomY),t.drawImage(this._cacheCanvas,-this.cacheTranslationX,-this.cacheTranslationY)},isCacheDirty:function(t){if(this.isNotVisible())return!1;if(this._cacheCanvas&&!t&&this._updateCacheCanvas())return!0;if(this.dirty||this.clipPath&&this.clipPath.absolutePositioned||this.statefullCache&&this.hasStateChanged("cacheProperties")){if(this._cacheCanvas&&!t){var e=this.cacheWidth/this.zoomX,i=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-e/2,-i/2,e,i)}return!0}return!1},_renderBackground:function(t){if(this.backgroundColor){var e=this._getNonTransformedDimensions();t.fillStyle=this.backgroundColor,t.fillRect(-e.x/2,-e.y/2,e.x,e.y),this._removeShadow(t)}},_setOpacity:function(t){this.group&&!this.group._transformDone?t.globalAlpha=this.getObjectOpacity():t.globalAlpha*=this.opacity},_setStrokeStyles:function(t,e){var i=e.stroke;i&&(t.lineWidth=e.strokeWidth,t.lineCap=e.strokeLineCap,t.lineDashOffset=e.strokeDashOffset,t.lineJoin=e.strokeLineJoin,t.miterLimit=e.strokeMiterLimit,i.toLive?"percentage"===i.gradientUnits||i.gradientTrasnform||i.patternTransform?this._applyPatternForTransformedGradient(t,i):(t.strokeStyle=i.toLive(t,this),this._applyPatternGradientTransform(t,i)):t.strokeStyle=e.stroke)},_setFillStyles:function(t,e){var i=e.fill;i&&(i.toLive?(t.fillStyle=i.toLive(t,this),this._applyPatternGradientTransform(t,e.fill)):t.fillStyle=i)},_setClippingProperties:function(t){t.globalAlpha=1,t.strokeStyle="transparent",t.fillStyle="#000000"},_setLineDash:function(t,e,i){e&&0!==e.length&&(1&e.length&&e.push.apply(e,e),n?t.setLineDash(e):i&&i(t))},_renderControls:function(t,e){var i,r,n,s=this.getViewportTransform(),o=this.calcTransformMatrix();r=void 0!==(e=e||{}).hasBorders?e.hasBorders:this.hasBorders,n=void 0!==e.hasControls?e.hasControls:this.hasControls,o=x.util.multiplyTransformMatrices(s,o),i=x.util.qrDecompose(o),t.save(),t.translate(i.translateX,i.translateY),t.lineWidth=1*this.borderScaleFactor,this.group||(t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1),e.forActiveSelection?(t.rotate(a(i.angle)),r&&this.drawBordersInGroup(t,i,e)):(t.rotate(a(this.angle)),r&&this.drawBorders(t,e)),n&&this.drawControls(t,e),t.restore()},_setShadow:function(t){if(this.shadow){var e,i=this.shadow,r=this.canvas,n=r&&r.viewportTransform[0]||1,s=r&&r.viewportTransform[3]||1;e=i.nonScaling?{scaleX:1,scaleY:1}:this.getObjectScaling(),r&&r._isRetinaScaling()&&(n*=x.devicePixelRatio,s*=x.devicePixelRatio),t.shadowColor=i.color,t.shadowBlur=i.blur*x.browserShadowBlurConstant*(n+s)*(e.scaleX+e.scaleY)/4,t.shadowOffsetX=i.offsetX*n*e.scaleX,t.shadowOffsetY=i.offsetY*s*e.scaleY}},_removeShadow:function(t){this.shadow&&(t.shadowColor="",t.shadowBlur=t.shadowOffsetX=t.shadowOffsetY=0)},_applyPatternGradientTransform:function(t,e){if(!e||!e.toLive)return{offsetX:0,offsetY:0};var i=e.gradientTransform||e.patternTransform,r=-this.width/2+e.offsetX||0,n=-this.height/2+e.offsetY||0;return"percentage"===e.gradientUnits?t.transform(this.width,0,0,this.height,r,n):t.transform(1,0,0,1,r,n),i&&t.transform(i[0],i[1],i[2],i[3],i[4],i[5]),{offsetX:r,offsetY:n}},_renderPaintInOrder:function(t){"stroke"===this.paintFirst?(this._renderStroke(t),this._renderFill(t)):(this._renderFill(t),this._renderStroke(t))},_render:function(){},_renderFill:function(t){this.fill&&(t.save(),this._setFillStyles(t,this),"evenodd"===this.fillRule?t.fill("evenodd"):t.fill(),t.restore())},_renderStroke:function(t){if(this.stroke&&0!==this.strokeWidth){if(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this.strokeUniform&&this.group){var e=this.getObjectScaling();t.scale(1/e.scaleX,1/e.scaleY)}else this.strokeUniform&&t.scale(1/this.scaleX,1/this.scaleY);this._setLineDash(t,this.strokeDashArray,this._renderDashedStroke),this._setStrokeStyles(t,this),t.stroke(),t.restore()}},_applyPatternForTransformedGradient:function(t,e){var i,r=this._limitCacheSize(this._getCacheCanvasDimensions()),n=x.util.createCanvasElement(),s=this.canvas.getRetinaScaling(),o=r.x/this.scaleX/s,a=r.y/this.scaleY/s;n.width=o,n.height=a,(i=n.getContext("2d")).beginPath(),i.moveTo(0,0),i.lineTo(o,0),i.lineTo(o,a),i.lineTo(0,a),i.closePath(),i.translate(o/2,a/2),i.scale(r.zoomX/this.scaleX/s,r.zoomY/this.scaleY/s),this._applyPatternGradientTransform(i,e),i.fillStyle=e.toLive(t),i.fill(),t.translate(-this.width/2-this.strokeWidth/2,-this.height/2-this.strokeWidth/2),t.scale(s*this.scaleX/r.zoomX,s*this.scaleY/r.zoomY),t.strokeStyle=i.createPattern(n,"no-repeat")},_findCenterFromElement:function(){return{x:this.left+this.width/2,y:this.top+this.height/2}},_assignTransformMatrixProps:function(){if(this.transformMatrix){var t=x.util.qrDecompose(this.transformMatrix);this.flipX=!1,this.flipY=!1,this.set("scaleX",t.scaleX),this.set("scaleY",t.scaleY),this.angle=t.angle,this.skewX=t.skewX,this.skewY=0}},_removeTransformMatrix:function(t){var e=this._findCenterFromElement();this.transformMatrix&&(this._assignTransformMatrixProps(),e=x.util.transformPoint(e,this.transformMatrix)),this.transformMatrix=null,t&&(this.scaleX*=t.scaleX,this.scaleY*=t.scaleY,this.cropX=t.cropX,this.cropY=t.cropY,e.x+=t.offsetLeft,e.y+=t.offsetTop,this.width=t.width,this.height=t.height),this.setPositionByOrigin(e,"center","center")},clone:function(t,e){var i=this.toObject(e);this.constructor.fromObject?this.constructor.fromObject(i,t):x.Object._fromObject("Object",i,t)},cloneAsImage:function(t,e){var i=this.toCanvasElement(e);return t&&t(new x.Image(i)),this},toCanvasElement:function(t){t||(t={});var e=x.util,i=e.saveObjectTransform(this),r=this.group,n=this.shadow,s=Math.abs,o=(t.multiplier||1)*(t.enableRetinaScaling?x.devicePixelRatio:1);delete this.group,t.withoutTransform&&e.resetObjectTransform(this),t.withoutShadow&&(this.shadow=null);var a,h,c,l,u=x.util.createCanvasElement(),f=this.getBoundingRect(!0,!0),d=this.shadow,g={x:0,y:0};d&&(h=d.blur,a=d.nonScaling?{scaleX:1,scaleY:1}:this.getObjectScaling(),g.x=2*Math.round(s(d.offsetX)+h)*s(a.scaleX),g.y=2*Math.round(s(d.offsetY)+h)*s(a.scaleY)),c=f.width+g.x,l=f.height+g.y,u.width=Math.ceil(c),u.height=Math.ceil(l);var p=new x.StaticCanvas(u,{enableRetinaScaling:!1,renderOnAddRemove:!1,skipOffscreen:!1});"jpeg"===t.format&&(p.backgroundColor="#fff"),this.setPositionByOrigin(new x.Point(p.width/2,p.height/2),"center","center");var v=this.canvas;p.add(this);var m=p.toCanvasElement(o||1,t);return this.shadow=n,this.set("canvas",v),r&&(this.group=r),this.set(i).setCoords(),p._objects=[],p.dispose(),p=null,m},toDataURL:function(t){return t||(t={}),x.util.toDataURL(this.toCanvasElement(t),t.format||"png",t.quality||1)},isType:function(t){return this.type===t},complexity:function(){return 1},toJSON:function(t){return this.toObject(t)},rotate:function(t){var e=("center"!==this.originX||"center"!==this.originY)&&this.centeredRotation;return e&&this._setOriginToCenter(),this.set("angle",t),e&&this._resetOrigin(),this},centerH:function(){return this.canvas&&this.canvas.centerObjectH(this),this},viewportCenterH:function(){return this.canvas&&this.canvas.viewportCenterObjectH(this),this},centerV:function(){return this.canvas&&this.canvas.centerObjectV(this),this},viewportCenterV:function(){return this.canvas&&this.canvas.viewportCenterObjectV(this),this},center:function(){return this.canvas&&this.canvas.centerObject(this),this},viewportCenter:function(){return this.canvas&&this.canvas.viewportCenterObject(this),this},getLocalPointer:function(t,e){e=e||this.canvas.getPointer(t);var i=new x.Point(e.x,e.y),r=this._getLeftTopCoords();return this.angle&&(i=x.util.rotatePoint(i,r,a(-this.angle))),{x:i.x-r.x,y:i.y-r.y}},_setupCompositeOperation:function(t){this.globalCompositeOperation&&(t.globalCompositeOperation=this.globalCompositeOperation)}}),x.util.createAccessors&&x.util.createAccessors(x.Object),e(x.Object.prototype,x.Observable),x.Object.NUM_FRACTION_DIGITS=2,x.Object._fromObject=function(t,i,r,n){var s=x[t];i=o(i,!0),x.util.enlivenPatterns([i.fill,i.stroke],function(t){void 0!==t[0]&&(i.fill=t[0]),void 0!==t[1]&&(i.stroke=t[1]),x.util.enlivenObjects([i.clipPath],function(t){i.clipPath=t[0];var e=n?new s(i[n],i):new s(i);r&&r(e)})})},x.Object.__uid=0)}("undefined"!=typeof exports?exports:this),function(){var a=fabric.util.degreesToRadians,l={left:-.5,center:0,right:.5},u={top:-.5,center:0,bottom:.5};fabric.util.object.extend(fabric.Object.prototype,{translateToGivenOrigin:function(t,e,i,r,n){var s,o,a,h=t.x,c=t.y;return"string"==typeof e?e=l[e]:e-=.5,"string"==typeof r?r=l[r]:r-=.5,"string"==typeof i?i=u[i]:i-=.5,"string"==typeof n?n=u[n]:n-=.5,o=n-i,((s=r-e)||o)&&(a=this._getTransformedDimensions(),h=t.x+s*a.x,c=t.y+o*a.y),new fabric.Point(h,c)},translateToCenterPoint:function(t,e,i){var r=this.translateToGivenOrigin(t,e,i,"center","center");return this.angle?fabric.util.rotatePoint(r,t,a(this.angle)):r},translateToOriginPoint:function(t,e,i){var r=this.translateToGivenOrigin(t,"center","center",e,i);return this.angle?fabric.util.rotatePoint(r,t,a(this.angle)):r},getCenterPoint:function(){var t=new fabric.Point(this.left,this.top);return this.translateToCenterPoint(t,this.originX,this.originY)},getPointByOrigin:function(t,e){var i=this.getCenterPoint();return this.translateToOriginPoint(i,t,e)},toLocalPoint:function(t,e,i){var r,n,s=this.getCenterPoint();return r=void 0!==e&&void 0!==i?this.translateToGivenOrigin(s,"center","center",e,i):new fabric.Point(this.left,this.top),n=new fabric.Point(t.x,t.y),this.angle&&(n=fabric.util.rotatePoint(n,s,-a(this.angle))),n.subtractEquals(r)},setPositionByOrigin:function(t,e,i){var r=this.translateToCenterPoint(t,e,i),n=this.translateToOriginPoint(r,this.originX,this.originY);this.set("left",n.x),this.set("top",n.y)},adjustPosition:function(t){var e,i,r=a(this.angle),n=this.getScaledWidth(),s=fabric.util.cos(r)*n,o=fabric.util.sin(r)*n;e="string"==typeof this.originX?l[this.originX]:this.originX-.5,i="string"==typeof t?l[t]:t-.5,this.left+=s*(i-e),this.top+=o*(i-e),this.setCoords(),this.originX=t},_setOriginToCenter:function(){this._originalOriginX=this.originX,this._originalOriginY=this.originY;var t=this.getCenterPoint();this.originX="center",this.originY="center",this.left=t.x,this.top=t.y},_resetOrigin:function(){var t=this.translateToOriginPoint(this.getCenterPoint(),this._originalOriginX,this._originalOriginY);this.originX=this._originalOriginX,this.originY=this._originalOriginY,this.left=t.x,this.top=t.y,this._originalOriginX=null,this._originalOriginY=null},_getLeftTopCoords:function(){return this.translateToOriginPoint(this.getCenterPoint(),"left","top")}})}(),function(){var c=fabric.util,l=c.degreesToRadians,a=c.multiplyTransformMatrices,u=c.transformPoint;c.object.extend(fabric.Object.prototype,{oCoords:null,aCoords:null,lineCoords:null,ownMatrixCache:null,matrixCache:null,controls:{},_getCoords:function(t,e){return e?t?this.calcACoords():this.calcLineCoords():(this.aCoords&&this.lineCoords||this.setCoords(!0),t?this.aCoords:this.lineCoords)},getCoords:function(t,e){return i=this._getCoords(t,e),[new fabric.Point(i.tl.x,i.tl.y),new fabric.Point(i.tr.x,i.tr.y),new fabric.Point(i.br.x,i.br.y),new fabric.Point(i.bl.x,i.bl.y)];var i},intersectsWithRect:function(t,e,i,r){var n=this.getCoords(i,r);return"Intersection"===fabric.Intersection.intersectPolygonRectangle(n,t,e).status},intersectsWithObject:function(t,e,i){return"Intersection"===fabric.Intersection.intersectPolygonPolygon(this.getCoords(e,i),t.getCoords(e,i)).status||t.isContainedWithinObject(this,e,i)||this.isContainedWithinObject(t,e,i)},isContainedWithinObject:function(t,e,i){for(var r=this.getCoords(e,i),n=e?t.aCoords:t.lineCoords,s=0,o=t._getImageLines(n);s<4;s++)if(!t.containsPoint(r[s],o))return!1;return!0},isContainedWithinRect:function(t,e,i,r){var n=this.getBoundingRect(i,r);return n.left>=t.x&&n.left+n.width<=e.x&&n.top>=t.y&&n.top+n.height<=e.y},containsPoint:function(t,e,i,r){var n=this._getCoords(i,r),s=(e=e||this._getImageLines(n),this._findCrossPoints(t,e));return 0!==s&&s%2==1},isOnScreen:function(t){if(!this.canvas)return!1;var e=this.canvas.vptCoords.tl,i=this.canvas.vptCoords.br;return!!this.getCoords(!0,t).some(function(t){return t.x<=i.x&&t.x>=e.x&&t.y<=i.y&&t.y>=e.y})||(!!this.intersectsWithRect(e,i,!0,t)||this._containsCenterOfCanvas(e,i,t))},_containsCenterOfCanvas:function(t,e,i){var r={x:(t.x+e.x)/2,y:(t.y+e.y)/2};return!!this.containsPoint(r,null,!0,i)},isPartiallyOnScreen:function(t){if(!this.canvas)return!1;var e=this.canvas.vptCoords.tl,i=this.canvas.vptCoords.br;return!!this.intersectsWithRect(e,i,!0,t)||this.getCoords(!0,t).every(function(t){return(t.x>=i.x||t.x<=e.x)&&(t.y>=i.y||t.y<=e.y)})&&this._containsCenterOfCanvas(e,i,t)},_getImageLines:function(t){return{topline:{o:t.tl,d:t.tr},rightline:{o:t.tr,d:t.br},bottomline:{o:t.br,d:t.bl},leftline:{o:t.bl,d:t.tl}}},_findCrossPoints:function(t,e){var i,r,n,s=0;for(var o in e)if(!((n=e[o]).o.y<t.y&&n.d.y<t.y||n.o.y>=t.y&&n.d.y>=t.y||(n.o.x===n.d.x&&n.o.x>=t.x?r=n.o.x:(0,i=(n.d.y-n.o.y)/(n.d.x-n.o.x),r=-(t.y-0*t.x-(n.o.y-i*n.o.x))/(0-i)),r>=t.x&&(s+=1),2!==s)))break;return s},getBoundingRect:function(t,e){var i=this.getCoords(t,e);return c.makeBoundingBoxFromPoints(i)},getScaledWidth:function(){return this._getTransformedDimensions().x},getScaledHeight:function(){return this._getTransformedDimensions().y},_constrainScale:function(t){return Math.abs(t)<this.minScaleLimit?t<0?-this.minScaleLimit:this.minScaleLimit:0===t?1e-4:t},scale:function(t){return this._set("scaleX",t),this._set("scaleY",t),this.setCoords()},scaleToWidth:function(t,e){var i=this.getBoundingRect(e).width/this.getScaledWidth();return this.scale(t/this.width/i)},scaleToHeight:function(t,e){var i=this.getBoundingRect(e).height/this.getScaledHeight();return this.scale(t/this.height/i)},calcCoords:function(t){return t?this.calcACoords():this.calcOCoords()},calcLineCoords:function(){var t=this.getViewportTransform(),e=this.padding,i=l(this.angle),r=c.cos(i)*e,n=c.sin(i)*e,s=r+n,o=r-n,a=this.calcACoords(),h={tl:u(a.tl,t),tr:u(a.tr,t),bl:u(a.bl,t),br:u(a.br,t)};return e&&(h.tl.x-=o,h.tl.y-=s,h.tr.x+=s,h.tr.y-=o,h.bl.x-=s,h.bl.y+=o,h.br.x+=o,h.br.y+=s),h},calcOCoords:function(){var t=this._calcRotateMatrix(),e=this._calcTranslateMatrix(),i=this.getViewportTransform(),r=a(i,e),n=a(r,t),s=(n=a(n,[1/i[0],0,0,1/i[3],0,0]),this._calculateCurrentDimensions()),o={};return this.forEachControl(function(t,e,i){o[e]=t.positionHandler(s,n,i)}),o},calcACoords:function(){var t=this._calcRotateMatrix(),e=this._calcTranslateMatrix(),i=a(e,t),r=this._getTransformedDimensions(),n=r.x/2,s=r.y/2;return{tl:u({x:-n,y:-s},i),tr:u({x:n,y:-s},i),bl:u({x:-n,y:s},i),br:u({x:n,y:s},i)}},setCoords:function(t){return this.aCoords=this.calcACoords(),this.lineCoords=this.group?this.aCoords:this.calcLineCoords(),t||(this.oCoords=this.calcOCoords(),this._setCornerCoords&&this._setCornerCoords()),this},_calcRotateMatrix:function(){return c.calcRotateMatrix(this)},_calcTranslateMatrix:function(){var t=this.getCenterPoint();return[1,0,0,1,t.x,t.y]},transformMatrixKey:function(t){var e="_",i="";return!t&&this.group&&(i=this.group.transformMatrixKey(t)+e),i+this.top+e+this.left+e+this.scaleX+e+this.scaleY+e+this.skewX+e+this.skewY+e+this.angle+e+this.originX+e+this.originY+e+this.width+e+this.height+e+this.strokeWidth+this.flipX+this.flipY},calcTransformMatrix:function(t){var e=this.calcOwnMatrix();if(t||!this.group)return e;var i=this.transformMatrixKey(t),r=this.matrixCache||(this.matrixCache={});return r.key===i?r.value:(this.group&&(e=a(this.group.calcTransformMatrix(!1),e)),r.key=i,r.value=e)},calcOwnMatrix:function(){var t=this.transformMatrixKey(!0),e=this.ownMatrixCache||(this.ownMatrixCache={});if(e.key===t)return e.value;var i=this._calcTranslateMatrix(),r={angle:this.angle,translateX:i[4],translateY:i[5],scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY};return e.key=t,e.value=c.composeMatrix(r),e.value},_calcDimensionsTransformMatrix:function(t,e,i){return c.calcDimensionsMatrix({skewX:t,skewY:e,scaleX:this.scaleX*(i&&this.flipX?-1:1),scaleY:this.scaleY*(i&&this.flipY?-1:1)})},_getNonTransformedDimensions:function(){var t=this.strokeWidth;return{x:this.width+t,y:this.height+t}},_getTransformedDimensions:function(t,e){void 0===t&&(t=this.skewX),void 0===e&&(e=this.skewY);var i,r,n=this._getNonTransformedDimensions(),s=0===t&&0===e;if(this.strokeUniform?(i=this.width,r=this.height):(i=n.x,r=n.y),s)return this._finalizeDimensions(i*this.scaleX,r*this.scaleY);var o=c.sizeAfterTransform(i,r,{scaleX:this.scaleX,scaleY:this.scaleY,skewX:t,skewY:e});return this._finalizeDimensions(o.x,o.y)},_finalizeDimensions:function(t,e){return this.strokeUniform?{x:t+this.strokeWidth,y:e+this.strokeWidth}:{x:t,y:e}},_calculateCurrentDimensions:function(){var t=this.getViewportTransform(),e=this._getTransformedDimensions();return u(e,t,!0).scalarAdd(2*this.padding)}})}(),fabric.util.object.extend(fabric.Object.prototype,{sendToBack:function(){return this.group?fabric.StaticCanvas.prototype.sendToBack.call(this.group,this):this.canvas&&this.canvas.sendToBack(this),this},bringToFront:function(){return this.group?fabric.StaticCanvas.prototype.bringToFront.call(this.group,this):this.canvas&&this.canvas.bringToFront(this),this},sendBackwards:function(t){return this.group?fabric.StaticCanvas.prototype.sendBackwards.call(this.group,this,t):this.canvas&&this.canvas.sendBackwards(this,t),this},bringForward:function(t){return this.group?fabric.StaticCanvas.prototype.bringForward.call(this.group,this,t):this.canvas&&this.canvas.bringForward(this,t),this},moveTo:function(t){return this.group&&"activeSelection"!==this.group.type?fabric.StaticCanvas.prototype.moveTo.call(this.group,this,t):this.canvas&&this.canvas.moveTo(this,t),this}}),function(){function f(t,e){if(e){if(e.toLive)return t+": url(#SVGID_"+e.id+"); ";var i=new fabric.Color(e),r=t+": "+i.toRgb()+"; ",n=i.getAlpha();return 1!==n&&(r+=t+"-opacity: "+n.toString()+"; "),r}return t+": none; "}var i=fabric.util.toFixed;fabric.util.object.extend(fabric.Object.prototype,{getSvgStyles:function(t){var e=this.fillRule?this.fillRule:"nonzero",i=this.strokeWidth?this.strokeWidth:"0",r=this.strokeDashArray?this.strokeDashArray.join(" "):"none",n=this.strokeDashOffset?this.strokeDashOffset:"0",s=this.strokeLineCap?this.strokeLineCap:"butt",o=this.strokeLineJoin?this.strokeLineJoin:"miter",a=this.strokeMiterLimit?this.strokeMiterLimit:"4",h=void 0!==this.opacity?this.opacity:"1",c=this.visible?"":" visibility: hidden;",l=t?"":this.getSvgFilter(),u=f("fill",this.fill);return[f("stroke",this.stroke),"stroke-width: ",i,"; ","stroke-dasharray: ",r,"; ","stroke-linecap: ",s,"; ","stroke-dashoffset: ",n,"; ","stroke-linejoin: ",o,"; ","stroke-miterlimit: ",a,"; ",u,"fill-rule: ",e,"; ","opacity: ",h,";",l,c].join("")},getSvgSpanStyles:function(t,e){var i="; ",r=t.fontFamily?"font-family: "+(-1===t.fontFamily.indexOf("'")&&-1===t.fontFamily.indexOf('"')?"'"+t.fontFamily+"'":t.fontFamily)+i:"",n=t.strokeWidth?"stroke-width: "+t.strokeWidth+i:"",s=(r=r,t.fontSize?"font-size: "+t.fontSize+"px"+i:""),o=t.fontStyle?"font-style: "+t.fontStyle+i:"",a=t.fontWeight?"font-weight: "+t.fontWeight+i:"",h=t.fill?f("fill",t.fill):"",c=t.stroke?f("stroke",t.stroke):"",l=this.getSvgTextDecoration(t);return l&&(l="text-decoration: "+l+i),[c,n,r,s,o,a,l,h,t.deltaY?"baseline-shift: "+-t.deltaY+"; ":"",e?"white-space: pre; ":""].join("")},getSvgTextDecoration:function(e){return["overline","underline","line-through"].filter(function(t){return e[t.replace("-","")]}).join(" ")},getSvgFilter:function(){return this.shadow?"filter: url(#SVGID_"+this.shadow.id+");":""},getSvgCommons:function(){return[this.id?'id="'+this.id+'" ':"",this.clipPath?'clip-path="url(#'+this.clipPath.clipPathId+')" ':""].join("")},getSvgTransform:function(t,e){var i=t?this.calcTransformMatrix():this.calcOwnMatrix();return'transform="'+fabric.util.matrixToSVG(i)+(e||"")+'" '},_setSVGBg:function(t){if(this.backgroundColor){var e=fabric.Object.NUM_FRACTION_DIGITS;t.push("\t\t<rect ",this._getFillAttributes(this.backgroundColor),' x="',i(-this.width/2,e),'" y="',i(-this.height/2,e),'" width="',i(this.width,e),'" height="',i(this.height,e),'"></rect>\n')}},toSVG:function(t){return this._createBaseSVGMarkup(this._toSVG(t),{reviver:t})},toClipPathSVG:function(t){return"\t"+this._createBaseClipPathSVGMarkup(this._toSVG(t),{reviver:t})},_createBaseClipPathSVGMarkup:function(t,e){var i=(e=e||{}).reviver,r=e.additionalTransform||"",n=[this.getSvgTransform(!0,r),this.getSvgCommons()].join(""),s=t.indexOf("COMMON_PARTS");return t[s]=n,i?i(t.join("")):t.join("")},_createBaseSVGMarkup:function(t,e){var i,r,n=(e=e||{}).noStyle,s=e.reviver,o=n?"":'style="'+this.getSvgStyles()+'" ',a=e.withShadow?'style="'+this.getSvgFilter()+'" ':"",h=this.clipPath,c=this.strokeUniform?'vector-effect="non-scaling-stroke" ':"",l=h&&h.absolutePositioned,u=this.stroke,f=this.fill,d=this.shadow,g=[],p=t.indexOf("COMMON_PARTS"),v=e.additionalTransform;return h&&(h.clipPathId="CLIPPATH_"+fabric.Object.__uid++,r='<clipPath id="'+h.clipPathId+'" >\n'+h.toClipPathSVG(s)+"</clipPath>\n"),l&&g.push("<g ",a,this.getSvgCommons()," >\n"),g.push("<g ",this.getSvgTransform(!1),l?"":a+this.getSvgCommons()," >\n"),i=[o,c,n?"":this.addPaintOrder()," ",v?'transform="'+v+'" ':""].join(""),t[p]=i,f&&f.toLive&&g.push(f.toSVG(this)),u&&u.toLive&&g.push(u.toSVG(this)),d&&g.push(d.toSVG(this)),h&&g.push(r),g.push(t.join("")),g.push("</g>\n"),l&&g.push("</g>\n"),s?s(g.join("")):g.join("")},addPaintOrder:function(){return"fill"!==this.paintFirst?' paint-order="'+this.paintFirst+'" ':""}})}(),function(){var n=fabric.util.object.extend,r="stateProperties";function s(e,t,i){var r={};i.forEach(function(t){r[t]=e[t]}),n(e[t],r,!0)}fabric.util.object.extend(fabric.Object.prototype,{hasStateChanged:function(t){var e="_"+(t=t||r);return Object.keys(this[e]).length<this[t].length||!function t(e,i,r){if(e===i)return!0;if(Array.isArray(e)){if(!Array.isArray(i)||e.length!==i.length)return!1;for(var n=0,s=e.length;n<s;n++)if(!t(e[n],i[n]))return!1;return!0}if(e&&"object"==typeof e){var o,a=Object.keys(e);if(!i||"object"!=typeof i||!r&&a.length!==Object.keys(i).length)return!1;for(n=0,s=a.length;n<s;n++)if("canvas"!==(o=a[n])&&"group"!==o&&!t(e[o],i[o]))return!1;return!0}}(this[e],this,!0)},saveState:function(t){var e=t&&t.propertySet||r,i="_"+e;return this[i]?(s(this,i,this[e]),t&&t.stateProperties&&s(this,i,t.stateProperties),this):this.setupState(t)},setupState:function(t){var e=(t=t||{}).propertySet||r;return this["_"+(t.propertySet=e)]={},this.saveState(t),this}})}(),function(){var n=fabric.util.degreesToRadians;fabric.util.object.extend(fabric.Object.prototype,{_findTargetCorner:function(t,e){if(!this.hasControls||this.group||!this.canvas||this.canvas._activeObject!==this)return!1;var i,r,n,s=t.x,o=t.y,a=Object.keys(this.oCoords),h=a.length-1;for(this.__corner=0;0<=h;h--)if(n=a[h],this.isControlVisible(n)&&(r=this._getImageLines(e?this.oCoords[n].touchCorner:this.oCoords[n].corner),0!==(i=this._findCrossPoints({x:s,y:o},r))&&i%2==1))return this.__corner=n;return!1},forEachControl:function(t){for(var e in this.controls)t(this.controls[e],e,this)},_setCornerCoords:function(){var t=this.oCoords;for(var e in t){var i=this.controls[e];t[e].corner=i.calcCornerCoords(this.angle,this.cornerSize,t[e].x,t[e].y,!1),t[e].touchCorner=i.calcCornerCoords(this.angle,this.touchCornerSize,t[e].x,t[e].y,!0)}},drawSelectionBackground:function(t){if(!this.selectionBackgroundColor||this.canvas&&!this.canvas.interactive||this.canvas&&this.canvas._activeObject!==this)return this;t.save();var e=this.getCenterPoint(),i=this._calculateCurrentDimensions(),r=this.canvas.viewportTransform;return t.translate(e.x,e.y),t.scale(1/r[0],1/r[3]),t.rotate(n(this.angle)),t.fillStyle=this.selectionBackgroundColor,t.fillRect(-i.x/2,-i.y/2,i.x,i.y),t.restore(),this},drawBorders:function(r,t){t=t||{};var e=this._calculateCurrentDimensions(),i=this.borderScaleFactor,n=e.x+i,s=e.y+i,o=void 0!==t.hasControls?t.hasControls:this.hasControls,a=!1;return r.save(),r.strokeStyle=t.borderColor||this.borderColor,this._setLineDash(r,t.borderDashArray||this.borderDashArray,null),r.strokeRect(-n/2,-s/2,n,s),o&&(r.beginPath(),this.forEachControl(function(t,e,i){t.withConnection&&t.getVisibility(i,e)&&(a=!0,r.moveTo(t.x*n,t.y*s),r.lineTo(t.x*n+t.offsetX,t.y*s+t.offsetY))}),a&&r.stroke()),r.restore(),this},drawBordersInGroup:function(t,e,i){i=i||{};var r=fabric.util.sizeAfterTransform(this.width,this.height,e),n=this.strokeWidth,s=this.strokeUniform,o=this.borderScaleFactor,a=r.x+n*(s?this.canvas.getZoom():e.scaleX)+o,h=r.y+n*(s?this.canvas.getZoom():e.scaleY)+o;return t.save(),this._setLineDash(t,i.borderDashArray||this.borderDashArray,null),t.strokeStyle=i.borderColor||this.borderColor,t.strokeRect(-a/2,-h/2,a,h),t.restore(),this},drawControls:function(r,n){return n=n||{},r.save(),r.setTransform(this.canvas.getRetinaScaling(),0,0,this.canvas.getRetinaScaling(),0,0),r.strokeStyle=r.fillStyle=n.cornerColor||this.cornerColor,this.transparentCorners||(r.strokeStyle=n.cornerStrokeColor||this.cornerStrokeColor),this._setLineDash(r,n.cornerDashArray||this.cornerDashArray,null),this.setCoords(),this.forEachControl(function(t,e,i){t.getVisibility(i,e)&&t.render(r,i.oCoords[e].x,i.oCoords[e].y,n,i)}),r.restore(),this},isControlVisible:function(t){return this.controls[t]&&this.controls[t].getVisibility(this,t)},setControlVisible:function(t,e){return this._controlsVisibility||(this._controlsVisibility={}),this._controlsVisibility[t]=e,this},setControlsVisibility:function(t){for(var e in t||(t={}),t)this.setControlVisible(e,t[e]);return this},onDeselect:function(){},onSelect:function(){}})}(),fabric.util.object.extend(fabric.StaticCanvas.prototype,{FX_DURATION:500,fxCenterObjectH:function(e,t){var i=function(){},r=(t=t||{}).onComplete||i,n=t.onChange||i,s=this;return fabric.util.animate({startValue:e.left,endValue:this.getCenter().left,duration:this.FX_DURATION,onChange:function(t){e.set("left",t),s.requestRenderAll(),n()},onComplete:function(){e.setCoords(),r()}}),this},fxCenterObjectV:function(e,t){var i=function(){},r=(t=t||{}).onComplete||i,n=t.onChange||i,s=this;return fabric.util.animate({startValue:e.top,endValue:this.getCenter().top,duration:this.FX_DURATION,onChange:function(t){e.set("top",t),s.requestRenderAll(),n()},onComplete:function(){e.setCoords(),r()}}),this},fxRemove:function(e,t){var i=function(){},r=(t=t||{}).onComplete||i,n=t.onChange||i,s=this;return fabric.util.animate({startValue:e.opacity,endValue:0,duration:this.FX_DURATION,onChange:function(t){e.set("opacity",t),s.requestRenderAll(),n()},onComplete:function(){s.remove(e),r()}}),this}}),fabric.util.object.extend(fabric.Object.prototype,{animate:function(){if(arguments[0]&&"object"==typeof arguments[0]){var t,e,i=[];for(t in arguments[0])i.push(t);for(var r=0,n=i.length;r<n;r++)t=i[r],e=r!==n-1,this._animate(t,arguments[0][t],arguments[1],e)}else this._animate.apply(this,arguments);return this},_animate:function(r,t,n,s){var o,a=this;t=t.toString(),n=n?fabric.util.object.clone(n):{},~r.indexOf(".")&&(o=r.split("."));var e=-1<a.colorProperties.indexOf(r)||o&&-1<a.colorProperties.indexOf(o[1]),i=o?this.get(o[0])[o[1]]:this.get(r);"from"in n||(n.from=i),e||(t=~t.indexOf("=")?i+parseFloat(t.replace("=","")):parseFloat(t));var h={startValue:n.from,endValue:t,byValue:n.by,easing:n.easing,duration:n.duration,abort:n.abort&&function(){return n.abort.call(a)},onChange:function(t,e,i){o?a[o[0]][o[1]]=t:a.set(r,t),s||n.onChange&&n.onChange(t,e,i)},onComplete:function(t,e,i){s||(a.setCoords(),n.onComplete&&n.onComplete(t,e,i))}};e?fabric.util.animateColor(h.startValue,h.endValue,h.duration,h):fabric.util.animate(h)}}),function(t){"use strict";var s=t.fabric||(t.fabric={}),o=s.util.object.extend,r=s.util.object.clone,i={x1:1,x2:1,y1:1,y2:1},n=s.StaticCanvas.supports("setLineDash");function e(t,e){var i=t.origin,r=t.axis1,n=t.axis2,s=t.dimension,o=e.nearest,a=e.center,h=e.farthest;return function(){switch(this.get(i)){case o:return Math.min(this.get(r),this.get(n));case a:return Math.min(this.get(r),this.get(n))+.5*this.get(s);case h:return Math.max(this.get(r),this.get(n))}}}s.Line?s.warn("fabric.Line is already defined"):(s.Line=s.util.createClass(s.Object,{type:"line",x1:0,y1:0,x2:0,y2:0,cacheProperties:s.Object.prototype.cacheProperties.concat("x1","x2","y1","y2"),initialize:function(t,e){t||(t=[0,0,0,0]),this.callSuper("initialize",e),this.set("x1",t[0]),this.set("y1",t[1]),this.set("x2",t[2]),this.set("y2",t[3]),this._setWidthHeight(e)},_setWidthHeight:function(t){t||(t={}),this.width=Math.abs(this.x2-this.x1),this.height=Math.abs(this.y2-this.y1),this.left="left"in t?t.left:this._getLeftToOriginX(),this.top="top"in t?t.top:this._getTopToOriginY()},_set:function(t,e){return this.callSuper("_set",t,e),void 0!==i[t]&&this._setWidthHeight(),this},_getLeftToOriginX:e({origin:"originX",axis1:"x1",axis2:"x2",dimension:"width"},{nearest:"left",center:"center",farthest:"right"}),_getTopToOriginY:e({origin:"originY",axis1:"y1",axis2:"y2",dimension:"height"},{nearest:"top",center:"center",farthest:"bottom"}),_render:function(t){if(t.beginPath(),!this.strokeDashArray||this.strokeDashArray&&n){var e=this.calcLinePoints();t.moveTo(e.x1,e.y1),t.lineTo(e.x2,e.y2)}t.lineWidth=this.strokeWidth;var i=t.strokeStyle;t.strokeStyle=this.stroke||t.fillStyle,this.stroke&&this._renderStroke(t),t.strokeStyle=i},_renderDashedStroke:function(t){var e=this.calcLinePoints();t.beginPath(),s.util.drawDashedLine(t,e.x1,e.y1,e.x2,e.y2,this.strokeDashArray),t.closePath()},_findCenterFromElement:function(){return{x:(this.x1+this.x2)/2,y:(this.y1+this.y2)/2}},toObject:function(t){return o(this.callSuper("toObject",t),this.calcLinePoints())},_getNonTransformedDimensions:function(){var t=this.callSuper("_getNonTransformedDimensions");return"butt"===this.strokeLineCap&&(0===this.width&&(t.y-=this.strokeWidth),0===this.height&&(t.x-=this.strokeWidth)),t},calcLinePoints:function(){var t=this.x1<=this.x2?-1:1,e=this.y1<=this.y2?-1:1,i=t*this.width*.5,r=e*this.height*.5;return{x1:i,x2:t*this.width*-.5,y1:r,y2:e*this.height*-.5}},_toSVG:function(){var t=this.calcLinePoints();return["<line ","COMMON_PARTS",'x1="',t.x1,'" y1="',t.y1,'" x2="',t.x2,'" y2="',t.y2,'" />\n']}}),s.Line.ATTRIBUTE_NAMES=s.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")),s.Line.fromElement=function(t,e,i){i=i||{};var r=s.parseAttributes(t,s.Line.ATTRIBUTE_NAMES),n=[r.x1||0,r.y1||0,r.x2||0,r.y2||0];e(new s.Line(n,o(r,i)))},s.Line.fromObject=function(t,e){var i=r(t,!0);i.points=[t.x1,t.y1,t.x2,t.y2],s.Object._fromObject("Line",i,function(t){delete t.points,e&&e(t)},"points")})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var a=t.fabric||(t.fabric={}),h=Math.PI;a.Circle?a.warn("fabric.Circle is already defined."):(a.Circle=a.util.createClass(a.Object,{type:"circle",radius:0,startAngle:0,endAngle:2*h,cacheProperties:a.Object.prototype.cacheProperties.concat("radius","startAngle","endAngle"),_set:function(t,e){return this.callSuper("_set",t,e),"radius"===t&&this.setRadius(e),this},toObject:function(t){return this.callSuper("toObject",["radius","startAngle","endAngle"].concat(t))},_toSVG:function(){var t,e=(this.endAngle-this.startAngle)%(2*h);if(0===e)t=["<circle ","COMMON_PARTS",'cx="0" cy="0" ','r="',this.radius,'" />\n'];else{var i=a.util.cos(this.startAngle)*this.radius,r=a.util.sin(this.startAngle)*this.radius,n=a.util.cos(this.endAngle)*this.radius,s=a.util.sin(this.endAngle)*this.radius,o=h<e?"1":"0";t=['<path d="M '+i+" "+r," A "+this.radius+" "+this.radius," 0 ",+o+" 1"," "+n+" "+s,'" ',"COMMON_PARTS"," />\n"]}return t},_render:function(t){t.beginPath(),t.arc(0,0,this.radius,this.startAngle,this.endAngle,!1),this._renderPaintInOrder(t)},getRadiusX:function(){return this.get("radius")*this.get("scaleX")},getRadiusY:function(){return this.get("radius")*this.get("scaleY")},setRadius:function(t){return this.radius=t,this.set("width",2*t).set("height",2*t)}}),a.Circle.ATTRIBUTE_NAMES=a.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")),a.Circle.fromElement=function(t,e){var i,r=a.parseAttributes(t,a.Circle.ATTRIBUTE_NAMES);if(!("radius"in(i=r)&&0<=i.radius))throw new Error("value of `r` attribute is required and can not be negative");r.left=(r.left||0)-r.radius,r.top=(r.top||0)-r.radius,e(new a.Circle(r))},a.Circle.fromObject=function(t,e){return a.Object._fromObject("Circle",t,e)})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var r=t.fabric||(t.fabric={});r.Triangle?r.warn("fabric.Triangle is already defined"):(r.Triangle=r.util.createClass(r.Object,{type:"triangle",width:100,height:100,_render:function(t){var e=this.width/2,i=this.height/2;t.beginPath(),t.moveTo(-e,i),t.lineTo(0,-i),t.lineTo(e,i),t.closePath(),this._renderPaintInOrder(t)},_renderDashedStroke:function(t){var e=this.width/2,i=this.height/2;t.beginPath(),r.util.drawDashedLine(t,-e,i,0,-i,this.strokeDashArray),r.util.drawDashedLine(t,0,-i,e,i,this.strokeDashArray),r.util.drawDashedLine(t,e,i,-e,i,this.strokeDashArray),t.closePath()},_toSVG:function(){var t=this.width/2,e=this.height/2;return["<polygon ","COMMON_PARTS",'points="',[-t+" "+e,"0 "+-e,t+" "+e].join(","),'" />']}}),r.Triangle.fromObject=function(t,e){return r.Object._fromObject("Triangle",t,e)})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var r=t.fabric||(t.fabric={}),e=2*Math.PI;r.Ellipse?r.warn("fabric.Ellipse is already defined."):(r.Ellipse=r.util.createClass(r.Object,{type:"ellipse",rx:0,ry:0,cacheProperties:r.Object.prototype.cacheProperties.concat("rx","ry"),initialize:function(t){this.callSuper("initialize",t),this.set("rx",t&&t.rx||0),this.set("ry",t&&t.ry||0)},_set:function(t,e){switch(this.callSuper("_set",t,e),t){case"rx":this.rx=e,this.set("width",2*e);break;case"ry":this.ry=e,this.set("height",2*e)}return this},getRx:function(){return this.get("rx")*this.get("scaleX")},getRy:function(){return this.get("ry")*this.get("scaleY")},toObject:function(t){return this.callSuper("toObject",["rx","ry"].concat(t))},_toSVG:function(){return["<ellipse ","COMMON_PARTS",'cx="0" cy="0" ','rx="',this.rx,'" ry="',this.ry,'" />\n']},_render:function(t){t.beginPath(),t.save(),t.transform(1,0,0,this.ry/this.rx,0,0),t.arc(0,0,this.rx,0,e,!1),t.restore(),this._renderPaintInOrder(t)}}),r.Ellipse.ATTRIBUTE_NAMES=r.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")),r.Ellipse.fromElement=function(t,e){var i=r.parseAttributes(t,r.Ellipse.ATTRIBUTE_NAMES);i.left=(i.left||0)-i.rx,i.top=(i.top||0)-i.ry,e(new r.Ellipse(i))},r.Ellipse.fromObject=function(t,e){return r.Object._fromObject("Ellipse",t,e)})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var s=t.fabric||(t.fabric={}),o=s.util.object.extend;s.Rect?s.warn("fabric.Rect is already defined"):(s.Rect=s.util.createClass(s.Object,{stateProperties:s.Object.prototype.stateProperties.concat("rx","ry"),type:"rect",rx:0,ry:0,cacheProperties:s.Object.prototype.cacheProperties.concat("rx","ry"),initialize:function(t){this.callSuper("initialize",t),this._initRxRy()},_initRxRy:function(){this.rx&&!this.ry?this.ry=this.rx:this.ry&&!this.rx&&(this.rx=this.ry)},_render:function(t){var e=this.rx?Math.min(this.rx,this.width/2):0,i=this.ry?Math.min(this.ry,this.height/2):0,r=this.width,n=this.height,s=-this.width/2,o=-this.height/2,a=0!==e||0!==i,h=.4477152502;t.beginPath(),t.moveTo(s+e,o),t.lineTo(s+r-e,o),a&&t.bezierCurveTo(s+r-h*e,o,s+r,o+h*i,s+r,o+i),t.lineTo(s+r,o+n-i),a&&t.bezierCurveTo(s+r,o+n-h*i,s+r-h*e,o+n,s+r-e,o+n),t.lineTo(s+e,o+n),a&&t.bezierCurveTo(s+h*e,o+n,s,o+n-h*i,s,o+n-i),t.lineTo(s,o+i),a&&t.bezierCurveTo(s,o+h*i,s+h*e,o,s+e,o),t.closePath(),this._renderPaintInOrder(t)},_renderDashedStroke:function(t){var e=-this.width/2,i=-this.height/2,r=this.width,n=this.height;t.beginPath(),s.util.drawDashedLine(t,e,i,e+r,i,this.strokeDashArray),s.util.drawDashedLine(t,e+r,i,e+r,i+n,this.strokeDashArray),s.util.drawDashedLine(t,e+r,i+n,e,i+n,this.strokeDashArray),s.util.drawDashedLine(t,e,i+n,e,i,this.strokeDashArray),t.closePath()},toObject:function(t){return this.callSuper("toObject",["rx","ry"].concat(t))},_toSVG:function(){return["<rect ","COMMON_PARTS",'x="',-this.width/2,'" y="',-this.height/2,'" rx="',this.rx,'" ry="',this.ry,'" width="',this.width,'" height="',this.height,'" />\n']}}),s.Rect.ATTRIBUTE_NAMES=s.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")),s.Rect.fromElement=function(t,e,i){if(!t)return e(null);i=i||{};var r=s.parseAttributes(t,s.Rect.ATTRIBUTE_NAMES);r.left=r.left||0,r.top=r.top||0,r.height=r.height||0,r.width=r.width||0;var n=new s.Rect(o(i?s.util.object.clone(i):{},r));n.visible=n.visible&&0<n.width&&0<n.height,e(n)},s.Rect.fromObject=function(t,e){return s.Object._fromObject("Rect",t,e)})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var o=t.fabric||(t.fabric={}),a=o.util.object.extend,r=o.util.array.min,n=o.util.array.max,h=o.util.toFixed;o.Polyline?o.warn("fabric.Polyline is already defined"):(o.Polyline=o.util.createClass(o.Object,{type:"polyline",points:null,cacheProperties:o.Object.prototype.cacheProperties.concat("points"),initialize:function(t,e){e=e||{},this.points=t||[],this.callSuper("initialize",e),this._setPositionDimensions(e)},_setPositionDimensions:function(t){var e,i=this._calcDimensions(t);this.width=i.width,this.height=i.height,t.fromSVG||(e=this.translateToGivenOrigin({x:i.left-this.strokeWidth/2,y:i.top-this.strokeWidth/2},"left","top",this.originX,this.originY)),void 0===t.left&&(this.left=t.fromSVG?i.left:e.x),void 0===t.top&&(this.top=t.fromSVG?i.top:e.y),this.pathOffset={x:i.left+this.width/2,y:i.top+this.height/2}},_calcDimensions:function(){var t=this.points,e=r(t,"x")||0,i=r(t,"y")||0;return{left:e,top:i,width:(n(t,"x")||0)-e,height:(n(t,"y")||0)-i}},toObject:function(t){return a(this.callSuper("toObject",t),{points:this.points.concat()})},_toSVG:function(){for(var t=[],e=this.pathOffset.x,i=this.pathOffset.y,r=o.Object.NUM_FRACTION_DIGITS,n=0,s=this.points.length;n<s;n++)t.push(h(this.points[n].x-e,r),",",h(this.points[n].y-i,r)," ");return["<"+this.type+" ","COMMON_PARTS",'points="',t.join(""),'" />\n']},commonRender:function(t){var e,i=this.points.length,r=this.pathOffset.x,n=this.pathOffset.y;if(!i||isNaN(this.points[i-1].y))return!1;t.beginPath(),t.moveTo(this.points[0].x-r,this.points[0].y-n);for(var s=0;s<i;s++)e=this.points[s],t.lineTo(e.x-r,e.y-n);return!0},_render:function(t){this.commonRender(t)&&this._renderPaintInOrder(t)},_renderDashedStroke:function(t){var e,i;t.beginPath();for(var r=0,n=this.points.length;r<n;r++)e=this.points[r],i=this.points[r+1]||e,o.util.drawDashedLine(t,e.x,e.y,i.x,i.y,this.strokeDashArray)},complexity:function(){return this.get("points").length}}),o.Polyline.ATTRIBUTE_NAMES=o.SHARED_ATTRIBUTES.concat(),o.Polyline.fromElementGenerator=function(s){return function(t,e,i){if(!t)return e(null);i||(i={});var r=o.parsePointsAttribute(t.getAttribute("points")),n=o.parseAttributes(t,o[s].ATTRIBUTE_NAMES);n.fromSVG=!0,e(new o[s](r,a(n,i)))}},o.Polyline.fromElement=o.Polyline.fromElementGenerator("Polyline"),o.Polyline.fromObject=function(t,e){return o.Object._fromObject("Polyline",t,e,"points")})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var i=t.fabric||(t.fabric={});i.Polygon?i.warn("fabric.Polygon is already defined"):(i.Polygon=i.util.createClass(i.Polyline,{type:"polygon",_render:function(t){this.commonRender(t)&&(t.closePath(),this._renderPaintInOrder(t))},_renderDashedStroke:function(t){this.callSuper("_renderDashedStroke",t),t.closePath()}}),i.Polygon.ATTRIBUTE_NAMES=i.SHARED_ATTRIBUTES.concat(),i.Polygon.fromElement=i.Polyline.fromElementGenerator("Polygon"),i.Polygon.fromObject=function(t,e){return i.Object._fromObject("Polygon",t,e,"points")})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var f=t.fabric||(t.fabric={}),d=f.util.array.min,g=f.util.array.max,n=f.util.object.extend,r=Object.prototype.toString,e=f.util.toFixed;f.Path?f.warn("fabric.Path is already defined"):(f.Path=f.util.createClass(f.Object,{type:"path",path:null,cacheProperties:f.Object.prototype.cacheProperties.concat("path","fillRule"),stateProperties:f.Object.prototype.stateProperties.concat("path"),initialize:function(t,e){e=e||{},this.callSuper("initialize",e),t||(t=[]);var i="[object Array]"===r.call(t);this.path=i?f.util.makePathSimpler(t):f.util.makePathSimpler(f.util.parsePath(t)),this.path&&f.Polyline.prototype._setPositionDimensions.call(this,e)},_renderPathCommands:function(t){var e,i=0,r=0,n=0,s=0,o=0,a=0,h=-this.pathOffset.x,c=-this.pathOffset.y;t.beginPath();for(var l=0,u=this.path.length;l<u;++l)switch((e=this.path[l])[0]){case"L":n=e[1],s=e[2],t.lineTo(n+h,s+c);break;case"M":i=n=e[1],r=s=e[2],t.moveTo(n+h,s+c);break;case"C":n=e[5],s=e[6],o=e[3],a=e[4],t.bezierCurveTo(e[1]+h,e[2]+c,o+h,a+c,n+h,s+c);break;case"Q":t.quadraticCurveTo(e[1]+h,e[2]+c,e[3]+h,e[4]+c),n=e[3],s=e[4],o=e[1],a=e[2];break;case"z":case"Z":n=i,s=r,t.closePath()}},_render:function(t){this._renderPathCommands(t),this._renderPaintInOrder(t)},toString:function(){return"#<fabric.Path ("+this.complexity()+'): { "top": '+this.top+', "left": '+this.left+" }>"},toObject:function(t){return n(this.callSuper("toObject",t),{path:this.path.map(function(t){return t.slice()})})},toDatalessObject:function(t){var e=this.toObject(["sourcePath"].concat(t));return e.sourcePath&&delete e.path,e},_toSVG:function(){return["<path ","COMMON_PARTS",'d="',this.path.map(function(t){return t.join(" ")}).join(" "),'" stroke-linecap="round" ',"/>\n"]},_getOffsetTransform:function(){var t=f.Object.NUM_FRACTION_DIGITS;return" translate("+e(-this.pathOffset.x,t)+", "+e(-this.pathOffset.y,t)+")"},toClipPathSVG:function(t){var e=this._getOffsetTransform();return"\t"+this._createBaseClipPathSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})},toSVG:function(t){var e=this._getOffsetTransform();return this._createBaseSVGMarkup(this._toSVG(),{reviver:t,additionalTransform:e})},complexity:function(){return this.path.length},_calcDimensions:function(){for(var t,e,i=[],r=[],n=0,s=0,o=0,a=0,h=0,c=this.path.length;h<c;++h){switch((t=this.path[h])[0]){case"L":o=t[1],a=t[2],e=[];break;case"M":n=o=t[1],s=a=t[2],e=[];break;case"C":e=f.util.getBoundsOfCurve(o,a,t[1],t[2],t[3],t[4],t[5],t[6]),o=t[5],a=t[6];break;case"Q":e=f.util.getBoundsOfCurve(o,a,t[1],t[2],t[1],t[2],t[3],t[4]),o=t[3],a=t[4];break;case"z":case"Z":o=n,a=s}e.forEach(function(t){i.push(t.x),r.push(t.y)}),i.push(o),r.push(a)}var l=d(i)||0,u=d(r)||0;return{left:l,top:u,width:(g(i)||0)-l,height:(g(r)||0)-u}}}),f.Path.fromObject=function(i,r){if("string"==typeof i.sourcePath){var t=i.sourcePath;f.loadSVGFromURL(t,function(t){var e=t[0];e.setOptions(i),r&&r(e)})}else f.Object._fromObject("Path",i,r,"path")},f.Path.ATTRIBUTE_NAMES=f.SHARED_ATTRIBUTES.concat(["d"]),f.Path.fromElement=function(t,e,i){var r=f.parseAttributes(t,f.Path.ATTRIBUTE_NAMES);r.fromSVG=!0,e(new f.Path(r.d,n(r,i)))})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var c=t.fabric||(t.fabric={}),l=c.util.array.min,u=c.util.array.max;c.Group||(c.Group=c.util.createClass(c.Object,c.Collection,{type:"group",strokeWidth:0,subTargetCheck:!1,cacheProperties:[],useSetOnGroup:!1,initialize:function(t,e,i){e=e||{},this._objects=[],i&&this.callSuper("initialize",e),this._objects=t||[];for(var r=this._objects.length;r--;)this._objects[r].group=this;if(i)this._updateObjectsACoords();else{var n=e&&e.centerPoint;void 0!==e.originX&&(this.originX=e.originX),void 0!==e.originY&&(this.originY=e.originY),n||this._calcBounds(),this._updateObjectsCoords(n),delete e.centerPoint,this.callSuper("initialize",e)}this.setCoords()},_updateObjectsACoords:function(){for(var t=this._objects.length;t--;)this._objects[t].setCoords(!0)},_updateObjectsCoords:function(t){t=t||this.getCenterPoint();for(var e=this._objects.length;e--;)this._updateObjectCoords(this._objects[e],t)},_updateObjectCoords:function(t,e){var i=t.left,r=t.top;t.set({left:i-e.x,top:r-e.y}),t.group=this,t.setCoords(!0)},toString:function(){return"#<fabric.Group: ("+this.complexity()+")>"},addWithUpdate:function(t){return this._restoreObjectsState(),c.util.resetObjectTransform(this),t&&(this._objects.push(t),t.group=this,t._set("canvas",this.canvas)),this._calcBounds(),this._updateObjectsCoords(),this.setCoords(),this.dirty=!0,this},removeWithUpdate:function(t){return this._restoreObjectsState(),c.util.resetObjectTransform(this),this.remove(t),this._calcBounds(),this._updateObjectsCoords(),this.setCoords(),this.dirty=!0,this},_onObjectAdded:function(t){this.dirty=!0,t.group=this,t._set("canvas",this.canvas)},_onObjectRemoved:function(t){this.dirty=!0,delete t.group},_set:function(t,e){var i=this._objects.length;if(this.useSetOnGroup)for(;i--;)this._objects[i].setOnGroup(t,e);if("canvas"===t)for(;i--;)this._objects[i]._set(t,e);c.Object.prototype._set.call(this,t,e)},toObject:function(r){var n=this.includeDefaultValues,t=this._objects.map(function(t){var e=t.includeDefaultValues;t.includeDefaultValues=n;var i=t.toObject(r);return t.includeDefaultValues=e,i}),e=c.Object.prototype.toObject.call(this,r);return e.objects=t,e},toDatalessObject:function(r){var t,e=this.sourcePath;if(e)t=e;else{var n=this.includeDefaultValues;t=this._objects.map(function(t){var e=t.includeDefaultValues;t.includeDefaultValues=n;var i=t.toDatalessObject(r);return t.includeDefaultValues=e,i})}var i=c.Object.prototype.toDatalessObject.call(this,r);return i.objects=t,i},render:function(t){this._transformDone=!0,this.callSuper("render",t),this._transformDone=!1},shouldCache:function(){var t=c.Object.prototype.shouldCache.call(this);if(t)for(var e=0,i=this._objects.length;e<i;e++)if(this._objects[e].willDrawShadow())return this.ownCaching=!1;return t},willDrawShadow:function(){if(c.Object.prototype.willDrawShadow.call(this))return!0;for(var t=0,e=this._objects.length;t<e;t++)if(this._objects[t].willDrawShadow())return!0;return!1},isOnACache:function(){return this.ownCaching||this.group&&this.group.isOnACache()},drawObject:function(t){for(var e=0,i=this._objects.length;e<i;e++)this._objects[e].render(t);this._drawClipPath(t)},isCacheDirty:function(t){if(this.callSuper("isCacheDirty",t))return!0;if(!this.statefullCache)return!1;for(var e=0,i=this._objects.length;e<i;e++)if(this._objects[e].isCacheDirty(!0)){if(this._cacheCanvas){var r=this.cacheWidth/this.zoomX,n=this.cacheHeight/this.zoomY;this._cacheContext.clearRect(-r/2,-n/2,r,n)}return!0}return!1},_restoreObjectsState:function(){return this._objects.forEach(this._restoreObjectState,this),this},realizeTransform:function(t){var e=t.calcTransformMatrix(),i=c.util.qrDecompose(e),r=new c.Point(i.translateX,i.translateY);return t.flipX=!1,t.flipY=!1,t.set("scaleX",i.scaleX),t.set("scaleY",i.scaleY),t.skewX=i.skewX,t.skewY=i.skewY,t.angle=i.angle,t.setPositionByOrigin(r,"center","center"),t},_restoreObjectState:function(t){return this.realizeTransform(t),delete t.group,t.setCoords(),this},destroy:function(){return this._objects.forEach(function(t){t.set("dirty",!0)}),this._restoreObjectsState()},toActiveSelection:function(){if(this.canvas){var t=this._objects,e=this.canvas;this._objects=[];var i=this.toObject();delete i.objects;var r=new c.ActiveSelection([]);return r.set(i),r.type="activeSelection",e.remove(this),t.forEach(function(t){t.group=r,t.dirty=!0,e.add(t)}),r.canvas=e,r._objects=t,(e._activeObject=r).setCoords(),r}},ungroupOnCanvas:function(){return this._restoreObjectsState()},setObjectsCoords:function(){return this.forEachObject(function(t){t.setCoords(!0)}),this},_calcBounds:function(t){for(var e,i,r,n=[],s=[],o=["tr","br","bl","tl"],a=0,h=this._objects.length,c=o.length;a<h;++a)for((e=this._objects[a]).aCoords=e.calcACoords(),r=0;r<c;r++)i=o[r],n.push(e.aCoords[i].x),s.push(e.aCoords[i].y);this._getBounds(n,s,t)},_getBounds:function(t,e,i){var r=new c.Point(l(t),l(e)),n=new c.Point(u(t),u(e)),s=r.y||0,o=r.x||0,a=n.x-r.x||0,h=n.y-r.y||0;this.width=a,this.height=h,i||this.setPositionByOrigin({x:o,y:s},"left","top")},_toSVG:function(t){for(var e=["<g ","COMMON_PARTS"," >\n"],i=0,r=this._objects.length;i<r;i++)e.push("\t\t",this._objects[i].toSVG(t));return e.push("</g>\n"),e},getSvgStyles:function(){var t=void 0!==this.opacity&&1!==this.opacity?"opacity: "+this.opacity+";":"",e=this.visible?"":" visibility: hidden;";return[t,this.getSvgFilter(),e].join("")},toClipPathSVG:function(t){for(var e=[],i=0,r=this._objects.length;i<r;i++)e.push("\t",this._objects[i].toClipPathSVG(t));return this._createBaseClipPathSVGMarkup(e,{reviver:t})}}),c.Group.fromObject=function(r,n){var i=r.objects,s=c.util.object.clone(r,!0);delete s.objects,"string"!=typeof i?c.util.enlivenObjects(i,function(i){c.util.enlivenObjects([r.clipPath],function(t){var e=c.util.object.clone(r,!0);e.clipPath=t[0],delete e.objects,n&&n(new c.Group(i,e,!0))})}):c.loadSVGFromURL(i,function(t){var e=c.util.groupSVGElements(t,r,i);e.set(s),n&&n(e)})})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var n=t.fabric||(t.fabric={});n.ActiveSelection||(n.ActiveSelection=n.util.createClass(n.Group,{type:"activeSelection",initialize:function(t,e){e=e||{},this._objects=t||[];for(var i=this._objects.length;i--;)this._objects[i].group=this;e.originX&&(this.originX=e.originX),e.originY&&(this.originY=e.originY),this._calcBounds(),this._updateObjectsCoords(),n.Object.prototype.initialize.call(this,e),this.setCoords()},toGroup:function(){var t=this._objects.concat();this._objects=[];var e=n.Object.prototype.toObject.call(this),i=new n.Group([]);if(delete e.type,i.set(e),t.forEach(function(t){t.canvas.remove(t),t.group=i}),i._objects=t,!this.canvas)return i;var r=this.canvas;return r.add(i),(r._activeObject=i).setCoords(),i},onDeselect:function(){return this.destroy(),!1},toString:function(){return"#<fabric.ActiveSelection: ("+this.complexity()+")>"},shouldCache:function(){return!1},isOnACache:function(){return!1},_renderControls:function(t,e,i){t.save(),t.globalAlpha=this.isMoving?this.borderOpacityWhenMoving:1,this.callSuper("_renderControls",t,e),void 0===(i=i||{}).hasControls&&(i.hasControls=!1),i.forActiveSelection=!0;for(var r=0,n=this._objects.length;r<n;r++)this._objects[r]._renderControls(t,i);t.restore()}}),n.ActiveSelection.fromObject=function(e,i){n.util.enlivenObjects(e.objects,function(t){delete e.objects,i&&i(new n.ActiveSelection(t,e,!0))})})}("undefined"!=typeof exports?exports:this),function(t){"use strict";var n=fabric.util.object.extend;t.fabric||(t.fabric={}),t.fabric.Image?fabric.warn("fabric.Image is already defined."):(fabric.Image=fabric.util.createClass(fabric.Object,{type:"image",strokeWidth:0,srcFromAttribute:!1,_lastScaleX:1,_lastScaleY:1,_filterScalingX:1,_filterScalingY:1,minimumScaleTrigger:.5,stateProperties:fabric.Object.prototype.stateProperties.concat("cropX","cropY"),cacheKey:"",cropX:0,cropY:0,imageSmoothing:!0,initialize:function(t,e){e||(e={}),this.filters=[],this.cacheKey="texture"+fabric.Object.__uid++,this.callSuper("initialize",e),this._initElement(t,e)},getElement:function(){return this._element||{}},setElement:function(t,e){return this.removeTexture(this.cacheKey),this.removeTexture(this.cacheKey+"_filtered"),this._element=t,this._originalElement=t,this._initConfig(e),0!==this.filters.length&&this.applyFilters(),this.resizeFilter&&this.applyResizeFilters(),this},removeTexture:function(t){var e=fabric.filterBackend;e&&e.evictCachesForKey&&e.evictCachesForKey(t)},dispose:function(){this.removeTexture(this.cacheKey),this.removeTexture(this.cacheKey+"_filtered"),this._cacheContext=void 0,["_originalElement","_element","_filteredEl","_cacheCanvas"].forEach(function(t){fabric.util.cleanUpJsdomNode(this[t]),this[t]=void 0}.bind(this))},getCrossOrigin:function(){return this._originalElement&&(this._originalElement.crossOrigin||null)},getOriginalSize:function(){var t=this.getElement();return{width:t.naturalWidth||t.width,height:t.naturalHeight||t.height}},_stroke:function(t){if(this.stroke&&0!==this.strokeWidth){var e=this.width/2,i=this.height/2;t.beginPath(),t.moveTo(-e,-i),t.lineTo(e,-i),t.lineTo(e,i),t.lineTo(-e,i),t.lineTo(-e,-i),t.closePath()}},_renderDashedStroke:function(t){var e=-this.width/2,i=-this.height/2,r=this.width,n=this.height;t.save(),this._setStrokeStyles(t,this),t.beginPath(),fabric.util.drawDashedLine(t,e,i,e+r,i,this.strokeDashArray),fabric.util.drawDashedLine(t,e+r,i,e+r,i+n,this.strokeDashArray),fabric.util.drawDashedLine(t,e+r,i+n,e,i+n,this.strokeDashArray),fabric.util.drawDashedLine(t,e,i+n,e,i,this.strokeDashArray),t.closePath(),t.restore()},toObject:function(t){var e=[];this.filters.forEach(function(t){t&&e.push(t.toObject())});var i=n(this.callSuper("toObject",["cropX","cropY"].concat(t)),{src:this.getSrc(),crossOrigin:this.getCrossOrigin(),filters:e});return this.resizeFilter&&(i.resizeFilter=this.resizeFilter.toObject()),i},hasCrop:function(){return this.cropX||this.cropY||this.width<this._element.width||this.height<this._element.height},_toSVG:function(){var t,e=[],i=[],r=this._element,n=-this.width/2,s=-this.height/2,o="",a="";if(!r)return[];if(this.hasCrop()){var h=fabric.Object.__uid++;e.push('<clipPath id="imageCrop_'+h+'">\n','\t<rect x="'+n+'" y="'+s+'" width="'+this.width+'" height="'+this.height+'" />\n',"</clipPath>\n"),o=' clip-path="url(#imageCrop_'+h+')" '}if(this.imageSmoothing||(a='" image-rendering="optimizeSpeed'),i.push("\t<image ","COMMON_PARTS",'xlink:href="',this.getSvgSrc(!0),'" x="',n-this.cropX,'" y="',s-this.cropY,'" width="',r.width||r.naturalWidth,'" height="',r.height||r.height,a,'"',o,"></image>\n"),this.stroke||this.strokeDashArray){var c=this.fill;this.fill=null,t=["\t<rect ",'x="',n,'" y="',s,'" width="',this.width,'" height="',this.height,'" style="',this.getSvgStyles(),'"/>\n'],this.fill=c}return e="fill"!==this.paintFirst?e.concat(t,i):e.concat(i,t)},getSrc:function(t){var e=t?this._element:this._originalElement;return e?e.toDataURL?e.toDataURL():this.srcFromAttribute?e.getAttribute("src"):e.src:this.src||""},setSrc:function(t,i,r){return fabric.util.loadImage(t,function(t,e){this.setElement(t,r),this._setWidthHeight(),i&&i(this,e)},this,r&&r.crossOrigin),this},toString:function(){return'#<fabric.Image: { src: "'+this.getSrc()+'" }>'},applyResizeFilters:function(){var t=this.resizeFilter,e=this.minimumScaleTrigger,i=this.getTotalObjectScaling(),r=i.scaleX,n=i.scaleY,s=this._filteredEl||this._originalElement;if(this.group&&this.set("dirty",!0),!t||e<r&&e<n)return this._element=s,this._filterScalingX=1,this._filterScalingY=1,this._lastScaleX=r,void(this._lastScaleY=n);fabric.filterBackend||(fabric.filterBackend=fabric.initFilterBackend());var o=fabric.util.createCanvasElement(),a=this._filteredEl?this.cacheKey+"_filtered":this.cacheKey,h=s.width,c=s.height;o.width=h,o.height=c,this._element=o,this._lastScaleX=t.scaleX=r,this._lastScaleY=t.scaleY=n,fabric.filterBackend.applyFilters([t],s,h,c,this._element,a),this._filterScalingX=o.width/this._originalElement.width,this._filterScalingY=o.height/this._originalElement.height},applyFilters:function(t){if(t=(t=t||this.filters||[]).filter(function(t){return t&&!t.isNeutralState()}),this.set("dirty",!0),this.removeTexture(this.cacheKey+"_filtered"),0===t.length)return this._element=this._originalElement,this._filteredEl=null,this._filterScalingX=1,this._filterScalingY=1,this;var e=this._originalElement,i=e.naturalWidth||e.width,r=e.naturalHeight||e.height;if(this._element===this._originalElement){var n=fabric.util.createCanvasElement();n.width=i,n.height=r,this._element=n,this._filteredEl=n}else this._element=this._filteredEl,this._filteredEl.getContext("2d").clearRect(0,0,i,r),this._lastScaleX=1,this._lastScaleY=1;return fabric.filterBackend||(fabric.filterBackend=fabric.initFilterBackend()),fabric.filterBackend.applyFilters(t,this._originalElement,i,r,this._element,this.cacheKey),this._originalElement.width===this._element.width&&this._originalElement.height===this._element.height||(this._filterScalingX=this._element.width/this._originalElement.width,this._filterScalingY=this._element.height/this._originalElement.height),this},_render:function(t){fabric.util.setImageSmoothing(t,this.imageSmoothing),!0!==this.isMoving&&this.resizeFilter&&this._needsResize()&&this.applyResizeFilters(),this._stroke(t),this._renderPaintInOrder(t)},drawCacheOnCanvas:function(t){fabric.util.setImageSmoothing(t,this.imageSmoothing),fabric.Object.prototype.drawCacheOnCanvas.call(this,t)},shouldCache:function(){return this.needsItsOwnCache()},_renderFill:function(t){var e=this._element;if(e){var i=this._filterScalingX,r=this._filterScalingY,n=this.width,s=this.height,o=Math.min,a=Math.max,h=a(this.cropX,0),c=a(this.cropY,0),l=e.naturalWidth||e.width,u=e.naturalHeight||e.height,f=h*i,d=c*r,g=o(n*i,l-f),p=o(s*r,u-d),v=-n/2,m=-s/2,b=o(n,l/i-h),_=o(s,u/i-c);e&&t.drawImage(e,f,d,g,p,v,m,b,_)}},_needsResize:function(){var t=this.getTotalObjectScaling();return t.scaleX!==this._lastScaleX||t.scaleY!==this._lastScaleY},_resetWidthHeight:function(){this.set(this.getOriginalSize())},_initElement:function(t,e){this.setElement(fabric.util.getById(t),e),fabric.util.addClass(this.getElement(),fabric.Image.CSS_CANVAS)},_initConfig:function(t){t||(t={}),this.setOptions(t),this._setWidthHeight(t)},_initFilters:function(t,e){t&&t.length?fabric.util.enlivenObjects(t,function(t){e&&e(t)},"fabric.Image.filters"):e&&e()},_setWidthHeight:function(t){t||(t={});var e=this.getElement();this.width=t.width||e.naturalWidth||e.width||0,this.height=t.height||e.naturalHeight||e.height||0},parsePreserveAspectRatioAttribute:function(){var t,e=fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio||""),i=this._element.width,r=this._element.height,n=1,s=1,o=0,a=0,h=0,c=0,l=this.width,u=this.height,f={width:l,height:u};return!e||"none"===e.alignX&&"none"===e.alignY?(n=l/i,s=u/r):("meet"===e.meetOrSlice&&(t=(l-i*(n=s=fabric.util.findScaleToFit(this._element,f)))/2,"Min"===e.alignX&&(o=-t),"Max"===e.alignX&&(o=t),t=(u-r*s)/2,"Min"===e.alignY&&(a=-t),"Max"===e.alignY&&(a=t)),"slice"===e.meetOrSlice&&(t=i-l/(n=s=fabric.util.findScaleToCover(this._element,f)),"Mid"===e.alignX&&(h=t/2),"Max"===e.alignX&&(h=t),t=r-u/s,"Mid"===e.alignY&&(c=t/2),"Max"===e.alignY&&(c=t),i=l/n,r=u/s)),{width:i,height:r,scaleX:n,scaleY:s,offsetLeft:o,offsetTop:a,cropX:h,cropY:c}}}),fabric.Image.CSS_CANVAS="canvas-img",fabric.Image.prototype.getSvgSrc=fabric.Image.prototype.getSrc,fabric.Image.fromObject=function(t,r){var n=fabric.util.object.clone(t);fabric.util.loadImage(n.src,function(i,t){t?r&&r(null,!0):fabric.Image.prototype._initFilters.call(n,n.filters,function(t){n.filters=t||[],fabric.Image.prototype._initFilters.call(n,[n.resizeFilter],function(t){n.resizeFilter=t[0],fabric.util.enlivenObjects([n.clipPath],function(t){n.clipPath=t[0];var e=new fabric.Image(i,n);r(e,!1)})})})},null,n.crossOrigin)},fabric.Image.fromURL=function(t,i,r){fabric.util.loadImage(t,function(t,e){i&&i(new fabric.Image(t,r),e)},null,r&&r.crossOrigin)},fabric.Image.ATTRIBUTE_NAMES=fabric.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")),fabric.Image.fromElement=function(t,e,i){var r=fabric.parseAttributes(t,fabric.Image.ATTRIBUTE_NAMES);fabric.Image.fromURL(r["xlink:href"],e,n(i?fabric.util.object.clone(i):{},r))})}("undefined"!=typeof exports?exports:this),fabric.util.object.extend(fabric.Object.prototype,{_getAngleValueForStraighten:function(){var t=this.angle%360;return 0<t?90*Math.round((t-1)/90):90*Math.round(t/90)},straighten:function(){return this.rotate(this._getAngleValueForStraighten()),this},fxStraighten:function(t){var e=function(){},i=(t=t||{}).onComplete||e,r=t.onChange||e,n=this;return fabric.util.animate({startValue:this.get("angle"),endValue:this._getAngleValueForStraighten(),duration:this.FX_DURATION,onChange:function(t){n.rotate(t),r()},onComplete:function(){n.setCoords(),i()}}),this}}),fabric.util.object.extend(fabric.StaticCanvas.prototype,{straightenObject:function(t){return t.straighten(),this.requestRenderAll(),this},fxStraightenObject:function(t){return t.fxStraighten({onChange:this.requestRenderAllBound}),this}}),function(){"use strict";function t(t){t&&t.tileSize&&(this.tileSize=t.tileSize),this.setupGLContext(this.tileSize,this.tileSize),this.captureGPUInfo()}fabric.isWebglSupported=function(t){if(fabric.isLikelyNode)return!1;t=t||fabric.WebglFilterBackend.prototype.tileSize;var e,i,r,n=document.createElement("canvas"),s=n.getContext("webgl")||n.getContext("experimental-webgl"),o=!1;if(s){fabric.maxTextureSize=s.getParameter(s.MAX_TEXTURE_SIZE),o=fabric.maxTextureSize>=t;for(var a=["highp","mediump","lowp"],h=0;h<3;h++)if(void 0,i="precision "+a[h]+" float;\nvoid main(){}",r=(e=s).createShader(e.FRAGMENT_SHADER),e.shaderSource(r,i),e.compileShader(r),e.getShaderParameter(r,e.COMPILE_STATUS)){fabric.webGlPrecision=a[h];break}}return this.isSupported=o},(fabric.WebglFilterBackend=t).prototype={tileSize:2048,resources:{},setupGLContext:function(t,e){this.dispose(),this.createWebGLCanvas(t,e),this.aPosition=new Float32Array([0,0,0,1,1,0,1,1]),this.chooseFastestCopyGLTo2DMethod(t,e)},chooseFastestCopyGLTo2DMethod:function(t,e){var i,r=void 0!==window.performance;try{new ImageData(1,1),i=!0}catch(t){i=!1}var n="undefined"!=typeof ArrayBuffer,s="undefined"!=typeof Uint8ClampedArray;if(r&&i&&n&&s){var o=fabric.util.createCanvasElement(),a=new ArrayBuffer(t*e*4);if(fabric.forceGLPutImageData)return this.imageBuffer=a,void(this.copyGLTo2D=copyGLTo2DPutImageData);var h,c,l={imageBuffer:a,destinationWidth:t,destinationHeight:e,targetCanvas:o};o.width=t,o.height=e,h=window.performance.now(),copyGLTo2DDrawImage.call(l,this.gl,l),c=window.performance.now()-h,h=window.performance.now(),copyGLTo2DPutImageData.call(l,this.gl,l),window.performance.now()-h<c?(this.imageBuffer=a,this.copyGLTo2D=copyGLTo2DPutImageData):this.copyGLTo2D=copyGLTo2DDrawImage}},createWebGLCanvas:function(t,e){var i=fabric.util.createCanvasElement();i.width=t,i.height=e;var r={alpha:!0,premultipliedAlpha:!1,depth:!1,stencil:!1,antialias:!1},n=i.getContext("webgl",r);n||(n=i.getContext("experimental-webgl",r)),n&&(n.clearColor(0,0,0,0),this.canvas=i,this.gl=n)},applyFilters:function(t,e,i,r,n,s){var o,a=this.gl;s&&(o=this.getCachedTexture(s,e));var h={originalWidth:e.width||e.originalWidth,originalHeight:e.height||e.originalHeight,sourceWidth:i,sourceHeight:r,destinationWidth:i,destinationHeight:r,context:a,sourceTexture:this.createTexture(a,i,r,!o&&e),targetTexture:this.createTexture(a,i,r),originalTexture:o||this.createTexture(a,i,r,!o&&e),passes:t.length,webgl:!0,aPosition:this.aPosition,programCache:this.programCache,pass:0,filterBackend:this,targetCanvas:n},c=a.createFramebuffer();return a.bindFramebuffer(a.FRAMEBUFFER,c),t.forEach(function(t){t&&t.applyTo(h)}),resizeCanvasIfNeeded(h),this.copyGLTo2D(a,h),a.bindTexture(a.TEXTURE_2D,null),a.deleteTexture(h.sourceTexture),a.deleteTexture(h.targetTexture),a.deleteFramebuffer(c),n.getContext("2d").setTransform(1,0,0,1,0,0),h},dispose:function(){this.canvas&&(this.canvas=null,this.gl=null),this.clearWebGLCaches()},clearWebGLCaches:function(){this.programCache={},this.textureCache={}},createTexture:function(t,e,i,r){var n=t.createTexture();return t.bindTexture(t.TEXTURE_2D,n),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),r?t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,r):t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,i,0,t.RGBA,t.UNSIGNED_BYTE,null),n},getCachedTexture:function(t,e){if(this.textureCache[t])return this.textureCache[t];var i=this.createTexture(this.gl,e.width,e.height,e);return this.textureCache[t]=i},evictCachesForKey:function(t){this.textureCache[t]&&(this.gl.deleteTexture(this.textureCache[t]),delete this.textureCache[t])},copyGLTo2D:copyGLTo2DDrawImage,captureGPUInfo:function(){if(this.gpuInfo)return this.gpuInfo;var t=this.gl,e={renderer:"",vendor:""};if(!t)return e;var i=t.getExtension("WEBGL_debug_renderer_info");if(i){var r=t.getParameter(i.UNMASKED_RENDERER_WEBGL),n=t.getParameter(i.UNMASKED_VENDOR_WEBGL);r&&(e.renderer=r.toLowerCase()),n&&(e.vendor=n.toLowerCase())}return this.gpuInfo=e}}}(),function(){"use strict";var t=function(){};function e(){}(fabric.Canvas2dFilterBackend=e).prototype={evictCachesForKey:t,dispose:t,clearWebGLCaches:t,resources:{},applyFilters:function(t,e,i,r,n){var s=n.getContext("2d");s.drawImage(e,0,0,i,r);var o={sourceWidth:i,sourceHeight:r,imageData:s.getImageData(0,0,i,r),originalEl:e,originalImageData:s.getImageData(0,0,i,r),canvasEl:n,ctx:s,filterBackend:this};return t.forEach(function(t){t.applyTo(o)}),o.imageData.width===i&&o.imageData.height===r||(n.width=o.imageData.width,n.height=o.imageData.height),s.putImageData(o.imageData,0,0),o}}}(),fabric.Image=fabric.Image||{},fabric.Image.filters=fabric.Image.filters||{},fabric.Image.filters.BaseFilter=fabric.util.createClass({type:"BaseFilter",vertexSource:"attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",fragmentSource:"precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}",initialize:function(t){t&&this.setOptions(t)},setOptions:function(t){for(var e in t)this[e]=t[e]},createProgram:function(t,e,i){e=e||this.fragmentSource,i=i||this.vertexSource,"highp"!==fabric.webGlPrecision&&(e=e.replace(/precision highp float/g,"precision "+fabric.webGlPrecision+" float"));var r=t.createShader(t.VERTEX_SHADER);if(t.shaderSource(r,i),t.compileShader(r),!t.getShaderParameter(r,t.COMPILE_STATUS))throw new Error("Vertex shader compile error for "+this.type+": "+t.getShaderInfoLog(r));var n=t.createShader(t.FRAGMENT_SHADER);if(t.shaderSource(n,e),t.compileShader(n),!t.getShaderParameter(n,t.COMPILE_STATUS))throw new Error("Fragment shader compile error for "+this.type+": "+t.getShaderInfoLog(n));var s=t.createProgram();if(t.attachShader(s,r),t.attachShader(s,n),t.linkProgram(s),!t.getProgramParameter(s,t.LINK_STATUS))throw new Error('Shader link error for "${this.type}" '+t.getProgramInfoLog(s));var o=this.getAttributeLocations(t,s),a=this.getUniformLocations(t,s)||{};return a.uStepW=t.getUniformLocation(s,"uStepW"),a.uStepH=t.getUniformLocation(s,"uStepH"),{program:s,attributeLocations:o,uniformLocations:a}},getAttributeLocations:function(t,e){return{aPosition:t.getAttribLocation(e,"aPosition")}},getUniformLocations:function(){return{}},sendAttributeData:function(t,e,i){var r=e.aPosition,n=t.createBuffer();t.bindBuffer(t.ARRAY_BUFFER,n),t.enableVertexAttribArray(r),t.vertexAttribPointer(r,2,t.FLOAT,!1,0,0),t.bufferData(t.ARRAY_BUFFER,i,t.STATIC_DRAW)},_setupFrameBuffer:function(t){var e,i,r=t.context;1<t.passes?(e=t.destinationWidth,i=t.destinationHeight,t.sourceWidth===e&&t.sourceHeight===i||(r.deleteTexture(t.targetTexture),t.targetTexture=t.filterBackend.createTexture(r,e,i)),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t.targetTexture,0)):(r.bindFramebuffer(r.FRAMEBUFFER,null),r.finish())},_swapTextures:function(t){t.passes--,t.pass++;var e=t.targetTexture;t.targetTexture=t.sourceTexture,t.sourceTexture=e},isNeutralState:function(){var t=this.mainParameter,e=fabric.Image.filters[this.type].prototype;if(t){if(Array.isArray(e[t])){for(var i=e[t].length;i--;)if(this[t][i]!==e[t][i])return!1;return!0}return e[t]===this[t]}return!1},applyTo:function(t){t.webgl?(this._setupFrameBuffer(t),this.applyToWebGL(t),this._swapTextures(t)):this.applyTo2d(t)},retrieveShader:function(t){return t.programCache.hasOwnProperty(this.type)||(t.programCache[this.type]=this.createProgram(t.context)),t.programCache[this.type]},applyToWebGL:function(t){var e=t.context,i=this.retrieveShader(t);0===t.pass&&t.originalTexture?e.bindTexture(e.TEXTURE_2D,t.originalTexture):e.bindTexture(e.TEXTURE_2D,t.sourceTexture),e.useProgram(i.program),this.sendAttributeData(e,i.attributeLocations,t.aPosition),e.uniform1f(i.uniformLocations.uStepW,1/t.sourceWidth),e.uniform1f(i.uniformLocations.uStepH,1/t.sourceHeight),this.sendUniformData(e,i.uniformLocations),e.viewport(0,0,t.destinationWidth,t.destinationHeight),e.drawArrays(e.TRIANGLE_STRIP,0,4)},bindAdditionalTexture:function(t,e,i){t.activeTexture(i),t.bindTexture(t.TEXTURE_2D,e),t.activeTexture(t.TEXTURE0)},unbindAdditionalTexture:function(t,e){t.activeTexture(e),t.bindTexture(t.TEXTURE_2D,null),t.activeTexture(t.TEXTURE0)},getMainParameter:function(){return this[this.mainParameter]},setMainParameter:function(t){this[this.mainParameter]=t},sendUniformData:function(){},createHelpLayer:function(t){if(!t.helpLayer){var e=document.createElement("canvas");e.width=t.sourceWidth,e.height=t.sourceHeight,t.helpLayer=e}},toObject:function(){var t={type:this.type},e=this.mainParameter;return e&&(t[e]=this[e]),t},toJSON:function(){return this.toObject()}}),fabric.Image.filters.BaseFilter.fromObject=function(t,e){var i=new fabric.Image.filters[t.type](t);return e&&e(i),i},function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.ColorMatrix=r(i.BaseFilter,{type:"ColorMatrix",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}",matrix:[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],mainParameter:"matrix",colorsOnly:!0,initialize:function(t){this.callSuper("initialize",t),this.matrix=this.matrix.slice(0)},applyTo2d:function(t){var e,i,r,n,s,o=t.imageData.data,a=o.length,h=this.matrix,c=this.colorsOnly;for(s=0;s<a;s+=4)e=o[s],i=o[s+1],r=o[s+2],c?(o[s]=e*h[0]+i*h[1]+r*h[2]+255*h[4],o[s+1]=e*h[5]+i*h[6]+r*h[7]+255*h[9],o[s+2]=e*h[10]+i*h[11]+r*h[12]+255*h[14]):(n=o[s+3],o[s]=e*h[0]+i*h[1]+r*h[2]+n*h[3]+255*h[4],o[s+1]=e*h[5]+i*h[6]+r*h[7]+n*h[8]+255*h[9],o[s+2]=e*h[10]+i*h[11]+r*h[12]+n*h[13]+255*h[14],o[s+3]=e*h[15]+i*h[16]+r*h[17]+n*h[18]+255*h[19])},getUniformLocations:function(t,e){return{uColorMatrix:t.getUniformLocation(e,"uColorMatrix"),uConstants:t.getUniformLocation(e,"uConstants")}},sendUniformData:function(t,e){var i=this.matrix,r=[i[0],i[1],i[2],i[3],i[5],i[6],i[7],i[8],i[10],i[11],i[12],i[13],i[15],i[16],i[17],i[18]],n=[i[4],i[9],i[14],i[19]];t.uniformMatrix4fv(e.uColorMatrix,!1,r),t.uniform4fv(e.uConstants,n)}}),e.Image.filters.ColorMatrix.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Brightness=r(i.BaseFilter,{type:"Brightness",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}",brightness:0,mainParameter:"brightness",applyTo2d:function(t){if(0!==this.brightness){var e,i=t.imageData.data,r=i.length,n=Math.round(255*this.brightness);for(e=0;e<r;e+=4)i[e]=i[e]+n,i[e+1]=i[e+1]+n,i[e+2]=i[e+2]+n}},getUniformLocations:function(t,e){return{uBrightness:t.getUniformLocation(e,"uBrightness")}},sendUniformData:function(t,e){t.uniform1f(e.uBrightness,this.brightness)}}),e.Image.filters.Brightness.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Convolute=n(r.BaseFilter,{type:"Convolute",opaque:!1,matrix:[0,0,0,0,1,0,0,0,0],fragmentSource:{Convolute_3_1:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}",Convolute_3_0:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",Convolute_5_1:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}",Convolute_5_0:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",Convolute_7_1:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}",Convolute_7_0:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",Convolute_9_1:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}",Convolute_9_0:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}"},retrieveShader:function(t){var e=Math.sqrt(this.matrix.length),i=this.type+"_"+e+"_"+(this.opaque?1:0),r=this.fragmentSource[i];return t.programCache.hasOwnProperty(i)||(t.programCache[i]=this.createProgram(t.context,r)),t.programCache[i]},applyTo2d:function(t){var e,i,r,n,s,o,a,h,c,l,u,f,d,g=t.imageData,p=g.data,v=this.matrix,m=Math.round(Math.sqrt(v.length)),b=Math.floor(m/2),_=g.width,y=g.height,x=t.ctx.createImageData(_,y),C=x.data,S=this.opaque?1:0;for(u=0;u<y;u++)for(l=0;l<_;l++){for(s=4*(u*_+l),d=n=r=i=e=0;d<m;d++)for(f=0;f<m;f++)o=l+f-b,(a=u+d-b)<0||y<=a||o<0||_<=o||(h=4*(a*_+o),c=v[d*m+f],e+=p[h]*c,i+=p[h+1]*c,r+=p[h+2]*c,S||(n+=p[h+3]*c));C[s]=e,C[s+1]=i,C[s+2]=r,C[s+3]=S?p[s+3]:n}t.imageData=x},getUniformLocations:function(t,e){return{uMatrix:t.getUniformLocation(e,"uMatrix"),uOpaque:t.getUniformLocation(e,"uOpaque"),uHalfSize:t.getUniformLocation(e,"uHalfSize"),uSize:t.getUniformLocation(e,"uSize")}},sendUniformData:function(t,e){t.uniform1fv(e.uMatrix,this.matrix)},toObject:function(){return i(this.callSuper("toObject"),{opaque:this.opaque,matrix:this.matrix})}}),e.Image.filters.Convolute.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Grayscale=r(i.BaseFilter,{type:"Grayscale",fragmentSource:{average:"precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}",lightness:"precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}",luminosity:"precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}"},mode:"average",mainParameter:"mode",applyTo2d:function(t){var e,i,r=t.imageData.data,n=r.length,s=this.mode;for(e=0;e<n;e+=4)"average"===s?i=(r[e]+r[e+1]+r[e+2])/3:"lightness"===s?i=(Math.min(r[e],r[e+1],r[e+2])+Math.max(r[e],r[e+1],r[e+2]))/2:"luminosity"===s&&(i=.21*r[e]+.72*r[e+1]+.07*r[e+2]),r[e]=i,r[e+1]=i,r[e+2]=i},retrieveShader:function(t){var e=this.type+"_"+this.mode;if(!t.programCache.hasOwnProperty(e)){var i=this.fragmentSource[this.mode];t.programCache[e]=this.createProgram(t.context,i)}return t.programCache[e]},getUniformLocations:function(t,e){return{uMode:t.getUniformLocation(e,"uMode")}},sendUniformData:function(t,e){t.uniform1i(e.uMode,1)},isNeutralState:function(){return!1}}),e.Image.filters.Grayscale.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Invert=r(i.BaseFilter,{type:"Invert",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}",invert:!0,mainParameter:"invert",applyTo2d:function(t){var e,i=t.imageData.data,r=i.length;for(e=0;e<r;e+=4)i[e]=255-i[e],i[e+1]=255-i[e+1],i[e+2]=255-i[e+2]},isNeutralState:function(){return!this.invert},getUniformLocations:function(t,e){return{uInvert:t.getUniformLocation(e,"uInvert")}},sendUniformData:function(t,e){t.uniform1i(e.uInvert,this.invert)}}),e.Image.filters.Invert.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.util.object.extend,r=e.Image.filters,n=e.util.createClass;r.Noise=n(r.BaseFilter,{type:"Noise",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}",mainParameter:"noise",noise:0,applyTo2d:function(t){if(0!==this.noise){var e,i,r=t.imageData.data,n=r.length,s=this.noise;for(e=0,n=r.length;e<n;e+=4)i=(.5-Math.random())*s,r[e]+=i,r[e+1]+=i,r[e+2]+=i}},getUniformLocations:function(t,e){return{uNoise:t.getUniformLocation(e,"uNoise"),uSeed:t.getUniformLocation(e,"uSeed")}},sendUniformData:function(t,e){t.uniform1f(e.uNoise,this.noise/255),t.uniform1f(e.uSeed,Math.random())},toObject:function(){return i(this.callSuper("toObject"),{noise:this.noise})}}),e.Image.filters.Noise.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Pixelate=r(i.BaseFilter,{type:"Pixelate",blocksize:4,mainParameter:"blocksize",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}",applyTo2d:function(t){var e,i,r,n,s,o,a,h,c,l,u,f=t.imageData,d=f.data,g=f.height,p=f.width;for(i=0;i<g;i+=this.blocksize)for(r=0;r<p;r+=this.blocksize)for(n=d[e=4*i*p+4*r],s=d[e+1],o=d[e+2],a=d[e+3],l=Math.min(i+this.blocksize,g),u=Math.min(r+this.blocksize,p),h=i;h<l;h++)for(c=r;c<u;c++)d[e=4*h*p+4*c]=n,d[e+1]=s,d[e+2]=o,d[e+3]=a},isNeutralState:function(){return 1===this.blocksize},getUniformLocations:function(t,e){return{uBlocksize:t.getUniformLocation(e,"uBlocksize"),uStepW:t.getUniformLocation(e,"uStepW"),uStepH:t.getUniformLocation(e,"uStepH")}},sendUniformData:function(t,e){t.uniform1f(e.uBlocksize,this.blocksize)}}),e.Image.filters.Pixelate.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var l=t.fabric||(t.fabric={}),e=l.util.object.extend,i=l.Image.filters,r=l.util.createClass;i.RemoveColor=r(i.BaseFilter,{type:"RemoveColor",color:"#FFFFFF",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}",distance:.02,useAlpha:!1,applyTo2d:function(t){var e,i,r,n,s=t.imageData.data,o=255*this.distance,a=new l.Color(this.color).getSource(),h=[a[0]-o,a[1]-o,a[2]-o],c=[a[0]+o,a[1]+o,a[2]+o];for(e=0;e<s.length;e+=4)i=s[e],r=s[e+1],n=s[e+2],h[0]<i&&h[1]<r&&h[2]<n&&i<c[0]&&r<c[1]&&n<c[2]&&(s[e+3]=0)},getUniformLocations:function(t,e){return{uLow:t.getUniformLocation(e,"uLow"),uHigh:t.getUniformLocation(e,"uHigh")}},sendUniformData:function(t,e){var i=new l.Color(this.color).getSource(),r=parseFloat(this.distance),n=[0+i[0]/255-r,0+i[1]/255-r,0+i[2]/255-r,1],s=[i[0]/255+r,i[1]/255+r,i[2]/255+r,1];t.uniform4fv(e.uLow,n),t.uniform4fv(e.uHigh,s)},toObject:function(){return e(this.callSuper("toObject"),{color:this.color,distance:this.distance})}}),l.Image.filters.RemoveColor.fromObject=l.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass,n={Brownie:[.5997,.34553,-.27082,0,.186,-.0377,.86095,.15059,0,-.1449,.24113,-.07441,.44972,0,-.02965,0,0,0,1,0],Vintage:[.62793,.32021,-.03965,0,.03784,.02578,.64411,.03259,0,.02926,.0466,-.08512,.52416,0,.02023,0,0,0,1,0],Kodachrome:[1.12855,-.39673,-.03992,0,.24991,-.16404,1.08352,-.05498,0,.09698,-.16786,-.56034,1.60148,0,.13972,0,0,0,1,0],Technicolor:[1.91252,-.85453,-.09155,0,.04624,-.30878,1.76589,-.10601,0,-.27589,-.2311,-.75018,1.84759,0,.12137,0,0,0,1,0],Polaroid:[1.438,-.062,-.062,0,0,-.122,1.378,-.122,0,0,-.016,-.016,1.483,0,0,0,0,0,1,0],Sepia:[.393,.769,.189,0,0,.349,.686,.168,0,0,.272,.534,.131,0,0,0,0,0,1,0],BlackWhite:[1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,1.5,1.5,1.5,0,-1,0,0,0,1,0]};for(var s in n)i[s]=r(i.ColorMatrix,{type:s,matrix:n[s],mainParameter:!1,colorsOnly:!0}),e.Image.filters[s].fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var f=t.fabric,e=f.Image.filters,i=f.util.createClass;e.BlendColor=i(e.BaseFilter,{type:"BlendColor",color:"#F95C63",mode:"multiply",alpha:1,fragmentSource:{multiply:"gl_FragColor.rgb *= uColor.rgb;\n",screen:"gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",add:"gl_FragColor.rgb += uColor.rgb;\n",diff:"gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",subtract:"gl_FragColor.rgb -= uColor.rgb;\n",lighten:"gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",darken:"gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",exclusion:"gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",overlay:"if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n",tint:"gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n"},buildSource:function(t){return"precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n"+this.fragmentSource[t]+"}\n}"},retrieveShader:function(t){var e,i=this.type+"_"+this.mode;return t.programCache.hasOwnProperty(i)||(e=this.buildSource(this.mode),t.programCache[i]=this.createProgram(t.context,e)),t.programCache[i]},applyTo2d:function(t){var e,i,r,n,s,o,a,h=t.imageData.data,c=h.length,l=1-this.alpha;e=(a=new f.Color(this.color).getSource())[0]*this.alpha,i=a[1]*this.alpha,r=a[2]*this.alpha;for(var u=0;u<c;u+=4)switch(n=h[u],s=h[u+1],o=h[u+2],this.mode){case"multiply":h[u]=n*e/255,h[u+1]=s*i/255,h[u+2]=o*r/255;break;case"screen":h[u]=255-(255-n)*(255-e)/255,h[u+1]=255-(255-s)*(255-i)/255,h[u+2]=255-(255-o)*(255-r)/255;break;case"add":h[u]=n+e,h[u+1]=s+i,h[u+2]=o+r;break;case"diff":case"difference":h[u]=Math.abs(n-e),h[u+1]=Math.abs(s-i),h[u+2]=Math.abs(o-r);break;case"subtract":h[u]=n-e,h[u+1]=s-i,h[u+2]=o-r;break;case"darken":h[u]=Math.min(n,e),h[u+1]=Math.min(s,i),h[u+2]=Math.min(o,r);break;case"lighten":h[u]=Math.max(n,e),h[u+1]=Math.max(s,i),h[u+2]=Math.max(o,r);break;case"overlay":h[u]=e<128?2*n*e/255:255-2*(255-n)*(255-e)/255,h[u+1]=i<128?2*s*i/255:255-2*(255-s)*(255-i)/255,h[u+2]=r<128?2*o*r/255:255-2*(255-o)*(255-r)/255;break;case"exclusion":h[u]=e+n-2*e*n/255,h[u+1]=i+s-2*i*s/255,h[u+2]=r+o-2*r*o/255;break;case"tint":h[u]=e+n*l,h[u+1]=i+s*l,h[u+2]=r+o*l}},getUniformLocations:function(t,e){return{uColor:t.getUniformLocation(e,"uColor")}},sendUniformData:function(t,e){var i=new f.Color(this.color).getSource();i[0]=this.alpha*i[0]/255,i[1]=this.alpha*i[1]/255,i[2]=this.alpha*i[2]/255,i[3]=this.alpha,t.uniform4fv(e.uColor,i)},toObject:function(){return{type:this.type,color:this.color,mode:this.mode,alpha:this.alpha}}}),f.Image.filters.BlendColor.fromObject=f.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var y=t.fabric,e=y.Image.filters,i=y.util.createClass;e.BlendImage=i(e.BaseFilter,{type:"BlendImage",image:null,mode:"multiply",alpha:1,vertexSource:"attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",fragmentSource:{multiply:"precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}",mask:"precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}"},retrieveShader:function(t){var e=this.type+"_"+this.mode,i=this.fragmentSource[this.mode];return t.programCache.hasOwnProperty(e)||(t.programCache[e]=this.createProgram(t.context,i)),t.programCache[e]},applyToWebGL:function(t){var e=t.context,i=this.createTexture(t.filterBackend,this.image);this.bindAdditionalTexture(e,i,e.TEXTURE1),this.callSuper("applyToWebGL",t),this.unbindAdditionalTexture(e,e.TEXTURE1)},createTexture:function(t,e){return t.getCachedTexture(e.cacheKey,e._element)},calculateMatrix:function(){var t=this.image,e=t._element.width,i=t._element.height;return[1/t.scaleX,0,0,0,1/t.scaleY,0,-t.left/e,-t.top/i,1]},applyTo2d:function(t){var e,i,r,n,s,o,a,h,c,l,u,f=t.imageData,d=t.filterBackend.resources,g=f.data,p=g.length,v=f.width,m=f.height,b=this.image;d.blendImage||(d.blendImage=y.util.createCanvasElement()),l=(c=d.blendImage).getContext("2d"),c.width!==v||c.height!==m?(c.width=v,c.height=m):l.clearRect(0,0,v,m),l.setTransform(b.scaleX,0,0,b.scaleY,b.left,b.top),l.drawImage(b._element,0,0,v,m),u=l.getImageData(0,0,v,m).data;for(var _=0;_<p;_+=4)switch(s=g[_],o=g[_+1],a=g[_+2],h=g[_+3],e=u[_],i=u[_+1],r=u[_+2],n=u[_+3],this.mode){case"multiply":g[_]=s*e/255,g[_+1]=o*i/255,g[_+2]=a*r/255,g[_+3]=h*n/255;break;case"mask":g[_+3]=n}},getUniformLocations:function(t,e){return{uTransformMatrix:t.getUniformLocation(e,"uTransformMatrix"),uImage:t.getUniformLocation(e,"uImage")}},sendUniformData:function(t,e){var i=this.calculateMatrix();t.uniform1i(e.uImage,1),t.uniformMatrix3fv(e.uTransformMatrix,!1,i)},toObject:function(){return{type:this.type,image:this.image&&this.image.toObject(),mode:this.mode,alpha:this.alpha}}}),y.Image.filters.BlendImage.fromObject=function(i,r){y.Image.fromObject(i.image,function(t){var e=y.util.object.clone(i);e.image=t,r(new y.Image.filters.BlendImage(e))})}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var m=t.fabric||(t.fabric={}),A=Math.pow,j=Math.floor,M=Math.sqrt,F=Math.abs,c=Math.round,r=Math.sin,I=Math.ceil,e=m.Image.filters,i=m.util.createClass;e.Resize=i(e.BaseFilter,{type:"Resize",resizeType:"hermite",scaleX:1,scaleY:1,lanczosLobes:3,getUniformLocations:function(t,e){return{uDelta:t.getUniformLocation(e,"uDelta"),uTaps:t.getUniformLocation(e,"uTaps")}},sendUniformData:function(t,e){t.uniform2fv(e.uDelta,this.horizontal?[1/this.width,0]:[0,1/this.height]),t.uniform1fv(e.uTaps,this.taps)},retrieveShader:function(t){var e=this.getFilterWindow(),i=this.type+"_"+e;if(!t.programCache.hasOwnProperty(i)){var r=this.generateShader(e);t.programCache[i]=this.createProgram(t.context,r)}return t.programCache[i]},getFilterWindow:function(){var t=this.tempScale;return Math.ceil(this.lanczosLobes/t)},getTaps:function(){for(var t=this.lanczosCreate(this.lanczosLobes),e=this.tempScale,i=this.getFilterWindow(),r=new Array(i),n=1;n<=i;n++)r[n-1]=t(n*e);return r},generateShader:function(t){for(var e=new Array(t),i=this.fragmentSourceTOP,r=1;r<=t;r++)e[r-1]=r+".0 * uDelta";return i+="uniform float uTaps["+t+"];\n",i+="void main() {\n",i+="  vec4 color = texture2D(uTexture, vTexCoord);\n",i+="  float sum = 1.0;\n",e.forEach(function(t,e){i+="  color += texture2D(uTexture, vTexCoord + "+t+") * uTaps["+e+"];\n",i+="  color += texture2D(uTexture, vTexCoord - "+t+") * uTaps["+e+"];\n",i+="  sum += 2.0 * uTaps["+e+"];\n"}),i+="  gl_FragColor = color / sum;\n",i+="}"},fragmentSourceTOP:"precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n",applyTo:function(t){t.webgl?(t.passes++,this.width=t.sourceWidth,this.horizontal=!0,this.dW=Math.round(this.width*this.scaleX),this.dH=t.sourceHeight,this.tempScale=this.dW/this.width,this.taps=this.getTaps(),t.destinationWidth=this.dW,this._setupFrameBuffer(t),this.applyToWebGL(t),this._swapTextures(t),t.sourceWidth=t.destinationWidth,this.height=t.sourceHeight,this.horizontal=!1,this.dH=Math.round(this.height*this.scaleY),this.tempScale=this.dH/this.height,this.taps=this.getTaps(),t.destinationHeight=this.dH,this._setupFrameBuffer(t),this.applyToWebGL(t),this._swapTextures(t),t.sourceHeight=t.destinationHeight):this.applyTo2d(t)},isNeutralState:function(){return 1===this.scaleX&&1===this.scaleY},lanczosCreate:function(i){return function(t){if(i<=t||t<=-i)return 0;if(t<1.1920929e-7&&-1.1920929e-7<t)return 1;var e=(t*=Math.PI)/i;return r(t)/t*r(e)/e}},applyTo2d:function(t){var e=t.imageData,i=this.scaleX,r=this.scaleY;this.rcpScaleX=1/i,this.rcpScaleY=1/r;var n,s=e.width,o=e.height,a=c(s*i),h=c(o*r);"sliceHack"===this.resizeType?n=this.sliceByTwo(t,s,o,a,h):"hermite"===this.resizeType?n=this.hermiteFastResize(t,s,o,a,h):"bilinear"===this.resizeType?n=this.bilinearFiltering(t,s,o,a,h):"lanczos"===this.resizeType&&(n=this.lanczosResize(t,s,o,a,h)),t.imageData=n},sliceByTwo:function(t,e,i,r,n){var s,o,a=t.imageData,h=!1,c=!1,l=.5*e,u=.5*i,f=m.filterBackend.resources,d=0,g=0,p=e,v=0;for(f.sliceByTwo||(f.sliceByTwo=document.createElement("canvas")),((s=f.sliceByTwo).width<1.5*e||s.height<i)&&(s.width=1.5*e,s.height=i),(o=s.getContext("2d")).clearRect(0,0,1.5*e,i),o.putImageData(a,0,0),r=j(r),n=j(n);!h||!c;)i=u,r<j(.5*(e=l))?l=j(.5*l):(l=r,h=!0),n<j(.5*u)?u=j(.5*u):(u=n,c=!0),o.drawImage(s,d,g,e,i,p,v,l,u),d=p,g=v,v+=u;return o.getImageData(d,g,r,n)},lanczosResize:function(t,g,p,v,m){var b=t.imageData.data,_=t.ctx.createImageData(v,m),y=_.data,x=this.lanczosCreate(this.lanczosLobes),C=this.rcpScaleX,S=this.rcpScaleY,T=2/this.rcpScaleX,w=2/this.rcpScaleY,O=I(C*this.lanczosLobes/2),k=I(S*this.lanczosLobes/2),P={},D={},E={};return function t(e){var i,r,n,s,o,a,h,c,l,u,f;for(D.x=(e+.5)*C,E.x=j(D.x),i=0;i<m;i++){for(D.y=(i+.5)*S,E.y=j(D.y),l=c=h=a=o=0,r=E.x-O;r<=E.x+O;r++)if(!(r<0||g<=r)){u=j(1e3*F(r-D.x)),P[u]||(P[u]={});for(var d=E.y-k;d<=E.y+k;d++)d<0||p<=d||(f=j(1e3*F(d-D.y)),P[u][f]||(P[u][f]=x(M(A(u*T,2)+A(f*w,2))/1e3)),0<(n=P[u][f])&&(o+=n,a+=n*b[s=4*(d*g+r)],h+=n*b[s+1],c+=n*b[s+2],l+=n*b[s+3]))}y[s=4*(i*v+e)]=a/o,y[s+1]=h/o,y[s+2]=c/o,y[s+3]=l/o}return++e<v?t(e):_}(0)},bilinearFiltering:function(t,e,i,r,n){var s,o,a,h,c,l,u,f,d,g=0,p=this.rcpScaleX,v=this.rcpScaleY,m=4*(e-1),b=t.imageData.data,_=t.ctx.createImageData(r,n),y=_.data;for(a=0;a<n;a++)for(h=0;h<r;h++)for(c=p*h-(s=j(p*h)),l=v*a-(o=j(v*a)),d=4*(o*e+s),u=0;u<4;u++)f=b[d+u]*(1-c)*(1-l)+b[d+4+u]*c*(1-l)+b[d+m+u]*l*(1-c)+b[d+m+4+u]*c*l,y[g++]=f;return _},hermiteFastResize:function(t,e,i,r,n){for(var s=this.rcpScaleX,o=this.rcpScaleY,a=I(s/2),h=I(o/2),c=t.imageData.data,l=t.ctx.createImageData(r,n),u=l.data,f=0;f<n;f++)for(var d=0;d<r;d++){for(var g=4*(d+f*r),p=0,v=0,m=0,b=0,_=0,y=0,x=0,C=(f+.5)*o,S=j(f*o);S<(f+1)*o;S++)for(var T=F(C-(S+.5))/h,w=(d+.5)*s,O=T*T,k=j(d*s);k<(d+1)*s;k++){var P=F(w-(k+.5))/a,D=M(O+P*P);1<D&&D<-1||0<(p=2*D*D*D-3*D*D+1)&&(x+=p*c[(P=4*(k+S*e))+3],m+=p,c[P+3]<255&&(p=p*c[P+3]/250),b+=p*c[P],_+=p*c[P+1],y+=p*c[P+2],v+=p)}u[g]=b/v,u[g+1]=_/v,u[g+2]=y/v,u[g+3]=x/m}return l},toObject:function(){return{type:this.type,scaleX:this.scaleX,scaleY:this.scaleY,resizeType:this.resizeType,lanczosLobes:this.lanczosLobes}}}),m.Image.filters.Resize.fromObject=m.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Contrast=r(i.BaseFilter,{type:"Contrast",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}",contrast:0,mainParameter:"contrast",applyTo2d:function(t){if(0!==this.contrast){var e,i=t.imageData.data,r=i.length,n=Math.floor(255*this.contrast),s=259*(n+255)/(255*(259-n));for(e=0;e<r;e+=4)i[e]=s*(i[e]-128)+128,i[e+1]=s*(i[e+1]-128)+128,i[e+2]=s*(i[e+2]-128)+128}},getUniformLocations:function(t,e){return{uContrast:t.getUniformLocation(e,"uContrast")}},sendUniformData:function(t,e){t.uniform1f(e.uContrast,this.contrast)}}),e.Image.filters.Contrast.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Saturation=r(i.BaseFilter,{type:"Saturation",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}",saturation:0,mainParameter:"saturation",applyTo2d:function(t){if(0!==this.saturation){var e,i,r=t.imageData.data,n=r.length,s=-this.saturation;for(e=0;e<n;e+=4)i=Math.max(r[e],r[e+1],r[e+2]),r[e]+=i!==r[e]?(i-r[e])*s:0,r[e+1]+=i!==r[e+1]?(i-r[e+1])*s:0,r[e+2]+=i!==r[e+2]?(i-r[e+2])*s:0}},getUniformLocations:function(t,e){return{uSaturation:t.getUniformLocation(e,"uSaturation")}},sendUniformData:function(t,e){t.uniform1f(e.uSaturation,-this.saturation)}}),e.Image.filters.Saturation.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var g=t.fabric||(t.fabric={}),e=g.Image.filters,i=g.util.createClass;e.Blur=i(e.BaseFilter,{type:"Blur",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}",blur:0,mainParameter:"blur",applyTo:function(t){t.webgl?(this.aspectRatio=t.sourceWidth/t.sourceHeight,t.passes++,this._setupFrameBuffer(t),this.horizontal=!0,this.applyToWebGL(t),this._swapTextures(t),this._setupFrameBuffer(t),this.horizontal=!1,this.applyToWebGL(t),this._swapTextures(t)):this.applyTo2d(t)},applyTo2d:function(t){t.imageData=this.simpleBlur(t)},simpleBlur:function(t){var e,i,r=t.filterBackend.resources,n=t.imageData.width,s=t.imageData.height;r.blurLayer1||(r.blurLayer1=g.util.createCanvasElement(),r.blurLayer2=g.util.createCanvasElement()),e=r.blurLayer1,i=r.blurLayer2,e.width===n&&e.height===s||(i.width=e.width=n,i.height=e.height=s);var o,a,h,c,l=e.getContext("2d"),u=i.getContext("2d"),f=.06*this.blur*.5;for(l.putImageData(t.imageData,0,0),u.clearRect(0,0,n,s),c=-15;c<=15;c++)h=f*(a=c/15)*n+(o=(Math.random()-.5)/4),u.globalAlpha=1-Math.abs(a),u.drawImage(e,h,o),l.drawImage(i,0,0),u.globalAlpha=1,u.clearRect(0,0,i.width,i.height);for(c=-15;c<=15;c++)h=f*(a=c/15)*s+(o=(Math.random()-.5)/4),u.globalAlpha=1-Math.abs(a),u.drawImage(e,o,h),l.drawImage(i,0,0),u.globalAlpha=1,u.clearRect(0,0,i.width,i.height);t.ctx.drawImage(e,0,0);var d=t.ctx.getImageData(0,0,e.width,e.height);return l.globalAlpha=1,l.clearRect(0,0,e.width,e.height),d},getUniformLocations:function(t,e){return{delta:t.getUniformLocation(e,"uDelta")}},sendUniformData:function(t,e){var i=this.chooseRightDelta();t.uniform2fv(e.delta,i)},chooseRightDelta:function(){var t,e=1,i=[0,0];return this.horizontal?1<this.aspectRatio&&(e=1/this.aspectRatio):this.aspectRatio<1&&(e=this.aspectRatio),t=e*this.blur*.12,this.horizontal?i[0]=t:i[1]=t,i}}),e.Blur.fromObject=g.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var e=t.fabric||(t.fabric={}),i=e.Image.filters,r=e.util.createClass;i.Gamma=r(i.BaseFilter,{type:"Gamma",fragmentSource:"precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}",gamma:[1,1,1],mainParameter:"gamma",initialize:function(t){this.gamma=[1,1,1],i.BaseFilter.prototype.initialize.call(this,t)},applyTo2d:function(t){var e,i=t.imageData.data,r=this.gamma,n=i.length,s=1/r[0],o=1/r[1],a=1/r[2];for(this.rVals||(this.rVals=new Uint8Array(256),this.gVals=new Uint8Array(256),this.bVals=new Uint8Array(256)),e=0,n=256;e<n;e++)this.rVals[e]=255*Math.pow(e/255,s),this.gVals[e]=255*Math.pow(e/255,o),this.bVals[e]=255*Math.pow(e/255,a);for(e=0,n=i.length;e<n;e+=4)i[e]=this.rVals[i[e]],i[e+1]=this.gVals[i[e+1]],i[e+2]=this.bVals[i[e+2]]},getUniformLocations:function(t,e){return{uGamma:t.getUniformLocation(e,"uGamma")}},sendUniformData:function(t,e){t.uniform3fv(e.uGamma,this.gamma)}}),e.Image.filters.Gamma.fromObject=e.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var n=t.fabric||(t.fabric={}),e=n.Image.filters,i=n.util.createClass;e.Composed=i(e.BaseFilter,{type:"Composed",subFilters:[],initialize:function(t){this.callSuper("initialize",t),this.subFilters=this.subFilters.slice(0)},applyTo:function(e){e.passes+=this.subFilters.length-1,this.subFilters.forEach(function(t){t.applyTo(e)})},toObject:function(){return n.util.object.extend(this.callSuper("toObject"),{subFilters:this.subFilters.map(function(t){return t.toObject()})})},isNeutralState:function(){return!this.subFilters.some(function(t){return!t.isNeutralState()})}}),n.Image.filters.Composed.fromObject=function(t,e){var i=(t.subFilters||[]).map(function(t){return new n.Image.filters[t.type](t)}),r=new n.Image.filters.Composed({subFilters:i});return e&&e(r),r}}("undefined"!=typeof exports?exports:this),function(t){"use strict";var s=t.fabric||(t.fabric={}),e=s.Image.filters,i=s.util.createClass;e.HueRotation=i(e.ColorMatrix,{type:"HueRotation",rotation:0,mainParameter:"rotation",calculateMatrix:function(){var t=this.rotation*Math.PI,e=s.util.cos(t),i=s.util.sin(t),r=Math.sqrt(1/3)*i,n=1-e;this.matrix=[1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0],this.matrix[0]=e+n/3,this.matrix[1]=1/3*n-r,this.matrix[2]=1/3*n+r,this.matrix[5]=1/3*n+r,this.matrix[6]=e+1/3*n,this.matrix[7]=1/3*n-r,this.matrix[10]=1/3*n-r,this.matrix[11]=1/3*n+r,this.matrix[12]=e+1/3*n},isNeutralState:function(t){return this.calculateMatrix(),e.BaseFilter.prototype.isNeutralState.call(this,t)},applyTo:function(t){this.calculateMatrix(),e.BaseFilter.prototype.applyTo.call(this,t)}}),s.Image.filters.HueRotation.fromObject=s.Image.filters.BaseFilter.fromObject}("undefined"!=typeof exports?exports:this),function(t){"use strict";var d=t.fabric||(t.fabric={}),g=d.util.object.clone;if(d.Text)d.warn("fabric.Text is already defined");else{var e="fontFamily fontWeight fontSize text underline overline linethrough"+" textAlign fontStyle lineHeight textBackgroundColor charSpacing styles path".split(" ");d.Text=d.util.createClass(d.Object,{_dimensionAffectingProps:["fontSize","fontWeight","fontFamily","fontStyle","lineHeight","text","charSpacing","textAlign","styles","path"],_reNewline:/\r?\n/,_reSpacesAndTabs:/[ \t\r]/g,_reSpaceAndTab:/[ \t\r]/,_reWords:/\S+/g,type:"text",fontSize:40,fontWeight:"normal",fontFamily:"Times New Roman",underline:!1,overline:!1,linethrough:!1,textAlign:"left",fontStyle:"normal",lineHeight:1.16,superscript:{size:.6,baseline:-.35},subscript:{size:.6,baseline:.11},textBackgroundColor:"",stateProperties:d.Object.prototype.stateProperties.concat(e),cacheProperties:d.Object.prototype.cacheProperties.concat(e),stroke:null,shadow:null,_fontSizeFraction:.222,offsets:{underline:.1,linethrough:-.315,overline:-.88},_fontSizeMult:1.13,charSpacing:0,styles:null,_measuringContext:null,deltaY:0,_styleProperties:["stroke","strokeWidth","fill","fontFamily","fontSize","fontWeight","fontStyle","underline","overline","linethrough","deltaY","textBackgroundColor"],__charBounds:[],CACHE_FONT_SIZE:400,MIN_TEXT_WIDTH:2,initialize:function(t,e){this.styles=e&&e.styles||{},this.text=t,this.__skipDimension=!0,this.callSuper("initialize",e),this.path&&this.setPathInfo(),this.__skipDimension=!1,this.initDimensions(),this.setCoords(),this.setupState({propertySet:"_dimensionAffectingProps"})},setPathInfo:function(){var t=this.path;t&&(t.segmentsInfo=d.util.getPathSegmentsInfo(t.path))},getMeasuringContext:function(){return d._measuringContext||(d._measuringContext=this.canvas&&this.canvas.contextCache||d.util.createCanvasElement().getContext("2d")),d._measuringContext},_splitText:function(){var t=this._splitTextIntoLines(this.text);return this.textLines=t.lines,this._textLines=t.graphemeLines,this._unwrappedTextLines=t._unwrappedLines,this._text=t.graphemeText,t},initDimensions:function(){this.__skipDimension||(this._splitText(),this._clearCache(),this.path?(this.width=this.path.width,this.height=this.path.height):(this.width=this.calcTextWidth()||this.cursorWidth||this.MIN_TEXT_WIDTH,this.height=this.calcTextHeight()),-1!==this.textAlign.indexOf("justify")&&this.enlargeSpaces(),this.saveState({propertySet:"_dimensionAffectingProps"}))},enlargeSpaces:function(){for(var t,e,i,r,n,s,o,a=0,h=this._textLines.length;a<h;a++)if(("justify"===this.textAlign||a!==h-1&&!this.isEndOfWrapping(a))&&(r=0,n=this._textLines[a],(e=this.getLineWidth(a))<this.width&&(o=this.textLines[a].match(this._reSpacesAndTabs)))){i=o.length,t=(this.width-e)/i;for(var c=0,l=n.length;c<=l;c++)s=this.__charBounds[a][c],this._reSpaceAndTab.test(n[c])?(s.width+=t,s.kernedWidth+=t,s.left+=r,r+=t):s.left+=r}},isEndOfWrapping:function(t){return t===this._textLines.length-1},missingNewlineOffset:function(){return 1},toString:function(){return"#<fabric.Text ("+this.complexity()+'): { "text": "'+this.text+'", "fontFamily": "'+this.fontFamily+'" }>'},_getCacheCanvasDimensions:function(){var t=this.callSuper("_getCacheCanvasDimensions"),e=this.fontSize;return t.width+=e*t.zoomX,t.height+=e*t.zoomY,t},_render:function(t){this._setTextStyles(t),this._renderTextLinesBackground(t),this._renderTextDecoration(t,"underline"),this._renderText(t),this._renderTextDecoration(t,"overline"),this._renderTextDecoration(t,"linethrough")},_renderText:function(t){"stroke"===this.paintFirst?(this._renderTextStroke(t),this._renderTextFill(t)):(this._renderTextFill(t),this._renderTextStroke(t))},_setTextStyles:function(t,e,i){t.textBaseline="alphabetic",t.font=this._getFontDeclaration(e,i)},calcTextWidth:function(){for(var t=this.getLineWidth(0),e=1,i=this._textLines.length;e<i;e++){var r=this.getLineWidth(e);t<r&&(t=r)}return t},_renderTextLine:function(t,e,i,r,n,s){this._renderChars(t,e,i,r,n,s)},_renderTextLinesBackground:function(t){if(this.textBackgroundColor||this.styleHas("textBackgroundColor")){for(var e,i,r,n,s,o,a=t.fillStyle,h=this._getLeftOffset(),c=this._getTopOffset(),l=0,u=0,f=this.path,d=0,g=this._textLines.length;d<g;d++)if(e=this.getHeightOfLine(d),this.textBackgroundColor||this.styleHas("textBackgroundColor",d)){r=this._textLines[d],i=this._getLineLeftOffset(d),l=u=0,n=this.getValueOfPropertyAt(d,0,"textBackgroundColor");for(var p=0,v=r.length;p<v;p++)s=this.__charBounds[d][p],o=this.getValueOfPropertyAt(d,p,"textBackgroundColor"),f?(t.save(),t.translate(s.renderLeft,s.renderTop),t.rotate(s.angle),(t.fillStyle=o)&&t.fillRect(-s.width/2,-e/this.lineHeight*(1-this._fontSizeFraction),s.width,e/this.lineHeight),t.restore()):o!==n?((t.fillStyle=n)&&t.fillRect(h+i+l,c,u,e/this.lineHeight),l=s.left,u=s.width,n=o):u+=s.kernedWidth;o&&!f&&(t.fillStyle=o,t.fillRect(h+i+l,c,u,e/this.lineHeight)),c+=e}else c+=e;t.fillStyle=a,this._removeShadow(t)}},getFontCache:function(t){var e=t.fontFamily.toLowerCase();d.charWidthsCache[e]||(d.charWidthsCache[e]={});var i=d.charWidthsCache[e],r=t.fontStyle.toLowerCase()+"_"+(t.fontWeight+"").toLowerCase();return i[r]||(i[r]={}),i[r]},_measureChar:function(t,e,i,r){var n,s,o,a,h=this.getFontCache(e),c=i+t,l=this._getFontDeclaration(e)===this._getFontDeclaration(r),u=e.fontSize/this.CACHE_FONT_SIZE;if(i&&void 0!==h[i]&&(o=h[i]),void 0!==h[t]&&(a=n=h[t]),l&&void 0!==h[c]&&(a=(s=h[c])-o),void 0===n||void 0===o||void 0===s){var f=this.getMeasuringContext();this._setTextStyles(f,e,!0)}return void 0===n&&(a=n=f.measureText(t).width,h[t]=n),void 0===o&&l&&i&&(o=f.measureText(i).width,h[i]=o),l&&void 0===s&&(s=f.measureText(c).width,a=(h[c]=s)-o),{width:n*u,kernedWidth:a*u}},getHeightOfChar:function(t,e){return this.getValueOfPropertyAt(t,e,"fontSize")},measureLine:function(t){var e=this._measureLine(t);return 0!==this.charSpacing&&(e.width-=this._getWidthOfCharSpacing()),e.width<0&&(e.width=0),e},_measureLine:function(t){var e,i,r,n,s,o,a=0,h=this._textLines[t],c=new Array(h.length),l=0,u=this.path;for(this.__charBounds[t]=c,u&&(s=d.util.getPointOnPath(u.path,0,u.segmentsInfo),o=u.segmentsInfo[u.segmentsInfo.length-1].length,s.x+=u.pathOffset.x,s.y+=u.pathOffset.y),e=0;e<h.length;e++)i=h[e],n=this._getGraphemeBox(i,t,e,r),u&&(o<l&&(l%=o),this._setGraphemeOnPath(l,n,s)),a+=(c[e]=n).kernedWidth,l+=n.kernedWidth,r=i;return c[e]={left:n?n.left+n.width:0,width:0,kernedWidth:0,height:this.fontSize},{width:a,numOfSpaces:0}},_setGraphemeOnPath:function(t,e,i){var r=t+e.kernedWidth/2,n=this.path,s=d.util.getPointOnPath(n.path,r-.1,n.segmentsInfo),o=d.util.getPointOnPath(n.path,r+.1,n.segmentsInfo);e.renderLeft=s.x-i.x,e.renderTop=s.y-i.y,e.angle=Math.atan2(o.y-s.y,o.x-s.x)},_getGraphemeBox:function(t,e,i,r,n){var s,o=this.getCompleteStyleDeclaration(e,i),a=r?this.getCompleteStyleDeclaration(e,i-1):{},h=this._measureChar(t,o,r,a),c=h.kernedWidth,l=h.width;0!==this.charSpacing&&(l+=s=this._getWidthOfCharSpacing(),c+=s);var u={width:l,left:0,height:o.fontSize,kernedWidth:c,deltaY:o.deltaY};if(0<i&&!n){var f=this.__charBounds[e][i-1];u.left=f.left+f.width+h.kernedWidth-h.width}return u},getHeightOfLine:function(t){if(this.__lineHeights[t])return this.__lineHeights[t];for(var e=this._textLines[t],i=this.getHeightOfChar(t,0),r=1,n=e.length;r<n;r++)i=Math.max(this.getHeightOfChar(t,r),i);return this.__lineHeights[t]=i*this.lineHeight*this._fontSizeMult},calcTextHeight:function(){for(var t,e=0,i=0,r=this._textLines.length;i<r;i++)t=this.getHeightOfLine(i),e+=i===r-1?t/this.lineHeight:t;return e},_getLeftOffset:function(){return-this.width/2},_getTopOffset:function(){return-this.height/2},_renderTextCommon:function(t,e){t.save();for(var i=0,r=this._getLeftOffset(),n=this._getTopOffset(),s=0,o=this._textLines.length;s<o;s++){var a=this.getHeightOfLine(s),h=a/this.lineHeight,c=this._getLineLeftOffset(s);this._renderTextLine(e,t,this._textLines[s],r+c,n+i+h,s),i+=a}t.restore()},_renderTextFill:function(t){(this.fill||this.styleHas("fill"))&&this._renderTextCommon(t,"fillText")},_renderTextStroke:function(t){(this.stroke&&0!==this.strokeWidth||!this.isEmptyStyles())&&(this.shadow&&!this.shadow.affectStroke&&this._removeShadow(t),t.save(),this._setLineDash(t,this.strokeDashArray),t.beginPath(),this._renderTextCommon(t,"strokeText"),t.closePath(),t.restore())},_renderChars:function(t,e,i,r,n,s){var o,a,h,c,l=this.getHeightOfLine(s),u=-1!==this.textAlign.indexOf("justify"),f="",d=0,g=this.path,p=!u&&0===this.charSpacing&&this.isEmptyStyles(s)&&!g;if(e.save(),n-=l*this._fontSizeFraction/this.lineHeight,p)return this._renderChar(t,e,s,0,i.join(""),r,n,l),void e.restore();for(var v=0,m=i.length-1;v<=m;v++)c=v===m||this.charSpacing||g,f+=i[v],h=this.__charBounds[s][v],0===d?(r+=h.kernedWidth-h.width,d+=h.width):d+=h.kernedWidth,u&&!c&&this._reSpaceAndTab.test(i[v])&&(c=!0),c||(o=o||this.getCompleteStyleDeclaration(s,v),a=this.getCompleteStyleDeclaration(s,v+1),c=this._hasStyleChanged(o,a)),c&&(g?(e.save(),e.translate(h.renderLeft,h.renderTop),e.rotate(h.angle),this._renderChar(t,e,s,v,f,-d/2,0,l),e.restore()):this._renderChar(t,e,s,v,f,r,n,l),f="",o=a,r+=d,d=0);e.restore()},_applyPatternGradientTransformText:function(t){var e,i=d.util.createCanvasElement(),r=this.width+this.strokeWidth,n=this.height+this.strokeWidth;return i.width=r,i.height=n,(e=i.getContext("2d")).beginPath(),e.moveTo(0,0),e.lineTo(r,0),e.lineTo(r,n),e.lineTo(0,n),e.closePath(),e.translate(r/2,n/2),e.fillStyle=t.toLive(e),this._applyPatternGradientTransform(e,t),e.fill(),e.createPattern(i,"no-repeat")},handleFiller:function(t,e,i){var r,n;return i.toLive?"percentage"===i.gradientUnits||i.gradientTrasnform||i.patternTransform?(r=-this.width/2,n=-this.height/2,t.translate(r,n),t[e]=this._applyPatternGradientTransformText(i),{offsetX:r,offsetY:n}):(t[e]=i.toLive(t,this),this._applyPatternGradientTransform(t,i)):(t[e]=i,{offsetX:0,offsetY:0})},_setStrokeStyles:function(t,e){return t.lineWidth=e.strokeWidth,t.lineCap=this.strokeLineCap,t.lineDashOffset=this.strokeDashOffset,t.lineJoin=this.strokeLineJoin,t.miterLimit=this.strokeMiterLimit,this.handleFiller(t,"strokeStyle",e.stroke)},_setFillStyles:function(t,e){return this.handleFiller(t,"fillStyle",e.fill)},_renderChar:function(t,e,i,r,n,s,o){var a,h,c=this._getStyleDeclaration(i,r),l=this.getCompleteStyleDeclaration(i,r),u="fillText"===t&&l.fill,f="strokeText"===t&&l.stroke&&l.strokeWidth;(f||u)&&(e.save(),u&&(a=this._setFillStyles(e,l)),f&&(h=this._setStrokeStyles(e,l)),e.font=this._getFontDeclaration(l),c&&c.textBackgroundColor&&this._removeShadow(e),c&&c.deltaY&&(o+=c.deltaY),u&&e.fillText(n,s-a.offsetX,o-a.offsetY),f&&e.strokeText(n,s-h.offsetX,o-h.offsetY),e.restore())},setSuperscript:function(t,e){return this._setScript(t,e,this.superscript)},setSubscript:function(t,e){return this._setScript(t,e,this.subscript)},_setScript:function(t,e,i){var r=this.get2DCursorLocation(t,!0),n=this.getValueOfPropertyAt(r.lineIndex,r.charIndex,"fontSize"),s=this.getValueOfPropertyAt(r.lineIndex,r.charIndex,"deltaY"),o={fontSize:n*i.size,deltaY:s+n*i.baseline};return this.setSelectionStyles(o,t,e),this},_hasStyleChanged:function(t,e){return t.fill!==e.fill||t.stroke!==e.stroke||t.strokeWidth!==e.strokeWidth||t.fontSize!==e.fontSize||t.fontFamily!==e.fontFamily||t.fontWeight!==e.fontWeight||t.fontStyle!==e.fontStyle||t.deltaY!==e.deltaY},_hasStyleChangedForSvg:function(t,e){return this._hasStyleChanged(t,e)||t.overline!==e.overline||t.underline!==e.underline||t.linethrough!==e.linethrough},_getLineLeftOffset:function(t){var e=this.getLineWidth(t);return"center"===this.textAlign?(this.width-e)/2:"right"===this.textAlign?this.width-e:"justify-center"===this.textAlign&&this.isEndOfWrapping(t)?(this.width-e)/2:"justify-right"===this.textAlign&&this.isEndOfWrapping(t)?this.width-e:0},_clearCache:function(){this.__lineWidths=[],this.__lineHeights=[],this.__charBounds=[]},_shouldClearDimensionCache:function(){var t=this._forceClearCache;return t||(t=this.hasStateChanged("_dimensionAffectingProps")),t&&(this.dirty=!0,this._forceClearCache=!1),t},getLineWidth:function(t){return this.__lineWidths[t]?this.__lineWidths[t]:(e=""===this._textLines[t]?0:this.measureLine(t).width,this.__lineWidths[t]=e);var e},_getWidthOfCharSpacing:function(){return 0!==this.charSpacing?this.fontSize*this.charSpacing/1e3:0},getValueOfPropertyAt:function(t,e,i){var r=this._getStyleDeclaration(t,e);return r&&void 0!==r[i]?r[i]:this[i]},_renderTextDecoration:function(t,e){if(this[e]||this.styleHas(e)){for(var i,r,n,s,o,a,h,c,l,u,f,d,g,p,v,m,b=this._getLeftOffset(),_=this._getTopOffset(),y=this.path,x=this._getWidthOfCharSpacing(),C=0,S=this._textLines.length;C<S;C++)if(i=this.getHeightOfLine(C),this[e]||this.styleHas(e,C)){h=this._textLines[C],p=i/this.lineHeight,s=this._getLineLeftOffset(C),f=u=0,c=this.getValueOfPropertyAt(C,0,e),m=this.getValueOfPropertyAt(C,0,"fill"),l=_+p*(1-this._fontSizeFraction),r=this.getHeightOfChar(C,0),o=this.getValueOfPropertyAt(C,0,"deltaY");for(var T=0,w=h.length;T<w;T++)d=this.__charBounds[C][T],g=this.getValueOfPropertyAt(C,T,e),v=this.getValueOfPropertyAt(C,T,"fill"),n=this.getHeightOfChar(C,T),a=this.getValueOfPropertyAt(C,T,"deltaY"),y&&g&&v?(t.save(),t.fillStyle=m,t.translate(d.renderLeft,d.renderTop),t.rotate(d.angle),t.fillRect(-d.kernedWidth/2,this.offsets[e]*n+a,d.kernedWidth,this.fontSize/15),t.restore()):(g!==c||v!==m||n!==r||a!==o)&&0<f?(c&&m&&t.fillRect(b+s+u,l+this.offsets[e]*r+o,f,this.fontSize/15),u=d.left,f=d.width,c=g,m=v,r=n,o=a):f+=d.kernedWidth;t.fillStyle=v,g&&v&&t.fillRect(b+s+u,l+this.offsets[e]*r+o,f-x,this.fontSize/15),_+=i}else _+=i;this._removeShadow(t)}},_getFontDeclaration:function(t,e){var i=t||this,r=this.fontFamily,n=-1<d.Text.genericFonts.indexOf(r.toLowerCase()),s=void 0===r||-1<r.indexOf("'")||-1<r.indexOf(",")||-1<r.indexOf('"')||n?i.fontFamily:'"'+i.fontFamily+'"';return[d.isLikelyNode?i.fontWeight:i.fontStyle,d.isLikelyNode?i.fontStyle:i.fontWeight,e?this.CACHE_FONT_SIZE+"px":i.fontSize+"px",s].join(" ")},render:function(t){this.visible&&(this.canvas&&this.canvas.skipOffscreen&&!this.group&&!this.isOnScreen()||(this._shouldClearDimensionCache()&&this.initDimensions(),this.callSuper("render",t)))},_splitTextIntoLines:function(t){for(var e=t.split(this._reNewline),i=new Array(e.length),r=["\n"],n=[],s=0;s<e.length;s++)i[s]=d.util.string.graphemeSplit(e[s]),n=n.concat(i[s],r);return n.pop(),{_unwrappedLines:i,lines:e,graphemeText:n,graphemeLines:i}},toObject:function(t){var e=["text","fontSize","fontWeight","fontFamily","fontStyle","lineHeight","underline","overline","linethrough","textAlign","textBackgroundColor","charSpacing"].concat(t),i=this.callSuper("toObject",e);return i.styles=g(this.styles,!0),i},set:function(t,e){this.callSuper("set",t,e);var i=!1,r=!1;if("object"==typeof t)for(var n in t)"path"===n&&this.setPathInfo(),i=i||-1!==this._dimensionAffectingProps.indexOf(n),r=r||"path"===n;else i=-1!==this._dimensionAffectingProps.indexOf(t),r="path"===t;return r&&this.setPathInfo(),i&&(this.initDimensions(),this.setCoords()),this},complexity:function(){return 1}}),d.Text.ATTRIBUTE_NAMES=d.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")),d.Text.DEFAULT_SVG_FONT_SIZE=16,d.Text.fromElement=function(t,e,i){if(!t)return e(null);var r=d.parseAttributes(t,d.Text.ATTRIBUTE_NAMES),n=r.textAnchor||"left";if((i=d.util.object.extend(i?g(i):{},r)).top=i.top||0,i.left=i.left||0,r.textDecoration){var s=r.textDecoration;-1!==s.indexOf("underline")&&(i.underline=!0),-1!==s.indexOf("overline")&&(i.overline=!0),-1!==s.indexOf("line-through")&&(i.linethrough=!0),delete i.textDecoration}"dx"in r&&(i.left+=r.dx),"dy"in r&&(i.top+=r.dy),"fontSize"in i||(i.fontSize=d.Text.DEFAULT_SVG_FONT_SIZE);var o="";"textContent"in t?o=t.textContent:"firstChild"in t&&null!==t.firstChild&&"data"in t.firstChild&&null!==t.firstChild.data&&(o=t.firstChild.data),o=o.replace(/^\s+|\s+$|\n+/g,"").replace(/\s+/g," ");var a=i.strokeWidth;i.strokeWidth=0;var h=new d.Text(o,i),c=h.getScaledHeight()/h.height,l=((h.height+h.strokeWidth)*h.lineHeight-h.height)*c,u=h.getScaledHeight()+l,f=0;"center"===n&&(f=h.getScaledWidth()/2),"right"===n&&(f=h.getScaledWidth()),h.set({left:h.left-f,top:h.top-(u-h.fontSize*(.07+h._fontSizeFraction))/h.lineHeight,strokeWidth:void 0!==a?a:1}),e(h)},d.Text.fromObject=function(t,e){return d.Object._fromObject("Text",t,e,"text")},d.Text.genericFonts=["sans-serif","serif","cursive","fantasy","monospace"],d.util.createAccessors&&d.util.createAccessors(d.Text)}}("undefined"!=typeof exports?exports:this),fabric.util.object.extend(fabric.Text.prototype,{isEmptyStyles:function(t){if(!this.styles)return!0;if(void 0!==t&&!this.styles[t])return!0;var e=void 0===t?this.styles:{line:this.styles[t]};for(var i in e)for(var r in e[i])for(var n in e[i][r])return!1;return!0},styleHas:function(t,e){if(!this.styles||!t||""===t)return!1;if(void 0!==e&&!this.styles[e])return!1;var i=void 0===e?this.styles:{0:this.styles[e]};for(var r in i)for(var n in i[r])if(void 0!==i[r][n][t])return!0;return!1},cleanStyle:function(t){if(!this.styles||!t||""===t)return!1;var e,i,r=this.styles,n=0,s=!0,o=0;for(var a in r){for(var h in e=0,r[a]){var c;n++,(c=r[a][h]).hasOwnProperty(t)?(i?c[t]!==i&&(s=!1):i=c[t],c[t]===this[t]&&delete c[t]):s=!1,0!==Object.keys(c).length?e++:delete r[a][h]}0===e&&delete r[a]}for(var l=0;l<this._textLines.length;l++)o+=this._textLines[l].length;s&&n===o&&(this[t]=i,this.removeStyle(t))},removeStyle:function(t){if(this.styles&&t&&""!==t){var e,i,r,n=this.styles;for(i in n){for(r in e=n[i])delete e[r][t],0===Object.keys(e[r]).length&&delete e[r];0===Object.keys(e).length&&delete n[i]}}},_extendStyles:function(t,e){var i=this.get2DCursorLocation(t);this._getLineStyle(i.lineIndex)||this._setLineStyle(i.lineIndex),this._getStyleDeclaration(i.lineIndex,i.charIndex)||this._setStyleDeclaration(i.lineIndex,i.charIndex,{}),fabric.util.object.extend(this._getStyleDeclaration(i.lineIndex,i.charIndex),e)},get2DCursorLocation:function(t,e){void 0===t&&(t=this.selectionStart);for(var i=e?this._unwrappedTextLines:this._textLines,r=i.length,n=0;n<r;n++){if(t<=i[n].length)return{lineIndex:n,charIndex:t};t-=i[n].length+this.missingNewlineOffset(n)}return{lineIndex:n-1,charIndex:i[n-1].length<t?i[n-1].length:t}},getSelectionStyles:function(t,e,i){void 0===t&&(t=this.selectionStart||0),void 0===e&&(e=this.selectionEnd||t);for(var r=[],n=t;n<e;n++)r.push(this.getStyleAtPosition(n,i));return r},getStyleAtPosition:function(t,e){var i=this.get2DCursorLocation(t);return(e?this.getCompleteStyleDeclaration(i.lineIndex,i.charIndex):this._getStyleDeclaration(i.lineIndex,i.charIndex))||{}},setSelectionStyles:function(t,e,i){void 0===e&&(e=this.selectionStart||0),void 0===i&&(i=this.selectionEnd||e);for(var r=e;r<i;r++)this._extendStyles(r,t);return this._forceClearCache=!0,this},_getStyleDeclaration:function(t,e){var i=this.styles&&this.styles[t];return i?i[e]:null},getCompleteStyleDeclaration:function(t,e){for(var i,r=this._getStyleDeclaration(t,e)||{},n={},s=0;s<this._styleProperties.length;s++)n[i=this._styleProperties[s]]=void 0===r[i]?this[i]:r[i];return n},_setStyleDeclaration:function(t,e,i){this.styles[t][e]=i},_deleteStyleDeclaration:function(t,e){delete this.styles[t][e]},_getLineStyle:function(t){return!!this.styles[t]},_setLineStyle:function(t){this.styles[t]={}},_deleteLineStyle:function(t){delete this.styles[t]}}),function(){function n(t){t.textDecoration&&(-1<t.textDecoration.indexOf("underline")&&(t.underline=!0),-1<t.textDecoration.indexOf("line-through")&&(t.linethrough=!0),-1<t.textDecoration.indexOf("overline")&&(t.overline=!0),delete t.textDecoration)}fabric.IText=fabric.util.createClass(fabric.Text,fabric.Observable,{type:"i-text",selectionStart:0,selectionEnd:0,selectionColor:"rgba(17,119,255,0.3)",isEditing:!1,editable:!0,editingBorderColor:"rgba(102,153,255,0.25)",cursorWidth:2,cursorColor:"",cursorDelay:1e3,cursorDuration:600,caching:!0,_reSpace:/\s|\n/,_currentCursorOpacity:0,_selectionDirection:null,_abortCursorAnimation:!1,__widthOfSpace:[],inCompositionMode:!1,initialize:function(t,e){this.callSuper("initialize",t,e),this.initBehavior()},setSelectionStart:function(t){t=Math.max(t,0),this._updateAndFire("selectionStart",t)},setSelectionEnd:function(t){t=Math.min(t,this.text.length),this._updateAndFire("selectionEnd",t)},_updateAndFire:function(t,e){this[t]!==e&&(this._fireSelectionChanged(),this[t]=e),this._updateTextarea()},_fireSelectionChanged:function(){this.fire("selection:changed"),this.canvas&&this.canvas.fire("text:selection:changed",{target:this})},initDimensions:function(){this.isEditing&&this.initDelayedCursor(),this.clearContextTop(),this.callSuper("initDimensions")},render:function(t){this.clearContextTop(),this.callSuper("render",t),this.cursorOffsetCache={},this.renderCursorOrSelection()},_render:function(t){this.callSuper("_render",t)},clearContextTop:function(t){if(this.isEditing&&this.canvas&&this.canvas.contextTop){var e=this.canvas.contextTop,i=this.canvas.viewportTransform;e.save(),e.transform(i[0],i[1],i[2],i[3],i[4],i[5]),this.transform(e),this._clearTextArea(e),t||e.restore()}},renderCursorOrSelection:function(){if(this.isEditing&&this.canvas&&this.canvas.contextTop){var t=this._getCursorBoundaries(),e=this.canvas.contextTop;this.clearContextTop(!0),this.selectionStart===this.selectionEnd?this.renderCursor(t,e):this.renderSelection(t,e),e.restore()}},_clearTextArea:function(t){var e=this.width+4,i=this.height+4;t.clearRect(-e/2,-i/2,e,i)},_getCursorBoundaries:function(t){void 0===t&&(t=this.selectionStart);var e=this._getLeftOffset(),i=this._getTopOffset(),r=this._getCursorBoundariesOffsets(t);return{left:e,top:i,leftOffset:r.left,topOffset:r.top}},_getCursorBoundariesOffsets:function(t){if(this.cursorOffsetCache&&"top"in this.cursorOffsetCache)return this.cursorOffsetCache;var e,i,r,n,s=0,o=0,a=this.get2DCursorLocation(t);r=a.charIndex,i=a.lineIndex;for(var h=0;h<i;h++)s+=this.getHeightOfLine(h);e=this._getLineLeftOffset(i);var c=this.__charBounds[i][r];return c&&(o=c.left),0!==this.charSpacing&&r===this._textLines[i].length&&(o-=this._getWidthOfCharSpacing()),n={top:s,left:e+(0<o?o:0)},this.cursorOffsetCache=n,this.cursorOffsetCache},renderCursor:function(t,e){var i=this.get2DCursorLocation(),r=i.lineIndex,n=0<i.charIndex?i.charIndex-1:0,s=this.getValueOfPropertyAt(r,n,"fontSize"),o=this.scaleX*this.canvas.getZoom(),a=this.cursorWidth/o,h=t.topOffset,c=this.getValueOfPropertyAt(r,n,"deltaY");h+=(1-this._fontSizeFraction)*this.getHeightOfLine(r)/this.lineHeight-s*(1-this._fontSizeFraction),this.inCompositionMode&&this.renderSelection(t,e),e.fillStyle=this.cursorColor||this.getValueOfPropertyAt(r,n,"fill"),e.globalAlpha=this.__isMousedown?1:this._currentCursorOpacity,e.fillRect(t.left+t.leftOffset-a/2,h+t.top+c,a,s)},renderSelection:function(t,e){for(var i=this.inCompositionMode?this.hiddenTextarea.selectionStart:this.selectionStart,r=this.inCompositionMode?this.hiddenTextarea.selectionEnd:this.selectionEnd,n=-1!==this.textAlign.indexOf("justify"),s=this.get2DCursorLocation(i),o=this.get2DCursorLocation(r),a=s.lineIndex,h=o.lineIndex,c=s.charIndex<0?0:s.charIndex,l=o.charIndex<0?0:o.charIndex,u=a;u<=h;u++){var f,d=this._getLineLeftOffset(u)||0,g=this.getHeightOfLine(u),p=0,v=0;if(u===a&&(p=this.__charBounds[a][c].left),a<=u&&u<h)v=n&&!this.isEndOfWrapping(u)?this.width:this.getLineWidth(u)||5;else if(u===h)if(0===l)v=this.__charBounds[h][l].left;else{var m=this._getWidthOfCharSpacing();v=this.__charBounds[h][l-1].left+this.__charBounds[h][l-1].width-m}f=g,(this.lineHeight<1||u===h&&1<this.lineHeight)&&(g/=this.lineHeight),this.inCompositionMode?(e.fillStyle=this.compositionColor||"black",e.fillRect(t.left+d+p,t.top+t.topOffset+g,v-p,1)):(e.fillStyle=this.selectionColor,e.fillRect(t.left+d+p,t.top+t.topOffset,v-p,g)),t.topOffset+=f}},getCurrentCharFontSize:function(){var t=this._getCurrentCharIndex();return this.getValueOfPropertyAt(t.l,t.c,"fontSize")},getCurrentCharColor:function(){var t=this._getCurrentCharIndex();return this.getValueOfPropertyAt(t.l,t.c,"fill")},_getCurrentCharIndex:function(){var t=this.get2DCursorLocation(this.selectionStart,!0),e=0<t.charIndex?t.charIndex-1:0;return{l:t.lineIndex,c:e}}}),fabric.IText.fromObject=function(t,e){if(n(t),t.styles)for(var i in t.styles)for(var r in t.styles[i])n(t.styles[i][r]);fabric.Object._fromObject("IText",t,e,"text")}}(),function(){var u=fabric.util.object.clone;fabric.util.object.extend(fabric.IText.prototype,{initBehavior:function(){this.initAddedHandler(),this.initRemovedHandler(),this.initCursorSelectionHandlers(),this.initDoubleClickSimulation(),this.mouseMoveHandler=this.mouseMoveHandler.bind(this)},onDeselect:function(){this.isEditing&&this.exitEditing(),this.selected=!1},initAddedHandler:function(){var e=this;this.on("added",function(){var t=e.canvas;t&&(t._hasITextHandlers||(t._hasITextHandlers=!0,e._initCanvasHandlers(t)),t._iTextInstances=t._iTextInstances||[],t._iTextInstances.push(e))})},initRemovedHandler:function(){var e=this;this.on("removed",function(){var t=e.canvas;t&&(t._iTextInstances=t._iTextInstances||[],fabric.util.removeFromArray(t._iTextInstances,e),0===t._iTextInstances.length&&(t._hasITextHandlers=!1,e._removeCanvasHandlers(t)))})},_initCanvasHandlers:function(t){t._mouseUpITextHandler=function(){t._iTextInstances&&t._iTextInstances.forEach(function(t){t.__isMousedown=!1})},t.on("mouse:up",t._mouseUpITextHandler)},_removeCanvasHandlers:function(t){t.off("mouse:up",t._mouseUpITextHandler)},_tick:function(){this._currentTickState=this._animateCursor(this,1,this.cursorDuration,"_onTickComplete")},_animateCursor:function(t,e,i,r){var n;return n={isAborted:!1,abort:function(){this.isAborted=!0}},t.animate("_currentCursorOpacity",e,{duration:i,onComplete:function(){n.isAborted||t[r]()},onChange:function(){t.canvas&&t.selectionStart===t.selectionEnd&&t.renderCursorOrSelection()},abort:function(){return n.isAborted}}),n},_onTickComplete:function(){var t=this;this._cursorTimeout1&&clearTimeout(this._cursorTimeout1),this._cursorTimeout1=setTimeout(function(){t._currentTickCompleteState=t._animateCursor(t,0,this.cursorDuration/2,"_tick")},100)},initDelayedCursor:function(t){var e=this,i=t?0:this.cursorDelay;this.abortCursorAnimation(),this._currentCursorOpacity=1,this._cursorTimeout2=setTimeout(function(){e._tick()},i)},abortCursorAnimation:function(){var t=this._currentTickState||this._currentTickCompleteState,e=this.canvas;this._currentTickState&&this._currentTickState.abort(),this._currentTickCompleteState&&this._currentTickCompleteState.abort(),clearTimeout(this._cursorTimeout1),clearTimeout(this._cursorTimeout2),this._currentCursorOpacity=0,t&&e&&e.clearContext(e.contextTop||e.contextContainer)},selectAll:function(){return this.selectionStart=0,this.selectionEnd=this._text.length,this._fireSelectionChanged(),this._updateTextarea(),this},getSelectedText:function(){return this._text.slice(this.selectionStart,this.selectionEnd).join("")},findWordBoundaryLeft:function(t){var e=0,i=t-1;if(this._reSpace.test(this._text[i]))for(;this._reSpace.test(this._text[i]);)e++,i--;for(;/\S/.test(this._text[i])&&-1<i;)e++,i--;return t-e},findWordBoundaryRight:function(t){var e=0,i=t;if(this._reSpace.test(this._text[i]))for(;this._reSpace.test(this._text[i]);)e++,i++;for(;/\S/.test(this._text[i])&&i<this._text.length;)e++,i++;return t+e},findLineBoundaryLeft:function(t){for(var e=0,i=t-1;!/\n/.test(this._text[i])&&-1<i;)e++,i--;return t-e},findLineBoundaryRight:function(t){for(var e=0,i=t;!/\n/.test(this._text[i])&&i<this._text.length;)e++,i++;return t+e},searchWordBoundary:function(t,e){for(var i=this._text,r=this._reSpace.test(i[t])?t-1:t,n=i[r],s=fabric.reNonWord;!s.test(n)&&0<r&&r<i.length;)n=i[r+=e];return s.test(n)&&(r+=1===e?0:1),r},selectWord:function(t){t=t||this.selectionStart;var e=this.searchWordBoundary(t,-1),i=this.searchWordBoundary(t,1);this.selectionStart=e,this.selectionEnd=i,this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()},selectLine:function(t){t=t||this.selectionStart;var e=this.findLineBoundaryLeft(t),i=this.findLineBoundaryRight(t);return this.selectionStart=e,this.selectionEnd=i,this._fireSelectionChanged(),this._updateTextarea(),this},enterEditing:function(t){if(!this.isEditing&&this.editable)return this.canvas&&(this.canvas.calcOffset(),this.exitEditingOnOthers(this.canvas)),this.isEditing=!0,this.initHiddenTextarea(t),this.hiddenTextarea.focus(),this.hiddenTextarea.value=this.text,this._updateTextarea(),this._saveEditingProps(),this._setEditingProps(),this._textBeforeEdit=this.text,this._tick(),this.fire("editing:entered"),this._fireSelectionChanged(),this.canvas&&(this.canvas.fire("text:editing:entered",{target:this}),this.initMouseMoveHandler(),this.canvas.requestRenderAll()),this},exitEditingOnOthers:function(t){t._iTextInstances&&t._iTextInstances.forEach(function(t){t.selected=!1,t.isEditing&&t.exitEditing()})},initMouseMoveHandler:function(){this.canvas.on("mouse:move",this.mouseMoveHandler)},mouseMoveHandler:function(t){if(this.__isMousedown&&this.isEditing){var e=this.getSelectionStartFromPointer(t.e),i=this.selectionStart,r=this.selectionEnd;(e===this.__selectionStartOnMouseDown&&i!==r||i!==e&&r!==e)&&(e>this.__selectionStartOnMouseDown?(this.selectionStart=this.__selectionStartOnMouseDown,this.selectionEnd=e):(this.selectionStart=e,this.selectionEnd=this.__selectionStartOnMouseDown),this.selectionStart===i&&this.selectionEnd===r||(this.restartCursorIfNeeded(),this._fireSelectionChanged(),this._updateTextarea(),this.renderCursorOrSelection()))}},_setEditingProps:function(){this.hoverCursor="text",this.canvas&&(this.canvas.defaultCursor=this.canvas.moveCursor="text"),this.borderColor=this.editingBorderColor,this.hasControls=this.selectable=!1,this.lockMovementX=this.lockMovementY=!0},fromStringToGraphemeSelection:function(t,e,i){var r=i.slice(0,t),n=fabric.util.string.graphemeSplit(r).length;if(t===e)return{selectionStart:n,selectionEnd:n};var s=i.slice(t,e);return{selectionStart:n,selectionEnd:n+fabric.util.string.graphemeSplit(s).length}},fromGraphemeToStringSelection:function(t,e,i){var r=i.slice(0,t).join("").length;return t===e?{selectionStart:r,selectionEnd:r}:{selectionStart:r,selectionEnd:r+i.slice(t,e).join("").length}},_updateTextarea:function(){if(this.cursorOffsetCache={},this.hiddenTextarea){if(!this.inCompositionMode){var t=this.fromGraphemeToStringSelection(this.selectionStart,this.selectionEnd,this._text);this.hiddenTextarea.selectionStart=t.selectionStart,this.hiddenTextarea.selectionEnd=t.selectionEnd}this.updateTextareaPosition()}},updateFromTextArea:function(){if(this.hiddenTextarea){this.cursorOffsetCache={},this.text=this.hiddenTextarea.value,this._shouldClearDimensionCache()&&(this.initDimensions(),this.setCoords());var t=this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart,this.hiddenTextarea.selectionEnd,this.hiddenTextarea.value);this.selectionEnd=this.selectionStart=t.selectionEnd,this.inCompositionMode||(this.selectionStart=t.selectionStart),this.updateTextareaPosition()}},updateTextareaPosition:function(){if(this.selectionStart===this.selectionEnd){var t=this._calcTextareaPosition();this.hiddenTextarea.style.left=t.left,this.hiddenTextarea.style.top=t.top}},_calcTextareaPosition:function(){if(!this.canvas)return{x:1,y:1};var t=this.inCompositionMode?this.compositionStart:this.selectionStart,e=this._getCursorBoundaries(t),i=this.get2DCursorLocation(t),r=i.lineIndex,n=i.charIndex,s=this.getValueOfPropertyAt(r,n,"fontSize")*this.lineHeight,o=e.leftOffset,a=this.calcTransformMatrix(),h={x:e.left+o,y:e.top+e.topOffset+s},c=this.canvas.getRetinaScaling(),l=this.canvas.upperCanvasEl,u=l.width/c,f=l.height/c,d=u-s,g=f-s,p=l.clientWidth/u,v=l.clientHeight/f;return h=fabric.util.transformPoint(h,a),(h=fabric.util.transformPoint(h,this.canvas.viewportTransform)).x*=p,h.y*=v,h.x<0&&(h.x=0),h.x>d&&(h.x=d),h.y<0&&(h.y=0),h.y>g&&(h.y=g),h.x+=this.canvas._offset.left,h.y+=this.canvas._offset.top,{left:h.x+"px",top:h.y+"px",fontSize:s+"px",charHeight:s}},_saveEditingProps:function(){this._savedProps={hasControls:this.hasControls,borderColor:this.borderColor,lockMovementX:this.lockMovementX,lockMovementY:this.lockMovementY,hoverCursor:this.hoverCursor,selectable:this.selectable,defaultCursor:this.canvas&&this.canvas.defaultCursor,moveCursor:this.canvas&&this.canvas.moveCursor}},_restoreEditingProps:function(){this._savedProps&&(this.hoverCursor=this._savedProps.hoverCursor,this.hasControls=this._savedProps.hasControls,this.borderColor=this._savedProps.borderColor,this.selectable=this._savedProps.selectable,this.lockMovementX=this._savedProps.lockMovementX,this.lockMovementY=this._savedProps.lockMovementY,this.canvas&&(this.canvas.defaultCursor=this._savedProps.defaultCursor,this.canvas.moveCursor=this._savedProps.moveCursor))},exitEditing:function(){var t=this._textBeforeEdit!==this.text,e=this.hiddenTextarea;return this.selected=!1,this.isEditing=!1,this.selectionEnd=this.selectionStart,e&&(e.blur&&e.blur(),e.parentNode&&e.parentNode.removeChild(e)),this.hiddenTextarea=null,this.abortCursorAnimation(),this._restoreEditingProps(),this._currentCursorOpacity=0,this._shouldClearDimensionCache()&&(this.initDimensions(),this.setCoords()),this.fire("editing:exited"),t&&this.fire("modified"),this.canvas&&(this.canvas.off("mouse:move",this.mouseMoveHandler),this.canvas.fire("text:editing:exited",{target:this}),t&&this.canvas.fire("object:modified",{target:this})),this},_removeExtraneousStyles:function(){for(var t in this.styles)this._textLines[t]||delete this.styles[t]},removeStyleFromTo:function(t,e){var i,r,n=this.get2DCursorLocation(t,!0),s=this.get2DCursorLocation(e,!0),o=n.lineIndex,a=n.charIndex,h=s.lineIndex,c=s.charIndex;if(o!==h){if(this.styles[o])for(i=a;i<this._unwrappedTextLines[o].length;i++)delete this.styles[o][i];if(this.styles[h])for(i=c;i<this._unwrappedTextLines[h].length;i++)(r=this.styles[h][i])&&(this.styles[o]||(this.styles[o]={}),this.styles[o][a+i-c]=r);for(i=o+1;i<=h;i++)delete this.styles[i];this.shiftLineStyles(h,o-h)}else if(this.styles[o]){r=this.styles[o];var l,u,f=c-a;for(i=a;i<c;i++)delete r[i];for(u in this.styles[o])c<=(l=parseInt(u,10))&&(r[l-f]=r[u],delete r[u])}},shiftLineStyles:function(t,e){var i=u(this.styles);for(var r in this.styles){var n=parseInt(r,10);t<n&&(this.styles[n+e]=i[n],i[n-e]||delete this.styles[n])}},restartCursorIfNeeded:function(){this._currentTickState&&!this._currentTickState.isAborted&&this._currentTickCompleteState&&!this._currentTickCompleteState.isAborted||this.initDelayedCursor()},insertNewlineStyleObject:function(t,e,i,r){var n,s={},o=!1,a=this._unwrappedTextLines[t].length===e;for(var h in i||(i=1),this.shiftLineStyles(t,i),this.styles[t]&&(n=this.styles[t][0===e?e:e-1]),this.styles[t]){var c=parseInt(h,10);e<=c&&(o=!0,s[c-e]=this.styles[t][h],a&&0===e||delete this.styles[t][h])}var l=!1;for(o&&!a&&(this.styles[t+i]=s,l=!0),l&&i--;0<i;)r&&r[i-1]?this.styles[t+i]={0:u(r[i-1])}:n?this.styles[t+i]={0:u(n)}:delete this.styles[t+i],i--;this._forceClearCache=!0},insertCharStyleObject:function(t,e,i,r){this.styles||(this.styles={});var n=this.styles[t],s=n?u(n):{};for(var o in i||(i=1),s){var a=parseInt(o,10);e<=a&&(n[a+i]=s[a],s[a-i]||delete n[a])}if(this._forceClearCache=!0,r)for(;i--;)Object.keys(r[i]).length&&(this.styles[t]||(this.styles[t]={}),this.styles[t][e+i]=u(r[i]));else if(n)for(var h=n[e?e-1:1];h&&i--;)this.styles[t][e+i]=u(h)},insertNewStyleBlock:function(t,e,i){for(var r=this.get2DCursorLocation(e,!0),n=[0],s=0,o=0;o<t.length;o++)"\n"===t[o]?n[++s]=0:n[s]++;0<n[0]&&(this.insertCharStyleObject(r.lineIndex,r.charIndex,n[0],i),i=i&&i.slice(n[0]+1)),s&&this.insertNewlineStyleObject(r.lineIndex,r.charIndex+n[0],s);for(o=1;o<s;o++)0<n[o]?this.insertCharStyleObject(r.lineIndex+o,0,n[o],i):i&&(this.styles[r.lineIndex+o][0]=i[0]),i=i&&i.slice(n[o]+1);0<n[o]&&this.insertCharStyleObject(r.lineIndex+o,0,n[o],i)},setSelectionStartEndWithShift:function(t,e,i){i<=t?(e===t?this._selectionDirection="left":"right"===this._selectionDirection&&(this._selectionDirection="left",this.selectionEnd=t),this.selectionStart=i):t<i&&i<e?"right"===this._selectionDirection?this.selectionEnd=i:this.selectionStart=i:(e===t?this._selectionDirection="right":"left"===this._selectionDirection&&(this._selectionDirection="right",this.selectionStart=e),this.selectionEnd=i)},setSelectionInBoundaries:function(){var t=this.text.length;this.selectionStart>t?this.selectionStart=t:this.selectionStart<0&&(this.selectionStart=0),this.selectionEnd>t?this.selectionEnd=t:this.selectionEnd<0&&(this.selectionEnd=0)}})}(),fabric.util.object.extend(fabric.IText.prototype,{initDoubleClickSimulation:function(){this.__lastClickTime=+new Date,this.__lastLastClickTime=+new Date,this.__lastPointer={},this.on("mousedown",this.onMouseDown)},onMouseDown:function(t){if(this.canvas){this.__newClickTime=+new Date;var e=t.pointer;this.isTripleClick(e)&&(this.fire("tripleclick",t),this._stopEvent(t.e)),this.__lastLastClickTime=this.__lastClickTime,this.__lastClickTime=this.__newClickTime,this.__lastPointer=e,this.__lastIsEditing=this.isEditing,this.__lastSelected=this.selected}},isTripleClick:function(t){return this.__newClickTime-this.__lastClickTime<500&&this.__lastClickTime-this.__lastLastClickTime<500&&this.__lastPointer.x===t.x&&this.__lastPointer.y===t.y},_stopEvent:function(t){t.preventDefault&&t.preventDefault(),t.stopPropagation&&t.stopPropagation()},initCursorSelectionHandlers:function(){this.initMousedownHandler(),this.initMouseupHandler(),this.initClicks()},doubleClickHandler:function(t){this.isEditing&&this.selectWord(this.getSelectionStartFromPointer(t.e))},tripleClickHandler:function(t){this.isEditing&&this.selectLine(this.getSelectionStartFromPointer(t.e))},initClicks:function(){this.on("mousedblclick",this.doubleClickHandler),this.on("tripleclick",this.tripleClickHandler)},_mouseDownHandler:function(t){!this.canvas||!this.editable||t.e.button&&1!==t.e.button||(this.__isMousedown=!0,this.selected&&(this.inCompositionMode=!1,this.setCursorByClick(t.e)),this.isEditing&&(this.__selectionStartOnMouseDown=this.selectionStart,this.selectionStart===this.selectionEnd&&this.abortCursorAnimation(),this.renderCursorOrSelection()))},_mouseDownHandlerBefore:function(t){!this.canvas||!this.editable||t.e.button&&1!==t.e.button||(this.selected=this===this.canvas._activeObject)},initMousedownHandler:function(){this.on("mousedown",this._mouseDownHandler),this.on("mousedown:before",this._mouseDownHandlerBefore)},initMouseupHandler:function(){this.on("mouseup",this.mouseUpHandler)},mouseUpHandler:function(t){if(this.__isMousedown=!1,!(!this.editable||this.group||t.transform&&t.transform.actionPerformed||t.e.button&&1!==t.e.button)){if(this.canvas){var e=this.canvas._activeObject;if(e&&e!==this)return}this.__lastSelected&&!this.__corner?(this.selected=!1,this.__lastSelected=!1,this.enterEditing(t.e),this.selectionStart===this.selectionEnd?this.initDelayedCursor(!0):this.renderCursorOrSelection()):this.selected=!0}},setCursorByClick:function(t){var e=this.getSelectionStartFromPointer(t),i=this.selectionStart,r=this.selectionEnd;t.shiftKey?this.setSelectionStartEndWithShift(i,r,e):(this.selectionStart=e,this.selectionEnd=e),this.isEditing&&(this._fireSelectionChanged(),this._updateTextarea())},getSelectionStartFromPointer:function(t){for(var e=this.getLocalPointer(t),i=0,r=0,n=0,s=0,o=0,a=0,h=this._textLines.length;a<h&&n<=e.y;a++)n+=this.getHeightOfLine(a)*this.scaleY,0<(o=a)&&(s+=this._textLines[a-1].length+this.missingNewlineOffset(a-1));r=this._getLineLeftOffset(o)*this.scaleX;for(var c=0,l=this._textLines[o].length;c<l&&(i=r,(r+=this.__charBounds[o][c].kernedWidth*this.scaleX)<=e.x);c++)s++;return this._getNewSelectionStartFromOffset(e,i,r,s,l)},_getNewSelectionStartFromOffset:function(t,e,i,r,n){var s=t.x-e,o=i-t.x,a=r+(s<o||o<0?0:1);return this.flipX&&(a=n-a),a>this._text.length&&(a=this._text.length),a}}),fabric.util.object.extend(fabric.IText.prototype,{initHiddenTextarea:function(){this.hiddenTextarea=fabric.document.createElement("textarea"),this.hiddenTextarea.setAttribute("autocapitalize","off"),this.hiddenTextarea.setAttribute("autocorrect","off"),this.hiddenTextarea.setAttribute("autocomplete","off"),this.hiddenTextarea.setAttribute("spellcheck","false"),this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea",""),this.hiddenTextarea.setAttribute("wrap","off");var t=this._calcTextareaPosition();this.hiddenTextarea.style.cssText="position: absolute; top: "+t.top+"; left: "+t.left+"; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; paddingｰtop: "+t.fontSize+";",fabric.document.body.appendChild(this.hiddenTextarea),fabric.util.addListener(this.hiddenTextarea,"keydown",this.onKeyDown.bind(this)),fabric.util.addListener(this.hiddenTextarea,"keyup",this.onKeyUp.bind(this)),fabric.util.addListener(this.hiddenTextarea,"input",this.onInput.bind(this)),fabric.util.addListener(this.hiddenTextarea,"copy",this.copy.bind(this)),fabric.util.addListener(this.hiddenTextarea,"cut",this.copy.bind(this)),fabric.util.addListener(this.hiddenTextarea,"paste",this.paste.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionstart",this.onCompositionStart.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionupdate",this.onCompositionUpdate.bind(this)),fabric.util.addListener(this.hiddenTextarea,"compositionend",this.onCompositionEnd.bind(this)),!this._clickHandlerInitialized&&this.canvas&&(fabric.util.addListener(this.canvas.upperCanvasEl,"click",this.onClick.bind(this)),this._clickHandlerInitialized=!0)},keysMap:{9:"exitEditing",27:"exitEditing",33:"moveCursorUp",34:"moveCursorDown",35:"moveCursorRight",36:"moveCursorLeft",37:"moveCursorLeft",38:"moveCursorUp",39:"moveCursorRight",40:"moveCursorDown"},ctrlKeysMapUp:{67:"copy",88:"cut"},ctrlKeysMapDown:{65:"selectAll"},onClick:function(){this.hiddenTextarea&&this.hiddenTextarea.focus()},onKeyDown:function(t){if(this.isEditing){if(t.keyCode in this.keysMap)this[this.keysMap[t.keyCode]](t);else{if(!(t.keyCode in this.ctrlKeysMapDown&&(t.ctrlKey||t.metaKey)))return;this[this.ctrlKeysMapDown[t.keyCode]](t)}t.stopImmediatePropagation(),t.preventDefault(),33<=t.keyCode&&t.keyCode<=40?(this.inCompositionMode=!1,this.clearContextTop(),this.renderCursorOrSelection()):this.canvas&&this.canvas.requestRenderAll()}},onKeyUp:function(t){!this.isEditing||this._copyDone||this.inCompositionMode?this._copyDone=!1:t.keyCode in this.ctrlKeysMapUp&&(t.ctrlKey||t.metaKey)&&(this[this.ctrlKeysMapUp[t.keyCode]](t),t.stopImmediatePropagation(),t.preventDefault(),this.canvas&&this.canvas.requestRenderAll())},onInput:function(t){var e=this.fromPaste;if(this.fromPaste=!1,t&&t.stopPropagation(),this.isEditing){var i,r,n,s,o,a=this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,h=this._text.length,c=a.length,l=c-h,u=this.selectionStart,f=this.selectionEnd,d=u!==f;if(""===this.hiddenTextarea.value)return this.styles={},this.updateFromTextArea(),this.fire("changed"),void(this.canvas&&(this.canvas.fire("text:changed",{target:this}),this.canvas.requestRenderAll()));var g=this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart,this.hiddenTextarea.selectionEnd,this.hiddenTextarea.value),p=u>g.selectionStart;d?(i=this._text.slice(u,f),l+=f-u):c<h&&(i=p?this._text.slice(f+l,f):this._text.slice(u,u-l)),r=a.slice(g.selectionEnd-l,g.selectionEnd),i&&i.length&&(r.length&&(n=this.getSelectionStyles(u,u+1,!1),n=r.map(function(){return n[0]})),d?(s=u,o=f):p?(s=f-i.length,o=f):o=(s=f)+i.length,this.removeStyleFromTo(s,o)),r.length&&(e&&r.join("")===fabric.copiedText&&!fabric.disableStyleCopyPaste&&(n=fabric.copiedTextStyle),this.insertNewStyleBlock(r,u,n)),this.updateFromTextArea(),this.fire("changed"),this.canvas&&(this.canvas.fire("text:changed",{target:this}),this.canvas.requestRenderAll())}},onCompositionStart:function(){this.inCompositionMode=!0},onCompositionEnd:function(){this.inCompositionMode=!1},onCompositionUpdate:function(t){this.compositionStart=t.target.selectionStart,this.compositionEnd=t.target.selectionEnd,this.updateTextareaPosition()},copy:function(){this.selectionStart!==this.selectionEnd&&(fabric.copiedText=this.getSelectedText(),fabric.disableStyleCopyPaste?fabric.copiedTextStyle=null:fabric.copiedTextStyle=this.getSelectionStyles(this.selectionStart,this.selectionEnd,!0),this._copyDone=!0)},paste:function(){this.fromPaste=!0},_getClipboardData:function(t){return t&&t.clipboardData||fabric.window.clipboardData},_getWidthBeforeCursor:function(t,e){var i,r=this._getLineLeftOffset(t);return 0<e&&(r+=(i=this.__charBounds[t][e-1]).left+i.width),r},getDownCursorOffset:function(t,e){var i=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(i),n=r.lineIndex;if(n===this._textLines.length-1||t.metaKey||34===t.keyCode)return this._text.length-i;var s=r.charIndex,o=this._getWidthBeforeCursor(n,s),a=this._getIndexOnLine(n+1,o);return this._textLines[n].slice(s).length+a+1+this.missingNewlineOffset(n)},_getSelectionForOffset:function(t,e){return t.shiftKey&&this.selectionStart!==this.selectionEnd&&e?this.selectionEnd:this.selectionStart},getUpCursorOffset:function(t,e){var i=this._getSelectionForOffset(t,e),r=this.get2DCursorLocation(i),n=r.lineIndex;if(0===n||t.metaKey||33===t.keyCode)return-i;var s=r.charIndex,o=this._getWidthBeforeCursor(n,s),a=this._getIndexOnLine(n-1,o),h=this._textLines[n].slice(0,s),c=this.missingNewlineOffset(n-1);return-this._textLines[n-1].length+a-h.length+(1-c)},_getIndexOnLine:function(t,e){for(var i,r,n=this._textLines[t],s=this._getLineLeftOffset(t),o=0,a=0,h=n.length;a<h;a++)if(e<(s+=i=this.__charBounds[t][a].width)){r=!0;var c=s-i,l=s,u=Math.abs(c-e);o=Math.abs(l-e)<u?a:a-1;break}return r||(o=n.length-1),o},moveCursorDown:function(t){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorUpOrDown("Down",t)},moveCursorUp:function(t){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorUpOrDown("Up",t)},_moveCursorUpOrDown:function(t,e){var i=this["get"+t+"CursorOffset"](e,"right"===this._selectionDirection);e.shiftKey?this.moveCursorWithShift(i):this.moveCursorWithoutShift(i),0!==i&&(this.setSelectionInBoundaries(),this.abortCursorAnimation(),this._currentCursorOpacity=1,this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())},moveCursorWithShift:function(t){var e="left"===this._selectionDirection?this.selectionStart+t:this.selectionEnd+t;return this.setSelectionStartEndWithShift(this.selectionStart,this.selectionEnd,e),0!==t},moveCursorWithoutShift:function(t){return t<0?(this.selectionStart+=t,this.selectionEnd=this.selectionStart):(this.selectionEnd+=t,this.selectionStart=this.selectionEnd),0!==t},moveCursorLeft:function(t){0===this.selectionStart&&0===this.selectionEnd||this._moveCursorLeftOrRight("Left",t)},_move:function(t,e,i){var r;if(t.altKey)r=this["findWordBoundary"+i](this[e]);else{if(!t.metaKey&&35!==t.keyCode&&36!==t.keyCode)return this[e]+="Left"===i?-1:1,!0;r=this["findLineBoundary"+i](this[e])}if(void 0!==typeof r&&this[e]!==r)return this[e]=r,!0},_moveLeft:function(t,e){return this._move(t,e,"Left")},_moveRight:function(t,e){return this._move(t,e,"Right")},moveCursorLeftWithoutShift:function(t){var e=!0;return this._selectionDirection="left",this.selectionEnd===this.selectionStart&&0!==this.selectionStart&&(e=this._moveLeft(t,"selectionStart")),this.selectionEnd=this.selectionStart,e},moveCursorLeftWithShift:function(t){return"right"===this._selectionDirection&&this.selectionStart!==this.selectionEnd?this._moveLeft(t,"selectionEnd"):0!==this.selectionStart?(this._selectionDirection="left",this._moveLeft(t,"selectionStart")):void 0},moveCursorRight:function(t){this.selectionStart>=this._text.length&&this.selectionEnd>=this._text.length||this._moveCursorLeftOrRight("Right",t)},_moveCursorLeftOrRight:function(t,e){var i="moveCursor"+t+"With";this._currentCursorOpacity=1,e.shiftKey?i+="Shift":i+="outShift",this[i](e)&&(this.abortCursorAnimation(),this.initDelayedCursor(),this._fireSelectionChanged(),this._updateTextarea())},moveCursorRightWithShift:function(t){return"left"===this._selectionDirection&&this.selectionStart!==this.selectionEnd?this._moveRight(t,"selectionStart"):this.selectionEnd!==this._text.length?(this._selectionDirection="right",this._moveRight(t,"selectionEnd")):void 0},moveCursorRightWithoutShift:function(t){var e=!0;return this._selectionDirection="right",this.selectionStart===this.selectionEnd?(e=this._moveRight(t,"selectionStart"),this.selectionEnd=this.selectionStart):this.selectionStart=this.selectionEnd,e},removeChars:function(t,e){void 0===e&&(e=t+1),this.removeStyleFromTo(t,e),this._text.splice(t,e-t),this.text=this._text.join(""),this.set("dirty",!0),this._shouldClearDimensionCache()&&(this.initDimensions(),this.setCoords()),this._removeExtraneousStyles()},insertChars:function(t,e,i,r){void 0===r&&(r=i),i<r&&this.removeStyleFromTo(i,r);var n=fabric.util.string.graphemeSplit(t);this.insertNewStyleBlock(n,i,e),this._text=[].concat(this._text.slice(0,i),n,this._text.slice(r)),this.text=this._text.join(""),this.set("dirty",!0),this._shouldClearDimensionCache()&&(this.initDimensions(),this.setCoords()),this._removeExtraneousStyles()}}),function(){var l=fabric.util.toFixed,u=/  +/g;fabric.util.object.extend(fabric.Text.prototype,{_toSVG:function(){var t=this._getSVGLeftTopOffsets(),e=this._getSVGTextAndBg(t.textTop,t.textLeft);return this._wrapSVGTextAndBg(e)},toSVG:function(t){return this._createBaseSVGMarkup(this._toSVG(),{reviver:t,noStyle:!0,withShadow:!0})},_getSVGLeftTopOffsets:function(){return{textLeft:-this.width/2,textTop:-this.height/2,lineTop:this.getHeightOfLine(0)}},_wrapSVGTextAndBg:function(t){var e=this.getSvgTextDecoration(this);return[t.textBgRects.join(""),'\t\t<text xml:space="preserve" ',this.fontFamily?'font-family="'+this.fontFamily.replace(/"/g,"'")+'" ':"",this.fontSize?'font-size="'+this.fontSize+'" ':"",this.fontStyle?'font-style="'+this.fontStyle+'" ':"",this.fontWeight?'font-weight="'+this.fontWeight+'" ':"",e?'text-decoration="'+e+'" ':"",'style="',this.getSvgStyles(!0),'"',this.addPaintOrder()," >",t.textSpans.join(""),"</text>\n"]},_getSVGTextAndBg:function(t,e){var i,r=[],n=[],s=t;this._setSVGBg(n);for(var o=0,a=this._textLines.length;o<a;o++)i=this._getLineLeftOffset(o),(this.textBackgroundColor||this.styleHas("textBackgroundColor",o))&&this._setSVGTextLineBg(n,o,e+i,s),this._setSVGTextLineText(r,o,e+i,s),s+=this.getHeightOfLine(o);return{textSpans:r,textBgRects:n}},_createTextCharSpan:function(t,e,i,r){var n=t!==t.trim()||t.match(u),s=this.getSvgSpanStyles(e,n),o=s?'style="'+s+'"':"",a=e.deltaY,h="",c=fabric.Object.NUM_FRACTION_DIGITS;return a&&(h=' dy="'+l(a,c)+'" '),['<tspan x="',l(i,c),'" y="',l(r,c),'" ',h,o,">",fabric.util.string.escapeXml(t),"</tspan>"].join("")},_setSVGTextLineText:function(t,e,i,r){var n,s,o,a,h,c=this.getHeightOfLine(e),l=-1!==this.textAlign.indexOf("justify"),u="",f=0,d=this._textLines[e];r+=c*(1-this._fontSizeFraction)/this.lineHeight;for(var g=0,p=d.length-1;g<=p;g++)h=g===p||this.charSpacing,u+=d[g],o=this.__charBounds[e][g],0===f?(i+=o.kernedWidth-o.width,f+=o.width):f+=o.kernedWidth,l&&!h&&this._reSpaceAndTab.test(d[g])&&(h=!0),h||(n=n||this.getCompleteStyleDeclaration(e,g),s=this.getCompleteStyleDeclaration(e,g+1),h=this._hasStyleChangedForSvg(n,s)),h&&(a=this._getStyleDeclaration(e,g)||{},t.push(this._createTextCharSpan(u,a,i,r)),u="",n=s,i+=f,f=0)},_pushTextBgRect:function(t,e,i,r,n,s){var o=fabric.Object.NUM_FRACTION_DIGITS;t.push("\t\t<rect ",this._getFillAttributes(e),' x="',l(i,o),'" y="',l(r,o),'" width="',l(n,o),'" height="',l(s,o),'"></rect>\n')},_setSVGTextLineBg:function(t,e,i,r){for(var n,s,o=this._textLines[e],a=this.getHeightOfLine(e)/this.lineHeight,h=0,c=0,l=this.getValueOfPropertyAt(e,0,"textBackgroundColor"),u=0,f=o.length;u<f;u++)n=this.__charBounds[e][u],(s=this.getValueOfPropertyAt(e,u,"textBackgroundColor"))!==l?(l&&this._pushTextBgRect(t,l,i+c,r,h,a),c=n.left,h=n.width,l=s):h+=n.kernedWidth;s&&this._pushTextBgRect(t,s,i+c,r,h,a)},_getFillAttributes:function(t){var e=t&&"string"==typeof t?new fabric.Color(t):"";return e&&e.getSource()&&1!==e.getAlpha()?'opacity="'+e.getAlpha()+'" fill="'+e.setAlpha(1).toRgb()+'"':'fill="'+t+'"'},_getSVGLineTopOffset:function(t){for(var e,i=0,r=0;r<t;r++)i+=this.getHeightOfLine(r);return e=this.getHeightOfLine(r),{lineTop:i,offset:(this._fontSizeMult-this._fontSizeFraction)*e/(this.lineHeight*this._fontSizeMult)}},getSvgStyles:function(t){return fabric.Object.prototype.getSvgStyles.call(this,t)+" white-space: pre;"}})}(),function(t){"use strict";var b=t.fabric||(t.fabric={});b.Textbox=b.util.createClass(b.IText,b.Observable,{type:"textbox",minWidth:20,dynamicMinWidth:2,__cachedLines:null,lockScalingFlip:!0,noScaleCache:!1,_dimensionAffectingProps:b.Text.prototype._dimensionAffectingProps.concat("width"),_wordJoiners:/[ \t\r]/,splitByGrapheme:!1,initDimensions:function(){this.__skipDimension||(this.isEditing&&this.initDelayedCursor(),this.clearContextTop(),this._clearCache(),this.dynamicMinWidth=0,this._styleMap=this._generateStyleMap(this._splitText()),this.dynamicMinWidth>this.width&&this._set("width",this.dynamicMinWidth),-1!==this.textAlign.indexOf("justify")&&this.enlargeSpaces(),this.height=this.calcTextHeight(),this.saveState({propertySet:"_dimensionAffectingProps"}))},_generateStyleMap:function(t){for(var e=0,i=0,r=0,n={},s=0;s<t.graphemeLines.length;s++)"\n"===t.graphemeText[r]&&0<s?(i=0,r++,e++):!this.splitByGrapheme&&this._reSpaceAndTab.test(t.graphemeText[r])&&0<s&&(i++,r++),n[s]={line:e,offset:i},r+=t.graphemeLines[s].length,i+=t.graphemeLines[s].length;return n},styleHas:function(t,e){if(this._styleMap&&!this.isWrapping){var i=this._styleMap[e];i&&(e=i.line)}return b.Text.prototype.styleHas.call(this,t,e)},isEmptyStyles:function(t){if(!this.styles)return!0;var e,i,r=0,n=!1,s=this._styleMap[t],o=this._styleMap[t+1];for(var a in s&&(t=s.line,r=s.offset),o&&(n=o.line===t,e=o.offset),i=void 0===t?this.styles:{line:this.styles[t]})for(var h in i[a])if(r<=h&&(!n||h<e))for(var c in i[a][h])return!1;return!0},_getStyleDeclaration:function(t,e){if(this._styleMap&&!this.isWrapping){var i=this._styleMap[t];if(!i)return null;t=i.line,e=i.offset+e}return this.callSuper("_getStyleDeclaration",t,e)},_setStyleDeclaration:function(t,e,i){var r=this._styleMap[t];t=r.line,e=r.offset+e,this.styles[t][e]=i},_deleteStyleDeclaration:function(t,e){var i=this._styleMap[t];t=i.line,e=i.offset+e,delete this.styles[t][e]},_getLineStyle:function(t){var e=this._styleMap[t];return!!this.styles[e.line]},_setLineStyle:function(t){var e=this._styleMap[t];this.styles[e.line]={}},_wrapText:function(t,e){var i,r=[];for(this.isWrapping=!0,i=0;i<t.length;i++)r=r.concat(this._wrapLine(t[i],i,e));return this.isWrapping=!1,r},_measureWord:function(t,e,i){var r,n=0;i=i||0;for(var s=0,o=t.length;s<o;s++){n+=this._getGraphemeBox(t[s],e,s+i,r,!0).kernedWidth,r=t[s]}return n},_wrapLine:function(t,e,i,r){var n=0,s=this.splitByGrapheme,o=[],a=[],h=s?b.util.string.graphemeSplit(t):t.split(this._wordJoiners),c="",l=0,u=s?"":" ",f=0,d=0,g=0,p=!0,v=this._getWidthOfCharSpacing();r=r||0;0===h.length&&h.push([]),i-=r;for(var m=0;m<h.length;m++)c=s?h[m]:b.util.string.graphemeSplit(h[m]),f=this._measureWord(c,e,l),l+=c.length,i<(n+=d+f-v)&&!p?(o.push(a),a=[],n=f,p=!0):n+=v,p||s||a.push(u),a=a.concat(c),d=s?0:this._measureWord([u],e,l),l++,p=!1,g<f&&(g=f);return m&&o.push(a),g+r>this.dynamicMinWidth&&(this.dynamicMinWidth=g-v+r),o},isEndOfWrapping:function(t){return!this._styleMap[t+1]||this._styleMap[t+1].line!==this._styleMap[t].line},missingNewlineOffset:function(t){return this.splitByGrapheme?this.isEndOfWrapping(t)?1:0:1},_splitTextIntoLines:function(t){for(var e=b.Text.prototype._splitTextIntoLines.call(this,t),i=this._wrapText(e.lines,this.width),r=new Array(i.length),n=0;n<i.length;n++)r[n]=i[n].join("");return e.lines=r,e.graphemeLines=i,e},getMinWidth:function(){return Math.max(this.minWidth,this.dynamicMinWidth)},_removeExtraneousStyles:function(){var t={};for(var e in this._styleMap)this._textLines[e]&&(t[this._styleMap[e].line]=1);for(var e in this.styles)t[e]||delete this.styles[e]},toObject:function(t){return this.callSuper("toObject",["minWidth","splitByGrapheme"].concat(t))}}),b.Textbox.fromObject=function(t,e){return b.Object._fromObject("Textbox",t,e,"text")}}("undefined"!=typeof exports?exports:this),function(){var t=fabric.controlsUtils,e=t.scaleSkewCursorStyleHandler,i=t.scaleCursorStyleHandler,r=t.scalingEqually,n=t.scalingYOrSkewingX,s=t.scalingXOrSkewingY,o=t.scaleOrSkewActionName,a=fabric.Object.prototype.controls;if(a.ml=new fabric.Control({x:-.5,y:0,cursorStyleHandler:e,actionHandler:s,getActionName:o}),a.mr=new fabric.Control({x:.5,y:0,cursorStyleHandler:e,actionHandler:s,getActionName:o}),a.mb=new fabric.Control({x:0,y:.5,cursorStyleHandler:e,actionHandler:n,getActionName:o}),a.mt=new fabric.Control({x:0,y:-.5,cursorStyleHandler:e,actionHandler:n,getActionName:o}),a.tl=new fabric.Control({x:-.5,y:-.5,cursorStyleHandler:i,actionHandler:r}),a.tr=new fabric.Control({x:.5,y:-.5,cursorStyleHandler:i,actionHandler:r}),a.bl=new fabric.Control({x:-.5,y:.5,cursorStyleHandler:i,actionHandler:r}),a.br=new fabric.Control({x:.5,y:.5,cursorStyleHandler:i,actionHandler:r}),a.mtr=new fabric.Control({x:0,y:-.5,actionHandler:t.rotationWithSnapping,cursorStyleHandler:t.rotationStyleHandler,offsetY:-40,withConnection:!0,actionName:"rotate"}),fabric.Textbox){var h=fabric.Textbox.prototype.controls={};h.mtr=a.mtr,h.tr=a.tr,h.br=a.br,h.tl=a.tl,h.bl=a.bl,h.mt=a.mt,h.mb=a.mb,h.mr=new fabric.Control({x:.5,y:0,actionHandler:t.changeWidth,cursorStyleHandler:e,actionName:"resizing"}),h.ml=new fabric.Control({x:-.5,y:0,actionHandler:t.changeWidth,cursorStyleHandler:e,actionName:"resizing"})}}();
define('model/ugc/pageHighlight',[],
    function() {
        var CURRENT_OBJECT_DATA_VERSION = 3;

        var PageHighlight = function(pageNumber, data, objectDataVersion, lastModified, lastSynced) {
            this.pageNumber = pageNumber;
            this.svgData = data;
            this.objectDataVersion = objectDataVersion;
            this.lastModified = lastModified || new Date().getTime();
            this.lastSynced = lastSynced || 0;

            this.id = function() {
                return this.pageNumber;
            };

            this.isSynced = function() {
                return this.lastModified <= this.lastSynced;
            };

            this.getSvgData = function() {
                return this.svgData;
            };

            this.setSvgData = function(svgData) {
                this.svgData = svgData;
                this.touch();
            };

            this.deleteHighlight = function() {
                this.svgData = null;
                this.touch();
            };

            this.touch = function() {
                this.lastModified = new Date().getTime();
            };

            this.getWriteableObject = function() {
                return {
                    pageNumber: this.pageNumber,
                    svgData: this.svgData,
                    objectDataVersion: this.objectDataVersion,
                    lastModified: this.lastModified,
                    lastSynced: this.lastSynced
                };
            };
        };

        return {
            CURRENT_OBJECT_DATA_VERSION: CURRENT_OBJECT_DATA_VERSION,
            PageHighlight: PageHighlight
        };
    });

/**
 * This module currently has two functions:
 *  1. It controls the fabric.js "highlighting" canvas, where the "free drawing" that creates the highlights occurs.
 *      In the DOM, this itself has two canvas objects, an "upper" and a "lower" canvas, to enable the
 *      highlight-currently-being-drawn to be redrawn at each refresh, as per standard practice, while keeping
 *      separate the canvas storing all previously drawn highlights for that page(-spread).
 *  2. Confusingly, it currently also has some functionality expected of a page highlights module, namely,
 *      responding to highlights-related events. In particular, when saving the highlights, this class converts the
 *      highlights on the fabric.js canvas to SVGs (`toSVG`) and then stores them in the SVG DOM elements associated
 *      with the highlights for each page. All this "controller" behaviour should be refactored out of this class (the
 *      event handling at least, not necessarily the actual implementation details).
 *  Note in particular the difference between:
 *      - `yudu_highlightingCanvasContainer`: a `div` set aside to contain the fabric.js canvas. This will end up with
 *          an inner `div` (created by fabric.js) containing two canvas objects
 *      - `yudu_pageHighlightsContainer`: a `div` set aside to contain a series of `yudu_pageHighlights_n` `div`
 *          wrappers (with at most one n per page number), each containing the SVG form of the last-saved state
 *          of the page highlights for page n
 */
define('ui/highlightingCanvas',['api', 'events', 'config', 'constants', 'resources', 'model/ugc/pageHighlight', 'shared/ui/messageBox',
        'ui/uiTools', 'utils/tools', 'utils/statistics', 'fabric', 'jquery'],
    function(api, events, config, constants, resources, pageHighlight, messageBox,
             uiTools, tools, statistics, fabric, $) {
        var TARGET_FIND_TOLERANCE = 0;
        var EMITTER_NAME = 'pageHighlights';

        var isShowing = false;
        var isHighlighting = false;
        var inEraserMode = false;
        var currentBrushColour;
        var currentBrushWidth;
        var onlyHighlightRightPage = false;

        var reader;
        var highlightingCanvas;
        var leftPage;
        var rightPage;

        var historyStack = [];
        var redoStack = [];

        var pageHighlights = {};

        var highlightingCanvasContainer = $('#yudu_highlightingCanvasContainer');

        var pagesNeedingUpdates = {};

        var init = function(retrievedPageHighlights) {
            setupPageHighlights(retrievedPageHighlights);
            updateCurrentPages();
            events.subscribe(events.ALL, events.PAGE_CHANGED, handlePageChangeEvent);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, handleTwoUpChangeEvent);
            events.subscribe(events.ALL, events.LOGIN_SUCCESS, updateCurrentPages);
        };

        /**
         * Allows reinitialisation of the highlights data, as well as ensuring those visible are updated properly
         * @param retrievedPageHighlights ; JSON/hash of stringified page highlights
         * @param parameters ; hash of additional parameters serving as advanced options for the reinitialisation
         */
        var reinit = function(retrievedPageHighlights, parameters) {
            if (parameters.reset) {
                resetHighlights();
            }
            if (parameters.merge) {
                // merge SVGs by combining all paths
                mergeHighlightsWith(retrievedPageHighlights);
            } else {
                // page-level merging as default behaviour (match app behaviour)
                setupPageHighlights(retrievedPageHighlights);
            }
            updateCurrentPages();
            if (!parameters.reset) {
                emitHighlightsChangedEvent(true);
            }
        };

        var resetHighlights = function() {
            pageHighlights = {};
            for (var i = 0, m = reader.shifter.getNumberOfPages(); i < m; i += 1) {
                pagesNeedingUpdates[i] = true;
            }
        };

        /**
         * Given a hash containing JSON-stringified page highlights, keyed by page,
         *  this method populates a local hash of `PageHighlight`s representing deserialised page highlights
         * For any given page-key, input page highlights will be merged at the SVG-path level with any existing page
         *  highlights object of the same key
         * Note that duplicate paths cannot be detected as there is no modification data for individual paths
         *  so this mechanic can only accept-all or reject-all
         * @param retrievedPageHighlights
         */
        var mergeHighlightsWith = function(retrievedPageHighlights) {
            for (var property in retrievedPageHighlights) {
                if (retrievedPageHighlights.hasOwnProperty(property)) {
                    var retrievedHighlightData = JSON.parse(retrievedPageHighlights[property]);
                    // for each highlight:
                    if (!!pageHighlights[property]) {
                        if (retrievedHighlightData.svgData) {
                            // if there is already a "page highlights" for that page, and the input SVG is non-empty
                            // create empty `div`s to manipulate the XML
                            var existingHighlightsObject = pageHighlights[property];
                            var existingAsElement = $('<div></div>');
                            existingAsElement[0].innerHTML = existingHighlightsObject.getSvgData();
                            var lastPath = existingAsElement.children('svg').children('path').last();
                            var emptyElement = $('<div></div>');
                            emptyElement[0].innerHTML = retrievedHighlightData.svgData;
                            // and add all the paths from the input to the existing page highlights object
                            lastPath.after(emptyElement.children('svg').children('path'));
                            existingHighlightsObject.setSvgData(existingAsElement[0].innerHTML);
                            pagesNeedingUpdates[property] = true;
                        }
                    } else {
                        // no existing highlights on page, create a new one from the input
                        pageHighlights[property] = createPageHighlightsObject(retrievedHighlightData);
                        pagesNeedingUpdates[property] = true;
                    }
                }
            }
        };

        /**
         * Given a hash containing JSON-stringified page highlights, keyed by page,
         *  this method populates a local hash of `PageHighlight`s representing deserialised page highlights
         * For any given page-key, input page highlights will override existing highlights,
         *  provided the existing page highlights have not been modified more recently than the input page highlights
         *  and record that the page needs updating
         * Otherwise, or for any existing page-key not in the newly-received dataset, the highlights will be preserved
         * This mimics "merging" behaviour on the other platforms
         * @param retrievedPageHighlights
         */
        var setupPageHighlights = function(retrievedPageHighlights) {
            for (var property in retrievedPageHighlights) {
                if (retrievedPageHighlights.hasOwnProperty(property)) {
                    var pageHighlightData = JSON.parse(retrievedPageHighlights[property]);
                    if (!!pageHighlights[property] &&
                            pageHighlights[property].lastModified > pageHighlightData.lastModified) {
                        // conflict between remote highlights and local highlights: keep the most recently modified
                        continue;
                    }
                    pageHighlights[property] = createPageHighlightsObject(pageHighlightData);
                    pagesNeedingUpdates[property] = true;
                }
            }
        };

        /**
         * Given an input (parsed) hash of pageHighlights data, create a Javascript representation of it
         * @param pageHighlightData
         * @returns {exports.PageHighlight}
         */
        var createPageHighlightsObject = function(pageHighlightData) {
            var svgData = pageHighlightData.svgData;
            if (!svgData) {
                // when deleted on other platforms, there can be a pageHighlights object with no SVG data
                svgData = null;
            }
            return new pageHighlight.PageHighlight(pageHighlightData.pageNumber, svgData,
                    pageHighlightData.objectDataVersion, pageHighlightData.lastModified, pageHighlightData.lastSynced);
        };

        var hideAllPageHighlights = function(event) {
            $('#yudu_pageHighlightsContainer .yudu_pageHighlights').hide();
        };

        var handlePageChangeEvent = function(event) {
            if (isShowing) {
                saveCanvas();
                hideAllPageHighlights(event);
                updateCurrentPages(event);
                setupCanvas();
            } else {
                hideAllPageHighlights(event);
                updateCurrentPages(event);
            }
        };

        var handleTwoUpChangeEvent = function(event) {
            if (isShowing) {
                saveCanvas();
                updateCurrentPages(event);
                setupCanvas();
            } else {
                updateCurrentPages(event);
            }
        };

        var updateCurrentPages = function(event) {
            leftPage = reader.shifter.getCentreTray().pages[0];
            rightPage = reader.shifter.getCentreTray().pages[1];

            // TODO ugc: move this into the pageHighlightsController
            //      OverlayController and NotesController have a listener, and this should mimic that behaviour
            //for page changes and 2up changes and show/hide the views accordingly
            // Do not display UGC on encrypted pages
            if (!leftPage.encrypted) {
                var leftPageNumber = leftPage.page.number;
                leftPage.updatePageHighlightsContainer(pageHighlights[leftPageNumber], !!pagesNeedingUpdates[leftPageNumber]);
                var leftPageContainer = $('#yudu_pageHighlights_' + leftPageNumber);
                resetViewbox(leftPageContainer, leftPage.page);
                leftPageContainer.show();
                pagesNeedingUpdates[leftPageNumber] = false;
            }

            if (rightPage && !rightPage.encrypted) {
                var rightPageNumber = rightPage.page.number;
                rightPage.updatePageHighlightsContainer(pageHighlights[rightPageNumber], !!pagesNeedingUpdates[rightPageNumber]);
                var rightPageContainer = $('#yudu_pageHighlights_' + rightPageNumber);
                resetViewbox(rightPageContainer, rightPage.page);
                rightPageContainer.show();
                pagesNeedingUpdates[rightPageNumber] = false;
            }
        };

        var resetViewbox = function(jqueryContainer, page) {
            // ensure there is some SVG/highlights data to initialise
            if (jqueryContainer[0].firstElementChild) {
                // page data is not stored with the highlights object on the server, so a default page size is returned
                // and needs to be overwritten on loading after a sync response
                jqueryContainer[0].firstElementChild.setAttribute('viewBox', '0 0 ' + page.width + ' ' + page.height);
            }
        };

        var setupCanvas = function(event) {
            if (resources.yuduBook.settings.highlightsEnabled) {
                onlyHighlightRightPage = leftPage.page.number == 0 && config.hasIntroPage;
                var pageToSetupOn;
                if (onlyHighlightRightPage && rightPage) {
                    pageToSetupOn = rightPage;
                } else {
                    pageToSetupOn = leftPage
                }
                var redrawnHighlightingCanvas = redrawHighlightingCanvas();
                pageToSetupOn.pageHighlightsLevel.setupCanvasElementContainer(redrawnHighlightingCanvas);
                if (redrawnHighlightingCanvas.width > 0 && redrawnHighlightingCanvas.height > 0) {
                    // fabric uses falsy evaluation to apply default sizes to a canvas, so a canvas with 0 size results
                    //  in a non-zero sized canvas, which we don't want, so we simply don't let fabric initialise it
                    pageToSetupOn.pageHighlightsLevel.setupFabricCanvasContainer(setupFabricCanvas());
                    loadInObjects();
                    isHighlighting = true;
                } else {
                    messageBox.displayByCode('highlights.introPageWarning');
                    isHighlighting = false;
                }
            }
        };

        var saveCanvas = function() {
            if (!isHighlighting) {
                return;
            }
            if (!rightPage) {
                saveCanvasToPageLeft();
            } else if (onlyHighlightRightPage) {
                saveCanvasToPageRight();
            } else {
                var objects = highlightingCanvas.getObjects();
                var objectsOnLHS = [];
                var objectsOnRHS = [];

                $.each(objects, function(index, object) {
                    var objectBoundingRect = object.getBoundingRect();

                    if (objectBoundingRect.left < leftPage.page.width) {
                        objectsOnLHS.push(object);
                        if (objectBoundingRect.left + objectBoundingRect.width > leftPage.page.width) {
                            objectsOnRHS.push(object);
                        }
                    } else {
                        objectsOnRHS.push(object);
                    }
                });

                highlightingCanvas.clear();
                $.each(objectsOnLHS, function (index, object) {
                    highlightingCanvas.add(object);
                });
                saveCanvasToPageLeft();

                highlightingCanvas.clear();
                $.each(objectsOnRHS, function (index, object) {
                    object.left -= leftPage.page.width;
                    highlightingCanvas.add(object);
                });
                saveCanvasToPageRight();
            }

            highlightingCanvas.clear();
            clearStacks();
            emitHighlightsChangedEvent(false);
        };

        var emitHighlightsChangedEvent = function(fromSync) {
            events.emit(EMITTER_NAME, events.UGC_CHANGED, this, {pageHighlights: pageHighlights, fromSync: fromSync});
        };

        var savePage = function(rightSide) {
            var page = rightSide ? rightPage.page : leftPage.page;
            var pageHighlightsContainer = $("#yudu_pageHighlights_" + page.number)[0];
            pageHighlightsContainer.innerHTML = highlightingCanvas.toSVG({ viewBox : { x : 0, y : 0, width : page.width, height : page.height}});
            pageHighlightsContainer.firstElementChild.setAttribute('width', '100%');
            pageHighlightsContainer.firstElementChild.setAttribute('height', '100%');

            if (pageHighlights[page.number]) {
                pageHighlights[page.number].setSvgData(pageHighlightsContainer.innerHTML);
            } else {
                pageHighlights[page.number] = new pageHighlight.PageHighlight(page.number, pageHighlightsContainer.innerHTML, pageHighlight.CURRENT_OBJECT_DATA_VERSION);
            }
        };

        var saveCanvasToPageLeft = function() {
            savePage(false);
        };

        var saveCanvasToPageRight = function() {
            savePage(true);
        };

        var setupFabricCanvas = function() {
            highlightingCanvas = new fabric.Canvas('yudu_highlightingCanvas', { isDrawingMode:!inEraserMode, perPixelTargetFind:true,
                                            allowTouchScrolling:false, targetFindTolerance:TARGET_FIND_TOLERANCE, selection: false });
            highlightingCanvas.freeDrawingBrush.color = currentBrushColour;
            highlightingCanvas.freeDrawingBrush.width = currentBrushWidth;

            events.yuduOn(highlightingCanvas, 'path:created', function(event) {
                convertQuadraticBezierToLineSegments(event.path);
                event.path.selectable = false;
                addCurrentCanvasToHistory();
                redoStack = [];
            });

            if (inEraserMode) {
                enterEraserMode();
            }

            return highlightingCanvas;
        };

        /**
         * Given an input path (from fabric.js's "path:created" event) with a `path` array element
         *  where each subelement is itself an array containing the SVG path command and control points / coordinates
         *  this method converts all quadratic bezier curve segments into line segments for backwards compatibility
         *      NB: bezier commands are Q (w/ control points) and T (infers control points from preceding Q/T command)
         * This method destructively modifies the input path
         * @param pathContainer
         */
        var convertQuadraticBezierToLineSegments = function(pathContainer) {
            var path = pathContainer.path;
            if (!path || path.length < 1) {
                return;
            }
            for (var i = 0; i < path.length; i++) {
                var element = path[i];
                if (element[0] == "Q" && element.length == 5) {
                    path[i] = ["L", element[3], element[4]];
                } else if (element[0] == "T" && element.length == 3) {
                    path[i] = ["L", element[1], element[2]];
                }
            }
        };

        var addCurrentCanvasToHistory = function() {
            var objectsOnCanvas = [];
            $.each(highlightingCanvas.getObjects(), function(index, object) {
                objectsOnCanvas.push(object);
            });
            historyStack.push(objectsOnCanvas);
        };

        var redrawHighlightingCanvas = function() {
            var canvasWidth = 0;
            var canvasHeight = 0;
            if (!onlyHighlightRightPage) {
                canvasWidth += leftPage.page.width;
                canvasHeight = leftPage.page.height;
            }
            if (rightPage) {
                canvasWidth += rightPage.page.width;
                canvasHeight = Math.max(canvasHeight, rightPage.page.height);
                // TODO: make this compatible with mixed layout documents
            }

            var htmlElement = document.createElement('canvas');
            htmlElement.id = 'yudu_highlightingCanvas';
            htmlElement.width = canvasWidth;
            htmlElement.height = canvasHeight;
            htmlElement.style.border = '0px';

            return htmlElement;
        };

        /**
         * prepare the highlighting canvas with available past data
         */
        var loadInObjects = function() {
            if (!onlyHighlightRightPage) {
                loadObjectsFromPage(true);
            }
            if (rightPage) {
                loadObjectsFromPage(false);
            }
            addCurrentCanvasToHistory();
        };

        /**
         * loads the saved paths for a page and copies them to the highlighting canvas (for potential modification)
         * @param loadLeftPage ; whether to load the left page (true) or the right (false)
         */
        var loadObjectsFromPage = function(loadLeftPage) {
            var loadingPage = loadLeftPage ? leftPage : rightPage;
            var svgData = $('#yudu_pageHighlights_' + loadingPage.page.number)[0].innerHTML;
            if (svgData) {
                fabric.loadSVGFromString(svgData, function (objects, options) {
                    $.each(objects, function (i, object) {
                        if (!loadLeftPage && !onlyHighlightRightPage) {
                            object.left += leftPage.page.width;
                        }
                        if (loadLeftPage || onlyHighlightRightPage
                                || object.getBoundingRect().left > leftPage.page.width) {
                            highlightingCanvas.add(object);
                        }
                    });
                });
            }
        };

        /**
         * helper function to extract the left/top offsets for a path from the XML for an SVG
         * @param svgXml ; the SVG's XML
         * @returns {{left: number, top: number}}
         */
        var getOffsetsFromSvgXml = function(svgXml) {
            // need to calculate how far the paths have been translated by fabricjs
            var leftOffset = 0;
            var topOffset = 0;
            // sum the x/y translations to calculate the correct position of the path within the canvas
            var transformString = svgXml.getAttribute('transform');
            // this regex extracts the x/y values from `translate(x, y)` where the numbers are separated by `[ ,]+`
            var regexp = /translate\(\s*([^\s,)]+)[ ,]+([^\s,)]+)/g;
            // fabricjs can create multiple translations for a single SVG
            var match = regexp.exec(transformString);
            while(!!match) {
                leftOffset += parseFloat(match[1]);
                topOffset += parseFloat(match[2]);
                match = regexp.exec(transformString);
            }
            return {
                left: leftOffset,
                top: topOffset
            };
        };

        var pageHasHighlight = function(pageIndex) {
            var pageHasHighlights = pageHighlights && pageHighlights[pageIndex] && !!pageHighlights[pageIndex].svgData;
            if (pageHasHighlights) {
                var svgPathsCount = $(pageHighlights[pageIndex].svgData).find('path').length;
                pageHasHighlights = svgPathsCount > 0
            }
            return pageHasHighlights;
        };

        var pagesSupportHighlights = function() {
            return !reader.isShowingEncryptedPage();
        };

        var showHighlightingCanvas = function() {
            setupCanvas();
            highlightingCanvasContainer.show();
            isShowing = true;
        };

        var hideHighlightingCanvas = function() {
            highlightingCanvasContainer.hide();
            clearStacks();
            isShowing = false;
            isHighlighting = false;
        };

        var cancel = function() {
            clearStacks();
        };

        var clearStacks = function() {
            historyStack = [];
            redoStack = [];
        };

        var clearCanvas = function() {
            if (highlightingCanvas) {
                highlightingCanvas.clear();
                addCurrentCanvasToHistory();
            }
        };

        var undo = function() {
            if (historyStack.length > 1){
                redoStack.push(historyStack.pop());
                highlightingCanvas.clear();
                var undo = historyStack[historyStack.length - 1];
                $.each(undo, function(index, object) {
                    highlightingCanvas.add(object);
                });
                highlightingCanvas.renderAll();
            }
        };

        var redo = function() {
            if (redoStack.length > 0) {
                highlightingCanvas.clear();
                var redo = redoStack.pop();
                $.each(redo, function(index, object) {
                    highlightingCanvas.add(object);
                });
                addCurrentCanvasToHistory();
                highlightingCanvas.renderAll();
            }
        };

        var setBrushColour = function(color) {
            currentBrushColour = color;
            if (highlightingCanvas) {
                highlightingCanvas.freeDrawingBrush.color = currentBrushColour;
            }
        };

        var setBrushWidth = function(width) {
            currentBrushWidth = width;
            if (highlightingCanvas) {
                highlightingCanvas.freeDrawingBrush.width = currentBrushWidth;
            }
        };

        var enterEraserMode = function() {
            if (highlightingCanvas) {
                highlightingCanvas.isDrawingMode = false;
                events.yuduOn(highlightingCanvas, 'mouse:down', handleEraserMouseDown);
            }
        };

        var exitEraserMode = function() {
            if (highlightingCanvas) {
                highlightingCanvas.off('mouse:down', handleEraserMouseDown);
                highlightingCanvas.off('mouse:move', handleEraserAction);
                highlightingCanvas.off('mouse:up', removeEraserMoveListeners);
            }
        };

        var handleEraserMouseDown = function(event) {
            handleEraserAction(event);
            events.yuduOn(highlightingCanvas, 'mouse:move', handleEraserAction);
            events.yuduOn(highlightingCanvas, 'mouse:up', removeEraserMoveListeners);
        };

        var removeEraserMoveListeners = function(event) {
            highlightingCanvas.off('mouse:move', handleEraserAction);
            highlightingCanvas.off('mouse:up', removeEraserMoveListeners);
        };

        var handleEraserAction = function(event) {
            if (!inEraserMode) {
                exitEraserMode();
            } else {
                var targetFound = false;
                var targetsStillToFind = true;
                while(targetsStillToFind) {
                    var target = highlightingCanvas.findTarget(event.e, null);
                    if (target) {
                        targetFound = true;
                        highlightingCanvas.remove(target);
                    } else {
                        targetsStillToFind = false;
                    }
                }
                if (targetFound) {
                    redoStack = [];
                    addCurrentCanvasToHistory();
                }
            }
        };

        var eraserMode = function(on) {
            inEraserMode = on;
            highlightingCanvas.isDrawingMode = !on;
            if (inEraserMode) {
                enterEraserMode();
            } else {
                exitEraserMode();
            }
        };

        return {
            init: init,
            reinit: reinit,
            setReader: events.callback(this, function(aReader) { reader = aReader; }),
            eraserMode: eraserMode,
            setBrushWidth: setBrushWidth,
            setBrushColour: setBrushColour,
            pageHasHighlight: pageHasHighlight,
            pagesSupportHighlights: pagesSupportHighlights,
            showHighlightingCanvas: showHighlightingCanvas,
            hideHighlightingCanvas: hideHighlightingCanvas,
            saveCanvas: saveCanvas,
            cancel: cancel,
            clearCanvas: clearCanvas,
            undo: undo,
            redo: redo
        };
    });

define('controllers/pageHighlightsController',['model/overlay','events', 'constants', 'resources', 'config', 'controllers/shifter', 'utils/tools', 'fabric', '../ui/highlightingCanvas'],
    function(overlay, events, constants, resources, config, shifter, tools, fabric, highlightingCanvas) {

        /**
         * Class that controls an overlay level for a page
         * @constructor
         */
        var PageHighlightsController = function(pageNumber) {
            this.highlightsContainerCreated = false;
            this.pageNumber = pageNumber;

            this.htmlElement = null;
            this.domElement = null;
            this.canvas = null;

            this.pageHighlightsContainer = $('#yudu_pageHighlightsContainer');
            this.highlightingCanvasContainer = $("#yudu_highlightingCanvasContainer")[0];
            this.container = new createjs.Container();

            this.setupCanvasElementContainer = function(canvasElement) {
                while (this.highlightingCanvasContainer.firstChild) {
                    this.highlightingCanvasContainer.removeChild(this.highlightingCanvasContainer.firstChild);
                }

                this.htmlElement = canvasElement;
                this.domElement = new createjs.DOMElement(this.htmlElement);
                this.highlightingCanvasContainer.appendChild(this.htmlElement);
            };

            this.setupFabricCanvasContainer = function(fabricCanvasElement) {
                this.canvas = fabricCanvasElement;
                this.getContainer().addChild(new createjs.DOMElement(document.getElementsByClassName("canvas-container")[0]));
            };

            this.createHighlightsContainer = function() {
                this.highlightsContainer = document.createElement("div");
                this.highlightsContainer.id = "yudu_pageHighlights_" + this.pageNumber;
                this.highlightsContainer.className = "yudu_pageHighlights";
                this.highlightsContainer.style.width = this.pageWidth + 'px';
                this.highlightsContainer.style.height = this.pageHeight + 'px';
                this.pageHighlightsContainer.append(this.highlightsContainer);
                this.getContainer().addChild(new createjs.DOMElement(this.highlightsContainer));
                this.highlightsContainerCreated = true;
            };

            this.updateHighlightsContainer = function(pageHighlight, forceUpdate) {
                var justCreated = false;
                if (!this.highlightsContainerCreated) {
                    this.createHighlightsContainer();
                    justCreated = true;
                }
                if (forceUpdate || justCreated) {
                    if (pageHighlight && pageHighlight.svgData) {
                        this.highlightsContainer.innerHTML = pageHighlight.svgData;
                    } else if (forceUpdate) {
                        // if forcing an update without any replacing SVG data, we probably just want to remove it
                        this.highlightsContainer.innerHTML = '';
                    }
                }
            };

            /**
             * Returns the container that the overlays for this controller are rendered to
             * @returns {container}
             */
            this.getContainer = function() {
                return this.container;
            };

            /**
             * Given the zoom level we are currently at and the page we are on, scales the overlays
             * to fit so that they appear in the correct places and at the correct sizes.
             * @param zoomLevel the model object for the zoom level we are currently at
             * @param page the model object for the page these overlays are on
             */
            this.scaleHighlights = function(zoomLevel, page) {
                var scaleX = zoomLevel.width / page.width;
                var scaleY = zoomLevel.height / page.height;

                this.getContainer().set({scaleX: scaleX, scaleY: scaleY});
            };

            this.setHitArea = function(pageW, pageH) {
                this.pageWidth = pageW;
                this.pageHeight = pageH;
                for (var i = 0, l = this.getContainer().getNumChildren(); i < l; i++) {
                    var hit = new createjs.Shape();
                    var hitWidth = pageW;
                    var hitHeight = pageH;
                    hit.graphics.beginFill("#000").drawRect(0, 0, hitWidth, hitHeight);
                    this.getContainer().getChildAt(i).hitArea = hit;
                }
            }
        };

        return {
            PageHighlightsController: PageHighlightsController
        };
    });

define('model/ugc/note',['../../events', 'constants', 'config', 'resources', 'tween', 'utils/tools', 'jquery', 'jquery.hammer'],
    function(events, constants, config, resources, createjs, tools, $) {
        var EMITTER_NAME = "note";
        var NOTE_ICON_PATH = constants.ugcNotePlaceholderUrl;
        var NOTE_ICON_DRAG_PATH = constants.ugcNotePlaceholderDragUrl;
        var DRAG_TIMEOUT = constants.ugcNoteDragTimeout;
        var holdTimeout;

        var Note = function(pageNumber, text, x, y, zIndex, clipping, id, lastModified, lastSynced, isDeleted) {
            this.pageNumber = pageNumber;
            this.text = text;
            this.x = Number(x);
            this.y = Number(y);
            this.zIndex = Number(zIndex) || 0;
            this.clipping = clipping || {};
            this.id = id || tools.createUID();
            this.lastModified = lastModified || new Date().getTime();
            this.lastSynced = lastSynced || 0;
            this.isDeleted = isDeleted || false;

            this.downStarted = false;
            this.inDraggingMode = false;

            this.rect = null;
            this.hitArea = null;
            this.htmlElement = null;
            this.domElement = false;

            this.isInDom = false;

            this.notesContainer = $("#yudu_notes")[0];

            this.isMouseIn = false;

            // newNote defines whether or not we are creating a new note or displaying an existing one
            this.init = function(newNote) {
                events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, this.toggleVisibility), false);
                events.subscribe(events.ALL, events.TWO_UP_CHANGED, events.callback(this, this.toggleVisibility), false);

                this.rect = new createjs.Container();
                this.rect.x = this.x;
                this.rect.y = this.y;

                this.createNoteContainer();

                if(newNote) {
                    var intervalId = setInterval(function() {
                        events.emit(EMITTER_NAME, events.NOTE_TRANSFORM_CHECK, this, {intervalId: intervalId});
                    }, 100);
                }


                return this.rect;
            };

            this.createNoteContainer = function() {
                this.isInDom = false;
                this.domElement = document.createElement("img");
                this.domElement.src = NOTE_ICON_PATH;

                //Can't use a clickAction here because we need to allow for long presses to drag the note
                events.yuduOn($(this.domElement), config.deviceUsesClicks ? 'mousedown' : 'touchstart', events.callback(this, this.handleStartEvent));

                //Following line is to avoid long hold IE issues on touch device
                events.yuduAddEventListener(this.domElement, "MSHoldVisual", function(e) { e.preventDefault(); }, false);

                this.rect.addChildAt(new createjs.DOMElement(this.domElement));
                this.toggleVisibility();
            };

            this.handleStartEvent = function(event) {
                events.yuduOn($('#yudu_reader'), config.deviceUsesClicks ? 'mouseup' : 'touchend', events.callback(this, this.handleEndEvent));

                this.downStarted = true;
                holdTimeout = setTimeout(events.callback(this, this.timerExpired), DRAG_TIMEOUT);

                //If move is outside the note when the mouse is down but before the timer has expired, then cancel
                events.yuduOn($(this.domElement), config.deviceUsesClicks ? 'mouseout' : 'touchleave', events.callback(this, this.cancelDrag));

                event.preventDefault();
            };

            this.cancelDrag = function(event) {
                //Timeout no longer valid, so clear it
                clearTimeout(holdTimeout);

                //No longer need to listen for the mouse out events
                $(this.domElement).off(config.deviceUsesClicks ? 'mouseout' : 'touchleave');
                this.downStarted = false;

                event.preventDefault();
            };

            this.handleEndEvent = function(event) {
                $('#yudu_reader').off(config.deviceUsesClicks ? 'mouseup' : 'touchend', events.callback(this, this.handleEndEvent));

                if (this.downStarted) {
                    this.downStarted = false;
                    //Timeout no longer valid, so clear it
                    clearTimeout(holdTimeout);

                    //Set the note icon back to normal icon
                    this.domElement.src = NOTE_ICON_PATH;

                    //No longer need to listen for the exit events
                    $(this.domElement).off(config.deviceUsesClicks ? 'mouseout' : 'touchleave');

                    //If it isn't a long click, then assume it's a normal click to view the note
                    if (!this.inDraggingMode) {
                        events.emit(EMITTER_NAME, events.VIEW_NOTE, this, {note: this, rect: this.domElement.getBoundingClientRect(), isNew: false});
                    }
                    else {
                        events.emit(EMITTER_NAME, events.NOTE_MOVED, this, {note: this, rect: this.domElement.getBoundingClientRect()});
                        //console.log(JSON.stringify(this.getWriteableObject()));
                    }

                    this.inDraggingMode = false;
                    event.preventDefault();
                }
            };

            this.timerExpired = function(event) {
                //Long press! Change the icon and set the long press flag
                this.domElement.src = NOTE_ICON_DRAG_PATH;
                $(this.domElement).off(config.deviceUsesClicks ? 'mouseout' : 'touchleave');
                this.inDraggingMode = true;
                events.emit(EMITTER_NAME, events.NOTE_DRAG_START, this, {note: this});
            };


            this.move = function(tapPoint, maxX, maxY, noteWidth, noteHeight) {
                var globalMovePosition = this.rect.globalToLocal(tapPoint.x, tapPoint.y);
                // offset the new position by half the note size to keep the note centred under the move event
                // note that this is needed to allow notes to detect movement above interactive iframes (which would otherwise capture the move event)
                this.rect.x = this.keepWithinLimits(0, this.rect.x + globalMovePosition.x - noteWidth/2, maxX);
                this.rect.y = this.keepWithinLimits(0, this.rect.y + globalMovePosition.y - noteHeight/2, maxY);
                this.x = this.rect.x;
                this.y = this.rect.y;
                this.touch();
            };

            /**
             * helper function to keep a specified value within certain bounds
             * ensures that the inequality `min <= value <= max` is enforced
             */
            this.keepWithinLimits = function(min, valueToRestrict, max) {
                return Math.max(min, Math.min(valueToRestrict, max));
            };

            this.pageChanged = function() {
                this.toggleVisibility();
            };

            this.toggleVisibility = function() {
                if (shifter.isPageShowing(this.pageNumber)) {
                    this.addToDom(true);
                    $(this.domElement).show();
                } else {
                    this.addToDom(false);
                    if (this.isInDom) {
                        $(this.domElement).hide();
                    }
                }
            };

            this.addToDom = function(force) {
                if (!this.isInDom && (force || shifter.isPageInTray(pageNumber))) {
                    this.isInDom = true;
                    this.notesContainer.appendChild(this.domElement);
                }
            };

            this.removeDomElement = function(setDeleted) {
                //Remove the dom element from the canvas and the document
                $(this.domElement).remove();
                if (setDeleted) {
                    this.isDeleted = true;
                    this.touch();
                }
            };

            this.setNoteText = function(noteText) {
                this.text = noteText;
                this.touch();
            };

            this.getGlobalLocation = function() {
                return this.rect.localToGlobal(this.x, this.y);
            };

            var zIndexComparator = function(note1, note2) {
                return note1.zIndex - note2.zIndex;
            };

            this.touch = function() {
                this.lastModified = new Date().getTime();
            };

            this.getWriteableObject = function() {
                return {
                    id: this.id,
                    pageNumber: this.pageNumber,
                    locationX: this.x,
                    locationY: this.y,
                    zIndex: this.zIndex,
                    text: this.text,
                    clipping: this.clipping,
                    lastModified: this.lastModified,
                    lastSynced: this.lastSynced,
                    isDeleted: this.isDeleted
                }
            };
        };

        return {
            Note: Note,
            EMITTER_NAME: EMITTER_NAME,
            setShifter: events.callback(this, function(aShifter) { shifter = aShifter; })
        };
    });

define('views/noteView',['easel', '../events'],
    function(createjs, events) {

        var EMITTER_NAME = 'NoteView';

        /**
         * Class that represents a level that the notes are rendered on - essentially just a container
         * @constructor
         */
        var NoteView = function() {
            this.container = new createjs.Container();

            /**
             * Adds the specified visual representation of a note to this layer.
             * @param note the visual representation of anote
             */
            this.addNote = function(note) {
                this.container.addChild(note);
                events.emit(EMITTER_NAME, events.NOTE_ADDED, this, {});
            };

            this.removeNote = function(note) {
                this.container.removeChild(note);
            };

            /**
             * Hides this layer
             */
            this.hide = function() {
                this.container.visible = false;
            };

            /**
             * Shows this layer
             */
            this.show = function() {
                this.container.visible = true;
            };
        };

        return {
            NoteView: NoteView
        };
    });

define('controllers/noteController',['model/ugc/note', 'views/noteView', 'events', 'constants', 'resources', 'config', 'controllers/shifter', 'utils/tools'],
    function(note, noteView, events, constants, resources, config, shifter, tools) {

        /**
         * Class that controls the note level for a page
         * @constructor
         */
        var NoteController = function(pageNumber) {
            this.initialised = false;
            this.pageNumber = pageNumber;
            this.notes = [];
            this.noteView = new noteView.NoteView();
            this.minimumZIndex = 3000;
            this.maximumZIndex = 4000;
            this.currentZIndex = this.minimumZIndex + 1;

            this.populateNotes = function(notesOnThisPage, forceUpdate) {
                if (forceUpdate && this.initialised) {
                    // if we are reinitialising with new data, we need to remove all existing notes
                    this.removeAllNotesFromDom();
                }
                // if we are already initialised, and not forcing an update, do nothing
                if (!this.initialised || forceUpdate) {
                    this.createNotes(notesOnThisPage);
                }
                this.initialised = true;
            };

            this.deleteNote = function(note) {
                this.removeNote(note, true)
            };

            this.removeNote = function(note, deleteAndRemoveFromDom) {
                for (var i = 0 ; i < this.notes.length; i++) {
                    if ( this.notes[i].id == note.id) {
                        this.noteView.removeNote(this.notes[i].rect);
                        if (deleteAndRemoveFromDom) {
                            this.notes[i].removeDomElement(true);
                        }
                        break;
                    }
                }
            };

            this.removeAllNotesFromDom = function() {
                for (var i = 0 ; i < this.notes.length; i++) {
                    this.noteView.removeNote(this.notes[i].rect);
                    this.notes[i].removeDomElement(false);
                }
                this.notes = [];
            };

            this.addNote = function(note) {
                this.noteView.addNote(note.rect);
                this.notes.push(note);
                note.pageWidth = this.pageWidth;
                note.pageHeight = this.pageHeight;
            };

            this.moveNote = function(note, movePoint) {
                var noteWidth = $(note.domElement).width();
                var noteHeight = $(note.domElement).height();

                var maxX = this.pageWidth - noteWidth;
                var maxY = this.pageHeight - noteHeight;

                note.move(movePoint, maxX, maxY, noteWidth, noteHeight);
            };

            this.createNoteAtPoint = function(tapPoint) {
                var localPoint = this.getContainer().globalToLocal(tapPoint.x, tapPoint.y);
                var newNote = new note.Note(this.pageNumber, "", localPoint.x, localPoint.y);
                this.notes.push(newNote);
                this.noteView.addNote(newNote.init(true));
                this.setCurrentZIndex(newNote);
                return newNote;
            };

            this.createNotes = function(notesOnThisPage) {
                if (notesOnThisPage) {
                    notesOnThisPage = (notesOnThisPage instanceof Array) ? notesOnThisPage : [notesOnThisPage];
                    for (var i=0; i < notesOnThisPage.length; i++) {
                        var theNote = notesOnThisPage[i];
                        if (theNote.isDeleted) {
                            continue;
                        }
                        this.notes.push(theNote);
                        this.noteView.addNote(theNote.init(false));
                        if (theNote.zIndex > 0) {
                            this.assignCustomZIndex(theNote, theNote.zIndex);
                            this.currentZIndex = Math.max(theNote.zIndex + this.minimumZIndex + 1, this.currentZIndex);
                        } else {
                            this.setCurrentZIndex(theNote);
                        }
                    }
                }
            };

            /**
             * The following methods control the assignment of z indexes to notes
             *  z-indexes are assigned on note creation and note movement only
             *      allows static indexes to be assigned on creation
             *      means that moving a note between pages will not unduly increase the z-index counter
             * @param note - the note to be changed
             */
            /**
             * @param index - the new index to be given
             * use this method to assign to a note a custom index in one of the ranges:
             *      - 0 <= index < max-min (given priority)
             *      - min <= index < max
             *  if the specified index is outside these ranges, setCurrentZIndex will be called
             */
            this.assignCustomZIndex = function(note, index) {
                // if supplied index between limits of range of z indexes, use it directly
                var useableIndex = index;
                // if 0 <= index < "range of z indexes" then shift it into the range and use it
                //  note that since this overrides the default, this has priority should `max-min` > `min`
                if (index >= 0 && index < this.maximumZIndex - this.minimumZIndex) {
                    useableIndex = index + this.minimumZIndex;
                // otherwise, use a new index
                } else if (index < this.minimumZIndex || index > this.maximumZIndex) {
                    this.setCurrentZIndex(note, false);
                    return;
                }
                $(note.domElement).css('zIndex', useableIndex);
                note.zIndex = index;
            };

            /**
             * use this method to assign the highest z-index to a note
             *  should not be used directly for permanent z-index changes
             *  suggested direct-use case is only for note movement
             */
            this.assignCurrentZIndex = function(note) {
                $(note.domElement).css('zIndex', this.currentZIndex);
                note.zIndex = this.currentZIndex - this.minimumZIndex;
            };

            /**
             * use this method to assign the current-highest z-index to a note, and increase the tracker
             */
            this.setCurrentZIndex = function(note, ignoreReorder) {
                this.assignCurrentZIndex(note);
                this.currentZIndex++;
                if (!ignoreReorder) {
                    this.checkZIndexLimits();
                }
            };

            /**
             * call this method after increasing the z-index tracker
             *  if the tracker equals or goes above the maximum:
             *      - notes are reordered by z-index
             *      - note z-indexes are renumbered, compressing all free space between notes
             */
            this.checkZIndexLimits = function() {
                if (this.currentZIndex >= this.maximumZIndex) {
                    this.resetNotesCounter();
                }
            };

            this.resetNotesCounter = function() {
                this.currentZIndex = this.minimumZIndex + 1;
                var numberOfNotes = this.notes.length;
                this.reorderNotesByZIndex();
                for (var i = 0; i < numberOfNotes; i++) {
                    var thisNote = this.notes[i];
                    this.setCurrentZIndex(thisNote, true);
                }
            };

            this.reorderNotesByZIndex = function() {
                this.notes.sort(note.Note.zIndexComparator);
            };

            /**
             * Returns the container that the notes for this controller are rendered to
             * @returns {container}
             */
            this.getContainer = function() {
                return this.noteView.container;
            };

            /**
             * Given the zoom level we are currently at and the page we are on, scales the notes
             * to fit so that they appear in the correct places and at the correct sizes.
             * @param zoomLevel the model object for the zoom level we are currently at
             * @param page the model object for the page these notes are on
             */
            this.scaleNotes = function(zoomLevel, page) {
                var scaleX = zoomLevel.width / page.width;
                var scaleY = zoomLevel.height / page.height;

                this.getContainer().set({scaleX: scaleX, scaleY: scaleY});
            };

            this.handleTap = function(tapPoint) {
                for (var i = this.notes.length - 1; i >= 0; i--) {
                    if (this.notes[i].handleTap(tapPoint))
                        return true;
                }
                return false;
            };

            this.hide = function () {
            };

            this.setNotesHitArea = function(pageW, pageH) {
                this.pageWidth = pageW;
                this.pageHeight = pageH;
                for (var i = 0, l = this.getContainer().getNumChildren(); i < l; i++) {
                    var hit = new createjs.Shape();
                    var hitWidth = this.getContainer().mask ?
                        Math.min(this.notes[i].width, pageW - this.notes[i].x) :
                        this.notes[i].width;
                    var hitHeight = this.getContainer().mask ?
                        Math.min(this.notes[i].height, pageH - this.notes[i].y) :
                        this.notes[i].height;
                    hit.graphics.beginFill("#000").drawRect(this.notes[i].x, this.notes[i].y, hitWidth, hitHeight);
                    this.getContainer().getChildAt(i).hitArea = hit;
                }
            }
        };

        return {
            NoteController: NoteController
        };
    });

define('model/searchOverlay',['config', 'model/overlay'],
    function(config, overlay) {

        var SearchOverlay = function(x, y, width, height, id) {
            overlay.Overlay.call(this, x, y, width, height, undefined, undefined, undefined, id);

            this.rectColour = config.searchOverlayColour;

            /**
             * Inits the overlay by creating a visual representation, the hit area and binding some events.
             */
            this.init = function() {
                this.createRectAndHitArea();
                return this.rect;
            };
        };

        return {
            SearchOverlay: SearchOverlay
        };
    });

define('controllers/searchOverlayController',['model/searchOverlay', 'views/overlayView', 'constants'],
    function(searchOverlay, overlayView, constants) {

        /**
         * Class that controls an overlay level for a page
         * @constructor
         */
        var SearchOverlayController = function() {
            this.initialised = false;

            this.overlays = [];

            this.overlayView = new overlayView.OverlayView();

            this.init = function(positions) {
                for (var i = 0; i < positions.length; i++) {
                    var dimensions = positions[i].split(",");
                    var overlay = new searchOverlay.SearchOverlay(dimensions[0], dimensions[1], dimensions[2], dimensions[3]);
                    this.overlays.push(overlay);
                    this.overlayView.addOverlay(overlay.init());
                }
            };

            /**
             * Returns the container that the overlays for this controller are rendered to
             * @returns {container}
             */
            this.getContainer = function() {
                return this.overlayView.container;
            };

            /**
             * Given the zoom level we are currently at and the page we are on, scales the overlays
             * to fit so that they appear in the correct places and at the correct sizes.
             * @param zoomLevel the model object for the zoom level we are currently at
             * @param page the model object for the page these overlays are on
             */
            this.scaleOverlays = function(zoomLevel, page) {
                var scaleX = zoomLevel.width / page.width;
                var scaleY = zoomLevel.height / page.height;

                this.getContainer().set({scaleX: scaleX, scaleY: scaleY});
            };

            /**
             * Briefly flashes the overlays if they are not already being flashed
             */
            this.flashOverlays = function() {
                for (var i = 0; i < this.overlays.length; i++) {
                    this.overlays[i].flash(constants.pauseBeforeOverlayFlash);
                }
            };

        };

        return {
            SearchOverlayController: SearchOverlayController
        };
    });

define('controllers/pageController',['events', 'controllers/zoomLevelController', 'model/page', 'views/pageView', 'controllers/overlayController', 'controllers/pageHighlightsController',
        'controllers/noteController', 'controllers/searchOverlayController', 'fetching/fetchHandler', 'resources', 'utils/tools', 'config'],
    function(events, zoomLevelController, page, pageView, overlayController, pageHighlightsController, noteController, searchOverlayController, fetchHandler, resources, tools, config) {

        /**
         * Class that controls a page (that it creates).
         * @param number the page number.
         * @param pageInfo an object containing information about the page.
         * @param zoomSettings an array of objects that contain tile dimensions for the zoom levels to be created.
         * @constructor
         */
        var PageController = function(number, pageInfo, zoomSettings) {
            //indicate that we are not yet initialised
            this.initialised = false;

            this.encrypted = pageInfo.isEnc;
            this.pageInfo = pageInfo;

            this.zoomSettings = zoomSettings;

            this.z = -1;

            /**
             * Creates the page view, event manager and zoom levels (lazily).
             */
            this.init = function() {
                //set this as soon as init is called so that it is not called multiple times
                this.initialised = true;

                //create the page view
                this.pageView = new pageView.PageView();

                this.zoomLevels = [];
                this.zoomLevelCount = 0;
                this.shouldFlashOverlaysOnLoaded = false;

                this.createSkeletonZoomLevels(this.zoomSettings, this.getPageInfo().zooms);

                this.mask = new createjs.Shape();
                this.mask.graphics.beginFill("#000").drawRect(0, 0, this.page.width, this.page.height);

                this.overlayLevel = new overlayController.OverlayController(this.page.number);
                this.overlayLevel.init(this.getPageInfo().ols);
                this.overlayLevel.getContainer().mask = this.mask;
                this.overlayLevel.setOverlaysHitArea(this.page.width, this.page.height);

                if (config.highlightsEnabled) {
                    this.pageHighlightsLevel= new pageHighlightsController.PageHighlightsController(this.page.number);
                    this.pageHighlightsLevel.getContainer().mask = this.mask;
                    this.pageHighlightsLevel.setHitArea(this.page.width, this.page.height);
                }

                if (config.notesEnabled) {
                    this.noteLevel = new noteController.NoteController(this.page.number);
                    this.noteLevel.getContainer().mask = this.mask;
                    this.noteLevel.setNotesHitArea(this.page.width, this.page.height);
                }

                events.subscribe(events.ALL, events.ZOOMLEVEL_TILESLOADED, events.callback(this, this.zoomLevelLoadedImages), false);
            };

            this.setUpNotes = function(notes, forceUpdate) {
                this.noteLevel.populateNotes(notes, forceUpdate);
            };

            this.decrypt = function(key) {
                if(!this.pageInfo.isEnc)
                    return;

                var newPageInfo;

                try {
                    newPageInfo = tools.decryptJson(this.pageInfo, key);
                }
                catch (e) {
                    // TODO: We should probably add some kind of error message here.
                    // Task for the future: steal the modal code from the Wrapper code
                    return;
                }

                if (!newPageInfo)
                    return;

                this.encrypted = false;
                this.pageInfo = newPageInfo;
                this.page = new page.Page(this.page.number, this.pageInfo.label, this.pageInfo.w, this.pageInfo.h, this.pageInfo.folder, this.pageInfo.pattern);
                config.pageDecrypted = true;

                this.initialised = false;
                events.unsubscribe(events.ALL, events.ZOOMLEVEL_TILESLOADED);
                events.unsubscribe(events.ALL, events.DECRYPT_ALL_PAGES, this.decryptionCallback, true);
                events.emit(yudu_events.ALL, yudu_events.THUMBNAILS.UPDATE_THUMBNAIL, this, {pageNumber: this.page.number});
                events.emit(events.ALL, events.PAGE_DECRYPTED, this, {});
            };

            this.decryptionCallback = events.callback(this, function(event) {this.decrypt(event.data.key)});

            this.getPageInfo = function() {
                if(this.pageInfo.isEnc) {
                    return resources.yuduBook.settings.placeHolderPage;
                }
                return this.pageInfo;
            };

            /**
             * Create the zoom levels for this page.
             * Only the base zoom level controller objects are created, they will be initialised lazily. However,
             * the zoom level defined by this.z will be initialised and loaded.
             * @param zoomSettings
             * @param zooms an array of objects containing information about each zoom level.
             */
            this.createSkeletonZoomLevels = function(zoomSettings, zooms) {
                //loop over the zooms array creating the base zoom level controller objects
                for (var i = 0; i < zooms.length; i++) {
                    var newZoomLevelController = new zoomLevelController.ZoomLevelController(i, zoomSettings[i], zooms[i], this.page.baseURL, this.page.filePattern, this.page.number);
                    this.zoomLevels.push(newZoomLevelController);
                }
                this.zoomLevelCount = zooms.length;
            };

            this.unloadAllTiles = function() {
                if (!this.initialised)
                    return;

                var unloadedTiles = 0;
                for (var i = 0, m = this.zoomLevels.length ; i < m ; i++ ) {
                    unloadedTiles += this.zoomLevels[i].unload();
                }

                this.pageView.container.removeAllChildren();

                return unloadedTiles;
            };

            /**
             * Initialises the zoom level at zoom z.
             * Note that the zoom level is not loaded, this is left to the caller to manage.
             * @param z The zoom level to initialise.
             */
            this.createZoomLevel = function(z) {
                var controller = this.zoomLevels[z];
                controller.init();
                controller.hide();
                this.pageView.container.addChild(controller.getContainer());
            };

            this.triggerShow = function() {
                this.overlaysPageReadyWhenNextLoaded();

                if (fetchHandler.isFullyLoaded(this.page.number, this.z)) {
                    this.overlaysPageReady();
                }
            };

            this.overlaysPageReadyWhenNextLoaded = function() {
                this.shouldFlashOverlaysOnLoaded = true;
            };

            this.overlaysPageReady = function() {
                this.shouldFlashOverlaysOnLoaded = false;
                this.overlayLevel.pageReady();
                this.flashSearchOverlays();
            };

            this.updatePageHighlightsContainer = function(pageHighlight, forceUpdate) {
                this.pageHighlightsLevel.updateHighlightsContainer(pageHighlight, forceUpdate);
            };

            this.zoomLevelLoadedImages = function(event) {
                if (!this.shouldFlashOverlaysOnLoaded)
                    return;
                if (!this.pageView.isShowing())
                    return;
                if (this.z != event.data.z)
                    return;
                if (this.page.number != event.data.pageNumber)
                    return;

                this.overlaysPageReady();
            };

            /**
             * Returns this page's number.
             * Note this returns the "index" not the "number" and as such it will be 0-indexed across all pages,
             *  If present, the intro page will always be index 0
             * @returns {number}
             */
            this.getPageNumber = function() {
                return this.page.number;
            };

            this.isIntroPage = function() {
                return config.hasIntroPage && this.getPageNumber() == 0;
            };

            /**
             * Returns this page's label.
             * @returns {string}
             */
            this.getPageLabel = function() {
                return this.page.label;
            };

            /**
             * Returns this page's width.
             * @returns {int}
             */
            this.getPageWidth = function() {
                return this.page.width;
            };

            /**
             * Returns this page's height.
             * @returns {int}
             */
            this.getPageHeight = function() {
                return this.page.height;
            };

            /**
             * Returns whether this page is encrypted.
             * @returns {boolean}
             */
            this.isPageEncrypted = function() {
                return this.encrypted;
            };

            this.setAlignment = function(alignment) {
                for (var i = 0, m = this.zoomLevels.length; i < m; i++) {
                    this.zoomLevels[i].setAlignment(alignment);
                }
            };

            this.resetAlignments = function(alignment) {
                this.setAlignment(alignment);
                this.getContainer().resetPosition();
            };

            this.getContainer = function() {
                return this.pageView.container;
            };

            this.prepareZoomLevel = function(newZ) {
                var newLevel = this.zoomLevels[newZ];
                if (!newLevel.initialised) {
                    this.createZoomLevel(newZ);
                }
            };

            this.endZoomOn = function(newZ) {
                var overlayContainer = this.overlayLevel.getContainer();
                if (this.pageHighlightsLevel) {
                    var highlightsContainer = this.pageHighlightsLevel.getContainer();
                }
                if (this.noteLevel) {
                    var noteContainer = this.noteLevel.getContainer();
                }
                if (this.searchOverlayLevel) {
                    var searchOverlayContainer = this.searchOverlayLevel.getContainer();
                }
                var newLevel = this.zoomLevels[newZ];

                if (this.z >= 0) {
                    var curLevel = this.zoomLevels[this.z];
                    if (curLevel.initialised) {
                        curLevel.hide();
                        curLevel.getContainer().removeChild(overlayContainer);
                        if (highlightsContainer) {
                            curLevel.getContainer().removeChild(highlightsContainer);
                        }
                        if (noteContainer) {
                            curLevel.getContainer().removeChild(noteContainer);
                        }
                        if (searchOverlayContainer) {
                            curLevel.getContainer().removeChild(searchOverlayContainer);
                        }
                    }
                }

                this.z = newZ;

                if (!newLevel.initialised) {
                    this.createZoomLevel(newZ);
                }

                newLevel.getContainer().addChild(overlayContainer);
                if (highlightsContainer) {
                    newLevel.getContainer().addChild(highlightsContainer);
                }
                if (noteContainer) {
                    newLevel.getContainer().addChild(noteContainer);
                }
                if (searchOverlayContainer) {
                    newLevel.getContainer().addChild(searchOverlayContainer);
                }
                newLevel.show();

                this.overlayLevel.scaleOverlays(newLevel.zoomLevel, this.page);
                if (this.pageHighlightsLevel) {
                    this.pageHighlightsLevel.scaleHighlights(newLevel.zoomLevel, this.page);
                }
                if (this.noteLevel) {
                    this.noteLevel.scaleNotes(newLevel.zoomLevel, this.page);
                }
                if (this.searchOverlayLevel) {
                    this.searchOverlayLevel.scaleOverlays(newLevel.zoomLevel, this.page);
                }
                this.mask.set({scaleX: this.overlayLevel.getContainer().scaleX, scaleY: this.overlayLevel.getContainer().scaleY});
            };

            this.deleteNote = function(note) {
                this.noteLevel.deleteNote(note)
            };

            this.canCreateNoteAt = function(tapPoint) {
                return !(this.isIntroPage());
            };

            this.noteIsWithinPageBounds = function(tapPoint) {
                var bounds = this.pageView.container.getBounds();
                var lowerBound = this.pageView.container.localToGlobal(bounds.x, bounds.y);
                if (this.noteLevel.getContainer().mask) {
                    upperBound = this.pageView.container.localToGlobal(bounds.x + this.zoomLevels[this.z].zoomLevel.width, bounds.y + this.zoomLevels[this.z].zoomLevel.height);
                } else {
                    var upperBound = this.pageView.container.localToGlobal(bounds.x + bounds.width, bounds.y + bounds.height);
                }

                if (tapPoint.x < lowerBound.x
                    || tapPoint.y < lowerBound.y
                    || tapPoint.x > upperBound.x
                    || tapPoint.y > upperBound.y) {
                    return false;
                }

                return true;
            };

            this.canDragNoteTo = function(tapPoint) {
                return this.canCreateNoteAt(tapPoint) && this.noteIsWithinPageBounds(tapPoint);
            };

            this.handleTap = function(tapPoint) {
                var bounds = this.pageView.container.getBounds();
                var lowerBound = this.pageView.container.localToGlobal(bounds.x, bounds.y);
                var upperBound = this.pageView.container.localToGlobal(bounds.x + bounds.width, bounds.y + bounds.height);

                if(this.encrypted) {
                    if (tapPoint.x > lowerBound.x
                        && tapPoint.y > lowerBound.y
                        && tapPoint.x < upperBound.x
                        && tapPoint.y < upperBound.y) {

                        //show login popup
                        events.emit(events.ALL, events.SHOW_LOGIN, this, {});
                        return true;
                    }
                }

                if (this.overlayLevel.getContainer().mask) {
                    lowerBound = this.pageView.container.localToGlobal(bounds.x, bounds.y);
                    upperBound = this.pageView.container.localToGlobal(bounds.x + this.zoomLevels[this.z].zoomLevel.width, bounds.y + this.zoomLevels[this.z].zoomLevel.height);
                }
                if (tapPoint.x < lowerBound.x
                    || tapPoint.y < lowerBound.y
                    || tapPoint.x > upperBound.x
                    || tapPoint.y > upperBound.y) {
                    return false;
                }

                if (this.overlayLevel)
                    return this.overlayLevel.handleTap(tapPoint);
                return false;
            };

            //create the backing model object
            this.page = new page.Page(number, this.getPageInfo().label, this.getPageInfo().w, this.getPageInfo().h, this.getPageInfo().folder, this.getPageInfo().pattern);

            this.createSearchOverlayLevel = function(positions) {
                this.searchOverlayLevel = new searchOverlayController.SearchOverlayController();
                this.searchOverlayLevel.init(positions);
                if (this.zoomLevels && this.z >= 0) {
                    this.zoomLevels[this.z].getContainer().addChild(this.searchOverlayLevel.getContainer());
                    this.searchOverlayLevel.scaleOverlays(this.zoomLevels[this.z].zoomLevel, this.page);
                }
            };

            this.removeSearchOverlayLevel = function() {
                if (this.searchOverlayLevel && this.zoomLevels && this.z >= 0) {
                    this.zoomLevels[this.z].getContainer().removeChild(this.searchOverlayLevel.getContainer());
                }
                this.searchOverlayLevel = false;
            };

            this.flashSearchOverlays = function() {
                if (this.searchOverlayLevel) {
                    this.searchOverlayLevel.flashOverlays();
                }
            };

            if (this.encrypted) {
                events.subscribe(events.ALL, events.DECRYPT_ALL_PAGES, this.decryptionCallback, true);
            }
        };

        return {
            PageController: PageController
        };
    });

define('model/ugc/bookmark',[],
    function() {
        var Bookmark = function(pageNumber, isBookmarked, lastModified, lastSynced) {
            this.pageNumber = pageNumber;
            this.isDeleted = !isBookmarked;
            this.lastModified = lastModified || new Date().getTime();
            this.lastSynced = lastSynced || 0;

            this.id = function() {
                return this.pageNumber;
            };

            this.deleteItem = function() {
                this.isDeleted = true;
                this.touch();
            };

            this.unDeleteItem = function() {
                this.isDeleted = false;
                this.touch();
            };

            this.isSynced = function() {
                return this.lastModified <= this.lastSynced;
            };

            this.touch = function() {
                this.lastModified = new Date().getTime();
            };

            this.getWriteableObject = function() {
                return {
                    pageNumber: this.pageNumber,
                    isDeleted: this.isDeleted,
                    lastModified: this.lastModified,
                    lastSynced: this.lastSynced
                };
            };
        };

        return {
            Bookmark: Bookmark
        };
    });

define('ui/bookmarks',['jquery', 'events', 'config', 'shared/ui/messageBox', 'model/ugc/bookmark'],
    function ($, events, config, messageBox, bookmark) {
        var reader;
        var leftPageNumber;
        var leftPageBookmarked;
        var rightPageNumber;
        var rightPageBookmarked;
        var isTwoUpMode;
        var bookmarks = {};

        var EMITTER_NAME = "bookmarks";

        var init = function(retrievedBookmarks) {
            isTwoUpMode = config.twoPageMode;
            setBookmarks(retrievedBookmarks);
            events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, updatePages));
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, events.callback(this, twoUpChanged));
            events.subscribe(events.ALL, yudu_events.TOOLBAR.LOADED, events.callback(this, updatePages));
        };

        /**
         * Allows reinitialisation of the bookmarks data, as well as ensuring those visible are updated properly
         * @param retrievedBookmarks ; JSON/hash of stringified bookmarks
         * @param parameters ; hash of additional parameters serving as advanced options for the reinitialisation
         */
        var reinit = function(retrievedBookmarks, parameters) {
            if (parameters.reset) {
                resetBookmarks();
            }
            setBookmarks(retrievedBookmarks);
            updatePages();
            if (!parameters.reset) {
                emitBookmarksChangedEvent(true);
            }
        };

        var resetBookmarks = function() {
            bookmarks = {};
        };

        /**
         * Given a hash containing JSON-stringified bookmarks, keyed by page,
         *  this method populates a local hash of `Bookmark`s representing deserialised bookmarks
         * For any given page-key, input bookmarks will override any existing bookmark,
         *  provided the existing bookmark was not modified more recently than the input bookmark
         * Otherwise, or for any existing page-key not in the newly-received dataset, the bookmark will be preserved
         * @param retrievedBookmarks
         */
        var setBookmarks = function(retrievedBookmarks) {
            for (var property in retrievedBookmarks) {
                if (retrievedBookmarks.hasOwnProperty(property)) {
                    var bookmarkData = JSON.parse(retrievedBookmarks[property]);
                    if (!!bookmarks[property] &&
                            bookmarks[property].lastModified > bookmarkData.lastModified) {
                        // conflict between remote bookmark and local bookmark: keep the most recently modified
                        continue;
                    }
                    bookmarks[property] = new bookmark.Bookmark(bookmarkData.pageNumber, !bookmarkData.isDeleted,
                            bookmarkData.lastModified, bookmarkData.lastSynced);
                }
            }
        };

        var pageHasBookmark = function(pageIndex) {
            return bookmarks && bookmarks[pageIndex] && !bookmarks[pageIndex].isDeleted;
        };

        var toggleBookmark = function() {
            var currentBookmarkState = bookmarkIconStatus();

            if (currentBookmarkState) {
                leftPageBookmarked = false;
                if (bookmarks[leftPageNumber]) {
                    bookmarks[leftPageNumber].deleteItem();
                } else {
                    bookmarks[leftPageNumber] = new bookmark.Bookmark(leftPageNumber, false);
                }
                if (isTwoUpMode) {
                    rightPageBookmarked = false;
                    if (bookmarks[rightPageNumber]) {
                        bookmarks[rightPageNumber].deleteItem();
                    } else {
                        bookmarks[rightPageNumber] = new bookmark.Bookmark(rightPageNumber, false);
                    }
                }
            } else {
                var pageToUndelete;
                if (leftPageNumber == 0 && config.hasIntroPage) {
                    if (isTwoUpMode) {
                        rightPageBookmarked = true;
                        pageToUndelete = rightPageNumber;
                    } else {
                        // only the intro page is visible, which cannot be bookmarked
                        messageBox.displayByCode('bookmarks.introPageWarning');
                        return;
                    }
                } else {
                    leftPageBookmarked = true;
                    pageToUndelete = leftPageNumber;
                }
                if (bookmarks[pageToUndelete]) {
                    bookmarks[pageToUndelete].unDeleteItem();
                } else {
                    bookmarks[pageToUndelete] = new bookmark.Bookmark(pageToUndelete, true);
                }
            }

            emitBookmarksChangedEvent(false);
            updateBookmarkButton();
        };

        var emitBookmarksChangedEvent = function(fromSync) {
            events.emit(EMITTER_NAME, events.UGC_CHANGED, this, {bookmarks: bookmarks, fromSync: fromSync});
        };

        var twoUpChanged = function(event) {
            isTwoUpMode = config.twoPageMode;
            updatePages(event);
        };

        var updatePages = function(event) {
            leftPageNumber = reader.shifter.getCentreTray().pages[0].page.number;
            leftPageBookmarked = bookmarks[leftPageNumber] && !bookmarks[leftPageNumber].isDeleted;

            var rightPage = reader.shifter.getCentreTray().pages[1];
            if (isTwoUpMode && rightPage) {
                rightPageNumber = rightPage.page.number;
                rightPageBookmarked = bookmarks[rightPageNumber] && !bookmarks[rightPageNumber].isDeleted;
            }

            updateBookmarkButton();
        };

        var updateBookmarkButton = function() {
            if (window.yudu_commonSettings.toolbarLoaded)
                emitUpdateEvent();
            else
                events.subscribe(events.ALL, yudu_events.TOOLBAR.LOADED, function() {
                    emitUpdateEvent();
                });
        };

        var emitUpdateEvent = function() {
            events.emit(EMITTER_NAME, yudu_events.TOOLBAR.UPDATE_BOOKMARK_BUTTON, this, { bookmarkOn : bookmarkIconStatus() });
        };

        var bookmarkIconStatus = function() {
            return leftPageBookmarked || (isTwoUpMode && rightPageBookmarked);
        };

    return {
            init: init,
            reinit: reinit,
            pageHasBookmark: pageHasBookmark,
            setReader: events.callback(this, function(aReader) { reader = aReader; }),
            toggleBookmark: toggleBookmark,
            updatePages: updatePages,
            twoUpChanged: twoUpChanged,
            bookmarkIconStatus: bookmarkIconStatus,
            updateBookmarkButton: updateBookmarkButton,
            EMITTER_NAME: EMITTER_NAME
        };
    });
/*
 Loading screen - a div that is visible by default but gets hidden when the page is loaded,
 with a progress check on how many tiles are loaded.
 */
define('ui/loading',['api', 'events', 'config', 'constants', 'resources', 'shared/localisation', 'jquery'],
    function(api, events, config, constants, resources, localisation, $) {

        var EMITTER_NAME = "loading";

        var element = $('#yudu_backgroundLoadCover');
        var tilesLoaded = 0;
        var pagesToLoad = [];
        var numberOfPages = 1;

        /**
         * Initialises the loading screen
         */
        var init = function(startPage, totalPages) {
            makeSettingsAvailableForBrandableLoading();
            makeFunctionsAvailableForBrandableLoading();
            element.append(resources.loadingHtml);
            window.yudu_commonFunctions.injectJavascript(
                constants.baseResourcesFolder + resources.loadingConfig.mainJavascriptFilePath);
            localisation.localiseHtml(element);

            $('#yudu_loadThrobber').remove();

            //subscribe to events
            events.subscribe(events.ALL, events.TILE_FETCHED, handleTileDownloaded);
            events.subscribe(events.ALL, events.ZOOMLEVEL_TILESLOADED, handlePageLoaded);

            pagesToLoad.push(startPage);
            if (config.twoPageMode && (!config.hasIntroPage && startPage > 0) && startPage < totalPages - 1) {
                pagesToLoad.push(startPage + (startPage % 2 ? 1 : -1));
            }

            numberOfPages = pagesToLoad.length;
        };

        var makeSettingsAvailableForBrandableLoading = function(){
            var settings = resources.yuduBook.settings;
            window.yudu_loadingSettings = {
                bgTopColour: config.bgTopColour,
                bgBottomColour: config.bgBottomColour,
                loadingString: localisation.get("loading.tiles"),
                lastProgressReport: 0,
                loaded: false
            };
        };

        var makeFunctionsAvailableForBrandableLoading = function(){
            window.yudu_loadingFunctions = {
                setGradientBackground: setLoadingBackground,
                fadeLoadingScreen: fadeLoadingScreen
            };
        };

        var setLoadingBackground = function (jqueryElement, settings) {
            if (!settings.bgTopColour || !settings.bgBottomColour) {
                return;
            }
            jqueryElement[0].style.background = '#' + settings.bgTopColour;
            jqueryElement[0].style.background = "-webkit-gradient(linear, left top, left bottom, color-stop(0%, #" + settings.bgTopColour + "), color-stop(100%, #" + settings.bgBottomColour + "))";
            jqueryElement[0].style.background = "-webkit-linear-gradient(top, #" + settings.bgTopColour + ",#" + settings.bgBottomColour + ")";
            jqueryElement[0].style.background = "-o-linear-gradient(top, #" + settings.bgTopColour + ",#" + settings.bgBottomColour + ")";
            jqueryElement[0].style.background = "-moz-linear-gradient(top, #" + settings.bgTopColour + ",#" + settings.bgBottomColour + ")";
            jqueryElement[0].style.background = "-ms-linear-gradient(top, #" + settings.bgTopColour + ",#" + settings.bgBottomColour + ")";
            jqueryElement[0].style.background = "linear-gradient(to bottom, #" + settings.bgTopColour + ",#" + settings.bgBottomColour + ")";
        };

        var fadeLoadingScreen = function(fadeLoadingScreenDuration){
            element.fadeOut(fadeLoadingScreenDuration);
        };

        /**
         * Increment tile download progress
         * @param event
         */
        var handleTileDownloaded = function(event) {
            tilesLoaded++;

            var percentage = Math.min(tilesLoaded / event.data.numTiles * 100 / numberOfPages, 100);
            events.emit(yudu_events.ALL, yudu_events.LOADING.DISPLAY_PROGRESS, this, {percentage: percentage});
            yudu_loadingSettings.lastProgressReport = percentage;
        };

        /**
         * If the page is one we are waiting for then removes it from the list
         * If the list is now empty then hides the loading screen
         * Adds flags to the branding API in case the script has not registered listeners yet
         * @param event
         */
        var handlePageLoaded = function(event) {
            var index = $.inArray(event.data.pageNumber, pagesToLoad);
            if (index >= 0) {
                pagesToLoad.splice(index, 1);
            }
            if(pagesToLoad.length == 0) {
                events.emit(yudu_events.ALL, yudu_events.LOADING.DISPLAY_PROGRESS, this, {percentage: 100});
                yudu_loadingSettings.lastProgressReport = 100;
                events.emit(yudu_events.ALL, yudu_events.LOADING.END_LOADING);
                yudu_loadingSettings.loaded = true;
                unsubscribeFromEvents();
            }
        };

        /**
         * Unsubscribes from the loading events
         */
        var unsubscribeFromEvents = function() {
            events.emit(EMITTER_NAME, events.LOADING_FINISHED, this, {});
            events.unsubscribe(events.ALL, events.TILE_FETCHED, handleTileDownloaded);
            events.unsubscribe(events.ALL, events.ZOOMLEVEL_TILESLOADED, handlePageLoaded);
        };

        return {
            init: init
        };

    });

define('utils/userOptions',['shared/storage'],
    function(storage) {

        var OPTIONS = {
            NO_SHOW_INFORMATION: "noShoddInfoBox",
            NO_SHOW_NOTE_MESSAGE: "noShowNoteMessage",
            NO_SHOW_BOOKMARK_MESSAGE: "noShowBookmarkMessage"
        };

        var shouldShowInformationBox = function() {
            return !storage.getItem(OPTIONS.NO_SHOW_INFORMATION);
        };

        var setNoShowInformationBox = function() {
            storage.setItem(OPTIONS.NO_SHOW_INFORMATION, true);
        };

        var shouldShowNoteInfoBox = function() {
            return !storage.getItem(OPTIONS.NO_SHOW_NOTE_MESSAGE);
        };

        var setNoShowNoteInfoBox = function() {
            storage.setItem(OPTIONS.NO_SHOW_NOTE_MESSAGE, true);
        };

        var shouldShowBookmarkInfoBox = function() {
            return !storage.getItem(OPTIONS.NO_SHOW_BOOKMARK_MESSAGE);
        };

        var setNoShowBookmarkInfoBox = function() {
            storage.setItem(OPTIONS.NO_SHOW_BOOKMARK_MESSAGE, true);
        };

        return {
            shouldShowInformationBox: shouldShowInformationBox,
            setNoShowInformationBox: setNoShowInformationBox,
            shouldShowNoteInfoBox: shouldShowNoteInfoBox,
            setNoShowNoteInfoBox: setNoShowNoteInfoBox,
            shouldShowBookmarkInfoBox: shouldShowBookmarkInfoBox,
            setNoShowBookmarkInfoBox: setNoShowBookmarkInfoBox
        };
});
define('ui/notes',[ 'config', 'events', 'interactions','model/ugc/note', 'controllers/shifter',  'shared/ui/messageBox',
        'shared/localisation', 'utils/userOptions','shared/hammerManager', 'jquery', 'jquery.hammer' ],
    function ( config, events, interactions, note, shifter, messageBox,
               localisation, userOptions, hammerManager, $) {
        var EMITTER_NAME = 'notes';

        var background = $("#yudu_noteBackground");
        var notesParent = $('#yudu_notes');
        var readerDiv = $('#yudu_reader');
        var closeButton = $("#yudu_noteCloseButton");
        var noteContainer = $("#yudu_noteContainer");
        var noteText = $("#yudu_noteText");
        var clippingContainer = $("#yudu_clippingContainer");
        var clippingImage = $("#yudu_clippingImage");

        var buttons = {
            editCancelButton: $("#yudu_editNoteCancelButton"),
            editOkButton: $("#yudu_editNoteOkButton"),
            viewDeleteButton: $("#yudu_viewNoteDeleteButton"),
            viewBrowseButton: $("#yudu_viewNoteBrowseButton"),
            viewOkButton: $("#yudu_viewNoteOkButton")
        };

        var currentlyViewedNote = null;
        var currentlyDraggedNote = null;
        var currentNoteIsNew = false;
        var leftPage;
        var rightPage;
        var backgroundHammerContext;
        var noteContainerHammerContext;
        var notes = {}; // hash of all notes in the edition, keyed by note ID
        var savedNotes = {}; // hash of arrays of notes on each page, keyed by page number
        var pagesNeedingUpdates = {}; // hash of booleans determining if a page needs an update, keyed by page number
        var noteContainerBaseHeight = false;
        var totalNumberOfNotes = 0;

        var init = function(retrievedNotes) {
            setupNotes(retrievedNotes);
            addEventListeners();
            backgroundHammerContext = background.hammer({transform_always_block: true});
            noteContainerHammerContext = notesParent.hammer({transform_always_block: true});

            events.subscribe(note.EMITTER_NAME, events.VIEW_NOTE, events.callback(this, handleViewNoteRequest));
            events.subscribe(note.EMITTER_NAME, events.NOTE_DRAG_START, events.callback(this, setupNoteDrag));
            events.subscribe(events.ALL, events.PAGE_CHANGED, updateCurrentPages);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, updateCurrentPages);
            events.subscribe(events.ALL, events.LOGIN_SUCCESS, updateCurrentPages);
            events.subscribe(events.ALL, events.RESIZE, events.callback(this, positionNote));

            updateCurrentPages();
        };

        /**
         * Allows reinitialisation of the notes data, as well as ensuring those visible are updated properly
         * @param retrievedNotes ; JSON/hash of stringified notes
         * @param parameters ; hash of additional parameters serving as advanced options for the reinitialisation
         */
        var reinit = function(retrievedNotes, parameters) {
            if (parameters.reset) {
                resetNotes();
            }
            setupNotes(retrievedNotes);
            updateCurrentPages();
            if (!parameters.reset) {
                emitNotesChangedEvent(true);
            }
        };

        var resetNotes = function() {
            notes = {};
            savedNotes = {};
            totalNumberOfNotes = 0;
            for (var i = 0, m = reader.shifter.getNumberOfPages(); i < m; i += 1) {
                pagesNeedingUpdates[i] = true;
            }
        };

        /**
         * Given a hash containing JSON-stringified notes, keyed by note ID,
         *  this method populates a local hash of `Note`s representing deserialised notes
         * For any given UID-key, input notes will override any existing note of the same ID,
         *  provided the existing note was not modified more recently than the input note
         *  and record that the page needs updating (potentially multiple times per page)
         * Otherwise, or for any existing UID-key not in the newly-received dataset, the note will be preserved
         * @param retrievedNotes
         */
        var setupNotes = function(retrievedNotes) {
            for (var property in retrievedNotes) {
                if (retrievedNotes.hasOwnProperty(property)) {
                    var retrievedNoteData = JSON.parse(retrievedNotes[property]);
                    var existingNote = notes[retrievedNoteData.id];
                    if (!!existingNote && existingNote.lastModified > retrievedNoteData.lastModified) {
                        // conflict between remote note and local note: keep the most recently modified
                        continue;
                    }
                    if (retrievedNoteData.isDeleted) {
                        handleDeletedNote(retrievedNoteData, true);
                    } else {
                        handleNewOrUpdatedNote(retrievedNoteData);
                    }
                }
            }
        };

        var handleDeletedNote = function(noteData, alsoDeleteFromEdition) {
            var currentNote = notes[noteData.id];
            // if we already know about this note, we need to make sure we delete it locally
            if (!!currentNote) {
                var currentNotePage = currentNote.pageNumber;
                var notesFromPage = savedNotes[currentNotePage];
                if (notesFromPage && notesFromPage.length) {
                    for (var i = 0, m = notesFromPage.length; i < m; i += 1) {
                        var noteFromSamePage = notesFromPage[i];
                        if (noteFromSamePage.id == currentNote.id) {
                            if (notesFromPage.length == 1) {
                                delete savedNotes[currentNotePage];
                            } else {
                                notesFromPage.splice(i, 1);
                            }
                            pagesNeedingUpdates[currentNotePage] = true;
                            break;
                        }
                    }
                }
                if (alsoDeleteFromEdition) {
                    delete notes[noteData.id];
                }
                totalNumberOfNotes--;
            }
        };

        var handleNewOrUpdatedNote = function(noteData) {
            var noteInNewState = new note.Note(noteData.pageNumber, noteData.text,
                    noteData.locationX, noteData.locationY, noteData.zIndex,
                    noteData.clipping, noteData.id, noteData.lastModified, false);
            // if the note is already on-page, the easiest way to ensure it is updated correctly is to remove it from
            //  the hash of notes by pages, and add the updated note as if new (moves between pages then come for free)
            handleDeletedNote(noteData, false);
            addNoteInternal(noteInNewState);
            pagesNeedingUpdates[noteInNewState.pageNumber] = true;
            totalNumberOfNotes++;
        };

        var pageHasNote = function(pageIndex) {
            return savedNotes && savedNotes[pageIndex] && savedNotes[pageIndex].length > 0;
        };

        var addNoteInternal = function(noteToAdd) {
            var notePageNumber = noteToAdd.pageNumber;
            if (savedNotes.hasOwnProperty(notePageNumber)) {
                savedNotes[notePageNumber].push(noteToAdd);
            } else {
                savedNotes[notePageNumber] = [noteToAdd];
            }
            notes[noteToAdd.id] = noteToAdd;
        };

        var removeNoteInternal = function(noteToRemove) {
            var notePageNumber = noteToRemove.pageNumber;
            var notesOnPage = savedNotes[notePageNumber];
            if (notesOnPage.length < 2) {
                delete savedNotes[notePageNumber];
            } else {
                notesOnPage.splice(notesOnPage.indexOf(noteToRemove), 1);
            }
        };

        var updateCurrentPages = function(event) {
            leftPage = reader.shifter.getCentreTray().pages[0];
            // Do not display UGC on encrypted pages
            if (!leftPage.encrypted) {
                var leftPageNumber = leftPage.page.number;
                leftPage.setUpNotes(savedNotes[leftPageNumber], !!pagesNeedingUpdates[leftPageNumber]);
                pagesNeedingUpdates[leftPageNumber] = false;
            }

            rightPage = reader.shifter.getCentreTray().pages[1];
            if (rightPage && !rightPage.encrypted) {
                var rightPageNumber = rightPage.page.number;
                rightPage.setUpNotes(savedNotes[rightPageNumber], !!pagesNeedingUpdates[rightPageNumber]);
                pagesNeedingUpdates[rightPageNumber] = false;
            }
        };

        var addEventListeners = function() {
            var closeNoteManager = hammerManager.createTapManager(closeButton[0]);
            closeNoteManager.on('tap', hideNotesMode);
            var editCancelManager = hammerManager.createTapManager(buttons.editCancelButton[0]);
            editCancelManager.on('tap', cancelEditClicked);
            var editOkManager = hammerManager.createTapManager(buttons.editOkButton[0]);
            editOkManager.on('tap', okEditClicked);
            var viewDeleteManager = hammerManager.createTapManager(buttons.viewDeleteButton[0]);
            viewDeleteManager.on('tap', deleteNoteButtonClicked);
            var viewBrowseManager = hammerManager.createTapManager(buttons.viewBrowseButton[0]);
            viewBrowseManager.on('tap', browseNoteClicked);
            var viewOkManager = hammerManager.createTapManager(buttons.viewOkButton[0]);
            viewOkManager.on('tap', okClicked);

            //Fix for horrible IE touch text area focus bug!
            events.yuduOn(noteText, config.clickAction, function() {
                background.focus();
                noteText.focus();
            });
        };

        var showNotesCreationMode = function() {
            if (reader.isShowingEncryptedPage()) {
                return;
            }
            interactions.setAllowKeyNavigation(false);
            events.yuduOn(backgroundHammerContext, 'tap', checkTapPointForValidNotePosition);
            background.addClass('yudu_createNote');
            noteContainer.addClass('yudu_dirtyNote');
            background.show();
        };

        var hideNotesMode = function() {
            currentlyViewedNote = null;
            backgroundHammerContext.off('tap', checkTapPointForValidNotePosition);
            interactions.setAllowKeyNavigation(true);
            background.hide();
            if (currentNoteIsNew && userOptions.shouldShowNoteInfoBox()) {
                messageBox.displayByCode('note.firstNoteCreated');
                userOptions.setNoShowNoteInfoBox();
            }
        };

        var checkTapPointForValidNotePosition = function(event) {
            //get the coordinates of the tap
            var tapPoint = {
                x: event.gesture.center.pageX * config.pixelDensity,
                y: (event.gesture.center.pageY - config.readerYOffset) * config.pixelDensity
            };

            var newNote = null;
            if (leftPage.noteIsWithinPageBounds(tapPoint)) {
                if (leftPage.canCreateNoteAt(tapPoint)) {
                    newNote = leftPage.noteLevel.createNoteAtPoint(tapPoint);
                } else {
                    messageBox.displayByCode('note.introPageWarning');
                }
            } else if (rightPage && rightPage.canDragNoteTo(tapPoint)) {
                newNote = rightPage.noteLevel.createNoteAtPoint(tapPoint);
            }
            if (!!newNote) {
                totalNumberOfNotes++;
                NoteTransformChangeListener.sub(newNote);
            }
            events.emit(EMITTER_NAME, events.NOTES_BACKGROUND_INTERACTION, this, {});
        };

        var NoteTransformChangeListener = function() {
            var subscribedNote;
            var subscribedToTransformChange;

            var checkIfNoteHasBeenTransformed = function(eventData) {
                if(subscribedNote && subscribedNote.domElement.style.transform !== "") {
                    viewNote(subscribedNote, true);
                    if(eventData) clearInterval(eventData.data.intervalId);
                    unsubscribeToTransformChange();
                }
            };

            var subscribeToTransformChange = function (newNote) {
                subscribedToTransformChange = true;
                subscribedNote = newNote;
                events.subscribe(note.EMITTER_NAME, events.NOTE_TRANSFORM_CHECK,
                        checkIfNoteHasBeenTransformed, true);
            };

            var unsubscribeToTransformChange = function () {
                subscribedToTransformChange = false;
                subscribedNote = null;
                events.unsubscribe(note.EMITTER_NAME, events.NOTE_TRANSFORM_CHECK,
                    checkIfNoteHasBeenTransformed, true);
            };

            var isSubscribed = function() {
                return subscribedToTransformChange;
            };

            return {
                sub: subscribeToTransformChange
                , isSubbed: isSubscribed
            };
        }();

        this.setupNoteDrag = function(event) {
            currentlyDraggedNote = event.data.note;
            bringNoteToFront(currentlyDraggedNote, true);
            events.yuduOn(noteContainerHammerContext, 'drag', moveNote);
            events.yuduOn(readerDiv, 'mouseup', endDrag);
        };

        var moveNote = function(event) {
            var dragPoint = { x:event.gesture.center.pageX * config.pixelDensity,
                              y:(event.gesture.center.pageY - config.readerYOffset) * config.pixelDensity};

            var draggedNotePage = reader.pages[currentlyDraggedNote.pageNumber];
            if (draggedNotePage.canDragNoteTo(dragPoint)) {
                draggedNotePage.noteLevel.moveNote(currentlyDraggedNote, dragPoint);
            } else if (config.twoPageMode) {
                var isRightPage = ((currentlyDraggedNote.pageNumber + (config.hasIntroPage ? 0 : 1)) % 2) == 1;
                var otherPageNumber = (isRightPage ? currentlyDraggedNote.pageNumber - 1 : currentlyDraggedNote.pageNumber + 1);
                var otherPage = reader.pages[otherPageNumber];
                if (otherPage && otherPage.canDragNoteTo(dragPoint)) {
                    // move note to the other page
                    draggedNotePage.noteLevel.removeNote(currentlyDraggedNote, false);
                    otherPage.noteLevel.addNote(currentlyDraggedNote);
                    otherPage.noteLevel.moveNote(currentlyDraggedNote, dragPoint);
                    removeNoteInternal(currentlyDraggedNote);
                    currentlyDraggedNote.pageNumber = otherPageNumber;
                    addNoteInternal(currentlyDraggedNote);
                    emitNotesChangedEvent(false);
                }
            }
            // note that the note change event is not fired from a single given movement: it would be expensive to do that!
        };

        var endDrag = function(event) {
            bringNoteToFront(currentlyDraggedNote, false);
            noteContainerHammerContext.off('drag', moveNote);
            readerDiv.off('mouseup', endDrag);
            emitNotesChangedEvent(false);
        };

        /**
         * This function uses awareness of the controller's z-index control methods
         *      to move a note to the front due to recent activity
         * @param note - the note to bring forward
         * @param temporary - whether this is:
         *      - a permanent change of index (eg creation, or finalisation of a move)
         *      - a temporary change of index (eg start of a move, where the same index needs to be reused as the note position updates)
         */
        var bringNoteToFront = function(note, temporary) {
            if (temporary) {
                reader.pages[note.pageNumber].noteLevel.assignCurrentZIndex(note);
            } else {
                reader.pages[note.pageNumber].noteLevel.setCurrentZIndex(note);
            }
        };

        var handleViewNoteRequest = function(event) {
            var note = event.data.note;
            viewNote(note, false);
        };

        var viewNote = function(note, isNew) {
            backgroundHammerContext.off('tap', checkTapPointForValidNotePosition);

            currentlyViewedNote = note;
            noteText.val(currentlyViewedNote.text);

            currentNoteIsNew = isNew;
            currentNoteIsNew ? noteContainer.addClass('yudu_dirtyNote') : noteContainer.removeClass('yudu_dirtyNote');

            background.removeClass('yudu_createNote');

            noteContainer.bind('input propertychange', markNoteDirty);

            if (currentlyViewedNote.clipping && currentlyViewedNote.clipping.url) {
                clippingImage.css('background-image', 'url("' + currentlyViewedNote.clipping.url + '")');
                clippingContainer.show();
                if (!noteContainerBaseHeight) {
                    noteContainerBaseHeight = noteContainer.height();
                }
                noteContainer.height(noteContainerBaseHeight + clippingContainer.height());
            } else {
                clippingImage.css('background-image', '');
                clippingContainer.hide();
                if (noteContainerBaseHeight) {
                    noteContainer.height(noteContainerBaseHeight);
                }
            }
            positionNote();
            interactions.setAllowKeyNavigation(false);
            background.show();
            noteText.focus();
        };

        var positionNote = function() {
            if (currentlyViewedNote) {
                var rect = currentlyViewedNote.domElement.getBoundingClientRect();
                var noteWidth = noteContainer.width();
                var noteHeight = noteContainer.height();
                var windowWidth = $(window).width();
                var windowHeight = $(window).height();
                var iconTop = rect.top;
                var iconLeft = rect.left;
                var iconWidth = rect.width;
                var iconHeight = rect.height;

                //the vertical position of the icon should be in the middle of the note container where possible
                var top = Math.min(windowHeight - noteHeight, Math.max(0, iconTop - ((noteHeight - iconHeight)/2)));
                noteContainer.css('top', top);

                // TODO ugc: implement "full-screen" notes view for low-res devices?
                //the horizontal position of the icon should be box with to the left of the icon if positioning on the left
                //otherwise it should be icon width to the right of the icon if positioning on the right
                var left;
                if (iconLeft < windowWidth/2) {
                    left = Math.min(windowWidth - noteWidth, iconLeft + iconWidth);
                } else {
                    left = Math.max(0, iconLeft - noteWidth);
                }

                noteContainer.css('left', left);
            }
        };

        var cancelEditClicked = function(event) {
            if (currentNoteIsNew) {
                deleteConfirmed();
            } else {
                hideNotesMode();
            }
        };

        var okEditClicked = function (event) {
            currentlyViewedNote.setNoteText(noteText.val());
            if (!notes.hasOwnProperty(currentlyViewedNote.id)) {
                addNoteInternal(currentlyViewedNote);
            }
            hideNotesMode();
            emitNotesChangedEvent(false);
        };

        var deleteNoteButtonClicked = function(event) {
            messageBox.displayTwoButtonPopup(localisation.get('note.deleteNoteMessage'), deleteConfirmed, deleteCancelled);
        };

        var deleteConfirmed = function(event) {
            reader.pages[currentlyViewedNote.pageNumber].noteLevel.deleteNote(currentlyViewedNote);
            handleDeletedNote(currentlyViewedNote.getWriteableObject(), false);
            emitNotesChangedEvent(false);
            hideNotesMode();
        };

        var deleteCancelled = function(event) {
        };

        var browseNoteClicked = function(event) {
            var noteToStartBrowseFrom = currentlyViewedNote;
            okEditClicked(event);
            notesBrowse.show(noteToStartBrowseFrom);
        };

        var okClicked = function(event) {
            hideNotesMode();
        };

        var markNoteDirty  = function() {
            noteContainer.addClass('yudu_dirtyNote');
        };

        var emitNotesChangedEvent = function(fromSync) {
            events.emit(EMITTER_NAME, events.UGC_CHANGED, this, {notes: notes, fromSync: fromSync});
        };

        /**
         * Submodule to handle the setup and control of the notes browse view
         * Leaving it as a submodule allows it to access the notes hashes (and other variables) of the main module directly
         */
        var notesBrowse = function() {
            var isBrowsing = false;
            var initialised = false;
            var browseBackground = $("#yudu_notesBrowseBackground");
            var browseCloseButton = $("#yudu_notesBrowseCloseButton");
            var browseLabelNote = $("#yudu_notesBrowseLabelNote");
            var browseLabelPage = $("#yudu_notesBrowseLabelPage");
            var browseMainImage = $("#yudu_notesBrowseImage");
            var browseMainText = $("#yudu_notesBrowseText");
            var browsePreviousImage = $("#yudu_notesBrowsePreviousImage");
            var browseNextImage = $("#yudu_notesBrowseNextImage");
            var hammerContext = false;
            var swipeSensitivity = 15;
            var isDragging = false;
            var dragStart = false;
            var currentlyBrowsedNote = false;
            var currentlyBrowsedNoteIndex = false;
            var nextNote = false;
            var nextNoteIndex = false;
            var previousNote = false;
            var previousNoteIndex = false;
            var weightOfPrecedingNotes = false;
            var pageOffset = 0;

            var init = function() {
                if (!initialised) {
                    // 1-time initialisation functionality
                    pageOffset = config.hasIntroPage ? 0 : 1; // with intro page the page numbers are human-readable - do not offset
                    events.subscribe(EMITTER_NAME, events.UGC_CHANGED, reinit, false);
                    browseCloseButton.click(function() {
                        isDragging = false;
                        hide();
                    });
                    browsePreviousImage.parent().parent().click(navigateToPreviousNote);
                    browseNextImage.parent().parent().click(navigateToNextNote);
                    hammerContext = browseMainImage.hammer({transform_always_block: true, prevent_default: true});
                    events.yuduOn(hammerContext, "dragend", handleDragEnd);
                    events.yuduOn(hammerContext, "dragstart", handleDragStart);
                    initialised = true;
                }
                // repeatable initialisation functionality
                if (!currentlyBrowsedNote) {
                    error('notes.browse.error');
                    return;
                }
                currentlyBrowsedNoteIndex = findNoteIndex(currentlyBrowsedNote);
                if (currentlyBrowsedNoteIndex < 0) {
                    error('notes.browse.modificationWarning');
                    return;
                }
                updateWeightOfPrecedingNotes();
                updateNextNote();
                updatePreviousNote();
            };

            /**
             * function to control behaviour for reinitialising notes browse when the notes data has changed while
             *  the view is open (eg from a sync response)
             */
            var reinit = function(event) {
                if (!isBrowsing) {
                    // only reinitialise if we are browsing
                    return;
                }
                var updatedNote = notes[currentlyBrowsedNote.id];
                if (!updatedNote || updatedNote.isDeleted || !updatedNote.pageNumber
                        || updatedNote.pageNumber != currentlyBrowsedNote.pageNumber) {
                    // note may have been modified/deleted remotely: close the view
                    error('notes.browse.modificationWarning')
                }
                currentlyBrowsedNote = notes[currentlyBrowsedNote.id];
                init();
                prepareCurrentView();
            };

            /**
             * error function: call this if the internal state of the browse submodule becomes impossible
             * safely closes the view and alert the user to a problem
             */
            var error = function(errorMessage) {
                hide();
                messageBox.displayByCode(errorMessage ? errorMessage : 'notes.browse.error');
            };

            /**
             * given the `currentlyBrowsedNote` is the note we want to view
             *  and `nextNote` and `previousNote` are either their logical counterparts or `false`
             * prepare the browse view with images and text as appropriate
             */
            var prepareCurrentView = function() {
                noteImageToContainer(browseMainImage, currentlyBrowsedNote);
                browseMainText.val(currentlyBrowsedNote.text);
                browseLabelNote.text('Note ' + (weightOfPrecedingNotes + currentlyBrowsedNoteIndex + 1) + ' of ' + totalNumberOfNotes);
                browseLabelPage.text('On page: ' + (currentlyBrowsedNote.pageNumber + pageOffset));
                noteImageToContainer(browseNextImage, nextNote);
                noteImageToContainer(browsePreviousImage, previousNote);
            };

            /**
             * assigns the image associated with a given note to the specified container
             * this also contains the decision method for what the image of a note should be, in order of precedence:
             *  - clipping
             *  - page thumbnail (may be a placeholder thumbnail if a page is encrypted)
             *  - no image
             * @param container ; the jQuery selector with the element to assign the image to
             * @param arbitraryNote ; the note whose image should be used
             */
            var noteImageToContainer = function(container, arbitraryNote) {
                if (!arbitraryNote) {
                    container.css('background-image', '');
                } else if (arbitraryNote.clipping && arbitraryNote.clipping.url) {
                    container.css('background-image', 'url(' + arbitraryNote.clipping.url + ')');
                } else {
                    yudu_thumbnailsFunctions.generateThumbnailUrlCss(
                            yudu_thumbnailsFunctions.getThumbnailFileName(arbitraryNote.pageNumber),
                            function (thumbnailUrl) {
                                container.css('background-image', thumbnailUrl);
                            });
                }
            };

            /**
             * finds the index of an arbitrary note in the array of notes on that page
             * @param arbitraryNote ; note to find the index of
             * @returns int ; the index of the note, or -1 if the note is not found
             */
            var findNoteIndex = function(arbitraryNote) {
                var notePageIndex = arbitraryNote.pageNumber;
                var notesOnSamePage = savedNotes[notePageIndex];
                if (notesOnSamePage && notesOnSamePage.length) {
                    for (var i = 0, m = notesOnSamePage.length; i < m; i += 1) {
                        if (arbitraryNote.id == notesOnSamePage[i].id) {
                            return i;
                        }
                    }
                }
                return -1;
            };

            /**
             * finds how many notes there are before those on this page
             * goes through the arrays of notes on each page, for pages prior to that of the currently browsed note
             */
            var updateWeightOfPrecedingNotes = function() {
                var notePageIndex = currentlyBrowsedNote.pageNumber;
                var weight = 0;
                for (var i = 0; i < notePageIndex; i++) {
                    if (savedNotes[i]) {
                        weight += savedNotes[i].length;
                    }
                }
                weightOfPrecedingNotes = weight;
            };

            /**
             * given that the currently browsed note and its index are correct, this method ensures
             *  that the next note and its index are assigned their logical counterparts
             */
            var updateNextNote = function() {
                // assume no note unless we find one
                nextNote = false;
                var notesOnCurrentPage = savedNotes[currentlyBrowsedNote.pageNumber];
                if (currentlyBrowsedNoteIndex + 1 < notesOnCurrentPage.length) {
                    // still another note on the current page - use it
                    nextNoteIndex = currentlyBrowsedNoteIndex + 1;
                    nextNote = notesOnCurrentPage[nextNoteIndex];
                } else {
                    var nextPageWithNotes = findNextPageWithNotes();
                    if (nextPageWithNotes >= 0) {
                        // another page after this one has notes - use the first from that page
                        nextNoteIndex = 0;
                        nextNote = savedNotes[nextPageWithNotes][nextNoteIndex]
                    } // else no more pages after this with notes, no more notes on this page: no next note
                }
            };

            /**
             * given that the currently browsed note and its index are correct, this method ensures
             *  that previous note and its index are assigned their logical counterparts
             */
            var updatePreviousNote = function() {
                // assume no note unless we find one
                previousNote = false;
                if (currentlyBrowsedNoteIndex > 0) {
                    // still another note on the current page - use it
                    previousNoteIndex = currentlyBrowsedNoteIndex - 1;
                    previousNote = savedNotes[currentlyBrowsedNote.pageNumber][previousNoteIndex];
                } else {
                    var previousPageWithNotes = findPreviousPageWithNotes();
                    if (previousPageWithNotes >= 0) {
                        // another page before this one has notes - use the last from that page
                        var notesOnTargetPage = savedNotes[previousPageWithNotes];
                        previousNoteIndex = notesOnTargetPage.length - 1;
                        previousNote = notesOnTargetPage[previousNoteIndex];
                    } // else no more pages before this with notes, no more notes on this page: no previous note
                }
            };

            /**
             * finds the index of the next page with notes, or -1 if there is none
             * @returns int
             */
            var findNextPageWithNotes = function() {
                for (var i = currentlyBrowsedNote.pageNumber + 1, m = reader.shifter.getNumberOfPages(); i < m; i += 1) {
                    if (savedNotes[i] && savedNotes[i].length > 0) {
                        return i;
                    }
                }
                return -1;
            };

            /**
             * finds the index of the previous page with notes, or -1 if there is none
             * @returns int
             */
            var findPreviousPageWithNotes = function() {
                // start from the page offset to avoid the intro page - need to invert the offset for the index
                for (var i = currentlyBrowsedNote.pageNumber - 1; i >= 1 - pageOffset; i--) {
                    if (savedNotes[i] && savedNotes[i].length > 0) {
                        return i;
                    }
                }
                return -1;
            };

            /**
             * handles navigation from the current note to the next note within the browse view
             */
            var navigateToNextNote = function() {
                if (nextNote) {
                    previousNote = currentlyBrowsedNote;
                    previousNoteIndex = currentlyBrowsedNoteIndex;
                    currentlyBrowsedNote = nextNote;
                    currentlyBrowsedNoteIndex = nextNoteIndex;
                    if (currentlyBrowsedNoteIndex - previousNoteIndex != 1) {
                        weightOfPrecedingNotes += savedNotes[previousNote.pageNumber].length;
                    }
                    updateNextNote();
                    prepareCurrentView();
                }
            };

            /**
             * handles navigation from the current note to the previous note within the browse view
             */
            var navigateToPreviousNote = function() {
                if (previousNote) {
                    nextNote = currentlyBrowsedNote;
                    nextNoteIndex = currentlyBrowsedNoteIndex;
                    currentlyBrowsedNote = previousNote;
                    currentlyBrowsedNoteIndex = previousNoteIndex;
                    if (nextNoteIndex - currentlyBrowsedNoteIndex != 1) {
                        weightOfPrecedingNotes -= savedNotes[currentlyBrowsedNote.pageNumber].length;
                    }
                    updatePreviousNote();
                    prepareCurrentView();
                }
            };

            /**
             * event handler for hammer drag start event
             * @param event
             */
            var handleDragStart = function(event) {
                isDragging = true;
                dragStart = event.gesture;
            };

            /**
             * event handler for hammer drag end event
             * @param event
             */
            var handleDragEnd = function(event) {
                var xMovement = event.gesture.deltaX - dragStart.deltaX;
                if (xMovement > swipeSensitivity) {
                    // swipe right: go to previous note
                    navigateToPreviousNote();
                } else if (xMovement < -swipeSensitivity) {
                    // swipe left: go to next note
                    navigateToNextNote();
                }
                isDragging = false;
            };

            /**
             * external interface method: called when the browse mode should be shown
             * @param arbitraryNote ; the note to start browse with
             */
            var show = function(arbitraryNote) {
                currentlyBrowsedNote = arbitraryNote;
                init();
                prepareCurrentView();
                browseBackground.css('display', 'block');
                isBrowsing = true;
            };

            /**
             * external interface method: called when the browse mode should be hidden
             * safe for internal use
             */
            var hide = function() {
                browseBackground.css('display', '');
                isBrowsing = false;
                events.emit(events.ALL, events.GOTO_PAGE, this, {pageNumber: currentlyBrowsedNote.pageNumber + pageOffset});
                currentlyBrowsedNote = false;
            };

            return {
                show: show,
                hide: hide
            };
        }();

        return {
            init: init,
            reinit: reinit,
            pageHasNote: pageHasNote,
            setReader: events.callback(this, function(aReader) { reader = aReader; }),
            showNotesCreationMode: showNotesCreationMode
        };
});
/**
 * Created by alg on 20/06/2016.
 */
define('utils/ugcApi',['config'],
function (config) {
    var UGCAPI = function() {
        var bookmarksModule = false;
        var pageHighlightsModule = false;
        var notesModule = false;

        this.emptyFunction = function(){};
        this.bookmarksReinit = this.emptyFunction;
        this.highlightsReinit = this.emptyFunction;
        this.notesReinit = this.emptyFunction;

        this.falseFunction = function() {return false;};
        this.pageHasBookmark = this.falseFunction;
        this.pageHasHighlight = this.falseFunction;
        this.pageHasNote = this.falseFunction;

        /**
         * Initialise the API
         * Since this is mapping functions declared by other modules, this should be called before other UGC module inits to make them available
         * Note that this should therefore also not contain any references to anything _not_ in another module's public API
         */
        this.init = function () {
            if (config.bookmarksEnabled) {
                bookmarksModule = require('ui/bookmarks');
                this.bookmarksReinit = bookmarksModule.reinit;
                this.pageHasBookmark = bookmarksModule.pageHasBookmark;
            }
            if (config.highlightsEnabled) {
                pageHighlightsModule = require('ui/highlightingCanvas');
                this.highlightsReinit = pageHighlightsModule.reinit;
                this.pageHasHighlight = pageHighlightsModule.pageHasHighlight;
            }
            if (config.notesEnabled) {
                notesModule = require('ui/notes');
                this.notesReinit = notesModule.reinit;
                this.pageHasNote = notesModule.pageHasNote;
            }
        };

    };

    return new UGCAPI();
});
/*
 Thumbnails bar for fast navigation
 */
define('ui/thumbnails',['events', 'constants', 'resources', 'config', 'shared/localisation', 'shared/utils/stringUtils', 'utils/tools',
            'utils/ugcApi', 'jquery', 'utils/encryptedResourceFetchingUtils'],
    function(events, constants, resources, config, localisation, stringUtils, tools,
             ugcApi, $, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "thumbnails";

        var init = function(reader) {
            var pages = reader.pages;
            var pagesDetails = [];
            for (var i = 0, l = pages.length; i < l; i++) {
                var pageDetails = {
                    width: events.callback(pages[i], pages[i].getPageWidth),
                    height: events.callback(pages[i], pages[i].getPageHeight),
                    encrypted: events.callback(pages[i], pages[i].isPageEncrypted),
                    label: events.callback(pages[i], pages[i].getPageLabel)
                };
                pagesDetails.push(pageDetails);
            }

            makeSettingsAvailableForBrandableThumbnails(pagesDetails);

            makeFunctionsAvailableForBrandableThumbnails(reader);
            events.subscribe(events.ALL, events.PAGE_CHANGED, forwardPageChangeEvent);
            events.subscribe(events.ALL, events.LOGIN_SUCCESS, function() {
                events.emit(yudu_events.ALL, yudu_events.COMMON.LOGIN_SUCCESS);
            });

            var position = config.isDesktop ? resources.thumbnailsConfig.desktopPosition : resources.thumbnailsConfig.touchPosition;
            $('#yudu_thumbnailBar' + stringUtils.capitalizeFirstLetter(position)).append(resources.thumbnailsHtml);
            window.yudu_commonFunctions.injectJavascript(
                    constants.baseResourcesFolder + resources.thumbnailsConfig.mainJavascriptFilePath);
        };

        var makeSettingsAvailableForBrandableThumbnails = function(pagesDetails, currentPageNumber) {
            window.yudu_thumbnailsSettings = {
                pagesDetails: pagesDetails,
                introString: localisation.get("thumbnails.intro"),
                pageString: localisation.get("thumbnails.page"),
                primarySegmentString: localisation.get("thumbnails.segments.primary"),
                bookmarksSegmentString: localisation.get("thumbnails.segments.bookmarks"),
                highlightsSegmentString: localisation.get("thumbnails.segments.pageHighlights"),
                notesSegmentString: localisation.get("thumbnails.segments.notes"),
                fps: constants.fps,
                tickTimeMs: constants.tickTimeMs,
                baseThumbnailFolder: constants.baseThumbnailFolder
            };
        };

        var makeFunctionsAvailableForBrandableThumbnails = function(reader) {
            window.yudu_thumbnailsFunctions = {
                getCurrentPage: function() { return reader.getCurrentPage().getPageNumber(); },
                getThumbnailUrl: function(fileName) {
                    return yudu_thumbnailsSettings.baseThumbnailFolder + fileName + '.jpg';
                },
                generateThumbnailUrl: function(fileName, onSuccess) {
                    var thumbnailUrl = yudu_thumbnailsSettings.baseThumbnailFolder + fileName + '.jpg';
                    encryptedResourceFetchingUtils.useResourceAsCallbackArgument(thumbnailUrl, onSuccess);
                },
                getThumbnailUrlCss: function(fileName) {
                    return 'url(' + yudu_thumbnailsFunctions.getThumbnailUrl(fileName) + ')';
                },
                generateThumbnailUrlCss: function(fileName, onSuccess) {
                    yudu_thumbnailsFunctions.generateThumbnailUrl(fileName, function (thumbnailUrl) {
                        onSuccess('url(' + thumbnailUrl + ')');
                    });
                },
                getThumbnailFileName: function(pageIndex) {
                    if (pageIndex === 0 && yudu_commonSettings.hasIntroPage) {
                        return 'intro';
                    } else if (!config.isUserLoggedIn && yudu_thumbnailsSettings.pagesDetails[pageIndex].encrypted()) {
                        if (!resources.yuduBook.settings.samlAuthenticationEnabled) {
                            events.emit(events.ALL, events.NEEDS_BACKGROUND_LOGIN_ATTEMPT, this, {});
                        }
                        return 'placeholder';
                    } else {
                        return '' + pageIndex;
                    }
                },
                pageHasBookmarks: tools.returnDynamicInput(function(){return ugcApi.pageHasBookmark}),
                pageHasHighlights: tools.returnDynamicInput(function(){return ugcApi.pageHasHighlight}),
                pageHasNotes: tools.returnDynamicInput(function(){return ugcApi.pageHasNote}),
                addElementToStage: function(element) { addElementToStage(element, reader); },
                toggleThumbnails: toggleThumbnails
            };
        };

        var addElementToStage = function(element, reader) {
            reader.stage.addChild(element);
        };

        var toggleThumbnails = function(toggle, show) {
            events.emit(yudu_events.ALL, yudu_events.THUMBNAILS.TOGGLE_THUMBNAILS, this, {toggle: toggle, show: show});
        };

        var prettyPrintPages = function(eventData) {
            if (eventData.page2) {
                return '' + eventData.page + '-' + eventData.page2;
            }
            return '' + eventData.page;
        };

        var forwardPageChangeEvent = function (event) {
            var newEventObject = {page: event.data.page};
            if (event.data.page2) {
                newEventObject.page2 = event.data.page2;
            }
            newEventObject.pageString = prettyPrintPages(newEventObject);
            events.emit(yudu_events.ALL, yudu_events.THUMBNAILS.PAGE_CHANGED, this, newEventObject);
        };

        return {
            EMITTER_NAME: EMITTER_NAME,
            init: init,
            makeSettingsAvailableForBrandableThumbnails: makeSettingsAvailableForBrandableThumbnails,
            makeFunctionsAvailableForBrandableThumbnails: makeFunctionsAvailableForBrandableThumbnails
        };

    });

define('utils/cssUtils',[],
function() {
    /**
     * Helper function to take in a css dimension (with unit suffix) or the string "auto"
     *  and apply a limit to the dimension if it is specified in pixels
     * @param dimension ; dimension (as string with unit suffix) or "auto"
     * @param limit ; limit to apply to the dimension, in pixels (as a number)
     * @returns {String|*} ; limited dimension (if in px), "auto" (if unable to parse pixel dimension),
     *  dimension (if a non-pixel string), or undefined (if not a string)
     */
    var applyPixelLimitToCssDimension = function(dimension, limit) {
        if (typeof dimension !== 'string') {
            // input is not a string as required
            return undefined;
        }
        var dim = dimension.trim();
        if (!dim.length || dim.length <= 2 || dim.substring(dim.length-2) !== 'px') {
            // not a pixel dimension: do not modify
            return dimension;
        }
        dim = parseInt(dim);
        // need to check we have a valid number
        // note that `typeof NaN === 'number'` and that `Number.isNaN` is not consistent or fully supported
        if ((typeof dim === 'number') && (('' + dim) !== 'NaN')) {
            return '' + Math.min(dim, limit) + 'px';
        }
        // number formatting failed, probable invalid dimension, return "auto"
        return 'auto';
    };

    return {
        applyPixelLimitToCssDimension: applyPixelLimitToCssDimension
    };
});

define('ui/search',['events', 'constants', 'jquery', 'config', 'resources', 'api', 'interactions',
    'shared/localisation', 'utils/statistics', 'utils/cssUtils', 'ui/uiTools', 'shared/utils/appUtils', 'shared/storage'],
    function(events, constants, $, config, resources, api, interactions,
             localisation, statistics, cssUtils, uiTools, appUtils, storage) {

        var KEY_RETURN = 13;
        var RESULTS_BATCH_SIZE = 10;

        var searchText;
        var searchGo;
        var noResults;
        var searching;
        var searchResultsList;
        var wasLastSearchArchive;

        var desktopSearchResultsContainer = $("#yudu_desktopSearchResultsContainer");
        var closeSearchResults = $("#yudu_closeSearchResults");
        var desktopSearchLocalButton = $("#yudu_desktopLocalSearch");
        var desktopSearchArchiveButton = $("#yudu_desktopArchiveSearch");
        var desktopSearchButtonContainer = $("#yudu_desktopSearchButtonContainer");
        var mobileSearchLocalButton = $("#yudu_mobileLocalSearch");
        var mobileSearchArchiveButton = $("#yudu_mobileArchiveSearch");
        var mobileSearchButtonContainer = $("#yudu_mobileSearchButtonContainer");

        var mobileSearchBackground = $("#yudu_mobileSearchBackground");
        var mobileSearchContainer = $("#yudu_mobileSearchContainer");
        var mobileSearchResultsHelper = $("#yudu_iOSHelperContainer");

        var reader = null;

        var results;
        var moreResults;
        var resultPages;

        var searchQuery;

        var pagesToPositions;

        var readyInit = function () {
            //init needs to be called after page loading is finished, so entering the edition from an archive search works properly
            events.subscribe(events.ALL, yudu_events.LOADING.END_LOADING, events.callback(this, init));
        }

        /* This file handles the search part of the HTML reader. It handles setup and handling of searches and the results
        * on both desktop and mobile devices. */
        var init = function() {
            initPlatformDependentVars();

            if (config.isDesktop) {
                window.yudu_searchFunctions = {
                    setBrandableSearchComponents: setBrandableSearchComponents,
                    positionDesktopSearchResults: positionDesktopSearchResults,
                    customiseDesktopSearchResults: customiseDesktopSearchResults
                };
                events.emit(yudu_events.ALL, yudu_events.TOOLBAR.SEARCH_READY);
            } else {
                initSearchTools();
            }

            events.yuduOn(mobileSearchBackground, config.clickAction, hideMobileSearch);
            events.yuduOn(mobileSearchContainer, "touchmove", function(event){ event.preventDefault(); });
            uiTools.enableScrollingWithoutDocumentBouncing(mobileSearchResultsHelper);
        };

        var initPlatformDependentVars = function() {
            searchText = $("#yudu_mobileSearchText");
            searchGo = $("#yudu_mobileSearchGo");
            var iconPath = constants.toolbarIconBasePath + (config.shouldUseHighRes ? constants.toolbarIconHighResPrefix : "") + "search" + constants.toolbarIconFileExtension;
            searchGo.css('background-image', 'url(' + iconPath + ')');
            noResults = config.isDesktop ? $("#yudu_desktopNoResults") : $("#yudu_mobileNoResults");
            searching = config.isDesktop ? $("#yudu_desktopSearching") : $("#yudu_mobileSearching");
            searchResultsList = config.isDesktop ? $("#yudu_desktopSearchResultsList") : $("#yudu_mobileSearchResultsList");
        };

        var setBrandableSearchComponents = function(searchTextComponent, searchGoComponent) {
            searchText = $(searchTextComponent);
            searchGo = $(searchGoComponent);

            initSearchTools();
        };

        var initSearchTools = function() {
            events.yuduOn(searchText, "keydown", onSearchFieldType);
            events.yuduOn(searchText, "focus", function(){ interactions.setAllowKeyNavigation(false); });
            events.yuduOn(searchText, "blur", function(){ interactions.setAllowKeyNavigation(true); });
            events.yuduOn(closeSearchResults, "click", events.callback(this, hideSearchResults));
            // The following block is here to fix an i.e. bug which only appears on tablets and phones.
            // IE disables the text box and one way to fix this is to focus somewhere else and then back to the input.
            // If you have any other text box, you can use this to fix it.
            events.yuduOn(searchText, config.clickAction, function() {
                mobileSearchContainer.focus();
                searchText.focus();
            });
            events.yuduOn(searchGo, config.clickAction, events.callback(this, function(){search(wasLastSearchArchive)}));

            initArchiveSearch();
        };

        /* The buttons need to reflect the choice the user last made, whether that was an Archive
        * or Document search. */
        var customiseDesktopArchiveButtons = function(useArchive) {
            if (config.isDesktop) {
                var activeButton = useArchive ? desktopSearchArchiveButton : desktopSearchLocalButton;
                var inactiveButton = useArchive ? desktopSearchLocalButton : desktopSearchArchiveButton;
            } else  {
                var activeButton = useArchive ? mobileSearchArchiveButton : mobileSearchLocalButton;
                var inactiveButton = useArchive ? mobileSearchLocalButton : mobileSearchArchiveButton;
            }
            activeButton.addClass('yudu_activeSearchButton');
            inactiveButton.removeClass('yudu_activeSearchButton');
        };

        var positionDesktopSearchResults = function(position, corners) {
            var widthLimit = config.width / config.pixelDensity - desktopSearchResultsContainer.width();
            desktopSearchResultsContainer.css('top', position.top);
            var limitedLeft = cssUtils.applyPixelLimitToCssDimension(position.left, widthLimit);
            if (limitedLeft) {
                desktopSearchResultsContainer.css('left', limitedLeft);
            }
            desktopSearchResultsContainer.css('bottom', position.bottom);
            var limitedRight = cssUtils.applyPixelLimitToCssDimension(position.right, widthLimit);
            if (limitedRight) {
                desktopSearchResultsContainer.css('right', limitedRight);
            }
            desktopSearchResultsContainer.css('border-radius', corners.topLeft + ' ' + corners.topRight + ' ' + corners.bottomRight + ' ' + corners.bottomLeft);
        };

        var customiseDesktopSearchResults = function(colour) {
            desktopSearchResultsContainer.css('background-color', colour);
        };

        /* This function runs on page load. First we check whether archiveSearch is actually enabled in the
        * properties of the file, otherwise we don't want to give the user the option to select it. Next
        * we need to check whether we landed on the current edition from an archive search in another edition,
        * in which case we grab the results from the localStorage, clean up the storage and ensure the results
        * are shown correctly.
        * Currently ArchiveSearch is only enabled on desktop, not in the wrapper apps. */
        var initArchiveSearch = function() {
            var isArchiveSearchEnabled = resources.yuduBook.settings.archiveSearchEnabled;
            if (!(appUtils.deviceType.isAndroid() || appUtils.deviceType.isMetro())  && isArchiveSearchEnabled){
                events.yuduOn(desktopSearchLocalButton, config.clickAction, events.callback(this, performLocalSearch));
                events.yuduOn(desktopSearchArchiveButton, config.clickAction, events.callback(this, performArchiveSearch));
                events.yuduOn(mobileSearchLocalButton, config.clickAction, events.callback(this, performLocalSearch));
                events.yuduOn(mobileSearchArchiveButton, config.clickAction, events.callback(this, performArchiveSearch));

                if (storage.results){
                    customiseDesktopArchiveButtons(true);
                    results = JSON.parse(storage.getItem("results"));
                    var query = JSON.parse(storage.getItem("searchQuery"));
                    var selectedResultIndex = JSON.parse(storage.getItem("selectedResultIndex"));
                    storage.removeItem("results");
                    storage.removeItem("searchQuery");
                    storage.removeItem("selectedResultIndex");
                    searchText.val(query);
                    wasLastSearchArchive = true;
                    pagesToPositions = {};
                    resultPages = [];

                    for (var i = 0, m = results.length; i < m; i++) {
                        if(resources.yuduBook.settings.id == results[i].bookId) {
                            results[i].sameBook = true;
                            resultPages.push(results[i].page -1);
                            loadWordPositionsForPage(resultPages[resultPages.length -1], 2);
                        } else if (results[i].sameBook) {
                            results[i].sameBook = false;
                        }
                    }

                    desktopSearchResultsContainer.show();
                    displaySearchResults();
                    var selectedResult = results[selectedResultIndex];
                    if (selectedResult && selectedResult.page) {
                        events.emit(events.ALL, events.GOTO_PAGE, this, { pageNumber: selectedResult.page });
                    }
                } else {
                    customiseDesktopArchiveButtons(false);
                }
            } else {
                desktopSearchButtonContainer.remove();
                mobileSearchButtonContainer.remove();
                return;
            }
        };

        var onSearchFieldType = function(event) {
            if (event.which == KEY_RETURN) {
                search(wasLastSearchArchive);
            }
        };

        var search = function(useArchiveSearch) {
            // Hide keyboard
            document.activeElement.blur();
            searchQuery = searchText.val();
            if (searchQuery) {
                searching.show();
                noResults.hide();
                (config.isDesktop ? searchResultsList : mobileSearchResultsHelper).empty();
                searchResultsList.hide();
                removeSearchHighlights();
                if (config.isDesktop) {
                    desktopSearchResultsContainer.show();
                }

                results = [];
                pagesToPositions = {};

                statistics.search({searchPhrase: searchQuery});

                sendRequest(useArchiveSearch);
            }
        };

        var sendRequest = function(useArchiveSearch) {
            var settings = resources.yuduBook.settings;
            var searchUrl = settings.searchUrl;
            var data = {
                bookId: settings.id,
                query: searchQuery,
                platform: "html",
                format: "xml",
                numberOfResultsToFetch: RESULTS_BATCH_SIZE,
                numberOfResultsAlreadyFetched: Object.keys(pagesToPositions).length,
                archiveSearch: useArchiveSearch,
                useNewEncoding: true
            };
            $.post(searchUrl, data, onSearchResults, "xml");
        };

        var onSearchResults = function(data) {
            resultPages = [];
            var editionId = parseInt($(data).find("searchResults").find("book").children("bookid").text());
            $(data).find("searchResults").find("book").children("match").each(function() {
                var matchEditionId = parseInt($(this).children("matchbookid").text());
                var pageLabel = $(this).children("pagelabel").text();
                var pageNumber = parseInt($(this).find("page").text());
                if (editionId == matchEditionId && !resources.wordPositions[pageNumber - 1]) {
                    resultPages.push(pageNumber - 1);
                }
                var text = $(this).find("text").text();
                text = text.replace(/(\+)+/g, " ");
                var pattern = /<hit>([^\s]*)<\/hit>/g;
                var query = searchText.val();
                var match;
                var hits = [];
                while (match = pattern.exec(text)) {
                    hits.push(match[1]);
                }

                var bookName = $(this).children("bookname").text();
                var bookUrl = $(this).children("liveurl").text();
                results.push({
                    bookName: bookName,
                    bookUrl: bookUrl,
                    page: pageNumber,
                    text: text,
                    pageLabel: pageLabel,
                    hits: hits,
                    query: query});

                var currentResultIndex = results.length -1;
                if(editionId != matchEditionId){
                    results[currentResultIndex].sameBook = false;
                    results[currentResultIndex].bookId = matchEditionId;
                } else {
                    results[currentResultIndex].sameBook = true;
                    results[currentResultIndex].bookId = editionId;
                }
            });
            moreResults = $(data).find("searchResults").find("moreResults").text() == "true";
            if (resultPages.length == 0) {
                displaySearchResults();
            }
            else {
                for (var i = 0, m = resultPages.length; i < m; i++) {
                    loadWordPositionsForPage(resultPages[i], 2);
                }
            }
        };

        var loadWordPositionsForPage = function(page, retries) {
            $.ajax({
                url: constants.wordPositionsFolder + page + ".http",
                type: 'GET',
                headers: {
                    "Content-Type": "application/text",
                    "Accept": "application/text"
                },
                contentType: "application/text",
                dataType: "text",
                success: function(data) {
                    wordPosFetched(page, data);
                },
                error: function() {
                    if (retries > 0) {
                        loadWordPositionsForPage(page, --retries);
                    }
                    else {
                        finishedProcessingWordPositionsForPage(page);
                    }
                }
            });
        };

        var wordPosFetched = function(page, data) {
            var wordPosJson = {};
            var wordAndPos = data.split("&");
            for (var i = 0; i < wordAndPos.length; i++) {
                wordPosJson[wordAndPos[i].substr(1, wordAndPos[i].indexOf("=") - 1)] =
                    wordAndPos[i].substr(wordAndPos[i].indexOf("=") + 1).split("%3C");
            }
            resources.wordPositions[page] = wordPosJson;
            finishedProcessingWordPositionsForPage(page);
        };

        var finishedProcessingWordPositionsForPage = function(page) {
            resultPages.splice(resultPages.indexOf(page), 1);
            if (resultPages.length == 0) {
                displaySearchResults();
            }
        };

        var displaySearchResults = function() {
            searching.hide();
            if (results.length == 0) {
                noResults.show();
            }
            else {
                searchResultsList.show();
                for (var i = 0; i < results.length; i++) {
                    if(results[i].sameBook) {
                        var wordPos = resources.wordPositions[results[i].page - 1];
                        var positions = [];
                        $(results[i].hits).each(function () {
                            // keys are percent encoded in the ".http file".
                            var hit = encodeURIComponent(this.toLowerCase());
                            var hitPositions = (wordPos && wordPos[hit]) ? wordPos[hit] : [];
                            for (var j = 0, l = hitPositions.length; j < l; j++) {
                                if ($.inArray(hitPositions[j], positions) < 0)
                                    positions.push(hitPositions[j]);
                            }
                        });
                        var pagePositions = pagesToPositions[results[i].page] || [];
                        for (var j = 0, l = positions.length; j < l; j++) {
                            if ($.inArray(positions[j], pagePositions) < 0)
                                pagePositions.push(positions[j]);
                        }
                        pagesToPositions[results[i].page] = pagePositions;
                    }
                }

                handleNextBatch();

                if (config.isDesktop) {
                    for (var page in pagesToPositions) {
                        if (pagesToPositions.hasOwnProperty(page)) {
                            var readerPage = page - (config.hasIntroPage ? 0 : 1);
                            reader.pages[readerPage].removeSearchOverlayLevel();
                            reader.pages[readerPage].createSearchOverlayLevel(pagesToPositions[page]);
                        }
                    }
                }
            }
        };

        var handleNextBatch = function() {
            var shownResults = searchResultsList.is(":visible") ? (config.isDesktop ? searchResultsList : mobileSearchResultsHelper).children().length : 0;
            if (results.length - shownResults < RESULTS_BATCH_SIZE && moreResults)
                sendRequest();
            else {
                searching.hide();
                for (var i = shownResults, l = Math.min(shownResults + RESULTS_BATCH_SIZE, results.length); i < l; i++) {
                    var pageIndex = parseInt(results[i].page - (config.hasIntroPage ? 0 : 1));
                    var resultDiv = document.createElement("div");
                    resultDiv.className = "yudu_searchResult";
                    if(results[i].isClickThrough){
                        resultDiv.className = "yudu_searchResult yudu_clickThrough";
                        /* We've set the class, now we want this to be false so that if we continue
                        * on to a new edition this doesn't again get the class. */
                        results[i].isClickThrough = false;
                    }
                    (config.isDesktop ? searchResultsList : mobileSearchResultsHelper).append(resultDiv);

                    //Create the label stating which page and (in case of archive) edition the result is in
                    var resultPage = document.createElement("p");
                    resultPage.className = "yudu_resultPage";

                    if (results[i].sameBook) {
                        var page = reader.pages[pageIndex];

                        if (page.encrypted && config.decryptionKey) {
                            page.decrypt(config.decryptionKey);
                        }

                        resultPage.innerHTML = localisation.get("search.page") + results[i].pageLabel;
                    } else {
                        resultPage.innerHTML = results[i].bookName + ", " + localisation.get("search.page") + results[i].pageLabel;
                    }

                    events.yuduOn($(resultDiv), "click", events.callback(this, onSearchResultClick(pageIndex, results, i)));
                    resultDiv.appendChild(resultPage);

                    var resultText = document.createElement("p");
                    resultText.className = "yudu_resultText";
                    resultText.innerHTML = results[i].text.replace(/<hit>/g, "<span class='yudu_hitText'>").replace(/<\/hit>/g, "</span>");
                    resultDiv.appendChild(resultText);
                }

                if (shownResults > 0 && !config.isDesktop)
                    mobileSearchResultsHelper.scrollTop(mobileSearchResultsHelper.scrollTop() + 10);
                if (moreResults || results.length - shownResults - RESULTS_BATCH_SIZE > 0) {
                    (config.isDesktop ? searchResultsList : mobileSearchResultsHelper).scroll(function() {
                        if ($(this).scrollTop() + $(this).height() + 30 > this.scrollHeight) {
                            $(this).off("scroll");
                            searching.show();
                            handleNextBatch();
                        }
                    });
                }
            }
        };

        var hideSearchResults = function() {
            closeSearchResults.off("click", events.callback(this, hideSearchResults));
            desktopSearchResultsContainer.hide();
            removeSearchHighlights();
        };

        var removeSearchHighlights = function() {
            events.unsubscribe(events.ALL, events.PAGE_CHANGED);
            for (var i = 0; i < reader.pages.length; i++) {
                reader.pages[i].removeSearchOverlayLevel();
            }
        };

        var onSearchResultClick = function(page, results, index) {
            var result = results[index];

            return function() {
                if(!result.sameBook){
                    result.isClickThrough = true;
                    storage.results = JSON.stringify(results);
                    storage.searchQuery = JSON.stringify(result.query);
                    storage.selectedResultIndex = JSON.stringify(index);
                    window.open(result.bookUrl, '_blank');
                    return;
                }
                var pageAlreadyShowing = reader.shifter.getCentreTray().hasPage(page);
                if (!pageAlreadyShowing) {
                    reader.goToPage(page);
                }
                if (!config.isDesktop) {
                    var wordPositionsPage = page + (config.hasIntroPage ? 0 : 1);
                    reader.pages[page].createSearchOverlayLevel(pagesToPositions[wordPositionsPage]);
                    if (page - 1 >= 0 && pagesToPositions[wordPositionsPage - 1])
                        reader.pages[page - 1].createSearchOverlayLevel(pagesToPositions[wordPositionsPage - 1]);
                    if (page + 1 < reader.pages.length && pagesToPositions[wordPositionsPage + 1])
                        reader.pages[page + 1].createSearchOverlayLevel(pagesToPositions[wordPositionsPage + 1]);
                    hideMobileSearch();
                    events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, removeSearchHighlights));
                }
                if (pageAlreadyShowing) {
                    reader.shifter.getCentreTray().zoom(-100, 0, 0);
                    reader.shifter.getCentreTray().flashSearchOverlays();
                }
            };
        };

        var showMobileSearch = function() {
            interactions.setAllowKeyNavigation(false);

            mobileSearchContainer.slideDown(function() {searchText.focus()});
            mobileSearchBackground.show();
        };

        var performLocalSearch = function() {
            wasLastSearchArchive = false;
            performLocalOrArchiveSearch(wasLastSearchArchive);
        };

        var performArchiveSearch = function() {
            wasLastSearchArchive = true;
            performLocalOrArchiveSearch(wasLastSearchArchive);
        };

        var performLocalOrArchiveSearch = function(useArchive){
            customiseDesktopArchiveButtons(useArchive);
            hideSearchResults();
            search(useArchive);
        };

        var hideMobileSearch = function() {
            // Hide keyboard
            document.activeElement.blur();
            interactions.setAllowKeyNavigation(true);
            mobileSearchContainer.hide();
            mobileSearchBackground.hide();
        };

        return {
            init: init,
            readyInit: readyInit,
            setReader: events.callback(this, function(aReader) { reader = aReader; }),
            showMobileSearch: showMobileSearch,
            removeSearchHighlights: removeSearchHighlights
        };
    });

define('shared/loader',['jquery', 'events'],
    function($, events) {

        var Loader = function() {
            self = this;
            var EMITTER_NAME = "loadingActions";

            var actions = [];
            var completedSteps = -1;

            // FETCH METHODS

            // Action compatible method for loading json
            self.fetchJson = function (action) {
                var headers = {
                    "Accept": "application/json"
                };
                if (!action.parameters.noCacheControlHeader) {
                    headers["Cache-control"] = "no-cache";
                }

                $.ajax({
                    url: action.parameters.src,
                    type: 'GET',
                    headers: headers,
                    dataType: "json",
                    cache: false,
                    success: function (data) {
                        actionDone(action, data);
                    },
                    error: function () {
                        actionFailed(action);
                    }
                });
            };

            // Action compatible method for loading images
            self.fetchImage = function (action) {
                var img = new Image();
                img.onload = events.callback(this, actionDone, action, img);
                img.onerror = events.callback(this, actionFailed, action);
                img.src = action.parameters.src;
            };

            /**
             * Load iFrame but don't display it (note if iFrame is not appended to body then in Chrome the
             * onload event doesn't fire)
             * @param action
             */
            self.fetchIFrame = function (action) {
                var iFrame = document.createElement("iframe");
                iFrame.id = action.parameters.id;
                iFrame.onload = events.callback(this, actionDone, action, iFrame);
                iFrame.onerror = events.callback(this, actionFailed, action);
                iFrame.style.display = "none";
                iFrame.src = action.parameters.src;
                document.body.appendChild(iFrame);
            };

            self.fetchHtml = function (action) {
                $.ajax({
                    url: action.parameters.src,
                    type: 'GET',
                    headers: {
                        "Accept": "text/html"
                    },
                    dataType: "html",
                    success: function (data) {
                        actionDone(action, data);
                    },
                    error: function () {
                        actionFailed(action);
                    }
                });
            };

            self.makeAction = function (name, method, params, onComplete, retries, optional) {
                optional = optional || false;
                retries = retries || 0;
                onComplete = onComplete || null;
                var resource = {
                    name: name,
                    method: method,
                    parameters: params,
                    retries: retries,
                    onComplete: onComplete,
                    optional: optional,
                    done: false,
                    failed: false
                };
                actions.push(resource);
            };

            var runAction = function (action) {
                action.method(action);
            };


            var actionDone = function (action, result) {
                action.done = true;

                if (!action.failed && action.onComplete)
                    action.onComplete(result);

                var completedAllActions = $.grep(actions, function (e) {
                        return !e.done
                    }).length == 0;
                if (completedAllActions) {
                    //has this action set failed?
                    var failed = $.grep(actions, function (e) {
                            return e.failed
                        }).length > 0;
                    if (failed) {
                        events.emit(EMITTER_NAME, events.CRITICAL_ERROR, this, {});
                        return;
                    }
                    self.loadNextStep();
                }
            };

            var actionFailed = function (action) {
                action.retries -= 1;

                if (action.retries > 0) {
                    if (action.parameters.altSrc) {
                        action.parameters.src = action.parameters.altSrc;
                    }
                    runAction(action);
                    return;
                }
                if (!action.optional)
                    action.failed = true;

                actionDone(action);
            };

            self.loadNextStep = function() {
                var steps = self.getAllSteps();
                if (completedSteps >= steps.length - 1)
                    return;

                actions = [];
                completedSteps += 1;
                steps[completedSteps]();
                if (actions.length > 0) {
                    for (var i = 0, m = actions.length ; i < m ; i++) {
                        runAction(actions[i]);
                    }
                } else {
                    self.loadNextStep();
                }
            };

            self.getAllSteps = function() { return []; }
        };

        return new Loader();
    });

/**
 * Module to make the global `document` object available as a dependency
 * Useful for testing a module with a dependency on the document object
 */
define('shared/global/document',[], function () {
    return document;
});

/**
 * Module to make the global `screen` object available as a dependency
 * Useful for testing a module with a dependency on the screen object
 */
define('shared/global/screen',[], function () {
    return screen;
});

/**
 * Module to make the global `window` object available as a dependency
 * Useful for testing a module with a dependency on the window object
 */
define('shared/global/window',[], function () {
    return window;
});

/**
 * Vacuous replacement for has.js (https://github.com/phiggins42/has.js)
 * To be used by the optimiser to prevent dependency fetch errors
 * Uses an always-false function to fail any missed `has` checks
 */
define('has',[], function () {
    return function() {
        return false;
    };
});

define('shared/device',['shared/global/document', 'shared/global/screen', 'shared/global/window', 'has'],
function(document, screen, window, has) {
    var bowser = null;
    /*
     * screen size limits
     * note that these are larger than expected, because the smaller devices seem to also be the least accurate
     *  when it comes to determining the device dpi
     * this is probably not helped by most browsers assuming and hardcoding for dpi values of 96
     *  (hence this script also assumes that)
     * phone limit set at ~9" = 864px, v.large for a phone, but phones are also the least accurate
     *  for example, the iPhone 6+ (5.5") calculates as being 8.8"...
     * tablet limit set at ~21" = 2016px, so as to include laptops too
     *  ideally, we'd use 17"/18" for laptops, since most are 11"-15", and few are above that,
     *  but a 13" macbook pro registers as being nearly 16", so we need a couple inches allowance here too
     *  this also cannot go above 22" because 23" is standard for desktop monitors
     *  and desktops can actually be pretty accurate
     */
    var PHONE_SIZE_LIMIT = 864;
    var TABLET_SIZE_LIMIT = 2016;
    /*
     * possible device types
     * the rough breakdown is
     *  - small screen => phone
     *  - large screen (and maybe no touch) => desktop
     *  - anything else is a "tablet" or laptop
     *  - windows apps have explicit phone separation
     *  - android apps have no desktops
     */
    var deviceTypes = {
        desktop: 'desktop',
        tablet: 'tablet',
        phone: 'phone'
    };
    // TODO: detect tv / watch / smartwear
    // ... don't even go there...

    var Device = function() {
        var self = this;
        self.types = deviceTypes;
        var hasBattery = null;

        /**
         * Setup libraries the module can use
         * Cannot import them directly since this is a shared module
         * @param bowserLib {*} [optional] the bowser library
         */
        self.setupLibraries = function(bowserLib) {
            bowser = bowserLib;
        };

        /**
         * Start any async checks that may be useful in detecting between device states
         */
        self.startDeviceDetectionAsyncChecks = function() {
            var ret = {};
            if ('getBattery' in window.navigator) {
                ret.batteryManagerPromise = window.navigator.getBattery().then(checkForBattery);
            }
            return ret;
        };

        /**
         * Interface function that attempts to classify this device into one of the categories specified above
         * @returns {string} the device type to assume this is
         */
        self.classify = function() {
            // if bowser is available, defer to its classification mechanisms
            if (bowser) {
                if (bowser.ios) {
                    if (bowser.iphone) {
                        return deviceTypes.phone;
                    }
                    return deviceTypes.tablet;
                }
                if (bowser.mobile) {
                    return deviceTypes.phone;
                }
                if (bowser.tablet) {
                    return deviceTypes.tablet;
                }
            }
            // otherwise, fall back to usual classification mechanisms
            var classification = new DeviceClassification();
            if (!self.mayBeTouchCapable() && classification.mayBe(deviceTypes.desktop)) {
                // no touch => desktop
                return deviceTypes.desktop
            }
            // not a small screen, but touch-capable: this is the (increasingly large) grey area
            if (hasBattery === true) {
                classification.eliminate(deviceTypes.desktop);
            }
            return classification.bestGuess();
        };

        /**
         * Object used to track the state of an ongoing classification
         * @param existingClassification {DeviceClassification} to provide an initial state
         * @constructor
         */
        var DeviceClassification = function(existingClassification) {
            var ino = this;

            var init = function() {
                ino.count = 0; // the number of remaining possible device types
                if (existingClassification instanceof DeviceClassification) {
                    initFrom(existingClassification);
                } else {
                    initNew();
                }
            };

            var initNew = function() {
                // mark all device types as possible classifications
                for (var type in deviceTypes) {
                    if (deviceTypes.hasOwnProperty(type)) {
                        ino[type] = true;
                        ino.count++;
                    }
                }
            };

            var initFrom = function(classification) {
                // copy properties from the other classification
                for (var type in deviceTypes) {
                    if (deviceTypes.hasOwnProperty(type)) {
                        ino[type] = classification.mayBe(type);
                        if (ino[type]) {
                            ino.count++;
                        }
                    }
                }
            };

            /**
             * Eliminate a device type from consideration for this classification attempt
             * @param type {string} of device to eliminate
             */
            ino.eliminate = function(type) {
                if (deviceTypes[type] == type && ino.mayBe[type]) {
                    ino[type] = false;
                    ino.count--;
                }
            };

            /**
             * Checks whether this classification could still support concluding a specified type
             * @param type {string} of device to check
             * @returns {boolean}
             */
            ino.mayBe = function(type) {
                return ino[type];
            };

            /**
             * Given the remaining possible device types, determine a "best guess" of what the device is
             * If there is only one remaining classification, that is returned as the result by elimination
             * Otherwise, an educated guess is made based on the size of the current screen
             * The decision process for the last is horribly flawed, and has more assumptions than certainties,
             *  but as a last resort it is better than nothing
             * @returns {string} the device type
             */
            ino.bestGuess = function() {
                if (ino.count <= 1) {
                    // if there is only one classification remaining, prioritise it
                    return ino.byElimination();
                }
                // NB: don't care about device pixel ratio, since CSS pixels already account for that
                var screenDiagonal = Math.sqrt(Math.pow(screen.width, 2) + Math.pow(screen.height, 2));
                // guesstimate time!
                // assumes an aspect ratio of something akin to 16:9
                // assumes a screen dpi of 96, which is apparently hardcoded into many browsers nowadays...
                // if that ever changes, consider estimating along the lines of https://stackoverflow.com/a/29252825/7189002
                if (screenDiagonal < PHONE_SIZE_LIMIT) {
                    return ino.byElimination(true);
                } else if (screenDiagonal > TABLET_SIZE_LIMIT) {
                    return ino.byElimination(false);
                }
                // tablets are the hardest to rule out, hence it should be safe to use it as a fallback
                return deviceTypes.tablet;
            };

            /**
             * Determine the most appropriate device type of those remaining given an order to the priority
             * Returns "tablet" if an impossible state is detected
             * @param preferSmallest {boolean} whether to prefer smaller (`true`) or larger (`false`) device types
             * @returns {string} determined device type
             */
            ino.byElimination = function(preferSmallest) {
                if (preferSmallest) {
                    if (ino.mayBe(deviceTypes.phone)) {
                        return deviceTypes.phone;
                    } else if (ino.mayBe(deviceTypes.tablet)) {
                        return deviceTypes.tablet;
                    } else if (ino.mayBe(deviceTypes.desktop)) {
                        return deviceTypes.desktop;
                    }
                } else {
                    if (ino.mayBe(deviceTypes.desktop)) {
                        return deviceTypes.desktop;
                    } else if (ino.mayBe(deviceTypes.tablet)) {
                        return deviceTypes.tablet;
                    } else if (ino.mayBe(deviceTypes.phone)) {
                        return deviceTypes.phone;
                    }
                }
                // just in case something went wrong
                return deviceTypes.tablet;
            };

            init();
        };

        /**
         * Helper that determines if the current device has suitable interfaces to handle touch events
         * @returns {boolean}
         */
        self.mayBeTouchCapable = function() {
            return ('ontouchstart' in window)
                    || (window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1)
                    || (window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1)
                    || (window.DocumentTouch && document instanceof DocumentTouch);
        };

        /**
         * Callback to `navigator.getBattery()` promise resolution
         * Will not be supported on all platforms
         * @param batteryManager
         */
        var checkForBattery = function(batteryManager) {
            if (!batteryManager || typeof batteryManager.charging != 'boolean') {
                // not a valid battery manager object
                return;
            }
            // battery discharging => has a battery => probably not a desktop
            //  (obviously not 100% accurate, but usually a safe assumption)
            // note that battery not discharging does not imply a desktop!
            hasBattery = batteryManager.dischargingTime != Infinity
        };

        if (false) { // make private variables available for tests
            self.testApi = {
                checkForBattery: checkForBattery
            };
            Object.defineProperty(self.testApi, 'hasBattery', {
                get: function() { return hasBattery; }
            });
        }
    };

    var module = new Device();

    if (false) {
        module.testApi.PHONE_SIZE_LIMIT = PHONE_SIZE_LIMIT;
        module.testApi.TABLET_SIZE_LIMIT = TABLET_SIZE_LIMIT;
    }

    return module;
});

define('utils/loadingActions',['jquery', 'events', 'config', 'constants', 'resources', 'shared/loader', 'utils/userOptions',
        'shared/localisation', 'shared/device', 'utils/tools', 'utils/encryptedResourceFetchingUtils'],
    function($, events, config, constants, resources, loader, userOptions,
             localisation, device, tools, encryptedResourceFetchingUtils) {

        var EMITTER_NAME = "loadingActions";

        // Set up aliases for the loader, and tell it what steps to follow.
        var fetchJson = loader.fetchJson;
        var fetchImage = loader.fetchImage;
        var fetchIFrame = loader.fetchIFrame;
        var fetchHtml = loader.fetchHtml;
        var makeAction = loader.makeAction;
        var loadNextStep = loader.loadNextStep;

        loader.getAllSteps = function() {
            return [loadYuduBook, loadContentDecryptionKey, loadBrandingConfigFiles, loadBrandingHtmlFiles,
                loadInfoScreen, loadImages, loadOptionalFiles, completeLoad];
        };

        var yuduBookSrc = null;

        // LOADING ACTION SETS
        var loadInfoScreen = function() {
            if (userOptions.shouldShowInformationBox() && !resources.yuduBook.settings.infoScreenDisabled
                && config.getFromQuery('preventInfoPage') != 'true') {
                var htmlDocument = device.mayBeTouchCapable() ? constants.informationTouch : constants.informationDesktop;
                makeAction("infoPage", fetchIFrame, {src: htmlDocument, id: "yudu_infoFrame"}, infoPageFetched);
            }
        };

        var loadYuduBook = function() {
            makeAction("yuduBook", fetchJson, {src: yuduBookSrc}, yuduBookFetched, constants.maxYuduBookFetchAttempts);
        };

        var loadContentDecryptionKey = function () {
            if (tools.isThisAnApp()) {
                var contentDecryptionKey = config.getFromQuery('contentDecryptionKey');
                if (contentDecryptionKey) {
                    contentDecryptionKeyFetched({contentDecryptionKey: contentDecryptionKey});
                }
                return;
            }

            var parameters = {
                nodeId: resources.yuduBook.settings.id.toString(),
                isPreview: resources.yuduBook.settings.preview.toString(),
                isWebReader: resources.yuduBook.settings.isWebReader.toString()
            };
            var contentDecryptionKeyUrl = tools.addToUrlQueryString(resources.yuduBook.settings.contentDecryptionKeyUrl,
                    parameters);
            makeAction("contentDecryptionKey", fetchJson, {src: contentDecryptionKeyUrl, noCacheControlHeader: true},
                    contentDecryptionKeyFetched);
        };

        var loadImages = function() {
            makeAction("playButtonTranslucent", fetchImage, {src: constants.playButtonTranslucentUrl}, playButtonTranslucentFetched);
            makeAction("overlayBackground", fetchImage, {src: constants.overlayBackgroundUrl}, overlayBackgroundFetched);
            makeAction("tileError", fetchImage, {src: constants.tileErrorUrl}, tileErrorFetched);
            makeAction("tileBackground", fetchImage, {src: constants.tileBackgroundUrl}, tileBackgroundFetched);
            makeAction("placeholderBackground", fetchImage, {src: constants.placeholderBackgroundUrl}, placeholderBackgroundFetched);
            makeAction("playButton", fetchImage, {src: constants.playButtonUrl}, playButtonFetched);
        };

        var loadBrandingConfigFiles = function() {
            makeAction("loadingConfig", fetchJson, {src: constants.brandingConfigFiles.loading}, loadingConfigFetched, constants.maxYuduBookFetchAttempts);
            makeAction("toolbarConfig", fetchJson, {src: constants.brandingConfigFiles.toolbar}, toolbarConfigFetched, constants.maxYuduBookFetchAttempts);
            makeAction("thumbnailsConfig", fetchJson, {src: constants.brandingConfigFiles.thumbnails}, thumbnailsConfigFetched, constants.maxYuduBookFetchAttempts);
            makeAction("drawingToolbarsConfig", fetchJson, {src: constants.brandingConfigFiles.drawingToolbars}, drawingToolbarsConfigFetched, constants.maxYuduBookFetchAttempts);
            makeAction("downloadPdfCustomSelectionToolbarConfig", fetchJson, {src: constants.brandingConfigFiles.downloadPdfCustomSelectionToolbar}, downloadPdfCustomSelectionToolbarConfigFetched, constants.maxYuduBookFetchAttempts);
        };

        var loadBrandingHtmlFiles = function() {
            makeAction("loadingHtml", fetchHtml, {src: constants.baseResourcesFolder + resources.loadingConfig.mainHtmlFilePath}, loadingHtmlFetched, constants.maxYuduBookFetchAttempts);
            makeAction("toolbarHtml", fetchHtml, {src: constants.baseResourcesFolder + resources.toolbarConfig.mainHtmlFilePath}, toolbarHtmlFetched, constants.maxYuduBookFetchAttempts);
            makeAction("thumbnailsHtml", fetchHtml, {src: constants.baseResourcesFolder + resources.thumbnailsConfig.mainHtmlFilePath}, thumbnailsHtmlFetched, constants.maxYuduBookFetchAttempts);
            makeAction("drawingToolbarsHtml", fetchHtml, {src: constants.baseResourcesFolder + resources.drawingToolbarsConfig.mainHtmlFilePath}, drawingToolbarsHtmlFetched, constants.maxYuduBookFetchAttempts);
            makeAction("downloadPdfCustomSelectionToolbarHtml", fetchHtml, {src: constants.baseResourcesFolder + resources.downloadPdfCustomSelectionToolbarConfig.mainHtmlFilePath}, downloadPdfCustomSelectionToolbarHtmlFetched, constants.maxYuduBookFetchAttempts);
        };

        var loadOptionalFiles = function() {
            var getPriceList = resources.yuduBook.settings.hasPriceList;
            var getRollovers = resources.yuduBook.settings.hasRollovers;
            var getYuduLogo = resources.yuduBook.settings.showYuduLogo;
            var getCustomLogo = resources.yuduBook.settings.showCustomLogo;

            if (getPriceList) {
                makeAction("priceList", fetchJson, {src: resources.yuduBook.settings.priceListUrl, altSrc: constants.priceListUrl}, priceListFetched, constants.maxOptionalJsonFetchAttempts, true);
            }

            if (getRollovers) {
                makeAction("rollovers", fetchJson, {src: resources.yuduBook.settings.rolloversUrl, altSrc: constants.rolloversUrl}, rolloversFetched, constants.maxOptionalJsonFetchAttempts, true);
            }

            if (getCustomLogo)
                makeAction("logo", fetchImage, {src: constants.baseResourcesFolder + resources.yuduBook.settings.customLogoFilename}, logoFetched);
            else if (getYuduLogo)
                makeAction("logo", fetchImage, {src: constants.logoUrl}, logoFetched);
        };

        var completeLoad = function() {
            events.emit(EMITTER_NAME, events.LOADING_ACTIONS_DONE, this, {});
        };

        // ON COMPLETIONS
        var overlayBackgroundFetched = function(img) {
            resources.overlayBackground = img;
        };

        var tileErrorFetched = function(img) {
            resources.tileError = img;
        };

        var tileBackgroundFetched = function(img) {
            resources.tileBackground = img;
        };

        var placeholderBackgroundFetched = function(img) {
            resources.placeholderBackground = img;
        };

        var playButtonFetched = function(img) {
            resources.playButton = img;
        };

        var playButtonTranslucentFetched = function(img) {
            resources.playButtonTranslucent = img;
        };

        var toolbarConfigFetched = function(data) {
            resources.toolbarConfig = data;
        };

        var thumbnailsConfigFetched = function(data) {
            resources.thumbnailsConfig = data;
        };

        var drawingToolbarsConfigFetched = function(data) {
            resources.drawingToolbarsConfig = data;
        };

        var downloadPdfCustomSelectionToolbarConfigFetched = function(data) {
            resources.downloadPdfCustomSelectionToolbarConfig = data;
        };

        var loadingConfigFetched = function(data) {
            resources.loadingConfig = data;
        };

        var toolbarHtmlFetched = function(data) {
            resources.toolbarHtml = data;
        };

        var thumbnailsHtmlFetched = function(data) {
            resources.thumbnailsHtml = data;
        };

        var drawingToolbarsHtmlFetched = function(data) {
            resources.drawingToolbarsHtml = data;
        };

        var downloadPdfCustomSelectionToolbarHtmlFetched = function(data) {
            resources.downloadPdfCustomSelectionToolbarHtml = data;
        };

        var loadingHtmlFetched = function(data) {
            resources.loadingHtml = data;
        };

        var logoFetched = function(img) {
            resources.logo = img;
        };

        var yuduBookFetched = function(data) {
            resources.setYuduBook(data.yuduBook);
            events.emit(EMITTER_NAME, events.YUDU_BOOK_LOADED, this, resources.yuduBook);
        };

        var contentDecryptionKeyFetched = function (data) {
            if (data.contentDecryptionKey) {
                config.contentDecryptionHeaders = {
                    "x-amz-server-side-encryption-customer-algorithm": "AES256",
                    "x-amz-server-side-encryption-customer-key": data.contentDecryptionKey,
                    "x-amz-server-side-encryption-customer-key-MD5":
                            encryptedResourceFetchingUtils.getBase64MD5DigestOfBase64Message(data.contentDecryptionKey)
                };
            }
        };

        var priceListFetched = function(data) {
            if (data)
                resources.priceList = data.items;
        };

        var rolloversFetched = function(data) {
            if (data)
                resources.rollovers = data.items;
        };

        var infoPageFetched = function(iFrame) {
            resources.infoPage = iFrame;
            localisation.localiseHtml($(iFrame).contents());
            if (resources.yuduBook.settings.showInfoScreenOnLaunch) {
                events.emit(EMITTER_NAME, events.INFORMATION_LOADED, this, {});
            }
        };

        var runLoadingActions = function(yuduBookUrl) {
            yuduBookSrc = yuduBookUrl;
            loadNextStep();
        };

        return {
            runLoadingActions: runLoadingActions,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('utils/resizeHelper',['constants', 'config/pageMode', 'config', 'resources', 'events', 'shared/utils/utils',
        'bowser'],
function(constants, pageMode, config, resources, events, sharedUtils,
        bowser) {
    var EMITTER_NAME = 'utils/resizeHelper';
    // define an arbitrary limit (%) to provide some buffer for false positives and unmeasured elements (like scrollbars)
    var arbitraryZoomScaleLimit = 1.0541328;

    var ResizeHelper = function() {
        var self = this;
        var resizeHelperElement;
        var isZoomedIn = false;
        var previousZoomFactor = 1;
        var lastMeasuredZoomFactor = 1;
        var readerElement;

        self.preinit = function() {
            createFullSizeElement();
            addResizeListenerToScroll();
        };

        /**
         * Creates a div that will be scaled to always fill the current viewport, allowing accurate size calculations
         *  based off its calculated dimensions
         * Should always be accurate since it uses `fixed` positioning
         */
        var createFullSizeElement = function() {
            resizeHelperElement = document.createElement('div');
            resizeHelperElement.classList.add('yuduUtilsResizeHelper');
            resizeHelperElement.classList.add('yuduUtilsSizeDetector');
            document.body.appendChild(resizeHelperElement);
        };

        /**
         * Accessor with cached looked
         * @returns {Element|undefined}
         */
        var getReaderElement = function() {
            if (!readerElement) {
                readerElement = document.getElementById('yudu_reader');
            }
            return readerElement;
        };

        /**
         * Get the calculated width of the fullsize element
         * @returns {number}
         */
        self.browserViewportWidth = function() {
            return resizeHelperElement.offsetWidth;
        };

        /**
         * Get the calculated height of the fullsize element
         * @returns {number}
         */
        self.browserViewportHeight = function() {
            return resizeHelperElement.offsetHeight;
        };

        /**
         * Attempts to check if the browser viewport is zoomed
         * Note that this will not be a strict value, since it will not include for example scrollbars
         * Also, it has only been tested for iOS mobile safari on iOS10
         * Originally inspired by the SO answer: http://stackoverflow.com/a/20016071/7189002 , however, it uses
         *  `documentElement.offsetWidth` instead of `screen.width`, since the former gives a reliable `1` when zoomed
         *  out, while the latter seems to give `1` in portrait and `0.75` when in landscape.
         * @returns {number}
         */
        self.viewportZoomFactor = function() {
            return document.documentElement.offsetWidth / window.innerWidth;
        };

        /**
         * Atomic function to update all states related to the zoom factor
         */
        self.touchZoomFactorState = function() {
            previousZoomFactor = lastMeasuredZoomFactor;
            lastMeasuredZoomFactor = self.viewportZoomFactor();
        };

        /**
         * Attempts to detect when a browser has "zoomed-in"
         * Updates the various tracked states as part of the check
         * Note that zoom detection and behaviour is different across platforms, so what works for one should not be
         *  assumed to be valid for another
         * This is currently only used to detect native zoom in mobile safari on iOS, to prevent chaos on iOS10
         *  which no longer respects `viewport scale` meta directives
         * @returns {boolean} is the browser in a zoomed-in state?
         */
        self.isIosAndHasViewportZoomed = function() {
            self.touchZoomFactorState();
            // the check for iOS here ensures zoom handling only happens on that platform: fragile code warning!
            // a greater-than check is used here because only if the user has zoomed in do we need to do anything
            var isZoomedNow = !!bowser.ios && lastMeasuredZoomFactor > arbitraryZoomScaleLimit;
            if (isZoomedNow != isZoomedIn) {
                isZoomedIn = isZoomedNow;
                events.emit(EMITTER_NAME, events.BROWSER_ZOOM_LEVEL_CHANGED, self, {isZoomedIn: isZoomedIn});
            }
            return isZoomedIn;
        };

        /**
         * Updates the config module's width and height, then emits a resize event for subscribers to update based
         *  on the new dimensions
         */
        self.updateSize = function() {
            // adjust for the toolbar
            var heightAdjust = 0;
            var widthAdjust = 0;
            if (config.isDesktop) {
                // desktop editions always need to account for the toolbar
                if (resources.toolbarConfig.desktopPosition == 'left' || resources.toolbarConfig.desktopPosition == 'right') {
                    widthAdjust = parseInt(resources.toolbarConfig.desktopSize);
                } else {
                    heightAdjust = parseInt(resources.toolbarConfig.desktopSize);
                }
            } else if (config.disableToggleToolbar) {
                // mobile editions only need to account for toolbar height if the toolbar does not auto-hide
                if (resources.toolbarConfig.touchPosition == 'left' || resources.toolbarConfig.touchPosition == 'right') {
                    widthAdjust = parseInt(resources.toolbarConfig.touchSize);
                } else {
                    heightAdjust = parseInt(resources.toolbarConfig.touchSize);
                }
            }
            var newWidth = self.browserViewportWidth() - widthAdjust;
            var newHeight = self.browserViewportHeight() - heightAdjust;

            if (!self.isIosAndHasViewportZoomed()) {
                // limit to window height - unless zoomed (iOS zoom makes the window seem smaller than the viewport)
                newHeight = Math.min(newHeight, window.innerHeight);
            }

            config.pixelDensity = window.devicePixelRatio || 1;

            var context = document.getElementById("yudu_readerCanvas").getContext('2d');

            var backingStoreRatio = context.webkitBackingStorePixelRatio ||
                    context.mozBackingStorePixelRatio ||
                    context.msBackingStorePixelRatio ||
                    context.oBackingStorePixelRatio ||
                    context.backingStorePixelRatio || 1;

            var ratio = config.pixelDensity / backingStoreRatio;

            config.canvasResizeWidth = newWidth;
            config.canvasResizeHeight = newHeight;

            config.width = newWidth * ratio;
            config.height = newHeight * ratio;

            //If the orientation has changed then change 1up/2up mode
            var newOrientation = config.width > config.height
                    ? constants.orientations.landscape
                    : constants.orientations.portrait;
            if (newOrientation != config.orientation) {
                // TODO: refactor this so auto-set two-page mode is called / verified even without an orientation change?
                pageMode.autoSetTwoPageMode();
                config.orientation = newOrientation;
                if (window.yudu_commonSettings) {
                    window.yudu_commonSettings.orientation = newOrientation;
                }
            }

            config.readerYOffset = getReaderElement().offsetTop;
            events.emit(events.ALL, events.RESIZE, self, { 'width': config.width, 'height': config.height });
        };

        /**
         * Listen to scroll events for zoom state changes
         * It turns out that some of the problems are caused by the iOS zoom events not emitting `resize` events
         *  For example, see: http://www.quirksmode.org/dom/events/resize_mobile.html
         * While researching alternative detection mechanisms, I came across an SO answer ([1]) referencing an external
         *  library that purported to detect size changes on arbitrary HTML DOM elements ([2])
         * I had a look at the `ResizeSensor` in that external library, and it was adding listeners to `scroll` events!
         * It turns out that scroll events are usually emitted at the end of a zoom, with sufficient regularity to
         *  be useful for checking for a change in zoom state
         * However, because the scroll event fires continuously during a pan, lots of events get fired, so any
         *  registered event listener must be careful not to do too much processing
         * Thus the below: it tries to add a `scroll` listener (on iOS10+ only) which checks if the zoom factor has
         *  changed, and if it has, calls a debounced size update function.
         * Since performance is critical here, we use the high-performant debounce function to try and minimise
         *  workload
         * [1]: http://stackoverflow.com/q/6492683/7189002
         * [2]: http://marcj.github.io/css-element-queries/
         */
        var addResizeListenerToScroll = function() {
            if (!bowser.ios || (bowser.osversion && parseInt(bowser.osversion) < 10)) {
                // Abort if not iOS, or known not to be iOS10+
                return;
            }
            console.log('Preparing to handle iOS 10 zoom mode.');
            var debouncedUpdate = sharedUtils.performanceCriticalDebounce(self.updateSize, 300);

            /**
             * Lightweight state check to determine if the viewport zoom has changed
             * @returns {boolean}
             */
            var hasZoomChanged = function() {
                self.touchZoomFactorState();
                return lastMeasuredZoomFactor != previousZoomFactor;
            };

            /**
             * Callback for a scroll event on the window
             * Note this could be performance restricting, so should only perform simple operations outside of a
             *  `requestAnimationFrame` call
             */
            var handleScroll = function() {
                if (!hasZoomChanged()) {
                    // ignore the event if the zoom is the same
                    return;
                }
                debouncedUpdate();
            };

            window.addEventListener('scroll', handleScroll);
        };

        self.preinit();
    };

    return new ResizeHelper();
});

define('shared/utils/versionUtils',[],
function() {
    var VersionUtils = function() {
        var self = this;
        var GREATER_THAN = 1;
        var EQUAL = 0;
        var LESS_THAN = -1;

        self.components = {
            reader: 'reader',
            app: 'app',
            appAndroid: 'appAndroid',
            appWindows: 'appWindows'
        };

        /**
         * Provide a standard way of storing a version number
         * Assumes a version number of distinct integers separated by dots of the form
         *  `major.minor.build.revision`
         * @param component {*} ; which component does this version correspond to
         * @param major {*}
         * @param minor {*}
         * @param build {*}
         * @param revision {*} (revision is an app-only identifier used for branding pack updates)
         * @constructor
         */
        self.VersionNumber = function(component, major, minor, build, revision) {
            var v = this;
            v.class = 'VERSION_NUMBER';

            /**
             * Helper to parse a possible input or default to 0
             * @param input {*}
             * @returns {number}
             */
            var versionOrZero = function(input) {
                var ret = 0;
                if (typeof input !== 'undefined') {
                    try {
                        ret = parseInt(input);
                    } catch (e) {
                        // leave it as 0
                    }
                    if (isNaN(ret)) {
                        ret = 0;
                    }
                }
                return ret;
            };

            v.component = component;
            v.major = versionOrZero(major);
            v.minor = versionOrZero(minor);
            v.build = versionOrZero(build);
            v.revision = versionOrZero(revision);

            /**
             * Returns whether this version is valid
             * Note that revision is not relevant to this check
             * @returns {boolean}
             */
            v.isValid = function() {
                return v.major > 0 || v.minor > 0 || v.build > 0;
            };

            /**
             * Helpful assertion that checks if two objects of this type can be compared
             * @param other ; {VersionNumber}
             * @throws if objects cannot be compared
             */
            v.assertCanCompareTo = function(other) {
                if (!other.class || other.class !== v.class) {
                    throw 'Invalid comparison target';
                }
            };

            /**
             * Helper to compare two version numbers
             * @param other ; {VersionNumber}
             * @returns {number} ; 1 if this is greater, -1 if this is less, 0 if equal
             */
            v.compareTo = function(other) {
                v.assertCanCompareTo(other);
                if (v.major > other.major) {
                    return GREATER_THAN;
                } else if (v.major < other.major) {
                    return LESS_THAN;
                }
                if (v.minor > other.minor) {
                    return GREATER_THAN;
                } else if (v.minor < other.minor) {
                    return LESS_THAN;
                }
                if (v.build > other.build) {
                    return GREATER_THAN;
                } else if (v.build < other.build) {
                    return LESS_THAN;
                }
                if (v.revision > other.revision) {
                    return GREATER_THAN;
                } else if (v.revision < other.revision) {
                    return LESS_THAN;
                }
                return EQUAL;
            };
        };

        /**
         * Helper that stringifies this version number object instance
         * @returns {string}
         */
        self.VersionNumber.prototype.toString = function() {
            var ret = [this.major, this.minor, this.build].join('.');
            if (this.component !== self.components.reader) {
                ret += '.' + this.revision;
            }
            return ret;
        };

        /**
         * Given a standard `x.y.z` form version number string,
         *  returns the appropriate `{VersionNumber}` object
         * @param component {string} ; the component identifier for this version number
         * @param v {string} ; the version string to parse
         * @returns {VersionUtils.VersionNumber}
         */
        self.parseVersionString = function(component, v) {
            var vParts = v.split('.');
            var major = vParts[0];
            var minor;
            var build;
            var revision;
            if (vParts.length > 1) {
                minor = vParts[1];
            }
            if (vParts.length > 2) {
                build = vParts[2];
            }
            if (vParts.length > 3) {
                revision = vParts[3];
            }
            return new self.VersionNumber(component, major, minor, build, revision);
        };
    };

    return new VersionUtils();
});

define('shared/version',['shared/utils/appUtils', 'shared/utils/utils', 'shared/utils/versionUtils'],
function(appUtils, utils, versionUtils) {
    // use a token to be replaced during the release build process
    // outside the usual release process, the string is parsed to `0.0.0` unless overridden
    var version = '4.3.49';
    // allow development-mode overriding
    if (version.length == 11 && version.substring(0, 9) === '-!version' && version.substring(9, 11) === '!-') {
        // default the developer version to the max safe integer so that version checks always succeed
        version = '9007199254740991';
    }

    var Versionator = function(readerVersion) {
        var self = this;
        var versionNumber = versionUtils.parseVersionString(versionUtils.components.reader, readerVersion);
        var appVersionNumber = false;

        // list of features with minimum required versions
        self.features = {
            phoneview: 'phoneview',
            speakerNotes: 'speakerNotes'
        };
        var featureCheckResults = {};

        /**
         * Return the current Reader instance's version
         * @returns {*} ; {VersionNumber}
         */
        self.getVersion = function() {
            return versionNumber;
        };

        /**
         * Return a version for the current app wrapper, if available
         * Returns a version of 0 for a placeholder component designator if not
         * @returns {*} ; {VersionNumber}
         */
        self.getAppVersion = function() {
            if (appVersionNumber === false) {
                appVersionNumber = appUtils.getVersion(versionUtils);
            }
            return appVersionNumber;
        };

        /**
         * Return a version for a specified component, if available
         * Returns `false` if not
         * @param component {string}
         * @returns {*} ; {VersionNumber|boolean}
         */
        self.getForComponent = function(component) {
            switch (component) {
                case versionUtils.components.reader:
                    return self.getVersion();
                case versionUtils.components.app:
                case versionUtils.components.appAndroid:
                case versionUtils.components.appWindows:
                    if (self.getAppVersion().component === component) {
                        return self.getAppVersion();
                    }
                    break;
            }
            return false;
        };

        /**
         * Check whether any known required minimum versions are exceeded for a target feature
         * Note that currently this function assumes:
         *  - `minimumVersions` is a hash of `self.feature` feature name strings to hashes
         *  - each sub hash maps `versionUtils.components` strings to the respective `minimumVersion` against which to check
         * @param featureName {string} ; `self.features` string
         */
        var checkMinimumExceededForFeature = function(featureName) {
            var featureMinimumVersions = minimumVersions[featureName];
            if (featureMinimumVersions) {
                for (var targetPlatform in featureMinimumVersions) {
                    if (featureMinimumVersions.hasOwnProperty(targetPlatform)) {
                        var componentVersion = self.getForComponent(targetPlatform);
                        if (componentVersion && componentVersion.compareTo(featureMinimumVersions[targetPlatform]) < 0) {
                            // current component version is less than the minimum: adjust for fail condition
                            featureCheckResults[featureName] = false;
                            return;
                        }
                    }
                }
            }
            featureCheckResults[featureName] = true;
        };

        /**
         * Check whether the current instance supports a target feature based on known minimum versions
         * @param feature {string} ; `self.features` string
         * @returns {boolean} ; `true` if feature supported
         */
        self.checkFeatureCompatibility = function(feature) {
            if (typeof featureCheckResults[feature] === 'undefined') {
                checkMinimumExceededForFeature(feature);
            }
            return featureCheckResults[feature];
        };

        //region Minimum versions
        // keep track of any features that have required minimum versions to function
        var minimumVersions = {};

        /**
         * Helper to add a minimum required version for a keynamed feature
         * @param feature {string} ; the name of the version-limited feature
         * @param component {string} ; the component the version applies to
         * @param versionArray {Array} ; array of version number parts in decreasing precedence
         */
        var addMinimumVersion = function(feature, component, versionArray) {
            if (!minimumVersions[feature]) {
                minimumVersions[feature] = {};
            }
            // note that array indexes return `undefined` if out of bounds, which is parsed to 0 by the constructor
            minimumVersions[feature][component] = new versionUtils.VersionNumber(component,
                    versionArray[0], versionArray[1], versionArray[2], versionArray[3]);
        };

        addMinimumVersion(self.features.phoneview, versionUtils.components.appAndroid, [10, 2]);
        addMinimumVersion(self.features.phoneview, versionUtils.components.appWindows, [1, 3, 0]);
        addMinimumVersion(self.features.speakerNotes, versionUtils.components.appWindows, [1, 3, 1]);
        //endregion
    };

    var moduleSingleton = new Versionator(version);

    // define a global read-only property
    Object.defineProperty(window, 'yudu_readerVersion', {
        get: function () {
            return moduleSingleton.getVersion().toString();
        }
    });

    return moduleSingleton;
});

define('controllers/articleViewController',['constants', 'config', 'resources', 'events', 'shared/version', 'shared/utils/appWrapHook', 'utils/tools',
            'shared/ui/messageBox', 'ui/uiTools', 'jquery'],
function(constants, config, resources, events, version, appWrapHook, tools,
         messageBox, uiTools, $) {
    /*
     * Please note that as of 10/08/2016, the feature internally referred to as "article view" or "html articles"
     *  is now publicly referred to as "phoneview"
     * The "phoneview" submodule in the branding pack relates to the article view component triggered by this controller
     */
    var ArticleViewController = function() {
        var self = this;
        var lastKnownState = false;
        self.EMITTER_NAME = 'articleViewController';

        var preinit = function() {
            // TODO: verify the message handling is still required, or remove it
            events.subscribe(events.ALL, events.MESSAGE_RECEIVED_FROM_ARTICLE_VIEW, handleWindowMessage);
            events.subscribe(events.ALL, events.QUERY_STRING_PARSED, checkForErrorState);
            appWrapHook.registerHandlerForMessageWithParameters('exitArticleView',
                    function(origin, parameters) {articleViewClosedWithState(parameters)}); // directly from the view
            appWrapHook.registerHandlerForMessageWithParameters('exitedArticleView',
                    function(origin, parameters) {articleViewClosedWithState(parameters)}); // from the app
        };

        var checkForErrorState = function() {
            if (config.getFromQuery('phoneviewCriticalError') === 'error49') {
                openErrorDialog();
            }
        };

        var openErrorDialog = function() {
            messageBox.displayByCode("phoneview.criticalError", constants.messageTypes.failure);
        };

        /**
         * Open the article view
         * @param args {{}} ; arguments for opening the article view
         */
        var openArticleView = function(args) {
            if (version.checkFeatureCompatibility(version.features.phoneview) && tools.isThisAnApp()
                    && (tools.deviceType.isAndroid() || tools.deviceType.isMetro())) {
                args.src = window.location.toString();
                args.bookId = resources.yuduBook.settings.id;
                appWrapHook.sendMessageWithParameters('openArticleView', args);
            } else {
                tools.openURL(targetUrlWithArgs(args), false);
            }
        };

        /**
         * Interface method to open the article view targeting a specific edition page
         * @param page {PageController} ; the page to target the article view for
         */
        self.openAtPage = function(page, samlData) {
            var args;
            if (typeof page != 'undefined') {
                args = generateArgs(pageControllerToArticleViewPageNumber(page));
            }
            if (samlData.samlAuthFailure) {
                args.samlAuthFailure = samlData.samlAuthFailure;
                args.samlErrorCode = samlData.samlErrorCode;
                args.samlErrorData = samlData.samlErrorData;
            }
            if (samlData.queryStringSamlAuthToken) {
                args.samlAuthToken = samlData.queryStringSamlAuthToken;
            }
            openArticleView(args);
        };

        /**
         * Interface method to open the article view targeting a specific article
         * @param article {string} ; the article to open
         * @param page {PageController} ; [optional] the page to target the article view for
         */
        self.openAtArticle = function(article, page) {
            var args = {
                article: article,
                mode: 'article'
            };
            if (page) {
                args.page = '' + pageControllerToArticleViewPageNumber(page);
            }
            openArticleView(args);
        };

        /**
         * Return the target URL required to open the article view targeting a specific edition page
         * @param args {{}} ; arguments for opening the article view
         * @returns {string}
         */
        var targetUrlWithArgs = function(args) {
            return tools.addToUrlQueryString(targetUrl(), args);
        };

        /**
         * Return the path to the article view page
         * @returns {string} relative URL for the article view page - may have a query string
         */
        var targetUrl = function() {
            // need to know this is an internal navigation
            return tools.addQueryStringToURL(constants.articleViewerPage, 'origin=reader');
        };

        /**
         * Creates a hash of parameters to be included int he call to the article view
         * Will include at a minimum the page number to open to, may also include previous known state
         * @param pageNumber {number}
         * @returns {{}}
         */
        var generateArgs = function(pageNumber) {
            // input is a number but a string is needed
            var pageString = '' + pageNumber;
            var args = {
                page: pageString
            };
            if (pageString === lastKnownState.page) {
                args.article = lastKnownState.article;
                if (typeof lastKnownState.articleIndex !== 'undefined') {
                    args.articleIndex = '' + lastKnownState.articleIndex;
                }
            }
            return args;
        };

        /**
         * Event handler
         * Process messages sent by the article view component
         * @param event
         */
        var handleWindowMessage = function(event) {
            if (event.data.messageType === 'exitArticleView') {
                closeArticleView(event.data.parameters);
            }
        };

        /**
         * Closes the article view
         * Only works if the view was opened by this module
         * If suitable state has been provided, stores it and updates the reader accordingly
         * @param state
         */
        var closeArticleView = function(state) {
            articleViewClosedWithState(state);
            uiTools.hideLightbox(true);
            events.emit(self.EMITTER_NAME, events.TOGGLE_KEY_NAVIGATION, this, {isAllowed: true});
        };

        var articleViewClosedWithState = function(state) {
            if (state.pageIndex >= 0) {
                lastKnownState = state;
                events.emit(self.EMITTER_NAME, events.GOTO_PAGE, this, {pageNumber: state.pageIndex + 1});
            } else {
                if (state.phoneviewCriticalError === 'error49') {
                    openErrorDialog();
                }
                lastKnownState = false;
            }
        };

        /**
         * Convert a page controller into its actual page number (not page index)
         * Page numbers are 1-indexed from the start of the edition
         *  no intro page => offset by 1
         *  intro page present => no offset
         * @param page {PageController}
         * @returns {number}
         */
        var pageControllerToArticleViewPageNumber = function(page) {
            return page.getPageNumber() + (config.hasIntroPage ? 0 : 1);
        };

        preinit();
    };

    return new ArticleViewController();
});
define('utils/rememberedPageUtils',['shared/storage', 'config'],
    function(storage, config) {

        /**
         * Retrieve the remembered page number from local storage. Note that if it had been stored more than one year
         * ago, it is considered invalid and thus not returned.
         * @param editionId The edition id to search for.
         * @returns {null|number} The remembered page number, if it exists and is valid.
         */
        var getRememberedPage = function(editionId) {
            if (config.rememberedPageDisabled) {
                return -1;
            }

            var rememberedPageKey = getKeyForEditionId(editionId);
            var timestampedPageNumber = storage.getItem(rememberedPageKey);
            storage.removeItem(rememberedPageKey);

            if (!timestampedPageNumber) {
                return -1;
            }

            var splitTimestampedPageNumber = timestampedPageNumber.split('-');
            var timestamp = Number(splitTimestampedPageNumber[0].trim());
            var pageNumber = Number(splitTimestampedPageNumber[1].trim());

            var timestampPlusOneYear = new Date(timestamp);
            timestampPlusOneYear.setFullYear(timestampPlusOneYear.getFullYear() + 1);
            if (timestampPlusOneYear.getTime() < new Date().getTime()) {
                return -1;
            }

            return pageNumber;
        };

        /**
         * Store the most recent page number in local storage. The key is based on the edition id. The value is a
         * timestamped page number.
         * @param editionId The edition id to store against.
         * @param pageNumber The page number to store.
         */
        var setRememberedPage = function(editionId, pageNumber) {
            if (config.rememberedPageDisabled) {
                return;
            }

            storage.setItem(getKeyForEditionId(editionId), (new Date().getTime() + "-" + pageNumber));
        };

        var getKeyForEditionId = function (editionId) {
            return "rememberedPage" + editionId;
        };

        return {
            getRememberedPage: getRememberedPage,
            setRememberedPage: setRememberedPage
        }

    });
define('ui/downloadPdfTools',['resources', 'utils/tools', 'config', 'shared/constants', 'jquery', 'shared/utils/stringUtils',
        'shared/localisation', 'shared/ui/messageBox', 'events', 'ui/bookmarks'],
    function(resources, tools, config, constants, $, stringUtils,
             localisation, messageBox, events, bookmarks) {
        var downloadWholePdfEnabled;
        var downloadCustomSelectionEnabled;
        var downloadBookmarkSelectionEnabled;
        var customSelectionToolbar;
        var reader;
        var emitterName = 'DOWNLOAD_PDF_TOOLS';
        var selectedPageIndexes = [];
        var bookmarkedPageIndexes = [];

        var init = function() {
            var settings = resources.yuduBook.settings;
            downloadWholePdfEnabled = settings.hasDownloadablePdf && !tools.isThisAnApp();
            downloadCustomSelectionEnabled = !!settings.userGeneratedPdfCreationUrl;
            downloadBookmarkSelectionEnabled = downloadCustomSelectionEnabled && config.bookmarksEnabled;

            if (downloadBookmarkSelectionEnabled) {
                events.subscribe(bookmarks.EMITTER_NAME, events.UGC_CHANGED, events.callback(this, bookmarksChanged),
                        false);
            }

            makeSettingsAvailableForBrandableDownloadPdfFeatures();
            makeFunctionsAvailableForBrandableDownloadPdfFeatures();
            setDownloadPdfCustomSelectionToolbarMode();
        };

        var makeSettingsAvailableForBrandableDownloadPdfFeatures = function() {
            window.yudu_downloadPdfSettings = {
                downloadWholePdfEnabled: downloadWholePdfEnabled,
                downloadCustomSelectionEnabled: downloadCustomSelectionEnabled,
                downloadBookmarkSelectionEnabled: downloadBookmarkSelectionEnabled
            };
        };

        var makeFunctionsAvailableForBrandableDownloadPdfFeatures = function() {
            window.yudu_downloadPdfFunctions = {};
            if (downloadWholePdfEnabled) {
                window.yudu_downloadPdfFunctions.downloadWholePdfClicked = onDownloadWholePdfClicked;
            }
            if (downloadCustomSelectionEnabled) {
                window.yudu_downloadPdfFunctions.downloadCustomSelectionClicked = onDownloadCustomSelectionClicked;
                window.yudu_downloadPdfFunctions.downloadCustomSelectionCancelClicked = onDownloadCustomSelectionCancelClicked;
                window.yudu_downloadPdfFunctions.downloadCustomSelectionSelectClicked = onDownloadCustomSelectionSelectClicked;
                window.yudu_downloadPdfFunctions.downloadCustomSelectionDoneClicked = onDownloadCustomSelectionDoneClicked;
            }
            if (downloadBookmarkSelectionEnabled) {
                window.yudu_downloadPdfFunctions.downloadBookmarkSelectionClicked = onDownloadBookmarkSelectionClicked;
            }
        };

        var setDownloadPdfCustomSelectionToolbarMode = function() {
            var position;
            var size;
            var mainToolbarSize;
            var dimension;
            var considerMainToolbarSizeWhenSettingReaderRules = false;

            if (config.isDesktop) {
                position = resources.downloadPdfCustomSelectionToolbarConfig.desktopPosition;
                size = parseInt(resources.downloadPdfCustomSelectionToolbarConfig.desktopSize.replace('px', ''));

                var mainToolbarPosition = resources.toolbarConfig.desktopPosition;
                if (position === mainToolbarPosition) {
                    mainToolbarSize = parseInt(resources.toolbarConfig.desktopSize.replace('px', ''));
                    size = Math.max(size, mainToolbarSize);
                }
                considerMainToolbarSizeWhenSettingReaderRules =
                        (position === 'top' && mainToolbarPosition === 'bottom')
                        || (position === 'bottom' && mainToolbarPosition === 'top')
                        || (position === 'left' && mainToolbarPosition === 'right')
                        || (position === 'right' && mainToolbarPosition === 'left');
            }
            else {
                position = resources.downloadPdfCustomSelectionToolbarConfig.touchPosition;
                size = parseInt(resources.downloadPdfCustomSelectionToolbarConfig.touchSize.replace('px', ''));
            }
            dimension = (position === 'top' || position === 'bottom') ? 'height' : 'width';

            var readerSizeRule = dimension + ": calc(100% - "
                    + (size + (considerMainToolbarSizeWhenSettingReaderRules ? mainToolbarSize : 0))
                    + "px) !important;";
            var readerDisplacementRule = position + " : " + size + "px;";
            var sheet = document.styleSheets[0];
            sheet.insertRule("#yudu_reader.yudu_downloadPdfCustomSelectionToolbarMode { " + readerSizeRule
                    + readerDisplacementRule + " }", 1);

            customSelectionToolbar = $('#yudu_downloadPdfCustomSelectionToolbar'
                    + stringUtils.capitalizeFirstLetter(position));
            customSelectionToolbar.css(dimension, size + 'px');
            customSelectionToolbar.append(resources.downloadPdfCustomSelectionToolbarHtml);
            window.yudu_commonFunctions.injectJavascript(
                    constants.baseResourcesFolder + resources.downloadPdfCustomSelectionToolbarConfig.mainJavascriptFilePath);
            localisation.localiseHtml(customSelectionToolbar);
        };

        var onDownloadWholePdfClicked = function() {
            if (reader.isShowingEncryptedPage()) {
                events.emit(events.ALL, events.SHOW_LOGIN, this, {});
            } else if (reader.hasEncryptedPage() && !config.decryptionKey) {
                messageBox.displayByCode('downloadPdf.loginRequired', constants.messageTypes.failure);
            } else {
                var url = constants.basePrintablesFolder + resources.yuduBook.settings.downloadablePdf;
                tools.openURL(url, true);
            }
        };

        var onDownloadCustomSelectionClicked = function() {
            customSelectionToolbar.show();
            $("#yudu_reader").addClass('yudu_downloadPdfCustomSelectionToolbarMode');
            emitUpdateSelectButtonLabelEvent('downloadPdf.customSelection.select', false);
            emitUpdateSelectPageIndicatorsEvent(getCurrentPageNumbers());
            events.subscribe(events.ALL, events.PAGE_CHANGED, onPageChanged, false);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, onPageChanged, false);
            emitCustomSelectionToolbarToggledEvent(true);
        };

        var onPageChanged = function() {
            var currentPageNumbers = getCurrentPageNumbers();
            var pageSpreadSelected = isPageSpreadSelected(currentPageNumbers.leftPageNumber,
                    currentPageNumbers.rightPageNumber);
            emitUpdateSelectButtonLabelEvent('downloadPdf.customSelection.'
                    + (pageSpreadSelected ? 'unselect' : 'select'), pageSpreadSelected);
            emitUpdateSelectPageIndicatorsEvent(currentPageNumbers);
        };

        var onDownloadCustomSelectionCancelClicked = function() {
            selectedPageIndexes = [];
            $("#yudu_reader").removeClass('yudu_downloadPdfCustomSelectionToolbarMode');
            customSelectionToolbar.hide();
            events.unsubscribe(events.ALL, events.PAGE_CHANGED, onPageChanged, false);
            events.unsubscribe(events.ALL, events.TWO_UP_CHANGED, onPageChanged, false);
            emitCustomSelectionToolbarToggledEvent(false);
        };

        var onDownloadCustomSelectionSelectClicked = function() {
            var currentPageNumbers = getCurrentPageNumbers();
            var leftPageNumber = currentPageNumbers.leftPageNumber;
            var rightPageNumber = currentPageNumbers.rightPageNumber;

            var pageSpreadSelected = isPageSpreadSelected(leftPageNumber, rightPageNumber);

            if (pageSpreadSelected) {
                selectedPageIndexes = tools.removeElementFromArray(selectedPageIndexes, leftPageNumber);
                if (rightPageNumber) {
                    selectedPageIndexes = tools.removeElementFromArray(selectedPageIndexes, rightPageNumber);
                }
                emitUpdateSelectButtonLabelEvent('downloadPdf.customSelection.select', false);
            }
            else {
                if (leftPageNumber === 0 && config.hasIntroPage) {
                    if (rightPageNumber) {
                        selectedPageIndexes.push(rightPageNumber);
                        emitUpdateSelectButtonLabelEvent('downloadPdf.customSelection.unselect', true);
                    }
                    else {
                        messageBox.displayByCode('downloadPdf.customSelection.introPageWarning',
                                constants.messageTypes.default);
                    }
                }
                else {
                    selectedPageIndexes.push(leftPageNumber);
                    if (rightPageNumber) {
                        selectedPageIndexes.push(rightPageNumber);
                    }
                    emitUpdateSelectButtonLabelEvent('downloadPdf.customSelection.unselect', true);
                }
            }
        };

        var onDownloadCustomSelectionDoneClicked = function() {
            if (!selectedPageIndexes || selectedPageIndexes.length === 0) {
                messageBox.displayAdvancedTwoButtonPopup({
                    text: localisation.get('downloadPdf.customSelection.noSelectedPagesWarning'),
                    leftLabel: localisation.get('downloadPdf.customSelection.no'),
                    rightLabel: localisation.get('downloadPdf.customSelection.yes'),
                    rightCallback: onDownloadCustomSelectionCancelClicked
                });
                return;
            }

            sendUserGeneratedPdfCreationRequest(selectedPageIndexes);
            onDownloadCustomSelectionCancelClicked();
        };

        var getCurrentPageNumbers = function() {
            var leftPageNumber = reader.shifter.getCentreTray().pages[0].page.number;
            var rightPageNumber;
            var rightPage = reader.shifter.getCentreTray().pages[1];
            if (config.twoPageMode && rightPage) {
                rightPageNumber = rightPage.page.number;
            }
            return { leftPageNumber: leftPageNumber, rightPageNumber: rightPageNumber };
        };

        /**
         * Note that a page spread is selected if:
         *   * it consists of a single page and that page is selected and is not the intro page (the intro page is not selectable)
         *   * it consists of two pages and
         *     * either both pages are selected
         *     * or the RHS page is selected and the LHS page is the intro page
         * Otherwise, the page spread is not selected.
         */
        var isPageSpreadSelected = function(leftPageNumber, rightPageNumber) {
            var leftPageSelected = selectedPageIndexes.includes(leftPageNumber);
            var spreadSelected = leftPageSelected;
            if (rightPageNumber) {
                var rightPageSelected = selectedPageIndexes.includes(rightPageNumber);
                spreadSelected = (leftPageSelected || (leftPageNumber === 0 && config.hasIntroPage))
                        && rightPageSelected;
            }
            return spreadSelected;
        };

        var emitUpdateSelectButtonLabelEvent = function(newLabelCode, pageSpreadSelected) {
            events.emit(emitterName, events.DOWNLOAD_PDF_CUSTOM_SELECTION_TOOLBAR.UPDATE_SELECT_BUTTON_LABEL, this,
                    { newLabel: localisation.get(newLabelCode), pageSpreadSelected: pageSpreadSelected});
        };

        var emitUpdateSelectPageIndicatorsEvent = function(currentPageNumbers) {
            events.emit(emitterName, events.DOWNLOAD_PDF_CUSTOM_SELECTION_TOOLBAR.UPDATE_CURRENT_PAGES, this,
                currentPageNumbers);
        }

        var emitCustomSelectionToolbarToggledEvent = function(showing) {
            events.emit(emitterName, events.DOWNLOAD_PDF_CUSTOM_SELECTION_TOOLBAR.TOOLBAR_TOGGLED, this,
                    {showing: showing});
        };

        var onDownloadBookmarkSelectionClicked = function() {
            if (!bookmarkedPageIndexes || bookmarkedPageIndexes.length === 0) {
                messageBox.displayByCode('downloadPdf.noBookmarks', constants.messageTypes.default);
                return;
            }

            sendUserGeneratedPdfCreationRequest(bookmarkedPageIndexes);
        };

        var initBookmarkedPageIndexes = function() {
            var numberOfPages = resources.yuduBook.pages.length + (config.hasIntroPage ? 1 : 0);
            for (var pageIndex = 0; pageIndex < numberOfPages; pageIndex++) {
                bookmarks.pageHasBookmark(pageIndex) && bookmarkedPageIndexes.push(pageIndex);
            }
        };

        var bookmarksChanged = function(event) {
            bookmarkedPageIndexes = [];
            Object.keys(event.data.bookmarks).forEach(function(pageNumber) {
                !event.data.bookmarks[pageNumber].isDeleted && bookmarkedPageIndexes.push(pageNumber);
            });
        };

        var sendUserGeneratedPdfCreationRequest = function(pageIndexes) {
            pageIndexes = pageIndexes.map(function(pageNumber) {
                return pageNumber - (config.hasIntroPage ? 1 : 0);
            });
            pageIndexes.sort(function(a, b) {
                return a - b;
            });

            var data = {
                nodeId: resources.yuduBook.settings.id,
                pageIndexes: JSON.stringify(pageIndexes),
                isPreview: config.isPreviewEdition
            };
            if (config.decryptionKey) {
                data.decryptionKey = config.decryptionKey;
            }
            $.ajax({
                url: resources.yuduBook.settings.userGeneratedPdfCreationUrl,
                type: 'POST',
                dataType: 'json',
                data: data,
                headers: {
                    Accept: "application/json",
                },
                success: function (data) {
                    if (!data.success) {
                        messageBox.displayByCode('downloadPdf.error', constants.messageTypes.failure);
                        return;
                    }

                    var userGeneratedPdfUrl = data.userGeneratedPdfUrl;
                    messageBox.displayWithLink(localisation.get('downloadPdf.success'), userGeneratedPdfUrl,
                            userGeneratedPdfUrl, constants.messageTypes.success);
                },
                error: function() {
                    messageBox.displayByCode('downloadPdf.error', constants.messageTypes.failure);
                }
            });

            messageBox.displayByCode('downloadPdf.requestSent', constants.messageTypes.default);
        };

        return {
            init: init,
            onDownloadWholePdfClicked: onDownloadWholePdfClicked,
            onDownloadCustomSelectionClicked: onDownloadCustomSelectionClicked,
            setReader: events.callback(this, function(aReader) { reader = aReader; }),
            initBookmarkedPageIndexes: initBookmarkedPageIndexes
        };
});

define('utils/speakerNotes',['events', 'config', 'constants', 'shared/resources', 'shared/utils/appWrapHook', 'shared/utils/appUtils',
        'shared/version'],
    function (events, config, constants, resources, appWrapHook, appUtils,
              version) {
        var speakerNotesMapping;
        var reader;

        var init = function(theReader) {
            if (!appUtils.deviceType.isMetro() || !version.checkFeatureCompatibility(version.features.speakerNotes)) {
                return;
            }

            reader = theReader;

            $.ajax({
                url: constants.speakerNotesFolder + "mapping.json",
                dataType: "json",
                success: continueInit
            });
        }

        var continueInit = function(data) {
            speakerNotesMapping = data;
            events.subscribe(events.ALL, events.PAGE_CHANGED, sendLoadSpeakerNotesRequest, false);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, sendLoadSpeakerNotesRequest, false);
            addEventListener('visibilityChange', sendHideSpeakerNotesRequest);
            sendShowSpeakerNotesRequest();
            sendLoadSpeakerNotesRequest();
        }

        var sendShowSpeakerNotesRequest = function() {
            appWrapHook.sendMessage("showSpeakerNotes");
        }

        var sendHideSpeakerNotesRequest = function() {
            appWrapHook.sendMessage("hideSpeakerNotes");
        };

        var sendLoadSpeakerNotesRequest = function() {
            var params = {};
            var pageNumbers = getCurrentPageNumbers();
            params.leftPageSpeakerNotesUrl = constants.speakerNotesFolder
                + speakerNotesMapping[pageNumbers.leftPageIndex];
            if (pageNumbers.rightPageIndex) {
                params.rightPageSpeakerNotesUrl = constants.speakerNotesFolder
                    + speakerNotesMapping[pageNumbers.rightPageIndex];
            }
            params.editionId = resources.yuduBook.settings.id;
            appWrapHook.sendMessageWithParameters("loadSpeakerNotes", params);
        }

        var getCurrentPageNumbers = function() {
            var leftPageIndex = reader.shifter.getCentreTray().pages[0].page.number - (config.hasIntroPage ? 1 : 0);
            var rightPageIndex;
            var rightPage = reader.shifter.getCentreTray().pages[1];
            if (config.twoPageMode && rightPage) {
                rightPageIndex = rightPage.page.number - (config.hasIntroPage ? 1 : 0);
            }
            return { leftPageIndex: leftPageIndex, rightPageIndex: rightPageIndex };
        };

        return {
            init: init
        }
    });

define('reader',['events', 'config', 'constants', 'resources', 'controllers/pageController', 'controllers/shifter', 'fetching/fetchHandler',
        'model/htmlOverlay', 'model/ugc/note', 'ui/bookmarks', 'ui/highlightingCanvas', 'ui/loading', 'ui/notes', 'ui/thumbnails',
        'ui/search', 'ui/uiTools', 'utils/tools', 'utils/loadingActions', 'utils/statistics', 'shared/localisation', 'shared/utils/appWrapHook',
        'utils/resizeHelper', 'controllers/articleViewController', 'config/pageMode', 'shared/device',
        'utils/rememberedPageUtils', 'jquery', 'easel', 'shared/utils/utils', 'ui/downloadPdfTools', 'utils/speakerNotes', 'shared/utils/appUtils'],
    function(events, config, constants, resources, pageController, shifter, fetchHandler,
             htmlOverlay, note, bookmarks, highlightingCanvas, loading, notes, thumbnails,
             search, uiTools, tools, loadingActions, statistics, localisation, appWrapHook,
             resizeHelper, articleViewController, pageMode, device,
             rememberedPageUtils, $, createjs, utils, downloadPdfTools, speakerNotes, appUtils) {

        var EMITTER_NAME = "reader";

        /**
         * Class that represents a reader.
         * @param elementId the elementId to attach to. No # at the start needed!
         * for performance reasons.
         * @constructor
         */
        var Reader = function(elementId) {
            //properties from construction parameters
            var self = this;
            this.elementId = elementId;
            this.tilesLoaded = false;

            this.informationIsShowingOnLaunch = false;
            this.wasInTwoUpMode = false;

            // setup environment vars
            config.setIsDesktop(!device.mayBeTouchCapable());

            /**
             * Load the reader.
             * @param yuduBookURL the URL to load the yudu book from.
             */
            this.load = function(yuduBookURL) {
                var queryStringData = tools.parseQueryString(window.location.search.substr(1));
                config.setQueryObject(queryStringData);
                events.emit(EMITTER_NAME, events.QUERY_STRING_PARSED, this, {});

                events.subscribe(loadingActions.EMITTER_NAME, events.LOADING_ACTIONS_DONE, events.callback(this, this.loadAfterYuduBook), false);
                events.subscribe(loadingActions.EMITTER_NAME, events.CRITICAL_ERROR, events.callback(this, this.criticalError), false);
                events.subscribe(yudu_events.ALL, yudu_events.LOADING.DISPLAY_PROGRESS, this.handleTilesLoaded, false);
                loadingActions.runLoadingActions(yuduBookURL);
            };

            this.handleTilesLoaded = function(event) {
                if (event.data.percentage == 100 && !self.tilesLoaded) {
                    self.tilesLoaded = true;
                }
            };

            /**
             * Loads the reader's components from the settings in the yuduBook.
             * @param event the event that triggered this function.
             */
            this.loadAfterYuduBook = function(event) {
                this.yuduBook = resources.yuduBook;

                fetchHandler.setReader(this);
                search.setReader(this);
                search.readyInit();

                if (resources.yuduBook.settings.bookmarksEnabled) {
                    config.bookmarksEnabled = true;
                    bookmarks.setReader(this);
                }

                if (resources.yuduBook.settings.notesEnabled) {
                    config.notesEnabled = true;
                    notes.setReader(this);
                }

                if (resources.yuduBook.settings.highlightsEnabled) {
                    config.highlightsEnabled = true;
                    highlightingCanvas.setReader(this);
                }

                if (!!resources.yuduBook.settings.userGeneratedPdfCreationUrl || resources.yuduBook.settings.hasDownloadablePdf) {
                    downloadPdfTools.setReader(this);
                }

                if (resources.yuduBook.settings.requestEmailAddress) {
                    config.emailCollectionEnabled = true;
                }

                if (this.yuduBook.settings.urlNavigationTarget) {
                    config.urlNavigationTarget = this.yuduBook.settings.urlNavigationTarget;
                }

                config.disableExtraZoom = !!this.yuduBook.settings.disableExtraZoom;
                config.rememberedPageDisabled = !!this.yuduBook.settings.rememberedPageDisabled;
                config.editionListUrl = this.yuduBook.settings.editionListUrl;
                config.highlightLinksOnLoadEnabled = this.yuduBook.settings.highlightLinksOnLoadEnabled;
                config.disableToggleToolbar = this.yuduBook.settings.disableToggleToolbar;
                config.tryToOpenWebOverlaysInNewWindow = resources.yuduBook.settings.openWebOverlaysInNewWindow !== false;
                config.pageTurnEnabled = resources.yuduBook.settings.pageTurnEnabled;
                config.pageTurnAudioEnabled = resources.yuduBook.settings.pageTurnAudioEnabled;
                config.pageTurnDurationMs = resources.yuduBook.settings.pageTurnDurationMs;
                config.alternatePhoneviewNavigationEnabled = resources.yuduBook.settings.phoneview
                    && resources.yuduBook.settings.phoneview.isAvailable
                    && resources.yuduBook.settings.alternatePhoneviewNavigationEnabled;

                if (this.yuduBook.settings.allowHtmlMediaContentDownload === false) {
                    events.yuduOn($(document), 'contextmenu', 'video', function(e) {e.preventDefault();});
                    events.yuduOn($(document), 'contextmenu', 'audio', function(e) {e.preventDefault();});
                }

                config.overlap = this.yuduBook.settings.overlap || config.overlap;
                this.storeOverlaySettings(this.yuduBook.settings);
                this.setReaderBackground(this.yuduBook.settings);
                if (this.yuduBook.settings.showCustomLogo) {
                    config.logoLinkUrl = this.yuduBook.settings.customLogoUrl;
                }
                else if (this.yuduBook.settings.showYuduLogo) {
                    config.logoLinkUrl = this.yuduBook.settings.yuduLogoUrl;
                }

                config.editionLaunchableHtmlEnabled = !!this.yuduBook.settings.editionLaunchableHtml;

                config.orderFormEnabled = this.yuduBook.orderForm && this.yuduBook.orderForm.orderFormEnabled;

                this.pages = [];
                var pageInfo;
                this.pageIndexOffset = 1;
                if (this.yuduBook.settings.introPage) {
                    pageInfo = this.yuduBook.settings.introPage;
                    this.pages.push(new pageController.PageController(0, pageInfo, this.yuduBook.zoomSettings));
                    config.hasIntroPage = true;
                    this.pageIndexOffset = 0;
                }
                for (var i = 0; i < this.yuduBook.pages.length; i++) {
                    var pageIndex = config.hasIntroPage ? i + 1 : i;
                    pageInfo = this.yuduBook.pages[i];
                    //create uninitiated pages (they will be initiated when needed)
                    this.pages.push(new pageController.PageController(pageIndex, pageInfo, this.yuduBook.zoomSettings));
                }

                resources.wordPositions = new Array(this.yuduBook.pages.length);

                this.shifter = new shifter.Shifter(this.pages);
                this.stage.addChild(this.shifter.container);

                htmlOverlay.setShifter(this.shifter);
                note.setShifter(this.shifter);

                // update pageMode
                pageMode.configureFromYuduBook(this.yuduBook);

                // update query string with the page number in '<pageNumber>.html' if applicable
                this.handleDirectlyAccessedPage();

                var startPage = this.getStartPage();

                appWrapHook.init(this.hasEncryptedPage());

                statistics.setYuduBookSettings(this.yuduBook.settings);

                this.updateReaderSize();
                this.shifter.init(startPage);
                this.updatePageTitle();
                this.updateCurrentHistoryState();

                var currentPage = this.getCurrentPage();
                var currentPageIndex = this.pages.indexOf(currentPage);
                var newVisitData = {};
                if (config.twoPageMode && (currentPageIndex != 0 || config.hasIntroPage)) {
                    var isRightPage = ((currentPageIndex + (config.hasIntroPage ? 0 : 1)) % 2) == 1;
                    if (isRightPage) {
                        newVisitData = {
                            startPage: currentPage.getPageNumber() - 1,
                            startLabel: this.pages[currentPageIndex - 1].getPageLabel(),
                            secondStartPage: currentPage.getPageNumber(),
                            secondStartLabel: currentPage.getPageLabel()
                        };
                    } else if (currentPageIndex + 1 < this.pages.length) {
                        newVisitData = {
                            startPage: currentPage.getPageNumber(),
                            startLabel: currentPage.getPageLabel(),
                            secondStartPage: currentPage.getPageNumber() + 1,
                            secondStartLabel: this.pages[currentPageIndex + 1].getPageLabel()
                        };
                    } else {
                        newVisitData = {
                            startPage: currentPage.getPageNumber(),
                            startLabel: currentPage.getPageLabel()
                        };
                    }
                } else {
                    newVisitData = {
                        startPage: currentPage.getPageNumber(),
                        startLabel: currentPage.getPageLabel()
                    };
                }
                newVisitData.indexOffset = this.pageIndexOffset;
                statistics.newVisit(newVisitData);

                this.updatePageNavigation();

                rememberedPageUtils.setRememberedPage(this.yuduBook.settings.id, this.shifter.getCurrentPageNumber());

                if (resources.yuduBook.settings.prioritiseNavControls) {
                    var highestZ = 1;
                    $("#yudu_interactiveOverlays").find("*").each(function() {
                        var currentZ = parseInt($(this).css("z-index"), 10);
                        if(currentZ > highestZ) {
                            highestZ = currentZ;
                        }
                    });
                    highestZ += 1;
                    $("#yudu_nextPageNav").css("z-index", highestZ);
                    $("#yudu_previousPageNav").css("z-index", highestZ);
                }

                this.tryOverlayReveal();

                if (resources.yuduBook.settings.speakerNotesEnabled) {
                    speakerNotes.init(this);
                }

                if (resources.yuduBook.settings.useBackgroundImage) {
                    var backgroundImage = $("#yudu_readerBackgroundTiling");
                    backgroundImage.css('background-image', 'url(../html/resources/' + resources.yuduBook.settings.backgroundImageFilename + ')');
                    if (resources.yuduBook.settings.backgroundImageDisplayOption === "FIT") {
                        backgroundImage.css('background-size', 'contain');
                        backgroundImage.css('background-position', 'center');
                        backgroundImage.css('background-repeat', 'no-repeat');
                    } else if (resources.yuduBook.settings.backgroundImageDisplayOption === "STRETCH") {
                        backgroundImage.css('background-size', 'cover');
                        backgroundImage.css('background-repeat', 'no-repeat');
                    }
                }

                if (!appUtils.deviceType.isAndroid()) {
                    events.emit(EMITTER_NAME, events.INIT_GA_CONSENT)
                }

                events.emit(EMITTER_NAME, events.READER_LOADED, this, {success: event.data.success}, true);
            };

            this.tryOverlayReveal = function() {
                if (this.shifter != null && !this.informationIsShowingOnLaunch) {
                    this.shifter.performReveal();
                }
            };

            this.informationLoaded = function() {
                this.informationIsShowingOnLaunch = true;
            };

            this.informationHidden = function() {
                var informationWasShowingOnLaunch = this.informationIsShowingOnLaunch;
                this.informationIsShowingOnLaunch = false;
                if (informationWasShowingOnLaunch) {
                    this.tryOverlayReveal();
                }
            };

            /**
             * Stores the overlay colours in config
             * @param settings yudubook settings
             */
            this.storeOverlaySettings = function(settings) {
                config.emailLinkOverlayColour = settings.emailOverlayColour;
                config.phoneOverlayColour = settings.phoneOverlayColour;
                config.pageLinkOverlayColour = settings.pageLinkOverlayColour;
                config.webLinkOverlayColour = settings.webOverlayColour;
                config.productOverlayColour = settings.productCodeOverlayColour;
                config.launchableHtmlOverlayColour = settings.htmlLightboxOverlayColour;
                config.contentOverlayColour = settings.contentOverlayColour;
                config.overlayAlpha = settings.defaultOverlayAlpha / 100;
                config.transparentProductOverlays = settings.transparentProductOverlays;
            };

            /**
             * If a background gradient is specified in the yudubook settings applies it to the reader div
             * @param settings yudubook settings
             */
            this.setReaderBackground = function(settings) {
                var brandingSettings = resources.loadingConfig;
                var bgTopColour = brandingSettings.bgTopColour ? brandingSettings.bgTopColour : settings.bgTop;
                var bgBottomColour = brandingSettings.bgBottomColour ? brandingSettings.bgBottomColour : settings.bgBottom;
                if(!bgTopColour || !bgBottomColour)
                    return;

                this.element[0].style.background = "-webkit-gradient(linear, left top, left bottom, color-stop(0%, #" + bgTopColour + "), color-stop(100%, #" + bgBottomColour + "))";
                this.element[0].style.background = "-webkit-linear-gradient(top, #" + bgTopColour + ",#" + bgBottomColour + ")";
                this.element[0].style.background = "-o-linear-gradient(top, #" + bgTopColour + ",#" + bgBottomColour + ")";
                this.element[0].style.background = "-moz-linear-gradient(top, #" + bgTopColour + ",#" + bgBottomColour + ")";
                this.element[0].style.background = "-ms-linear-gradient(top, #" + bgTopColour + ",#" + bgBottomColour + ")";
                this.element[0].style.background = "linear-gradient(to bottom, #" + bgTopColour + ",#" + bgBottomColour + ")";
                $(document.body)[0].style.background="#"+bgTopColour;

                config.bgTopColour = bgTopColour;
                config.bgBottomColour = bgBottomColour;
            };

            this.updatePageTitle = function() {
                var pageNum = this.shifter.getCurrentPageNumber();
                var title = this.yuduBook.settings.name + (pageNum ? " :: " + (pageNum + (config.hasIntroPage ? 0 : 1)) : '');
                document.title = title;
            };

            this.criticalError = function() {
                if (this.criticalErrorElement) {
                    return;
                }
                this.criticalErrorElement = $('<div id="errorCover"><div id="criticalFail">' + localisation.get('criticalError') + '</div></div>');
                $(document.body).append(this.criticalErrorElement);
            };
            /**
             * Starts the reader. This equates to adding an event listener for the reader on the stage.
             */
            this.start = function() {
                //setup fps and tick
                createjs.Ticker.setFPS(constants.fps);
                createjs.Ticker.timingMode = createjs.Ticker.RAF;

                events.yuduAddEventListener(createjs.Ticker, "tick", events.callback(this, this.tick));

                //emit reader started event for subscribers
                events.emit(EMITTER_NAME, events.READER_STARTED, this, {}, true);
            };

            this.tick = function(event) {
                if (this.shifter.update(event.delta) && this.tilesLoaded) {
                    this.stage.update(event);
                    events.emit(events.ALL, events.READER_TICK_STAGE_UPDATE);
                }
            };

            this.getSafePageNumber = function(pageNumberOrLabel) {
                var pageNumberToSwapTo = -1;
                if (typeof pageNumberOrLabel == "number") {
                    if (pageNumberOrLabel >= 0 && pageNumberOrLabel < this.pages.length) {
                        pageNumberToSwapTo = pageNumberOrLabel;
                    }
                } else {
                    for (var i = 0; i < this.pages.length; i++) {
                        if (this.pages[i].getPageLabel() == pageNumberOrLabel) {
                            pageNumberToSwapTo = i;
                            break;
                        }
                    }
                }
                return pageNumberToSwapTo;
            };

            this.isFirstPage = function() {
                return this.shifter.isFirstPage();
            };

            this.isLastPage = function() {
                return this.shifter.isLastPage();
            };

            /**
             * Moves to the next page.
             */
            this.nextPage = function() {
                this.shifter.goNextPage();
            };

            this.nextPageUnanimated = function() {
                if (!this.isLastPage()) {
                    this.shifter.goNextPageUnanimated();
                }
            };

            /**
             * Moves to the previous page.
             */
            this.previousPage = function() {
                this.shifter.goPreviousPage();
            };

            this.previousPageUnanimated = function() {
                if (!this.isFirstPage()) {
                    this.shifter.goPreviousPageUnanimated();
                }
            };

            /**
             * Returns the current page or null if there isn't one.
             */
            this.getCurrentPage = function() {
                return this.shifter.getCurrentPage();
            };

            /**
             * Returns a list of the currently visible pages.
             */
            this.getPagesInCurrentTray = function() {
                return this.shifter.getCentreTray().pages;
            };

            /**
             * Returns the specified page or null if there isn't one.
             */
            this.getPage = function(pageNumber) {
                var pageIndex = this.getSafePageNumber(pageNumber - this.pageIndexOffset);
                if (pageIndex < 0) {
                    return null;
                } else {
                    return this.shifter.getPage(pageIndex);
                }
            };

            this.twoUpToggle = function() {
                if (config.fitOnlyWidth) {
                    config.setFitOnlyWidth(false);
                }
                pageMode.togglePageMode();
            };

            this.fitToWidth = function(fitWidth) {
                if (config.fitOnlyWidth) {
                    if (this.wasInTwoUpMode) {
                        pageMode.setTwoPageMode(true);
                    }
                    config.setFitOnlyWidth(fitWidth);
                    return;
                }
                this.wasInTwoUpMode = config.twoPageMode;
                pageMode.setTwoPageMode(false);

                if (this.shifter.willNewFitHaveVisibleEffect()) {
                    config.setFitOnlyWidth(fitWidth);
                } else {
                    this.shifter.triggerFalseZoom();
                }
            };

            this.goFullscreen = function() {
                var body = document.body;
                if (body.requestFullscreen) {
                    body.requestFullscreen();
                } else if (body.msRequestFullscreen) {
                    body.msRequestFullscreen();
                } else if (body.mozRequestFullScreen) {
                    body.mozRequestFullScreen();
                } else if (body.webkitRequestFullscreen) {
                    body.webkitRequestFullscreen()
                }
            };

            this.exitFullscreen = function() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen()
                }
            };

            /**
             * Resizes the canvas (and hence the stage).
             */
            this.resize = function() {
                this.stage.canvas.width = config.width;
                this.stage.canvas.height = config.height;
                this.stage.canvas.style.width = config.canvasResizeWidth + 'px';
                this.stage.canvas.style.height = config.canvasResizeHeight + 'px';
                this.interactionDiv.width = config.width;
                this.interactionDiv.height = config.height;
                this.interactionDiv.style.width = config.canvasResizeWidth + 'px';
                this.interactionDiv.style.height = config.canvasResizeHeight + 'px';
                this.scaleOverlayContainers();
            };

            this.resizeReader = function() {
                this.resize();
                this.updateReaderSize();
            };

            /**
             * Takes event data from a PageLinkOverlay being clicked, parses it and calls goToPage with result
             * @param event
             */
            this.goToPageResponder = function(event) {
                var number = parseInt(event.data.pageNumber);
                this.goToPage(number - this.pageIndexOffset);
            };

            this.goToPage = function(numberOrLabel) {
                var pageIndex = this.getSafePageNumber(numberOrLabel);

                if (pageIndex > 0)
                    pageIndex -= ((pageIndex + this.pageIndexOffset) % this.shifter.getPagesPerTray());

                if (pageIndex >= 0) {
                    this.shifter.goToPage(pageIndex);
                }
            };

            this.handleTap = function(event) {
                var tapPoint = {
                    x: event.data.pageX * config.pixelDensity,
                    y: (event.data.pageY - config.readerYOffset) * config.pixelDensity
                };

                // Check if shifter wants it (overlays)
                if (this.shifter.handleTap(tapPoint)) {
                    if (event.data.stopDetect) {
                        event.data.stopDetect();
                    }
                    return;
                }

                // Check for left/right screen taps
                if (tapPoint.x < config.width * constants.turnPageScreenTapThreshold) {
                    this.previousPage();
                    return;
                }
                else if (tapPoint.x > config.width * (1 - constants.turnPageScreenTapThreshold)) {
                    this.nextPage();
                    return;
                }

                if (config.alternatePhoneviewNavigationEnabled) {
                    if (this.tapIsWithinPageBounds(tapPoint)) {
                        this.openArticleView(config.twoPageMode
                            && this.shifter.getCentreTray().pages.length > 1 && tapPoint.x > config.width / 2);
                    }
                    return;
                }

                events.emit(EMITTER_NAME, events.SHOWHIDE_TOOLBAR, this, {toggle: true});
            };

            this.tapIsWithinPageBounds = function(tapPoint) {
                var bounds =this.getCurrentPage().getContainer().getBounds();
                var lowerBound = this.getCurrentPage().getContainer().localToGlobal(bounds.x, bounds.y);
                var boundsWidth = bounds.width;

                if (config.twoPageMode && this.shifter.getCentreTray().pages.length > 1) {
                    boundsWidth += bounds.width;
                }
                var upperBound = this.getCurrentPage().getContainer().localToGlobal(bounds.x + boundsWidth, bounds.y + bounds.height);

                return !(tapPoint.x < lowerBound.x
                    || tapPoint.y < lowerBound.y
                    || tapPoint.x > upperBound.x
                    || tapPoint.y > upperBound.y);
            };

            /**
             * Scale the overlay container (necessary when pixel density > 1)
             */
            this.scaleOverlayContainers = function() {
                var scale = 1 / config.pixelDensity;
                this.overlayContainer.style.webkitTransform = "scale(" + scale + "," + scale + ")";
                this.overlayContainer.style.transform = "scale(" + scale + "," + scale + ")";
                this.overlayContainer.style.width = config.canvasResizeWidth + 'px';
                this.overlayContainer.style.marginLeft = -1 * config.canvasResizeWidth * (1 - scale) / 2 + 'px';
                this.interactiveOverlayContainer.style.webkitTransform = "scale(" + scale + "," + scale + ")";
                this.interactiveOverlayContainer.style.transform = "scale(" + scale + "," + scale + ")";
                this.interactiveOverlayContainer.style.width = config.canvasResizeWidth + 'px';
                this.interactiveOverlayContainer.style.marginLeft = -1 * config.canvasResizeWidth * (1 - scale) / 2 + 'px';
                this.highlightingCanvasContainer.style.webkitTransform = "scale(" + scale + "," + scale + ")";
                this.highlightingCanvasContainer.style.transform = "scale(" + scale + "," + scale + ")";
                this.highlightingCanvasContainer.style.width = config.canvasResizeWidth + 'px';
                this.highlightingCanvasContainer.style.marginLeft = -1 * config.canvasResizeWidth * (1 - scale) / 2 + 'px';
                this.pageHighlightsContainer.style.webkitTransform = "scale(" + scale + "," + scale + ")";
                this.pageHighlightsContainer.style.transform = "scale(" + scale + "," + scale + ")";
                this.pageHighlightsContainer.style.width = config.canvasResizeWidth + 'px';
                this.pageHighlightsContainer.style.marginLeft = -1 * config.canvasResizeWidth * (1 - scale) / 2 + 'px';
                this.noteContainer.style.webkitTransform = "scale(" + scale + "," + scale + ")";
                this.noteContainer.style.transform = "scale(" + scale + "," + scale + ")";
                this.noteContainer.style.width = config.canvasResizeWidth + 'px';
                this.noteContainer.style.marginLeft = -1 * config.canvasResizeWidth * (1 - scale) / 2 + 'px';
            };

            this.updateReaderSize = function() {
                resizeHelper.updateSize();
                var navigationImages = $('img', this.interactionDiv);
                for (var i = 0, m = navigationImages.length; i < m; i++) {
                    $(navigationImages[i]).css('top', (($(this.interactionDiv).height() - navigationImages[i].height) / 2) + "px");
                }
            };

            //setup canvas
            this.element = $('#' + elementId);
            //set the initial size for the reader

            this.canvas = $('<canvas id="' + elementId + 'Canvas" ' + 'width="' + config.width + '" height="' + config.height + '"' +
                'style="width: ' + config.canvasResizeWidth + 'px; height: ' + config.canvasResizeHeight + 'px"' +
                '></canvas>');

            this.element.append(this.canvas);

            //setup containers
            this.overlayContainer = $("#yudu_overlays")[0];
            this.interactiveOverlayContainer = $("#yudu_interactiveOverlays")[0];
            this.highlightingCanvasContainer = $("#yudu_highlightingCanvasContainer")[0];
            this.pageHighlightsContainer = $("#yudu_pageHighlightsContainer")[0];
            this.noteContainer = $("#yudu_notes")[0];

            this.scaleOverlayContainers();

            this.interactionDiv = $("#yudu_interactionDiv")[0];

            this.interactionDiv.style.width = config.width + "px";
            this.interactionDiv.style.height = config.height + "px";
            this.interactionDiv.style.position = "absolute";
            // We need to give it a background colour to make it respond to events in IE.
            this.interactionDiv.style.backgroundColor = "rgba(0, 0, 0, 0)";

            //setup stage
            this.stage = new createjs.Stage(this.canvas.attr("id"));
            this.stage.snapToPixel = true;
            //this.stage.tickChildren = false;
            //TODO: look into optimisation that would allow us to re-enable this option
            //this.stage.tickOnUpdate = false;
            //this.stage.tickEnabled = false;

            this.pageChanged = function(event) {
                if(this.shifter.getCentreTray().containsEncryptedPage()) {
                    events.emit(EMITTER_NAME, events.SHOW_LOGIN, this, {});
                }

                var newPage = event.data.page;
                var thePage = this.pages[newPage];

                var pageViewData = {
                    newPage: thePage.getPageNumber(),
                    newPageLabel: thePage.getPageLabel(),
                    indexOffset: this.pageIndexOffset
                };
                if (event.data.page2) {
                    var thePage2 = this.pages[event.data.page2];
                    pageViewData.newPage2 = thePage2.getPageNumber();
                    pageViewData.newPageLabel2 = thePage2.getPageLabel();
                }
                statistics.pageView(pageViewData);

                var historyPage = (history && history.state ? history.state.page : 0) || 0;
                if (historyPage == newPage)
                    return;

                this.updatePageTitle();

                this.pushPageHistory(newPage);

                this.updatePageNavigation();

                rememberedPageUtils.setRememberedPage(this.yuduBook.settings.id, this.shifter.getCurrentPageNumber());
            };

            this.pushPageHistory = function(newPage) {
                var newUrl = tools.getLastPathComponent();
                if (newUrl == null) {
                    return;
                }

                var queryString = tools.getPrettyQueryString(newPage + this.pageIndexOffset);

                if (queryString && queryString.length > 2)
                    newUrl += "?" + queryString;
                if (history && history.pushState)
                    history.pushState({page: newPage}, document.title, newUrl);
            };

            this.updatePageNavigation = function() {
                var previousPageNav = $("#yudu_previousPageNav");
                var nextPageNav = $("#yudu_nextPageNav");
                var isTouchDevice = device.mayBeTouchCapable();
                var hideNavArrows = config.getFromQuery('hideEditionNavigationArrows') === "true";

                if ((isTouchDevice && hideNavArrows) || this.shifter.isFirstPage()) {
                    previousPageNav.hide();
                }
                else {
                    previousPageNav.show();
                }

                if ((isTouchDevice && hideNavArrows) || this.shifter.isLastPage()) {
                    nextPageNav.hide();
                }
                else {
                    nextPageNav.show();
                }
            };

            this.historyChange = function(event) {
                if (!this.shifter)
                    return;
                // if we've suffered a critical error. Do this:
                if (this.criticalErrorElement) {
                    location.reload();
                    return;
                }

                if (event.data.page != this.shifter.getCurrentPageNumber()) {
                    if ($("#yudu_lightboxBackground").is(":visible")) {
                        uiTools.hideLightbox();
                    }
                    this.shifter.goToSnapPage(event.data.page);
                }

                this.updatePageTitle();
            };

            this.updateCurrentHistoryState = function() {
                if (history && history.replaceState)
                    history.replaceState({page: this.shifter.getCurrentPageNumber()},
                                          document.title);
            };

            this.mouseOverEnabled = true;

            this.deactivateMouseMove = function() {
                this.mouseOverEnabled = false;
                $("#yudu_interactionDiv").off("mousemove");
            };

            this.fadeInOrOutOverlayIfNecessary = function(event) {
                for (var i = 0, l = this.shifter.getCentreTray().pages.length; i < l; i++) {
                    this.shifter.getCentreTray().pages[i].overlayLevel.handleMouseInteraction(event);
                }
            };

            this.getNextFreePage = function() {
                var currentPage = this.getCurrentPage().getPageNumber();
                var freePages = $.grep(this.pages.slice(currentPage), function(e) {return !e.encrypted;});
                if(freePages.length > 0) {
                    return freePages[0].getPageNumber() + 1;
                }
                return false;
            };

            this.hasEncryptedPage = function() {
                return ($.grep(this.pages, function(e) {return e.encrypted;}).length > 0);
            };

            this.isShowingEncryptedPage = function() {
                return this.shifter.getCentreTray().containsEncryptedPage();
            };

            this.isUgcEnabled = function() {
                return config.bookmarksEnabled || config.highlightsEnabled || config.notesEnabled;
            };

            this.openArticleView = function(openArticleForRightPage) {
                var page;
                if (this.shifter) {
                    if (openArticleForRightPage) {
                        page = this.shifter.getCentreTray().pages[1];
                    } else {
                        page = this.getCurrentPage();
                    }
                }
                const samlAuthFailure = utils.getLeafOrUndefined(config.queryObject, "samlAuthFailure");
                const samlErrorCode = utils.getLeafOrUndefined(config.queryObject, "samlErrorCode");
                const samlErrorData = utils.getLeafOrUndefined(config.queryObject, "samlErrorData");
                const queryStringSamlAuthToken = utils.getLeafOrUndefined(config.queryObject, 'samlAuthToken');
                var samlData = {
                  samlAuthFailure: samlAuthFailure,
                  samlErrorCode: samlErrorCode,
                  samlErrorData: samlErrorData,
                  queryStringSamlAuthToken: queryStringSamlAuthToken,
                };
                articleViewController.openAtPage(page, samlData);
            };

            this.handleOpenArticle = function(event) {
                if (event.data && event.data.article) {
                    articleViewController.openAtArticle(event.data.article, this.getCurrentPage());
                }
            };

            /**
             * Adds a 'page' query string parameter with the appropriate page number if the reader is loaded in a
             * <pageNumber>.html page. Note that if said parameter already exists, it takes precedence and is not
             * replaced by the path value.
             */
            this.handleDirectlyAccessedPage = function() {
                if (!(history && history.pushState && config.getFromQuery("page") == undefined)) {
                    return;
                }

                var lastPathElement = tools.getLastPathComponent();
                if (lastPathElement == null) {
                    return;
                }

                var pathPageNumber = lastPathElement.match(/^[\d]+/);
                if (!pathPageNumber || pathPageNumber.length == 0)
                    return;

                tools.addPageToQueryObjectAndPushPageHistory(parseInt(pathPageNumber[0]), false);
            };

            /**
             * Function that determines what the start page should be. Attempt to use the page query string parameter if
             * it exists, otherwise the remembered page if it exists. If neither of these are valid, attempt to use the
             * default start page set in Publisher. If that is also invalid, default to 0 (i.e. first page).
             * @returns {number} The start page number.
             */
            this.getStartPage = function () {
                var startPage = -1;
                var queryStringPage = config.getFromQuery("page");
                var rememberedPage = rememberedPageUtils.getRememberedPage(this.yuduBook.settings.id);
                // Prioritise the query string page number only if it's potentially valid (i.e. larger than -1).
                // One example of arriving at an edition with a -1 query string page number is opening an edition from
                //   the edition list in app.
                if (queryStringPage != undefined && queryStringPage > -1) {
                    startPage = this.getSafePageNumber(Number(config.getFromQuery("page")) - this.pageIndexOffset);
                }
                else if (rememberedPage > -1) {
                    startPage = this.getSafePageNumber(rememberedPage);
                    tools.addPageToQueryObjectAndPushPageHistory(rememberedPage + (config.hasIntroPage ? 0 : 1), true);
                }
                if (startPage <= -1) {
                    startPage = this.getSafePageNumber(Number(this.yuduBook.settings.defaultStartPage) || 0);
                }
                return startPage;
            };

            this.loadingFinished = function() {
                fetchHandler.activatePreloader();
            };

            //subscribe to some events
            events.subscribe(events.ALL, events.TAP, events.callback(this, this.handleTap), false);
            events.subscribe(events.ALL, events.RESIZE, events.callback(this, this.resize), false);
            events.subscribe(events.ALL, events.GOTO_NEXT_PAGE, events.callback(this, this.nextPage), false);
            events.subscribe(events.ALL, events.GOTO_PREVIOUS_PAGE, events.callback(this, this.previousPage), false);
            events.subscribe(events.ALL, events.GOTO_PAGE, events.callback(this, this.goToPageResponder), true);
            events.subscribe(events.ALL, events.PAGE_CHANGED, events.callback(this, this.pageChanged), true);
            events.subscribe(events.ALL, events.HISTORY_CHANGE, events.callback(this, this.historyChange), true);
            events.subscribe(events.ALL, events.MOUSE_MOVE_STOP, events.callback(this, this.deactivateMouseMove), false);
            events.subscribe(events.ALL, events.LOADING_FINISHED, events.callback(this, this.loadingFinished), false);
            events.subscribe(events.ALL, events.OPEN_ARTICLE, events.callback(this, this.handleOpenArticle), false);
            events.subscribe(events.ALL, events.INFORMATION_LOADED, events.callback(this, this.informationLoaded), false);
            events.subscribe(events.ALL, events.HIDE_INFORMATION, events.callback(this, this.informationHidden), false);

            //core properties
            this.pages = null;
        };

        return {
            Reader: Reader,
            EMITTER_NAME: EMITTER_NAME
        };
    });

define('api',['reader', 'events', 'interactions'],
    function(readerModule, events, interaction) {

        //the reader we are interfacing with
        var reader = null;

        var EMITTER_NAME = "api";

        /**
         * Creates a reader instance that is then controlled by this API.
         * @param elementId the elementId to create the reader in, should be a div and does not need to include a # at
         * the start.
         */
        var createReader = function(elementId) {
            reader = new readerModule.Reader(elementId);

            //load the reader using the yuduBook given in the URL
            reader.load("yuduBook.json");
        };

        /**
         * Resize the reader to account for new toolbars onscreen etc
         */
        var resizeReader = function() {
            reader.resizeReader();
        };

        /**
         * Zoom in the given direction on the current page.
         * @param direction an integer indicating direction (positive = in, negative = out) and magnitude
         * (1 will zoom in by one level, -3 will zoom out by 3 levels). If the number would cause an invalid
         * zoom level to be selected (i.e. < 0 or > the number of zoom levels) the max or min zoom level is
         * shown depending on direction.
         * @param x the x position the zoom should be centred around.
         * @param y the y position the zoom should be centred around.
         */
        var zoom = function(direction, x, y) {
            events.emit(EMITTER_NAME, events.ZOOM, this, {direction: direction, "scaled": false, "x": x, "y": y});
        };

        /**
         * Returns the current page's controller.
         * @returns {*}
         */
        var getCurrentPage = function() {
            return reader.getCurrentPage();
        };

        /**
         * Returns a list of the currently visible pages.
         * @returns [*]
         */
        var getPagesInCurrentTray = function() {
            return reader.getPagesInCurrentTray();
        };

        /**
         * Returns the page controller for a given page number.
         * @returns {*}
         */
        var getPage = function(pageNumber) {
            return reader.getPage(pageNumber);
        };

        /**
         * Returns the index of the current page.
         * @returns {number}
         */
        var getCurrentPageIndex = function() {
            return reader.getCurrentPage().getPageNumber();
        };

        /**
         * Returns the number of the current page.
         * @returns {number}
         */
        var getCurrentPageNumber = function() {
            return reader.getCurrentPage().getPageNumber() + reader.pageIndexOffset;
        };

        /**
         * Returns the label of the current page.
         * @returns {string}
         */
        var getCurrentPageLabel = function() {
            return reader.getCurrentPage().getPageLabel();
        };

        var isFirstPage = function() {
            return reader.isFirstPage();
        };

        var isLastPage = function() {
            return reader.isLastPage();
        };

        /**
         * Tells the reader to move to the next page. Does nothing if the reader is on the last page.
         */
        var nextPage = function() {
            reader.nextPage();
        };

        var nextPageUnanimated = function() {
            reader.nextPageUnanimated();
        };

        /**
         * Tells the reader to move to the previous page. Does nothing if the reader is on the first page.
         */
        var previousPage = function() {
            reader.previousPage();
        };

        var previousPageUnanimated = function() {
            reader.previousPageUnanimated();
        };

        var twoUpToggle = function() {
            reader.twoUpToggle();
        };

        var fitToWidth = function(fitWidth) {
            reader.fitToWidth(fitWidth);
        };

        var goFullscreen = function() {
            reader.goFullscreen();
        };

        var exitFullscreen = function() {
            reader.exitFullscreen();
        };

        /**
         * Goes to the page given. Does nothing if the page number is out of bounds or the label doesn't exist.
         * @param pageNumberOrLabel the page number or the page label to go to.
         */
        var goToPage = function(pageNumberOrLabel) {
            reader.goToPage(pageNumberOrLabel);
        };

        var getNextFreePage = function() {
            return reader.getNextFreePage();
        };

        var hasEncryptedPage = function() {
            return reader.hasEncryptedPage();
        };

        var isShowingEncryptedPage = function() {
            return reader.isShowingEncryptedPage();
        };

        var isUgcEnabled = function() {
            return reader.isUgcEnabled();
        };

        var openArticleView = function() {
            reader.openArticleView();
        };

        return {
            createReader: createReader,
            resizeReader: resizeReader,
            zoom: zoom,
            getPage: getPage,
            getPagesInCurrentTray: getPagesInCurrentTray,
            getCurrentPage: getCurrentPage,
            getCurrentPageIndex: getCurrentPageIndex,
            getCurrentPageNumber: getCurrentPageNumber,
            getCurrentPageLabel: getCurrentPageLabel,
            isFirstPage: isFirstPage,
            isLastPage: isLastPage,
            nextPage: nextPage,
            nextPageUnanimated: nextPageUnanimated,
            previousPage: previousPage,
            previousPageUnanimated: previousPageUnanimated,
            goToPage: goToPage,
            twoUpToggle: twoUpToggle,
            fitToWidth: fitToWidth,
            goFullscreen: goFullscreen,
            exitFullscreen: exitFullscreen,
            openArticleView: openArticleView,
            getNextFreePage: getNextFreePage,
            hasEncryptedPage: hasEncryptedPage,
            isShowingEncryptedPage: isShowingEncryptedPage,
            isUgcEnabled: isUgcEnabled
        };
    });

define('ui/contents',[],function() {
        var Contents = function() {
            /**
             * Given the contents data from the yudubook initialises the contents
             * @param contentsData
             */
            this.init = function(contentsData) {
                window.yudu_contentsSettings = {
                    contentsData: contentsData
                };
            };
        };

        return {
            Contents: Contents
        };
    });
define('ui/information',['config', 'events', 'interactions', 'resources', 'utils/userOptions',
        'shared/hammerManager', 'jquery'],
    function(config, events, interactions, resources, userOptions,
             hammerManager, $) {

        var EMITTER_NAME = "information";

        var iFrame = null;

        //initialises the information popup
        var init = function() {
            events.subscribe(events.ALL, events.INFORMATION_LOADED, events.callback(this, showInfo));
            events.subscribe(events.ALL, events.HIDE_INFORMATION, events.callback(this, handleDismiss));
        };

        /**
         * Shows the iFrame
         */
        var showInfo = function() {
            events.subscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback);
            interactions.setAllowKeyNavigation(false);
            // if user has told us not to show info. Don't do it.
            iFrame = resources.infoPage;
            iFrame.style.display = "block";
            var iFrameDoc = iFrame.contentDocument;
            if (iFrameDoc) {
                /*
                 * HammerJS has no concept of event propagation
                 * Adding listeners to a child and a parent will always trigger events on both
                 *  when the child is triggered
                 * To get around this, there are a couple of options:
                 *  - check the event target, and abort (in the parent) if it is the child
                 *      - requires a condition for abortion, which in this case would mean scanning
                 *          up an element's ancestry tree to check for a class: not ideal
                 *  - enable `domEvents` on both managers, and call `stopPropagation`
                 *      - requires the child manager be added first because Hammer triggers callbacks
                 *          in the order they are added
                 *      - achieves inconsistent results
                 *  - call `stopImmediatePropagation` on the child callback
                 *      - also requires the child manager be added first
                 *  - prevent all events on the child from propagating
                 *      - courtesy of https://github.com/hammerjs/hammer.js/issues/1064#issuecomment-271861428
                 * Since the iframe is simple, this uses the fourth option to just stop everything
                 */
                var bodyManager = hammerManager.createTapManager(iFrameDoc.body);
                bodyManager.on('tap', closeInfo);
                var elementsPreventingPropagation = iFrameDoc.getElementsByClassName('noTouch');
                for (var i = 0; i < elementsPreventingPropagation.length; i++) {
                    var noPropagationManager = hammerManager.createTapManager(elementsPreventingPropagation[i]);
                    noPropagationManager.on('hammer.input', stopPropagation);
                }
            }
        };

        var closeInfo = function() {
            events.emit(EMITTER_NAME, events.HIDE_INFORMATION, this, {});
        };

        var stopPropagation = function(event) {
            event.srcEvent.stopPropagation();
        };

        /**
         * Removes the information iFrame from the document
         */
        var handleDismiss = function() {
            events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback, false);
            var noRepeatCheckbox = $(iFrame).contents().find("#noRepeatShow");
            if (noRepeatCheckbox && noRepeatCheckbox.prop('checked'))
                userOptions.setNoShowInformationBox();

            if (iFrame) {
                iFrame.blur();
                $(iFrame).hide();
                iFrame = null;
            }

            events.emit(EMITTER_NAME, events.SHOWHIDE_TOOLBAR, this, {show: true});
            interactions.setAllowKeyNavigation(true);
            events.emit(EMITTER_NAME, events.SHOW_LOGIN, this, {});
        };

        var cancelCallback = events.callback(this, handleDismiss);

        return {
            init: init,
            showInfo: showInfo
        };
    });

define('shared/rememberMeToken',['shared/utils/eventUtils', 'shared/utils/utils', 'jquery', 'shared/storage'],
    function (eventUtils, utils, $, storage) {
        var setupComplete = false;
        var bookId = false;
        var authenticateWithExternalAuthId = false;
        var externalAuthId = false;
        var requestNewTokenDetailsUrl = false;
        var editionToken = false;
        var extAuthIdToken = false;

        var BOOK_PREFIX = "bookId-";
        var EXT_AUTH_ID_PREFIX = "extAuthId-";
        var REMEMBER_ME_TOKEN_KEY = "rememberMeTokenKey";
        var REMEMBER_ME_TOKEN_SECRET = "rememberMeTokenSecret";

        var setup = function(yuduBook) {
            if (!setupComplete) {
                var yuduBookSettings = yuduBook.settings;
                bookId = yuduBookSettings.id;
                if (yuduBookSettings.authenticateWithExternalAuthId) {
                    authenticateWithExternalAuthId = yuduBookSettings.authenticateWithExternalAuthId;
                    externalAuthId = yuduBookSettings.externalAuthId;
                }
                requestNewTokenDetailsUrl =
                    yuduBookSettings.rememberMeTokenBaseUrl + yuduBookSettings.requestSingleUseShortLifeTokenPath;
                setupComplete = true;
            }
        };

        var storeTokenDetails = function(tokenDetails) {
            for (var i = 0; i < tokenDetails.length; i++) {
                var token = tokenDetails[i];
                storage.setItem(token.identifier + "-" + REMEMBER_ME_TOKEN_KEY, token.key);
                storage.setItem(token.identifier + "-" + REMEMBER_ME_TOKEN_SECRET, token.secret);
            }
        };

        var hasTokenDetails = function() {
            var editionKey = storage.getItem(BOOK_PREFIX + bookId + "-" + REMEMBER_ME_TOKEN_KEY);
            var editionSecret = storage.getItem(BOOK_PREFIX + bookId + "-" + REMEMBER_ME_TOKEN_SECRET);
            if (editionKey && editionSecret) {
                editionToken = {key: editionKey, secret: editionSecret};
            }

            if (authenticateWithExternalAuthId) {
                var extAuthIdKey = storage.getItem(EXT_AUTH_ID_PREFIX + externalAuthId + "-" + REMEMBER_ME_TOKEN_KEY);
                var extAuthIdSecret = storage.getItem(EXT_AUTH_ID_PREFIX + externalAuthId + "-" + REMEMBER_ME_TOKEN_SECRET);
                if (extAuthIdKey && extAuthIdSecret) {
                    extAuthIdToken = {key: extAuthIdKey, secret: extAuthIdSecret};
                }
            }
            return editionToken || extAuthIdToken;
        };

        var addTokenData = function(data) {
            data.shortLifeRememberMeTokenLogin = true;
            if (editionToken) {
                data.editionRememberMeKey = editionToken.key;
                data.editionRememberMeSecret = editionToken.secret;
            }
            if (extAuthIdToken) {
                data.externalAuthId = externalAuthId;
                data.extAuthIdRememberMeKey = extAuthIdToken.key;
                data.extAuthIdRememberMeSecret = extAuthIdToken.secret;
            }
            return data;
        };

        var resetTokenDetails = function() {
            editionToken = false;
            extAuthIdToken = false;

            storage.removeItem(BOOK_PREFIX + bookId + "-" + REMEMBER_ME_TOKEN_KEY);
            storage.removeItem(BOOK_PREFIX + bookId + "-" + REMEMBER_ME_TOKEN_SECRET);

            if (authenticateWithExternalAuthId) {
                storage.removeItem(EXT_AUTH_ID_PREFIX + externalAuthId + "-" + REMEMBER_ME_TOKEN_KEY);
                storage.removeItem(EXT_AUTH_ID_PREFIX + externalAuthId + "-" + REMEMBER_ME_TOKEN_SECRET);
            }
        };

        var requestNewTokenDetails = utils.throttle(function() {
            if (!hasTokenDetails()) {
                return;
            }
            var data = addTokenData({bookId: bookId});
            $.ajax({
                url: requestNewTokenDetailsUrl,
                type: 'POST',
                dataType: 'json',
                data: data,
                success: eventUtils.callback(this, requestedTokenDetailsSuccess)
            })
        }, 900000); // Only allow the request to be sent once in 15 minutes

        var requestedTokenDetailsSuccess = function (data) {
            if (!data.success) {
                resetTokenDetails();
            } else if (data.authDetails && data.authDetails.rememberMeTokens) {
                storeTokenDetails(data.authDetails.rememberMeTokens);
            }
        };

        return {
            setup: setup,
            storeTokenDetails: storeTokenDetails,
            hasTokenDetails: hasTokenDetails,
            addTokenData: addTokenData,
            resetTokenDetails: resetTokenDetails,
            requestNewTokenDetails: requestNewTokenDetails
        }
    }
);
define('utils/rememberMeToken',['events', 'shared/rememberMeToken'],
    function (events, sharedRememberMeToken) {

        var init = function() {
            events.subscribe(events.ALL, events.YUDU_BOOK_LOADED, setup);
            // We subscribe to interaction event listeners after loading has finished to avoid resize events that occur
            // while the reader is loading
            events.subscribe(events.ALL, events.LOADING_FINISHED, registerInteractionListeners);
        };

        var setup = function(event) {
            sharedRememberMeToken.setup(event.data);
        };

        var registerInteractionListeners = function() {
            events.subscribe(events.ALL, events.ZOOM, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.ZOOM_SCALE, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.BROWSER_ZOOM_LEVEL_CHANGED, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.TAP, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.TOUCH, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.RESIZE, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.LEVEL_DRAGGED, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.PAGE_CHANGED, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.TWO_UP_CHANGED, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.DRAG, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.DRAG_END, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.DRAG_START, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.SHOWHIDE_TOOLBAR, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.MOUSE_MOVE_STOP, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.VIEW_NOTE, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.NOTE_MOVED, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.NOTES_BACKGROUND_INTERACTION, sharedRememberMeToken.requestNewTokenDetails, true);
            events.subscribe(events.ALL, events.CLOSE_LIGHTBOX, sharedRememberMeToken.requestNewTokenDetails, true);
        };

        var handleLoginFailure = function() {
            sharedRememberMeToken.resetTokenDetails();
            events.emit(events.ALL, events.SHOW_LOGIN, this, {});
        };

        return {
            init: init,
            storeTokenDetails: sharedRememberMeToken.storeTokenDetails,
            hasTokenDetails: sharedRememberMeToken.hasTokenDetails,
            addTokenData: sharedRememberMeToken.addTokenData,
            handleLoginFailure: handleLoginFailure
        }
    }
);
define('shared/samlAuthToken',['events', 'shared/storage'],
    function (events, storage) {
        var SAML_AUTH_TOKEN_KEY = "samlAuthTokenKey";
        var BOOK_PREFIX = "bookId-";
        var setupComplete = false;
        var bookId = "";

        var setup = function(event) {
            if (!setupComplete) {
                var yuduBookSettings = event.data.settings;
                bookId = yuduBookSettings.id;
                setupComplete = true;
            }
        };

        var init = function() {
            events.subscribe(events.ALL, events.YUDU_BOOK_LOADED, setup);
        }

        var storeToken = function(token) {
            if (setupComplete) {
                storage.setItem(BOOK_PREFIX + bookId + "-" + SAML_AUTH_TOKEN_KEY, token);
            }
        };

        var getToken = function() {
            if (setupComplete) {
                return storage.getItem(BOOK_PREFIX + bookId + "-" + SAML_AUTH_TOKEN_KEY) || null;
            } else return null;
        };

        var removeToken = function() {
            if (setupComplete) {
                storage.removeItem(BOOK_PREFIX + bookId + "-" + SAML_AUTH_TOKEN_KEY);
            }
        };

        return {
            init: init,
            setup: setup,
            storeToken: storeToken,
            getToken: getToken,
            removeToken: removeToken
        }
    }
);
define('shared/login',['jquery', 'shared/hammerManager', 'shared/resources', 'shared/config', 'shared/localisation', 'shared/constants', 'shared/events', 'shared/rememberMeToken', 'shared/utils/urlUtils', 'shared/utils/tools',
        'shared/storage', 'shared/samlAuthToken', 'shared/utils/utils',],
    function($, hammerManager, resources, config, localisation, constants, events, rememberMeToken, urlUtils, tools, storage,
             samlAuthToken, utils) {

        var EMITTER_NAME = 'sharedLogin';
        var self = this;
        self.loginUI = null;

        var samlResponseErrorCodes = {
            INVALID_CREDENTIALS: "invalidCredentials",
            SERVER_ERROR: "serverError",
            DATE_RESTRICTION_FAILURE: "dateRestrictionFailure",
        };
        var SAML_UNEXPECTED_ERROR = localisation.get("saml.genericError");
        var SAML_CONNECTION_ERROR = localisation.get("saml.noResponse");
        var VALIDATE_SAML_AUTH_TOKEN_URL_PATH_PART = "/validate";

        var coreSetupComplete = false;

        var nextLoginForUgc = false;
        var authenticationUrl = false;
        var subscribeUrl = false;
        var resetPasswordUrl = false;
        var suppressNextLoginPrompt = false;
        var text = {};
        var attemptLibraryCookieLogin = true;

        /**
         * Setup to perform prior to any login requests being sent
         * Should be a requirement of any other setup methods (other than the first `init` function)
         */
        var setupCore = function() {
            if (!coreSetupComplete) {
                var settings = resources.yuduBook.settings;
                authenticationUrl = settings.authenticationUrl;
                config.isPreviewEdition = settings.preview;
                coreSetupComplete = true;
            }
        };
        
        var getAuthenticationUrl = function () {
            return authenticationUrl;
        };

        /**
         * Displays response to login attempt
         * @param code
         * @param isError
         */
        var displayMessage = function(code, isError) {
            self.loginUI.response.text(localisation.get(code));
            if (isError) {
                self.loginUI.response.removeClass(constants.messageTypes.success);
                self.loginUI.response.addClass(constants.messageTypes.failure);
            } else {
                self.loginUI.response.removeClass(constants.messageTypes.failure);
                self.loginUI.response.addClass(constants.messageTypes.success);
            }

            self.loginUI.response.show();
        };

        var setupUi = function(loginUI, statistics) {
            self.loginUI = loginUI;
            setupCore();

            var subscribeManager = hammerManager.createTapManager(self.loginUI.subscribe[0]);
            subscribeManager.on('tap', function () {subscribe (statistics)});

            var resetPasswordManager = hammerManager.createTapManager(self.loginUI.resetPassword[0]);
            resetPasswordManager.on('tap', resetPassword);
            
            //prevent the user from being able to drag the page
            events.yuduOn(self.loginUI.background, "touchmove", stopPropagation);
            events.yuduOn(self.loginUI.prompt, "touchmove", stopPropagation);

            // The following two blocks are here to fix an i.e. bug which only appears on tablets and phones.
            // IE disables the txt box and one way to fix
            // this is to focus somewhere else and then back to the input.
            // If you have any other text box, you can use this to fix it.
            events.yuduOn(self.loginUI.usernameInput, config.clickAction, function(){
                self.loginUI.background.focus();
                self.loginUI.usernameInput.focus();
            });

            events.yuduOn(self.loginUI.passwordInput, config.clickAction, function(){
                self.loginUI.background.focus();
                self.loginUI.passwordInput.focus();
            });

            var settings = resources.yuduBook.settings;
            if (settings.useCustomLoginPrompts) {
                text.explanation = settings.loginExplanation;
                text.username = settings.loginUsername;
                text.password = settings.loginPassword;
            } else if (settings.drmRequiresEmailAddress === false && settings.isLibraryBook) {
                text.explanation = localisation.get("login.libraryPasswordExplanation");
                text.password = localisation.get("login.password");
            } else if (settings.isLibraryBook) {
                text.explanation = localisation.get("login.libraryExplanation");
                text.username = localisation.get("login.username");
                text.password = localisation.get("login.password");
            } else {
                text.explanation = localisation.get("login.explanation");
                text.username = localisation.get("login.username");
                text.password = localisation.get("login.password");
            }
            if (settings.subscribeButtonEnabled) {
                text.subscribe = settings.subscribeText;
                subscribeUrl = settings.subscribeUrl;
            }
            if (settings.resetPasswordButtonEnabled) {
                resetPasswordUrl = settings.resetPasswordUrl;
            }

            // Ensure the UI has been properly localised.
            localisation.localiseHtml(self.loginUI.loginButtons);
        };

        /**
         * Send login request to the server
         */
        var login = function() {
            displayMessage("login.contactingServer", false);
        };

        var show = function () {
            if (suppressNextLoginPrompt) {
                suppressNextLoginPrompt = false;
                return;
            }

            if (nextLoginForUgc) {
                self.loginUI.explanation.text(localisation.get("ugc.login.explanation"));
            } else {
                self.loginUI.explanation.text(text.explanation);
            }
            tools.showHideElement(self.loginUI.usernameInput.attr("placeholder", text.username),
                !(resources.yuduBook.settings.drmRequiresEmailAddress === false));
            self.loginUI.passwordInput.attr("placeholder", text.password);
            if (resources.yuduBook.settings.drmRequiresEmailAddress === false) {
                self.loginUI.passwordInput.addClass("noUsername");
            }

            tools.showHideElement(self.loginUI.subscribe, !!subscribeUrl);
            if (subscribeUrl)
                self.loginUI.subscribe.text(text.subscribe);

            tools.showHideElement(self.loginUI.resetPassword, !!resetPasswordUrl && !resources.yuduBook.settings.isLibraryBook);

            self.loginUI.background.show();

            self.loginUI.prompt.slideDown();
            setButtonSize(self.loginUI);

            //yep, you have to do this async for some reason...
            setTimeout(function() { self.loginUI.usernameInput.focus(); }, 0);
        };

        var attemptSamlLogin = function(isRetry) {
            const queryStringSamlAuthToken = utils.getLeafOrUndefined(config.queryObject, 'samlAuthToken');
            const storedSamlAuthToken = samlAuthToken.getToken();

            if (storedSamlAuthToken != null && !isRetry) {
                attemptBackgroundSamlLogin(storedSamlAuthToken);
            } else if (queryStringSamlAuthToken && !isRetry) {
                attemptBackgroundSamlLogin(queryStringSamlAuthToken);
            } else {
                getSamlRequestString();
            }
        };

        var getSamlRequestString = function() {
            var emitSamlRequestReceivedEvent = function (data) {
                events.emit(EMITTER_NAME, events.SAML_REQUEST_RECEIVED, this, data);
            };

            $.ajax({
                url: resources.yuduBook.settings.generateSamlRequestUrl,
                type: 'POST',
                dataType: "json",
                data: {
                    nodeId: resources.yuduBook.settings.id,
                    preview: resources.yuduBook.settings.preview,
                    platform: "HTML_READER"
                },
                headers: {
                    Accept: "application/json",
                },
                success: function (data) {
                    if (data.error) {
                        emitSamlRequestReceivedEvent({ error: data.error });
                    } else if (!data.encodedSignedRequest) {
                        emitSamlRequestReceivedEvent({ error: SAML_UNEXPECTED_ERROR });
                    } else {
                        emitSamlRequestReceivedEvent({ encodedSignedRequest: data.encodedSignedRequest });
                    }
                },
                error: function() {
                    emitSamlRequestReceivedEvent({ error: SAML_CONNECTION_ERROR });
                }
            });
        };

        var attemptBackgroundSamlLogin = function (token) {
            var emitSamlAuthTokenValidationResponseReceivedEvent = function (data) {
                events.emit(EMITTER_NAME, events.SAML_AUTH_TOKEN_VALIDATION_RESPONSE_RECEIVED, this, data);
            };

            var validateSamlAuthTokenUrl = resources.yuduBook.settings.handleSamlAuthTokenUrl
                + VALIDATE_SAML_AUTH_TOKEN_URL_PATH_PART;

            $.ajax({
                url: validateSamlAuthTokenUrl,
                type: 'POST',
                dataType: "json",
                data: {
                    samlAuthToken: token,
                    nodeId: resources.yuduBook.settings.id,
                    preview: resources.yuduBook.settings.preview,
                    platform: "HTML_READER"
                },
                headers: {
                    Accept: "application/json",
                },
                success: function (data) {
                    if (data.error) {
                        emitSamlAuthTokenValidationResponseReceivedEvent({ error: data.error });
                    } else if (!data.key) {
                        emitSamlAuthTokenValidationResponseReceivedEvent({ error: SAML_UNEXPECTED_ERROR });
                    } else {
                        emitSamlAuthTokenValidationResponseReceivedEvent(data);
                    }
                },
                error: function() {
                    emitSamlAuthTokenValidationResponseReceivedEvent({ error: SAML_CONNECTION_ERROR });
                }
            });
        };


        var showSamlLogin = function (encodedSignedRequest) {
            var form, input;
            form = document.createElement("form");
            form.method = "POST";
            form.action = resources.yuduBook.settings.samlAuthenticationUrl;
            input = document.createElement("input");
            input.type = "hidden";
            input.name = "SAMLRequest";
            input.value = encodedSignedRequest;
            form.appendChild(input);
            document.body.appendChild(form);
            form.submit();
        };

        var showSamlLoginFailure = function (errorMessage, onRetry) {
            self.loginUI.samlExplanation.text(localisation.get("saml.explanation") + errorMessage);
            events.yuduOn(self.loginUI.samlButton, config.clickAction, onRetry);
            self.loginUI.samlRetryPrompt.slideDown();
        };

        var onSamlAuthFailure = function(errorCode, errorData) {
            var samlErrorResponseCode = samlResponseErrorCodes[errorCode];
            var message = localisation.get("samlLogin." + samlErrorResponseCode);
            if (errorData) {
                message = message +
                    "\n\n" +
                    localisation.get('samlLogin.extraInformationMessage') +
                    errorData;
            }
            showSamlLoginFailure(message, samlRetry);
            samlAuthToken.removeToken();
        };

        var samlRetry = function() {
            attemptSamlLogin(true);
        };

        var onSamlError = function(errorMessage) {
            showSamlLoginFailure(errorMessage, samlRetry);
            samlAuthToken.removeToken();
        };

        var sendAjaxLoginRequest = function(data, authenticationUrl, successCallback, failureCallback) {
            $.ajax({
                url: authenticationUrl,
                type: 'POST',
                dataType: "json",
                data: data,
                success: successCallback,
                error: failureCallback
            });
        };

        var resetPassword = function() {
            displayMessage("login.reset.contactingServer", false);
            var data = {
                "nodeId": resources.yuduBook.settings.id,
                "emailAddress": self.loginUI.usernameInput.val()
            };
            $.ajax({
                url: resetPasswordUrl,
                type: 'POST',
                dataType: "json",
                data: data,
                success: events.callback(this, function(data) {
                    if (data.success) {
                        if (data.url != undefined) {
                            self.loginUI.response.hide();
                            urlUtils.openURL(data.url, true);
                        } else {
                            displayMessage("login.reset.sent", false);
                        }
                    } else {
                        displayMessage("login.reset.errors." + data.error, true);
                    }
                }),
                error: function() {
                    displayMessage("login.reset.genericError", true);
                }
            });
        };

        var subscribe = function(statistics) {
            if (statistics) {
                statistics.action({
                    actionType: statistics.events.subscribed,
                    extraInfo: subscribeUrl
                });
            }
            urlUtils.openURL(subscribeUrl, '_self', true);
        };

        /**
         * Prepare an object hash with login credentials for a login request
         * @param credentials ; a credentials object from the `lastUsedCredentials` submodule
         * @returns {*}
         */
        var getLoginData = function(credentials, sendLibraryCookieData) {
            var data = getCoreLoginData(sendLibraryCookieData);
            data.readerUid = credentials.readerUid;
            data.emailAddress = credentials.username;
            data.password = credentials.password;
            return data;
        };

        /**
         * Prepares an object hash with core, shared login data
         * @returns {*}
         */
        var getCoreLoginData = function(sendLibraryCookieData) {
            var data = {
                "bookId": resources.yuduBook.settings.id,
                "preview": config.isPreviewEdition,
                "libraryCookie": !!sendLibraryCookieData ? getLibrarySessionCookieData() : ""
            };
            if (nextLoginForUgc) {
                data.ignoreMissingKey = true;
                nextLoginForUgc = false;
            }
            return data;
        };

        var getLibrarySessionCookieData = function() {
            var libraryCookie = "library_session=";
            var decodedCookie = decodeURIComponent(document.cookie);
            var ca = decodedCookie.split(';');
            for (var i = 0; i < ca.length; i++) {
                var c = ca[i];
                while (c.charAt(0) == ' ') {
                    c = c.substring(1);
                }
                if (c.indexOf(libraryCookie) == 0) {
                    return encodeURIComponent(c.substring(libraryCookie.length));
                }
            }
            return "";
        };

        var stopPropagation = function(event) {
            event.preventDefault();
            return false;
        };

        var setButtonSize = function() {
            if (!events.isSubscribed(events.ALL, events.RESIZE, setButtonSize, false)) {
                events.subscribe(events.ALL, events.RESIZE, setButtonSize, false);
            }
            var height = Math.max(self.loginUI.resetPassword.children('div').height(), self.loginUI.loginSend.children('div').height()) + "px";
            self.loginUI.resetPassword.height(height);
            self.loginUI.loginSend.height(height);
        };

        var saveCurrentCredentials = function() {
            lastUsedCredentials.newCredentials(
                tools.getUniqueUserId(),
                self.loginUI.usernameInput.val(),
                self.loginUI.passwordInput.val()
            );
            return lastUsedCredentials.getCredentials();
        };

        var lastUsedCredentials = function() {
            var userHasSuppliedCredentials = false;
            var superCredentials = false;
            var readerUid = false;
            var username = false;
            var password = false;
            var tokenKey = false;
            var tokenId = false;
            var subscriberEmail = false;
            var subscriberId = false;
            var ssoSubscriberId = false;

            var registerListeners = function() {
                events.subscribe(events.ALL, events.CHANGE_FOR_LOGIN_DETAILS,
                    events.callback(this, tryFindingCredentialsFromEvent));
                events.subscribe(events.ALL, events.REQUEST_LOGIN_DETAILS,
                    events.callback(this, resendCredentials));
            };

            var tryFindingCredentialsFromEvent = function(event) {
                if (event && event.data) {
                    if (event.data.superLoginSuccess) {
                        var subId = event.data.subscriberId || false;
                        newSuperCredentials(event.data.tokenKey, event.data.tokenId,
                            event.data.subscriberEmail, subId, event.data.deviceId,
                            event.data.username, event.data.password);
                        events.emit(EMITTER_NAME, events.LOGIN_DETAILS_CHANGED, this, {
                            credentials: getCredentials()
                        })
                    }
                }
            };

            var resendCredentials = function() {
                if (getHasCredentials()){
                    events.emit(EMITTER_NAME, events.LOGIN_DETAILS_CHANGED, this, {
                        credentials: getCredentials()
                    })
                }
            };

            /**
             * Update the credentials object with new login details from a reader login request
             * Note that the calling function should emit a `LOGIN_DETAILS_CHANGED` event if the login is unsuccessful
             *  to ensure modules requiring login details are at least alerted to the change
             * @param newUid
             * @param newUsername
             * @param newPassword
             */
            var newCredentials = function(newUid, newUsername, newPassword) {
                superCredentials = false;
                readerUid = newUid;
                username = newUsername;
                password = newPassword;
                subscriberId = false;
                userHasSuppliedCredentials = username.length > 0 && password.length > 0
            };
            /**
             * Update the credentials object with new login details from a wrapper app
             * Note this function is not exposed to the reader directly
             * Note that the calling function should additionally emit a `LOGIN_DETAILS_CHANGED` event
             * @param newTokenKey ; the token's alphanumeric string value
             * @param newTokenId ; the ID of the token
             * @param newSubscriberEmail ; the email for the subscriber associated with the token
             * @param newSubscriberId ; the ID for the subscriber associated with the token, where known
             * @param newUid ; the device UID as supplied by the app
             * @param newUsername ; the new username
             * @param newPassword ; the new password
             */
            var newSuperCredentials = function(newTokenKey, newTokenId, newSubscriberEmail, newSubscriberId, newUid,
                                               newUsername, newPassword) {
                superCredentials = true;
                tokenKey = newTokenKey;
                tokenId = newTokenId;
                subscriberEmail = newSubscriberEmail;
                subscriberId = newSubscriberId;
                readerUid = newUid;
                username = newUsername;
                password = newPassword;
                userHasSuppliedCredentials = (username.length > 0 && password.length > 0) ||
                    (subscriberEmail.length > 0 && tokenKey && tokenId);
            };

            var getCredentials = function(shouldIncludeSubscriberId) {
                var credentials = {
                    "readerUid": readerUid,
                    "username": username,
                    "password": password
                };
                if (getCredentialsAreFromSuper()) {
                    credentials.tokenKey = tokenKey;
                    credentials.tokenId = tokenId;
                    credentials.subscriberEmail = subscriberEmail;
                }
                if(rememberMeToken.hasTokenDetails()) {
                    credentials.rememberMeTokenKey = rememberMeToken.hasTokenDetails().key;
                }
                if (shouldIncludeSubscriberId) {
                    credentials.ssoSubscriberId = ssoSubscriberId;
                }
                return credentials;
            };

            var getHasCredentials = function() {
                return userHasSuppliedCredentials;
            };

            var getCredentialsAreFromSuper = function() {
                return superCredentials;
            };

            /**
             * Fetch the username of the currently logged in subscriber
             * @returns {*} : string containing current email
             */
            var getUsername = function() {
                if (getHasCredentials() && !!username) {
                    return username;
                }
                return "";
            };

            var getSubscriberId = function() {
                return subscriberId;
            };

            var setSubscriberId = function(newId) {
                subscriberId = newId;
            };

            var getSsoSubscriberId = function() {
                return ssoSubscriberId;
            };

            var setSsoSubscriberId = function(newId) {
                ssoSubscriberId = newId;
            };

            return {
                registerListeners: registerListeners,
                newCredentials: newCredentials,
                getHasCredentials: getHasCredentials,
                getCredentialsAreFromSuper: getCredentialsAreFromSuper,
                getCredentials: getCredentials,
                getUsername: getUsername,
                getSubscriberId: getSubscriberId,
                setSubscriberId: setSubscriberId,
                getSsoSubscriberId: getSsoSubscriberId,
                setSsoSubscriberId: setSsoSubscriberId
            };
        }();

        var sso = function() {
            var KEY_YUDU_AUTH_TOKEN = 'yuduAuthToken';
            var KEY_YUDU_AUTH_ID = 'yuduAuthId';
            var KEY_UGC_KEY = 'ugcKey';
            var retrievedStates = {
                noTokenAvailable: 'noTokenAvailable',
                queryString: 'queryString',
                localStorage: 'localStorage'
            };
            var retrievedFrom = retrievedStates.noTokenAvailable;
            var tokenSetupComplete = false;
            var bookId = false;
            var authTokenId = false;
            var authTokenValue = false;
            var ugcKey = false;
            var triggeringEvent = false;

            /**
             * Setup to perform prior to attempting a token login
             * Used externally to lazily setup the submodule when needed
             */
            var setup = function() {
                if (!tokenSetupComplete) {
                    setupCore();
                    bookId = resources.yuduBook.settings.id;
                    // use empty conditionals to define priority of available token details
                    if (checkQueryForTokenDetails()) {
                        retrievedFrom = retrievedStates.queryString;
                    } else if (retrieveStoredTokenDetails()) {
                        retrievedFrom = retrievedStates.localStorage;
                    }
                    tokenSetupComplete = true;
                }
                return true;
            };

            /**
             * Checks the query string for input token details
             * @returns {boolean} ; was the retrieval successful
             */
            var checkQueryForTokenDetails = function() {
                var newTokenValue = config.getFromQuery(KEY_YUDU_AUTH_TOKEN);
                if (newTokenValue) {
                    authTokenValue = newTokenValue;
                    authTokenId = config.getFromQuery(KEY_YUDU_AUTH_ID);

                    var newUgcKey = config.getFromQuery(KEY_UGC_KEY);
                    if (newUgcKey) {
                        ugcKey = newUgcKey;
                    }

                    return true;
                }
                return false;
            };

            /**
             * Saves the current token details to the local storage for persistence between windows
             */
            var preserveTokenDetails = function() {
                if (!authTokenValue) {
                    return;
                }
                storage.setItem(bookId + '-' + KEY_YUDU_AUTH_TOKEN, authTokenValue);
                storage.setItem(bookId + '-' + KEY_YUDU_AUTH_ID, authTokenId);
                if (ugcKey) {
                    storage.setItem(bookId + '-' + KEY_UGC_KEY, ugcKey);
                }
            };

            /**
             * Attempts to load token details that have been persisted in the local storage
             * @returns {boolean} ; was the retrieval successful
             */
            var retrieveStoredTokenDetails = function() {
                var val = storage.getItem(bookId + '-' + KEY_YUDU_AUTH_TOKEN);
                if (val) {
                    authTokenValue = val;
                    authTokenId = storage.getItem(bookId + '-' + KEY_YUDU_AUTH_ID);

                    var ugcKeyVal = storage.getItem(bookId + '-' + KEY_UGC_KEY);
                    if (ugcKeyVal) {
                        ugcKey = ugcKeyVal;
                    }
                    return true;
                }
                return false;
            };

            /**
             * Clears any token details that have been persisted in the local storage
             */
            var resetStoredTokenDetails = function() {
                storage.removeItem(bookId + '-' + KEY_YUDU_AUTH_TOKEN, authTokenValue);
                storage.removeItem(bookId + '-' + KEY_YUDU_AUTH_ID, authTokenId);
                storage.removeItem(bookId + '-' + KEY_UGC_KEY);
            };

            /**
             * Attempt to login using token details
             * Preserve triggering event details in case the token login attempt fails
             *  - no event data: ensure any pre-existing data is wiped
             */
            var tokenLogin = function(event, sendLoginRequest) {
                if (!event) {
                    triggeringEvent = event;
                } else {
                    triggeringEvent = false;
                }
                sendLoginRequest(getTokenLoginData());
            };

            /**
             * Prepare an object hash with token details for a token login request
             * @returns {*}
             */
            var getTokenLoginData = function() {
                var data = getCoreLoginData();
                data.readerUid = tools.getUniqueUserId();
                data.tokenId = authTokenId;
                data.tokenValue = authTokenValue;
                if (ugcKey) {
                    data.ugcKey = ugcKey;
                }
                data.tokenLoginRequest = true;
                return data;
            };

            /**
             * Helper method: are token details available
             * @returns {boolean}
             */
            var hasTokenDetails = function() {
                return !!authTokenValue;
            };

            /**
             * Helper method to deal with any post-processing as a result of a successful token login
             */
            var handleSuccess = function(eventData) {
                triggeringEvent = false;
                if (eventData.authToken) {
                    var ssoToken = eventData.authToken.ssoToken;
                    var uid = eventData.authToken.uid;
                    var internalUse = eventData.authToken.internalUse;
                    if (internalUse === true && ssoToken) {
                        authTokenValue = ssoToken;
                        authTokenId = uid;
                        preserveTokenDetails();
                    }
                }
            };

            /**
             * Helper method to deal with the case that an attempted token login has failed:
             *  - delete token details: they do not work so don't try again
             *  - uses preserved event data if there is any
             *      - this should only be called after a `tokenLogin` so the preserved event data should always be up to date
             */
            var handleFailure = function() {
                authTokenId = false;
                authTokenValue = false;
                ugcKey = false;
                if (retrievedFrom === retrievedStates.localStorage) {
                    resetStoredTokenDetails();
                }
                var data = triggeringEvent ? triggeringEvent : {};
                events.emit('*', events.SHOW_LOGIN, this, data);
                triggeringEvent = false;
            };

            return {
                isSetup: setup,
                hasTokenDetails: hasTokenDetails,
                tokenLogin: tokenLogin,
                handleSuccess: handleSuccess,
                handleFailure: handleFailure
            }
        }();

        var logout = function() {
            rememberMeToken.resetTokenDetails();
        };

        return {
            setupCore: setupCore,
            setupUi: setupUi,
            login: login,
            show: show,
            attemptSamlLogin: attemptSamlLogin,
            showSamlLogin: showSamlLogin,
            onSamlError: onSamlError,
            showSamlLoginFailure: showSamlLoginFailure,
            onSamlAuthFailure: onSamlAuthFailure,
            sendAjaxLoginRequest: sendAjaxLoginRequest,
            displayMessage: displayMessage,
            getAuthenticationUrl: getAuthenticationUrl,
            stopPropagation: stopPropagation,
            setButtonSize: setButtonSize,
            getLoginData: getLoginData,
            getCoreLoginData: getCoreLoginData,
            getLibrarySessionCookieData: getLibrarySessionCookieData,
            saveCurrentCredentials: saveCurrentCredentials,
            
            lastUsedCredentials: lastUsedCredentials,
            sso: sso,
            
            subscribeUrl: subscribeUrl,
            resetPasswordUrl: resetPasswordUrl,
            nextLoginForUgc: nextLoginForUgc,
            attemptLibraryCookieLogin: attemptLibraryCookieLogin,
            logout: logout
        };
    });

define('ui/login',['api', 'config', 'constants', 'events', 'interactions', 'resources', 'shared/hammerManager', 'shared/storage',
        'shared/utils/utils', 'shared/utils/appWrapHook','utils/rememberMeToken', 'utils/statistics', 'shared/localisation',
        'utils/tools', 'utils/userOptions', 'jquery', 'utils/encryptedResourceFetchingUtils', 'shared/login', 'shared/samlAuthToken'],
    function(api, config, constants, events, interactions, resources, hammerManager, storage,
             utils, appWrapHook, rememberMeToken, statistics, localisation,
             tools, userOptions, $, encryptedResourceFetchingUtils, sharedLogin, samlAuthToken) {
        
        function Login() {
            var EMITTER_NAME = "login";

            var loginUI = {
                "background": $("#yudu_loginBackground"),
                "prompt": $("#yudu_loginPrompt"),
                "samlRetryPrompt": $("#yudu_samlRetryPrompt"),
                "samlExplanation": $("#yudu_failedSamlLoginExplanation"),
                "samlButton": $("#yudu_samlRetry"),
                "explanation": $("#yudu_loginExplanation"),
                "usernameInput": $("#yudu_username"),
                "passwordInput": $("#yudu_password"),
                "response": $("#yudu_loginResponse"),
                "form": $("#yudu_loginForm"),
                "subscribe": $("#yudu_loginSubscribe"),
                "loginButtons": $("#yudu_loginButtons"),
                "resetPassword": $("#yudu_resetPassword"),
                "loginSend": $("#yudu_loginSend")
            };
            var uiSetupComplete = false;

            /**
             * Initialises the login ui
             */
            var init = function () {
                events.subscribe(events.ALL, events.SHOW_LOGIN, events.callback(this, tryShow));
                events.subscribe(events.ALL, events.NEEDS_BACKGROUND_LOGIN_ATTEMPT,
                    events.callback(this, attemptBackgroundLogin), true);
                sharedLogin.lastUsedCredentials.registerListeners();
                rememberMeToken.init();
                samlAuthToken.init();
                events.subscribe(events.ALL, events.SAML_REQUEST_RECEIVED, events.callback(this, onSamlRequestReceived));
                events.subscribe(events.ALL, events.SAML_AUTH_TOKEN_VALIDATION_RESPONSE_RECEIVED, events.callback(this,
                    onSamlAuthTokenValidationResponseReceived));
            };

            var login = function () {
                sharedLogin.login();
                sendLoginRequest(sharedLogin.getLoginData(sharedLogin.saveCurrentCredentials()));
            };


            /**
             * Setup to perform prior to showing the login UI
             */
            var setupUi = function () {
                uiSetupComplete = true;
                sharedLogin.setupUi(loginUI, statistics);

                loginUI.form.submit(events.callback(this, function (event) {
                    $("input").blur();
                    login();
                    return sharedLogin.stopPropagation(event);
                }));

                var backgroundManager = hammerManager.createTapManager(loginUI.background[0]);
                backgroundManager.on('tap', hide);
            };

            /**
             * Something wants to show the login prompt. This decision method determines whether to do so.
             * @param event ; data from the event sending the request
             */
            var tryShow = function (event) {
                if (!uiSetupComplete) {
                    setupUi();
                }

                // check for conditions that might permit a login prompt
                var encryptedPageVisible = api.isShowingEncryptedPage();
                // whether to allow UGC to show the login credentials prompt
                // (Note: the final setting hasn't been implemented on Publisher yet, so will always be false!)
                var ugcRequestingCredentials = api.isUgcEnabled() && event.data && event.data.ugcCredentialsRequested &&
                    resources.yuduBook.settings.allowUgcToOpenLogin;
                var mayShowLoginPrompt = encryptedPageVisible || ugcRequestingCredentials;
                // decision method
                if (!mayShowLoginPrompt) {
                    return;
                } else if (!resources.yuduBook.settings.samlAuthenticationEnabled && attemptBackgroundLogin()) {
                    return;
                } else if (encryptedPageVisible) {
                    // Encrypted page visible, need login to decrypt
                    if (resources.yuduBook.settings.samlAuthenticationEnabled) {
                        const wasPhoneviewLogin = utils.getLeafOrUndefined(config.queryObject, "phoneview");
                        if (wasPhoneviewLogin) {
                            api.openArticleView();
                            return;
                        }

                        const samlAuthFailure = utils.getLeafOrUndefined(config.queryObject, "samlAuthFailure");
                        if (samlAuthFailure) {
                            const samlAuthErrorCode = utils.getLeafOrUndefined(config.queryObject, "samlErrorCode");
                            const samlAuthErrorData = utils.getLeafOrUndefined(config.queryObject, "samlErrorData");
                            sharedLogin.onSamlAuthFailure(samlAuthErrorCode, samlAuthErrorData);
                            return;
                        }

                        sharedLogin.attemptSamlLogin();
                        return;
                    }

                    if (!(event.data && event.data.noSuper) && appWrapHook.trySuperLogin()) {
                        // Request to open a login prompt has been sent to the app
                        return;
                    }
                    // Either an explicit message was received to not attempt an app login via the app hook or the hook
                    //  was unable to send a request: continue in this method
                } else if (ugcRequestingCredentials) {
                    // UGC is enabled, and has requested credentials
                    if (appWrapHook.tryGettingSuperCredentials()) {
                        // request for credentials sent to app
                        return;
                    }

                    // no app communications: need to show login prompt locally: continue in this method
                    // set a UGC-login flag, as logins for unencrypted editions require special processing
                    sharedLogin.nextLoginForUgc = true;
                } else {
                    // no other valid reason to show a prompt
                    // should no longer be required, but is kept as an emergency catch-all
                    return;
                }
                sharedLogin.attemptLibraryCookieLogin = false;
                show();
                /*
                 Current state of this logic flow (as a PlantUML diagram):
                 @startuml
                 skinparam activityShape<<state>> octagon

                 (*) <<state>> --> "Should a login\nprompt be allowed?" as allow
                 allow -right->[N] "return" as r1 <<state>>
                 allow -->[Y] "Has SSO details?" as c1
                 c1 -right->[Y] "`tokenLogin()`" as token <<state>>
                 c1 -->[N] "Is showing encrypted page?" as c2
                 c2 -->[Y] "`event.data.noSuper`?" as e1
                 e1 -->[N] "App Hook\n`trySuperLogin()`" as ehook
                 ehook -->[Y] "return" as r2 <<state>>
                 ehook -->[N] "`show()`" as show <<state>>
                 e1 -->[Y] show
                 c2 -->[N] "UGC enabled?" as other1u1
                 other1u1 -->[N] "return" as r3 <<state>>
                 other1u1 -->[Y] "`event.data.ugc`?" as other1u2
                 other1u2 -->[N] r3
                 other1u2 -->[Y] "`settings.allowUgcToOpenLogin`?" as other1u3
                 other1u3 -left->[N] r3
                 other1u3 -->[Y] "App Hook\n`tryGettingSuperCredentials()`" as other1uhook
                 other1uhook -->[N] show
                 other1uhook -->[Y] "return" as r4 <<state>>
                 @enduml

                 Node naming scheme:
                 r = return
                 c = initial choice
                 e = encrypted page flow
                 other = non-encrypted page flow
                 u = UGC flow
                 # = node of current sub-flow
                 hook = app hook
                 */
            };

            var isAttemptingRememberMeTokenLogin = false;
            var attemptBackgroundLogin = utils.debounce(function (event) {
                if (sharedLogin.sso.isSetup() && sharedLogin.sso.hasTokenDetails()) {
                    sharedLogin.sso.tokenLogin(event, sendLoginRequest);
                    return true;
                } else if (sharedLogin.attemptLibraryCookieLogin && sharedLogin.getLibrarySessionCookieData() != "") {
                    sendLoginRequest(sharedLogin.getLoginData(sharedLogin.saveCurrentCredentials(), true));
                    return true;
                } else if (rememberMeToken.hasTokenDetails() && isAttemptingRememberMeTokenLogin == false) {
                    isAttemptingRememberMeTokenLogin = true;
                    sendLoginRequest(rememberMeToken.addTokenData(sharedLogin.getCoreLoginData()));
                    return true;
                }
                return false;
            }, 300, true, false);

            /**
             * Show login prompt.
             */
            var show = function () {
                interactions.setAllowKeyNavigation(false);
                events.subscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback);

                sharedLogin.show()
            };

            var onSamlRequestReceived = function(event) {
                if (event.data.error) {
                    sharedLogin.onSamlError(event.data.error);
                } else {
                    showSamlLogin(event.data.encodedSignedRequest);
                }
            };

            var onSamlAuthTokenValidationResponseReceived = function(event) {
                if (event.data.error) {
                    sharedLogin.onSamlError(event.data.error);
                } else {
                    samlAuthToken.storeToken(event.data.samlAuthToken);
                    handleDecryptionKey(event.data);
                }
            };

            /**
             * Show saml login prompt.
             */
            var showSamlLogin = function (request) {
                interactions.setAllowKeyNavigation(false);
                events.subscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback);
                sharedLogin.showSamlLogin(request);
            };

            /**
             * Hide the login prompt
             */
            var hide = function () {
                events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback, false);
                loginUI.background.hide();
                loginUI.prompt.hide();
                loginUI.response.hide();
                interactions.setAllowKeyNavigation(true);
            };


            /**
             * Sends an AJAX request to authenticate the reader
             * @param data ; request parameters
             */
            var sendLoginRequest = function (data) {
                sharedLogin.sendAjaxLoginRequest(data, sharedLogin.getAuthenticationUrl(), loginSuccess, function () {
                    if (sharedLogin.attemptLibraryCookieLogin) {
                        sharedLogin.attemptLibraryCookieLogin = false;
                        show();
                    } else {
                        sharedLogin.displayMessage("login.auth.genericError", true);
                    }
                });
            };

            /**
             * If login succeeds calls the onSuccess function and hides the login
             */
            var loginSuccess = function (data) {
                if (!data.success) {
                    isAttemptingRememberMeTokenLogin = false;
                    handleFailureResponse(data);
                    config.isLoggedIn = false;
                    return;
                }

                config.isLoggedIn = true;

                if (data.authDetails) {
                    if (data.authDetails.rememberMeTokens) {
                        rememberMeToken.storeTokenDetails(data.authDetails.rememberMeTokens);
                    }

                    if (data.authDetails.ssoSubscriber) {
                        sharedLogin.lastUsedCredentials.setSsoSubscriberId(data.authDetails.ssoSubscriber.subscriberId);
                        events.emit(EMITTER_NAME, events.LOGIN_DETAILS_CHANGED, this, {
                            credentials: sharedLogin.lastUsedCredentials.getCredentials(true)
                        });
                    }
                }
                if (data.key) {
                    handleDecryptionKey(data);
                } else {
                    events.emit(EMITTER_NAME, events.LOGIN_DETAILS_CHANGED, this, {
                        credentials: sharedLogin.lastUsedCredentials.getCredentials()
                    });
                }
                if (data.tokenLoginResponse) {
                    sharedLogin.sso.handleSuccess(data);
                }
                hide();
            };

            var handleDecryptionKey = function (data) {
                config.decryptionKey = data.key;
                if (data.contentDecryptionKey) {
                    config.contentDecryptionHeaders = {
                        "x-amz-server-side-encryption-customer-algorithm": "AES256",
                        "x-amz-server-side-encryption-customer-key": data.contentDecryptionKey,
                        "x-amz-server-side-encryption-customer-key-MD5": encryptedResourceFetchingUtils.getBase64MD5DigestOfBase64Message(
                            data.contentDecryptionKey)
                    };
                }
                events.emit(EMITTER_NAME, events.LOGIN_SUCCESS, this, {
                    credentials: sharedLogin.lastUsedCredentials.getCredentials()
                });
            };

            var handleFailureResponse = function (data) {
                if (data.tokenLoginResponse) {
                    sharedLogin.sso.handleFailure();
                } else if (data.shortLifeRememberMeTokenResponse) {
                    rememberMeToken.handleLoginFailure();
                } else if (sharedLogin.attemptLibraryCookieLogin) {
                    sharedLogin.attemptLibraryCookieLogin = false;
                    show();
                } else {
                    sharedLogin.displayMessage("login.auth.errors." + data.error, true);
                }
            };

            var cancelCallback = events.callback(this, hide);

            return {
                init: init,
                getCurrentUserCredentials: sharedLogin.lastUsedCredentials.getCredentials,
                getHasCredentials: sharedLogin.lastUsedCredentials.getHasCredentials,
                getCredentialsAreFromSuper: sharedLogin.lastUsedCredentials.getCredentialsAreFromSuper,
                getSubscriberId: sharedLogin.lastUsedCredentials.getSubscriberId,
                setSubscriberId: sharedLogin.lastUsedCredentials.setSubscriberId,
                getSsoSubscriberId: sharedLogin.lastUsedCredentials.getSsoSubscriberId,
                setSsoSubscriberId: sharedLogin.lastUsedCredentials.setSsoSubscriberId,
                EMITTER_NAME: EMITTER_NAME
            };
        }

        return $.extend(sharedLogin, new Login());
    });

define('shared/ui/sharing',['shared/constants', 'shared/config', 'shared/events', 'shared/resources', 'shared/localisation', 'shared/utils/appUtils',
        'shared/utils/urlUtils', 'shared/ui/messageBox', 'shared/hammerManager', 'jquery', 'shared/utils/appWrapHook'],
    function(constants, config, events, resources, localisation, appUtils,
             urlUtils, messageBox, hammerManager, $, appWrapHook) {

        var EMITTER_NAME = "sharing";

        var url = false;
        var bookId = false;
        var shareCurrentPage = false;
        var sharingUI = {};
        var emailSubject;
        var emailBodyTemplate;
        var getShareTargets = null;

        var getShareContainer = function() {
            return $('#shareContainer');
        };

        var bindEvents = function() {
            if (events.LOADING_ACTIONS_DONE) {
                events.subscribe(events.ALL, events.LOADING_ACTIONS_DONE, events.callback(this, settingsLoaded), false);
            }
    };

    /**
     * Subscribes to events and adds desktop/ touch device class as necessary
     */
    var init = function(getShareTargetsHandler) {
        getShareTargets = getShareTargetsHandler;
        sharingUI = {
            //Email pop up elements
            emailPopup: {
                background: $("#yudu_shareBackground"),
                container: $("#yudu_emailShareContainer"),
                fromAddress: $("#yudu_fromAddress"),
                toAddress: $("#yudu_toAddress"),
                comment: $("#yudu_comment"),
                form: $("#yudu_emailForm"),
                cancel: $("#yudu_emailCancel"),
                send: $("#yudu_emailSend")
            }
        };

        var backgroundManager = hammerManager.createTapManager(sharingUI.emailPopup.background[0]);
        backgroundManager.on('tap', hidePopup);
    };

    /**
     * Fix for IE11 to allow text input!
     */

    $("input, textarea").click(function(){
        $("#yudu_emailSend").focus();
        this.focus();
    });

    /**
     * Reads the sharing settings from the yudubook and determines which buttons to
     * show and binds events
     */
    var settingsLoaded = function() {
        var settings = resources.yuduBook.settings.sharing;
        if (!settings)
            return;
        localisation.localiseHtml(getShareContainer());
        localisation.localiseHtml(sharingUI.emailPopup.container);

        url = settings.url;
        bookId = resources.yuduBook.settings.id;

        //prevent the user from being able to drag the page
        events.yuduOn($(".yudu_noDrag"), "touchmove", events.callback(this, function() {
            return false;
        }));

        window.yudu_sharingFunctions = {};
        window.yudu_sharingSettings = {};
        window.yudu_sharingSettings.toolbarIconBasePath = constants.toolbarIconBasePath;

        if(settings.emailEnabled || settings.twitter || settings.facebook || settings.linkedIn)
            window.yudu_sharingFunctions.togglePage = togglePage;
        if(settings.emailEnabled) {
            window.yudu_sharingFunctions.shareEmail = shareEmail;

            sharingUI.emailPopup.form.submit(events.callback(this, function(event) {
                $("input").blur();
                event.stopPropagation();
                sendEmail();
                return false;
            }));

            var backgroundManager = hammerManager.createTapManager(sharingUI.emailPopup.cancel[0]);
            backgroundManager.on('tap', hidePopup);

            emailSubject = settings.emailSubject;
            emailBodyTemplate = settings.emailBody;
        }
        if(settings.twitter) {
            window.yudu_sharingFunctions.shareTwitter = events.callback(this, shareSite, settings.twitter);
            window.yudu_sharingSettings.twitterIconPath = constants.baseRequiredFolder + "twitter.png";
        }
        if(settings.facebook) {
            window.yudu_sharingFunctions.shareFacebook = events.callback(this, shareSite, settings.facebook);
            window.yudu_sharingSettings.facebookIconPath = constants.baseRequiredFolder + "facebook.png";
        }
        if(settings.linkedIn) {
            window.yudu_sharingFunctions.shareLinkedIn = events.callback(this, shareSite, settings.linkedIn);
            window.yudu_sharingSettings.linkedInIconPath = constants.baseRequiredFolder + "linkedIn.png";
        }
    };

    /**
     * Shows the email pop up
     */
    var shareEmail = function() {
        events.subscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback);
        events.emit(EMITTER_NAME, events.SHARE_EMAIL_DIALOG_OPEN, this, {});
        sharingUI.emailPopup.container.slideDown();
        sharingUI.emailPopup.background.show();
        sharingUI.emailPopup.fromAddress.focus();
    };


    /**
     * Sends the email data to the server
     */
    var sendEmail = function() {
        if (appUtils.isThisAnApp() && !config.liveUrl && config.liveUrl !== "") {
            events.subscribe("appWrapHook", events.LIVE_URL_RECEIVED, continueSendingEmail);
            appWrapHook.tryGettingLiveUrl(bookId);
        }
        else {
            continueSendingEmail();
        }
    };

    var continueSendingEmail = function() {
        events.unsubscribe("appWrapHook", events.LIVE_URL_RECEIVED, continueSendingEmail);

        var toAddress = sharingUI.emailPopup.toAddress.val();
        var shareUrl = getShareUrl().url;

        var emailBody = emailBodyTemplate.replace(/#to#/gi, toAddress);
        emailBody = emailBody.replace(/#from#/gi, sharingUI.emailPopup.fromAddress.val());
        emailBody = emailBody.replace(/#url#/gi, "<a href='" + shareUrl + "'>" + shareUrl + "</a>");
        emailBody = emailBody.replace(/#comments#/gi, sharingUI.emailPopup.comment.val());
        urlUtils.openURL('mailto:' + toAddress + '?subject=' + encodeURIComponent(emailSubject) + '&body=' + encodeURIComponent($(emailBody).text()), false);
        events.emit(EMITTER_NAME, events.SHARE_TO.EMAIL, this, {shareUrl: shareUrl});
        hidePopup();
    };

    /**
     * Requests the url to share to for the given site
     * @param siteId
     */
    var shareSite = function(siteId) {
        if(!siteId)
            return;

        if (appUtils.isThisAnApp() && !config.liveUrl && config.liveUrl !== "") {
            events.subscribe("appWrapHook", events.LIVE_URL_RECEIVED, function() { continueSharingSite(siteId); });
            appWrapHook.tryGettingLiveUrl(bookId);
        }
        else {
            continueSharingSite(siteId);
        }
    };

    var continueSharingSite = function(siteId) {
        var shareUrl = getShareUrl();
        var json = {"bookId": bookId, "siteId": siteId, "url": shareUrl.url, "thumbnailUrl": shareUrl.thumbnailUrl, 'waitTime': 4};
        var respondedTo = false;

        postData(json, function(sentJson, data) {
            if (!respondedTo) {
                respondedTo = true;
                handleSiteResponse(sentJson, data);
            }
        }, function() {
            if (!respondedTo) {
                respondedTo = true;
                messageBox.displayByCode("sharing.genericError", constants.messageTypes.failure);
            }
        });

        setTimeout(function() {
            if (!respondedTo) {
                respondedTo = true;
                messageBox.displayByCode("sharing.genericError", constants.messageTypes.failure);
            }
        }, constants.shareSiteTimeout);
    };

    /**
     * Gets the current url to share and the thumbnail url
     * @returns {{url: string, thumbnailUrl: string}}
     */
    var getShareUrl = function() {
        if (!getShareTargets || typeof getShareTargets !== 'function') {
            return {};
        }

        var currentUrl = config.liveUrl || (location.protocol + '//' + location.host + location.pathname);
        var shareFirstPage = !shareCurrentPage;
        return getShareTargets(shareFirstPage, currentUrl);
    };

    /**
     * Posts the given JSON to the server
     * @param data the JSON to pass
     * @param success the function to run after a successful response
     * @param error the function to run on failure
     */
    var postData = function(data, success, error) {
        $.ajax({
            url: url,
            type: 'POST',
            dataType: "json",
            data: data,
            success: events.callback(this, success, data),
            error: error
        });
    };

    /**
     * If the response returns success true then opens the share site in a new window
     * (or tries to). If it fails then displays the returned error message.
     * @param sentJson
     * @param data
     */
    var handleSiteResponse = function(sentJson, data) {
        if(data.success) {
            var facebook = resources.yuduBook.settings.sharing.facebook;
            var twitter = resources.yuduBook.settings.sharing.twitter;
            var linkedIn = resources.yuduBook.settings.sharing.linkedIn;

            if (facebook && sentJson.siteId == facebook) {
                events.emit(EMITTER_NAME, events.SHARE_TO.FACEBOOK, this, {shareUrl: sentJson.url});
            } else if (twitter && sentJson.siteId == twitter) {
                events.emit(EMITTER_NAME, events.SHARE_TO.TWITTER, this, {shareUrl: sentJson.url});
            } else if (linkedIn && sentJson.siteId == linkedIn) {
                events.emit(EMITTER_NAME, events.SHARE_TO.LINKED_IN, this, {shareUrl: sentJson.url});
            }

            urlUtils.openURL(data.url, true);
        }
        else {
            var errorMsg = localisation.get(data.error ? "sharing.errors." + data.error : "sharing.genericError");
            messageBox.display(errorMsg, constants.messageTypes.failure);
        }
    };

    /**
     * Hides any visible sharing pop ups
     */
    var hidePopup = function() {
        events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, cancelCallback);
        events.emit(EMITTER_NAME, events.SHARE_EMAIL_DIALOG_CLOSE, this, {});
        sharingUI.emailPopup.background.hide();
        sharingUI.emailPopup.container.hide();
    };

    var togglePage = function(currentPageClicked) {
        shareCurrentPage = currentPageClicked;
    };

    var cancelCallback = events.callback(this, hidePopup);

    return {
        init: init,
        bindEvents: bindEvents,
        _private: {
            getShareUrl: getShareUrl,
            shareSite: shareSite,
            togglePage: togglePage
        }
    };
});
define('ui/sharing',['events', 'constants', 'config', 'resources', 'api', 'interactions', 'utils/statistics',
        'shared/ui/sharing', 'jquery'],
    function(events, constants, config, resources, api, interactions, statistics,
             sharing, $) {

        function Sharing() {
            var self = this;

            // Make the _private functions available to the unit tests.
            this._private = sharing._private;

            self.bindEvents = function() {
                sharing.bindEvents();

                events.subscribe(events.ALL, events.SHARE_EMAIL_DIALOG_OPEN, handleShareEmailDialogOpen);
                events.subscribe(events.ALL, events.SHARE_EMAIL_DIALOG_CLOSE, handleShareEmailDialogClose);
                events.subscribe(events.ALL, events.SHARE_TO.FACEBOOK, handleShareToFacebookFinished);
                events.subscribe(events.ALL, events.SHARE_TO.TWITTER, handleShareToTwitterFinished);
            };

            self.init = function() {
                sharing.init(getShareTargets);
            };

            var getShareTargets = function(shareFirst, currentUrl) {
                // If there is an intro page, the correct index is the same for pages and thumbnails, and the index to
                // share as the 'first' page is #1.
                // If there is no intro page, the thumbnail index is one lower than the page index. The 'first' page
                // index is still 1 for pages, but 0 for thumbnails.
                var firstRealPage = config.hasIntroPage ? 1 : 0;
                var targetPageIndex = shareFirst ? firstRealPage : api.getCurrentPageIndex();
                targetPageIndex = Math.max(firstRealPage, targetPageIndex);

                var pageNumber = targetPageIndex;
                var thumbnailPageNumber = targetPageIndex;

                if (!config.hasIntroPage) {
                    ++pageNumber;
                }

                var pageQuery = '?page=' + pageNumber;
                var thumbnailPath = thumbnailPageNumber + '.jpg';

                return {
                    url: currentUrl + pageQuery,
                    thumbnailUrl: getThumbnailDirectory(currentUrl) + thumbnailPath
                };
            };

            var getThumbnailDirectory = function(currentUrl) {
                return currentUrl.slice(0, currentUrl.lastIndexOf('/') + 1) + constants.baseThumbnailFolder;
            };

            var handleShareEmailDialogOpen = function(event) {
                interactions.setAllowKeyNavigation(false);
            };

            var handleShareEmailDialogClose = function(event) {
                interactions.setAllowKeyNavigation(true);
            };

            var handleShareToFacebookFinished = function(event) {
                handleShareToSocialSite(statistics.events.facebooked, event.data.shareUrl);
            };

            var handleShareToTwitterFinished = function(event) {
                handleShareToSocialSite(statistics.events.tweeted, event.data.shareUrl);
            };

            var handleShareToSocialSite = function(actionType, shareUrl) {
                var actionData = {
                    actionType: actionType,
                    extraInfo: shareUrl
                };

                statistics.action(actionData);
            };
        }

        return new Sharing();
    });

define('ui/drawingToolbars',['api', 'events', 'config', 'constants', 'resources', 'utils/tools', 'utils/statistics', 'ui/uiTools', 'ui/highlightingCanvas', 'shared/localisation', 'jquery'],
    function(api, events, config, constants, resources, tools, statistics, uiTools, highlightingCanvas, localisation, $) {
        var inEraserMode = false;
        var inPanMode = false;

        var reader = $("#yudu_reader");
        var pageHighlightsContainer = $('#yudu_pageHighlightsContainer');
        var interactionDiv = $('#yudu_interactionDiv');

        var init = function() {
            makeSettingsAvailableForBrandableDrawingToolbars();
            makeFunctionsAvailableForBrandableDrawingToolbars();
            setMode();
        };

        var makeSettingsAvailableForBrandableDrawingToolbars = function() {
            window.yudu_drawingToolbarFunctions = {
                inEraserMode: inEraserMode,
                inPanMode: inPanMode
            };
        };

        var makeFunctionsAvailableForBrandableDrawingToolbars = function() {
            window.yudu_drawingToolbarFunctions = {
                setDrawingBrushColour: setDrawingBrushColour,
                setDrawingBrushWidth: setDrawingBrushWidth,
                setHighlightingMode: setHighlightingMode,
                goToPreviousPage: goToPreviousPage,
                goToNextPage: goToNextPage,
                hasNextPage: hasNextPage,
                hasPreviousPage: hasPreviousPage,
                clearAll: clearAll,
                undo: undo,
                redo: redo,
                cancel: cancel,
                save: save,
                penMode: enterPenMode,
                eraserMode: enterEraserMode,
                panMode: enterPanMode
            };
        };

        var setMode = function() {
            var position;
            var readerDrawingModeSize;
            var readerDrawingModeDisplacement;
            var editOptionsToolbarSize;
            var drawingOptionsToolbarSize;

            if (config.isDesktop) {
                position = resources.drawingToolbarsConfig.desktopPosition;
                editOptionsToolbarSize = resources.drawingToolbarsConfig.desktopEditOptionsToolbarSize;
                drawingOptionsToolbarSize = resources.drawingToolbarsConfig.desktopDrawingOptionsToolbarSize;
            } else {
                position = resources.drawingToolbarsConfig.touchPosition;
                editOptionsToolbarSize = resources.drawingToolbarsConfig.touchEditOptionsToolbarSize;
                drawingOptionsToolbarSize = resources.drawingToolbarsConfig.touchDrawingOptionsToolbarSize;
            }

            // Add in a rule to resize the reader whenever the drawing mode option is shown
            readerDrawingModeSize = (position == 'topBottom' ? 'height' : 'width');
            var readerSizeRule = readerDrawingModeSize + ": calc(100% - " + (parseInt(editOptionsToolbarSize.replace('px', '')) + parseInt(drawingOptionsToolbarSize.replace('px', ''))) + "px) !important;";

            readerDrawingModeDisplacement = (position == 'topBottom' ? 'top' : 'left');
            var readerDisplacementRule = readerDrawingModeDisplacement + " : " + editOptionsToolbarSize + ";";

            var sheet = document.styleSheets[0];
            sheet.insertRule("#yudu_reader.yudu_drawingMode { " + readerSizeRule + readerDisplacementRule + " }", 1);

            var drawingToolbarsContainer = $('#yudu_drawingToolbars');
            drawingToolbarsContainer.append(resources.drawingToolbarsHtml);
            window.yudu_commonFunctions.injectJavascript(
                    constants.baseResourcesFolder + resources.drawingToolbarsConfig.mainJavascriptFilePath);
            localisation.localiseHtml(drawingToolbarsContainer);
        };

        var setDrawingBrushColour = function(colour) {
            highlightingCanvas.setBrushColour(colour);
        };

        var setDrawingBrushWidth = function(width) {
            highlightingCanvas.setBrushWidth(parseInt(width));
        };

        var enterPenMode = function() {
            inEraserMode = false;
            inPanMode = false;
            highlightingCanvas.eraserMode(false);
            interactionDiv.hide();
        };

        var enterEraserMode = function() {
            inEraserMode = true;
            inPanMode = false;
            highlightingCanvas.eraserMode(true);
            interactionDiv.hide();
        };

        var enterPanMode = function() {
            inPanMode = true;
            inEraserMode = false;
            highlightingCanvas.eraserMode(false);
            interactionDiv.show();
        };

        var goToNextPage = function() {
            if (hasNextPage()){
                api.nextPageUnanimated();
            }
        };

        var goToPreviousPage = function() {
            if (hasPreviousPage()){
                api.previousPageUnanimated();
            }
        };

        var hasNextPage = function() {
            return !api.isLastPage();
        };

        var hasPreviousPage = function() {
            return !api.isFirstPage();
        };

        var cancel = function() {
            highlightingCanvas.cancel();
            setHighlightingMode(false);
        };

        var undo = function() {
            highlightingCanvas.undo();
        };

        var redo = function() {
            highlightingCanvas.redo();
        };

        var clearAll = function() {
            highlightingCanvas.clearCanvas();
        };

        var save = function() {
            highlightingCanvas.saveCanvas();
            setHighlightingMode(false);
        };

        var setHighlightingMode = function(show) {
            if (show) {
                if (!highlightingCanvas.pagesSupportHighlights()) {
                    return;
                }
                highlightingCanvas.showHighlightingCanvas();
                pageHighlightsContainer.hide();
                if (!inPanMode) {
                    interactionDiv.hide();
                }
                $('#yudu_reader').addClass('yudu_drawingMode');
                $('#yudu_notes').hide();
                api.resizeReader();
            } else {
                highlightingCanvas.hideHighlightingCanvas();
                pageHighlightsContainer.show();
                interactionDiv.show();
                $('#yudu_reader').removeClass('yudu_drawingMode');
                $('#yudu_notes').show();
                api.resizeReader();
            }
            events.emit(yudu_events.ALL, yudu_events.DRAWING_TOOLBARS.TOGGLE_TOOLBARS, this, {show: show});
        };

        return {
            init: init
        };
    });

define('model/editionLaunchableHtml',['events', 'ui/uiTools', 'utils/tools', 'resources', 'api'],
    function(events, uiTools, tools, resources, api){
        // TODO This function uses code copied from htmlOverlay.js and launchableHtmlOverlay.js. Ideally it should be
        // extracted in a separate file, but due to coupling with the various components, it would require rewriting a
        // good part of the overlays. Hence, for now, this will have to do...
        var EditionLaunchableHtml = function(settings) {
            var self = this;

            // Settings
            var extraQueryString = settings.extraQueryString;
            var interactionEnabled = !!settings.interactionEnabled;
            var requiresUserCredentials = !!settings.requiresUserCredentials;
            var src = tools.addQueryStringToURL(settings.src, extraQueryString);

            // UI elements
            var domElement;
            var iframe;
            var cover;

            self.showContent = function() {
                createContent();
                $(domElement).show();
            };

            var createContent = function() {
                var lightboxArgs = {
                    w: 80,
                    h: 80,
                    callback: events.callback(self, function(){
                        $('.yudu_throbberWrapper', $(domElement)).hide();
                        $('.yudu_lightboxContent', $(domElement)).css("visibility", "visible");

                        // Set the iframe here so that sendCredentials() will point to the correct iframe
                        iframe = $(domElement).find('iframe')[0];

                        // Send the credentials to the overlay on creation
                        sendCredentials();

                        // If the login details are updated after the overlay is created (like in wrapper-apps),
                        // subscribe to the change in login details, and then try to pass the credentials to the
                        // overlays again
                        events.subscribe(events.ALL, events.PUBLIC_API_LOGIN_STATE_CHANGED,
                                sendCredentialsCallback);
                    }),
                    src: src,
                    interactionEnabled: interactionEnabled,
                    addCloseButton: true,
                    animated: false,
                    closeCallback: unsubscribeFromSendCredentialsCallback
                };

                domElement = uiTools.createIframeLightbox(lightboxArgs);

                if (!interactionEnabled) {
                    disableUserInteractionWithIframe("80%", "80%");
                    events.yuduOn($(cover), "click touchstart", events.callback(self, stopPropagation));
                    cover.style.position = "fixed";
                    cover.style.top = "10%";
                    cover.style.right = "10%";
                }
                if (cover) {
                    domElement.appendChild(cover);
                }
            };

            var disableUserInteractionWithIframe = function(width, height) {
                uiTools.hideIframeScrollBars($("iframe", domElement)[0]);

                cover = document.createElement("div");
                cover.style.width = width;
                cover.style.height = height;
                // We need to give it a background colour to make it respond to events in IE.
                cover.style.opacity = "0";
                cover.style.backgroundColor = "black";
            };

            var sendCredentials = function() {
                if (!requiresUserCredentials || !iframe.contentWindow) {
                    return;
                }

                var credentials = window.yudu_readerApi.getCredentials();
                var context = {
                    editionTitle: resources.yuduBook.settings.name,
                    editionId: resources.yuduBook.settings.id,
                    editionCurrentPage: api.getCurrentPageNumber()
                };

                if (credentials.username && credentials.password) {
                    iframe.contentWindow.postMessage({
                        messageName: "userCredentialsAvailable",
                        username: credentials.username,
                        password: credentials.password,
                        context: context
                    }, '*');
                }
                else {
                    iframe.contentWindow.postMessage({
                        messageName: "userCredentialsNotAvailable"
                    }, '*');
                }
            };

            var sendCredentialsCallback = events.callback(self, sendCredentials);

            var unsubscribeFromSendCredentialsCallback = events.callback(self, function() {
                events.unsubscribe(events.ALL, events.PUBLIC_API_LOGIN_STATE_CHANGED, sendCredentialsCallback);
            });

            var stopPropagation = function(event) {
                event.stopPropagation();
                event.preventDefault();
            };
        };

        return {
            EditionLaunchableHtml: EditionLaunchableHtml
        }
    });
define('ui/toolbar',['api', 'events', 'config', 'constants', 'resources','ui/sharing',  'ui/search', 'ui/uiTools', 'ui/orderForm',
        'ui/drawingToolbars', 'ui/notes', 'ui/bookmarks', 'utils/tools', 'utils/statistics', 'shared/localisation',
        'shared/utils/stringUtils', 'model/editionLaunchableHtml', 'ui/downloadPdfTools', 'ui/information', 'jquery',
        'shared/login', 'utils/rememberedPageUtils', 'shared/utils/tools'],
    function(api, events, config, constants, resources, sharing, search, uiTools, orderForm,
             drawingToolbars, notes, bookmarks, tools, statistics, localisation,
             stringUtils, editionLaunchableHtml, downloadPdfTools, information, $,
             sharedLogin, rememberedPageUtils, sharedTools) {
        var isShowing = true;
        var timeout = null;

        var controls = $('#controls');

        var preInit = function() {
            makeSettingsAvailableForBrandableToolbar();
            makeFunctionsAvailableForBrandableToolbar();
            setMode();
        };

        var setMode = function() {
            var position;
            var size;
            var dimension;
            if (config.isDesktop) {
                var reader = $("#yudu_reader");
                position = resources.toolbarConfig.desktopPosition;
                size = resources.toolbarConfig.desktopSize;
                dimension = (position == 'top' || position == 'bottom') ? 'height' : 'width';
                reader.css(position, size);
                reader.css(dimension, 'calc(100% - ' + size + ')');
            }
            else {
                position = resources.toolbarConfig.touchPosition;
                size = resources.toolbarConfig.touchSize;
                dimension = (position == 'top' || position == 'bottom') ? 'height' : 'width';

                // To hide the toolbar when the 'hide' class is added to it, the CSS for the 'hide' class needs to be
                // changed. Using jquery's '.css()' won't help here, as a) that would only apply to elements which
                // already have that class and b) removing the class from the element would have no effect. Therefore
                // we must change the stylesheet itself.
                // First, we get the correct stylesheet. This is based on the fact that the main 'style.css' is the
                // first one loaded. If this changes, the code below also needs to change.
                var sheet = document.styleSheets[0];
                // Then we get the rules. Most browsers use '.cssRules', IE uses '.rules'.
                var rules = 'cssRules' in sheet ? sheet.cssRules : sheet.rules;
                var controlsId = '#yudu_toolbar' + stringUtils.capitalizeFirstLetter(position);
                // The animation looks better if the absolute value of the hiding position is a bit more than the
                // toolbar's size, hence the -10. It used to be that the (touch device) toolbar height was 44px and the
                // hiding position was -50px.
                var hideSize = -10 - parseInt(size);
                for (var i = 0, l = rules.length; i < l; i++) {
                    // The rule we are looking for is '<controlsId>.touchDevice.hide', but its selectorText doesn't
                    // necessarily keep that order (for example, it could be '.touchDevice.hide.<controlsId>'), hence we
                    // need to look for the one containing all three components in any order (there should only be one
                    // satisfying this condition).
                    if (rules[i].selectorText.indexOf(controlsId) > -1 && rules[i].selectorText.indexOf('.touchDevice') > -1 && rules[i].selectorText.indexOf('.hide') > -1) {
                        rules[i].style[position] = hideSize + 'px';
                        break;
                    }
                }
            }

            controls = $('#yudu_toolbar' + stringUtils.capitalizeFirstLetter(position));
            controls.css(dimension, size);
            if (!config.isDesktop) {
                controls.addClass("touchDevice");
                controls.css('transition', position + ' 0.4s');
            }
            controls.append(resources.toolbarHtml);
            window.yudu_commonFunctions.injectJavascript(
                constants.baseResourcesFolder + resources.toolbarConfig.mainJavascriptFilePath);
            localisation.localiseHtml(controls);
        };

        var makeSettingsAvailableForBrandableToolbar = function() {
            var settings = resources.yuduBook.settings;
            window.yudu_toolbarSettings = {
                toolbarIconBasePath: constants.toolbarIconBasePath,
                iconHighResPrefix: constants.toolbarIconHighResPrefix,
                iconFileExtension: constants.toolbarIconFileExtension,
                shouldUseHighRes: uiTools.shouldUseHighRes(),
                // This needs to be kept as a toolbar setting for backwards compatibility
                hasDownloadablePdfAndIsNotApp: window.yudu_downloadPdfSettings.downloadWholePdfEnabled,
                searchEnabled: settings.searchEnabled,
                editionListEnabled: settings.editionListEnabled && !tools.isThisAnApp(),
                sharing: {
                    emailEnabled: settings.sharing.emailEnabled,
                    twitter: settings.sharing.twitter,
                    facebook: settings.sharing.facebook,
                    linkedIn: settings.sharing.linkedIn
                },
                pageModeStopToggle: config.pageModeStopToggle,
                fullscreenModeEnabled: config.fullscreenCompatible && settings.fullscreenModeEnabled,
                bookmarksEnabled: config.bookmarksEnabled,
                notesEnabled: config.notesEnabled,
                highlightsEnabled: config.highlightsEnabled,
                hasArticles: resources.yuduBook.settings.phoneview && resources.yuduBook.settings.phoneview.isAvailable,
                orderFormEnabled: config.orderFormEnabled,
                editionLaunchableHtmlEnabled: config.editionLaunchableHtmlEnabled,
                // User preferences appears if 1+ setting has 'show' set to true. Currently the only setting used is
                // page turn.
                userPreferences: {
                    pageTurn: { show: config.pageTurnEnabled, default: config.pageTurnEnabled }
                },
                infoScreenDisabled: settings.infoScreenDisabled,
                logoutEnabled: settings.logoutButtonEnabled && !sharedTools.isThisAnApp() && config.isDesktop
            };

            // Adds backwards compatibility for the new hasArticles function
            window.yudu_toolbarSettings.articlesAvailable = function() {
                return window.yudu_toolbarSettings.hasArticles;
            };

            if (settings.showCustomLogo)
                window.yudu_toolbarSettings.logoSrc = constants.baseResourcesFolder + resources.yuduBook.settings.customLogoFilename;
            else if (settings.showYuduLogo)
                window.yudu_toolbarSettings.logoSrc = constants.logoUrl;
            window.yudu_toolbarSettings.logoLinkUrlExists = !!config.logoLinkUrl;
        };

        var makeFunctionsAvailableForBrandableToolbar = function() {
            var settings = resources.yuduBook.settings;
            window.yudu_toolbarFunctions = {
                zoomInClicked: buttonHit(this, api.zoom, 1, config.width / 2, config.height / 2),
                zoomOutClicked: buttonHit(this, api.zoom, -1, config.width / 2, config.height / 2),
                prevPageClicked: buttonHit(this, api.previousPage),
                nextPageClicked: buttonHit(this, api.nextPage),
                twoUpToggleClicked: buttonHit(this, api.twoUpToggle),
                fitWidthClicked: buttonHit(this, fitWidthOrScreenAction, true),
                fitPageClicked: buttonHit(this, fitWidthOrScreenAction, false),
                exitFullscreen: buttonHit(this, api.exitFullscreen),
                openPhoneView: buttonHit(this, openArticleView),
                setAutoHide: setAutoHide
            };
            if (!settings.infoScreenDisabled) {
                window.yudu_toolbarFunctions.helpClicked = buttonHit(this, showInfo);
            }
            if (config.logoLinkUrl)
                window.yudu_toolbarFunctions.logoClicked = buttonHit(this, onLogoClicked);
            if (settings.editionListEnabled && !tools.isThisAnApp()) {
                window.yudu_toolbarFunctions.editionListClicked = buttonHit(this, toggleEditionList);
            }
            if (window.yudu_downloadPdfSettings.downloadWholePdfEnabled
                    && !window.yudu_downloadPdfSettings.downloadCustomSelectionEnabled)
                window.yudu_toolbarFunctions.downloadPdfClicked = buttonHit(this, onDownloadPdfClicked);
            if (window.yudu_downloadPdfSettings.downloadCustomSelectionEnabled
                    && !window.yudu_downloadPdfSettings.downloadWholePdfEnabled)
                window.yudu_toolbarFunctions.downloadPdfCustomSelectionClicked = buttonHit(this, onDownloadPdfCustomSelectionClicked);
            if (settings.searchEnabled && !config.isDesktop)
                window.yudu_toolbarFunctions.searchClicked = buttonHit(this, showMobileSearch);
            if (config.fullscreenCompatible && settings.fullscreenModeEnabled)
                window.yudu_toolbarFunctions.goFullscreen = buttonHit(this, api.goFullscreen);
            if (config.orderFormEnabled)
                window.yudu_toolbarFunctions.shoppingCartClicked = buttonHit(this, showOrderForm);
            if (config.bookmarksEnabled)
                window.yudu_toolbarFunctions.bookmarkClicked = buttonHit(this, toggleBookmark, false);
            if (config.notesEnabled)
                window.yudu_toolbarFunctions.notesClicked = buttonHit(this, showNotesMode, false);
            if (config.editionLaunchableHtmlEnabled) {
                window.yudu_toolbarFunctions.editionLaunchableHtmlClicked = buttonHit(this, showEditionLaunchableHtml, false);
            }
            if (yudu_toolbarSettings.logoutEnabled) {
                window.yudu_toolbarFunctions.logoutClicked = buttonHit(this, logout);
            }
        };

        var showToolbar = function(shouldShow) {
            shouldShow = shouldShow || false;
            if (shouldShow == isShowing)
                return;

            isShowing = shouldShow;

            if (shouldShow)
                controls.removeClass("hide");
            else
                controls.addClass("hide");

            if (shouldShow) {
                clearToolbarHideTimeout();
                hideToolbarAfterTimeout();
            }
        };

        var handleChangeEvent = function(event) {
            var shouldChange;
            var shouldShow;
            if (config.disableToggleToolbar) {
                // if toolbar toggling is disabled, only permit showing the toolbar when appropriate and already hidden
                // (this allows recovery from any weird hidden state the toolbar might get into)
                shouldChange = !isShowing && (event.data.toggle || event.data.show);
                shouldShow = true;
            } else {
                // toolbar can be toggled: always change, and use event data to drive result
                shouldChange = true;
                // if toggle property is true, then toggle as normal
                // otherwise only show if told to
                shouldShow = event.data.toggle ? !isShowing : !!event.data.show;
            }
            if (shouldChange) {
                showToolbar(shouldShow);
            }
        };

        var handleThumbnailsToggledOrPageChanged = function (event) {
            if (!config.disableToggleToolbar || !event.data) {
                return;
            }

            var shouldShowThumbnails = event.data.show;
            var isToolbarShowing = isShowing;

            if (event.data.toggle) {
                showToolbar(!isToolbarShowing);
            } else {
                showToolbar(!shouldShowThumbnails);
            }
        };

        var handleThumbnailsHiddenPageNotChanged = function () {
            showToolbar(true);
        };


        var buttonHit = function(scope, method) {
            var args = Array.prototype.slice.call(arguments, 2);

            return function() {
                if (!isShowing && !config.isDesktop)
                    return;

                clearToolbarHideTimeout();
                hideToolbarAfterTimeout();

                return method.apply(scope, args);
            };
        };

        var fitWidthOrScreenAction = function(fitWidth) {
            api.fitToWidth(fitWidth);

            events.emit(yudu_events.ALL, yudu_events.TOOLBAR.FIT_WIDTH_OR_SCREEN_ACTION, controls, {fitOnlyWidth: config.fitOnlyWidth});
        };

        /**
         * Toggles the sharing dropdown and clears the contents and thumbnails bars
         */
        var setAutoHide = function(enable) {
            if (enable) {
                // only start the counter if it is not already here, ie, do not reset the timer
                if (!timeout) {
                    hideToolbarAfterTimeout();
                }
            }
            else {
                clearToolbarHideTimeout();
            }
        };

        var toggleEditionList = function() {
            var src = config.editionListUrl + "?pubId=" + resources.yuduBook.settings.pubId +
                "&editionId=" + resources.yuduBook.settings.id +
                "&bgTopColour=" + config.bgTopColour +
                "&bgBottomColour=" + config.bgBottomColour +
                "&textColour=" + resources.yuduBook.settings.editionListTextColour +
                "&editionListSource=" + resources.yuduBook.settings.editionListSource +
                "&windowWidth=" + $(window).width() +
                "&windowHeight=" + $(window).height();

            var lightboxArgs = {
                w:100,
                h:100,
                callback: events.callback(this, function(){
                    if (config.isDesktop) {
                        $('iframe', $(editionListLightbox))[0].contentWindow.setLogo(resources.logo != false, resources.logo.src, config.logoLinkUrl);
                    }
                }),
                src: src,
                interactionEnabled: true,
                addCloseButton: false,
                bgColour: "000000",
                animated: true
            };

            var editionListLightbox = uiTools.createIframeLightbox(lightboxArgs);
            $(editionListLightbox).show();
            // note this does not need to be explicitly shown since the edition list sends a `finishedLoadingEditionList`
            //  message to uiTools when it finishes loading which does so on its behalf
            // other uses of the iframe lightbox will need to explicitly show the content when it finishes loading, for
            //  example via the `callback` "argument"
        };

        //initialises the toolbar
        var init = function() {
            //prevent the user from being able to drag the toolbar
            events.yuduOn(controls, "touchmove", events.callback(this, function() {
                return false;
            }));

            events.subscribe(events.ALL, events.SHOWHIDE_TOOLBAR, handleChangeEvent, false);
            if (config.alternatePhoneviewNavigationEnabled) {
                showToolbar(true);
            } else if(!config.disableToggleToolbar) {
                showToolbar(false);
            } else {
                events.subscribe(events.ALL, events.THUMBNAILS.TOGGLE_THUMBNAILS, handleThumbnailsToggledOrPageChanged);
                events.subscribe(events.ALL, events.THUMBNAILS.PAGE_CHANGED, handleThumbnailsToggledOrPageChanged);
                events.subscribe(events.ALL, events.THUMBNAILS.HIDE_THUMBNAILS_PAGE_NOT_CHANGED, handleThumbnailsHiddenPageNotChanged);
            }
            if (yudu_toolbarSettings.logoutEnabled) {
                events.subscribe(events.ALL, events.LOGIN_SUCCESS, function() {
                    events.emit(yudu_events.ALL, yudu_events.COMMON.LOGIN_SUCCESS);
                });
            }
        };

        /**
         * Helper that sets a timeout which will hide the toolbar after a given period of time
         */
        var hideToolbarAfterTimeout = function() {
            if (config.isDesktop || config.disableToggleToolbar || config.alternatePhoneviewNavigationEnabled) {
                // desktop toolbars will never be hidden - this is also enforced in the stylesheet
                return;
            }
            timeout = window.setTimeout(function() {
                showToolbar(false);
            }, constants.toolbarTimeout);
        };

        /**
         * Helper that resets any active timeout to hide the toolbar
         */
        var clearToolbarHideTimeout = function() {
            if (timeout) {
                window.clearTimeout(timeout);
                timeout = null;
            }
        };

        var showMobileSearch = function() {
            search.showMobileSearch();
        };

        var toggleBookmark = function() {
            bookmarks.toggleBookmark();
        };

        var showNotesMode = function() {
            notes.showNotesCreationMode();
        };

        var showOrderForm = function() {
            orderForm.showForDuration();
        };

        var onLogoClicked = function() {
            var url = config.logoLinkUrl;
            statistics.action({
                actionType: statistics.events.logo_clicked,
                extraInfo: url
            });
            tools.openURL(url, true);
        };

        var onDownloadPdfClicked = function() {
            downloadPdfTools.onDownloadWholePdfClicked();
        };

        var onDownloadPdfCustomSelectionClicked = function() {
            downloadPdfTools.onDownloadCustomSelectionClicked();
        };

        var openArticleView = function() {
            api.openArticleView();
        };

        var showInfo = function() {
            information.showInfo();
        };

        var showEditionLaunchableHtml = function() {
            if (!this.launchableHtml) {
                this.launchableHtml = new editionLaunchableHtml.EditionLaunchableHtml(
                    resources.yuduBook.settings.editionLaunchableHtml);
            }
            this.launchableHtml.showContent();
        };

        var logout = function() {
            sharedLogin.logout();
            rememberedPageUtils.setRememberedPage(resources.yuduBook.settings.id, 0);
            var firstPageUrl = new URL(location.href);
            firstPageUrl.searchParams.delete('page');
            tools.openURL(firstPageUrl);
        };

        return {
            init: init,
            preInit: preInit
        };
    });

define('shared/commonFunctionsApi',['constants', 'config', 'events', 'shared/hammerManager'], function(constants, config, events, hammerManager) {

        var cssFilesCounter = {};

        var loadCss = function(cssFiles, callback) {
            cssFiles = (cssFiles instanceof Array) ? cssFiles : [cssFiles];
            var l = cssFiles.length;

            var key = Math.floor((Math.random() * 1000) + 1);
            while (cssFilesCounter.hasOwnProperty(key)) {
                key = Math.floor((Math.random() * 1000) + 1);
            }
            cssFilesCounter[key] = 0;

            for (var i = 0; i < l; i++) {
                var link = $('<link rel="stylesheet" type="text/css" href="' + cssFiles[i] + '">');
                link.on('load', function() {
                    onCssFileLoaded(callback, l, key);
                });
                $('head').append(link);
            }
        };

        var onCssFileLoaded = function(callback, numberOfFiles, key) {
            cssFilesCounter[key]++;
            if (cssFilesCounter[key] == numberOfFiles) {
                delete cssFilesCounter[key];
                callback.call();
            }
        };

    var hideToolbar = function() {
        events.emit(events.ALL, events.SHOWHIDE_TOOLBAR, this, {toggle: false, show: false});
    };

    var injectJavascript = function(localFilePath) {
            // do not use jQuery to inject scripts to the head element - it breaks silently on Metro
            var newScript = document.createElement('script');
            newScript.type = 'text/javascript';
            newScript.src = localFilePath;
            document.getElementsByTagName('head')[0].appendChild(newScript);
        };

        var createBrandingPath = function(relativePath) {
            return constants.baseResourcesFolder + relativePath;
        };

        var init = function() {
            window.yudu_commonSettings = window.yudu_commonSettings || {};
            window.yudu_commonFunctions = window.yudu_commonFunctions || {};

            // There is a lot of functionality in brandableSubmodulesApi that is a more natural fit for this class,
            // and should be moved over if/when there's a need to do so.

            // These temporary values are overwritten on initialisation.
            window.yudu_commonSettings.width = 1200;
            window.yudu_commonSettings.height = 800;
            window.yudu_commonSettings.pixelDensity = 1;
            window.yudu_commonSettings.isDesktop = config.isDesktop;

            window.yudu_commonFunctions.loadCss = loadCss;
            window.yudu_commonFunctions.injectJavascript = injectJavascript;
            window.yudu_commonFunctions.createBrandingPath = createBrandingPath;
            window.yudu_commonFunctions.createHammerJSTapManager = hammerManager.createTapManager;

            // toolbar functions
            window.yudu_commonFunctions.hideToolbar = hideToolbar; // Only hides when the current toolbar supports hiding!

            events.subscribe(events.ALL, events.RESIZE, events.callback(this, resizeCallback));
        };

        var resizeCallback = function(event) {
            yudu_commonSettings.width = event.data.width;
            yudu_commonSettings.height = event.data.height;
        };

        return {
            init: init
        };
    });
define('brandableSubmodulesApi',['constants', 'config', 'events', 'ui/uiTools', 'shared/localisation', 'utils/tools',
        'shared/hammerManager', 'easel', 'hammer2', 'jquery'],
function(constants, config, events, uiTools, localisation, tools,
         hammerManager, createjs, hammerjs, $) {

    var decryptAllPages = function() {
        if (config.decryptionKey) {
            events.emit(events.ALL, events.DECRYPT_ALL_PAGES, this, {key: config.decryptionKey});
        }
    };

    var toolbarFinishedLoading = function() {
        window.yudu_commonSettings.toolbarLoaded = true;
        events.emit(events.ALL, yudu_events.TOOLBAR.LOADED);
    };

    var goToPage = function(pageNumber) {
        events.emit(events.ALL, events.GOTO_PAGE, this, {pageNumber: pageNumber});
    };

    var init = function() {
        // See also shared/commonFunctionsApi.

        window.yudu_commonSettings = window.yudu_commonSettings || {};
        window.yudu_commonFunctions = window.yudu_commonFunctions || {};

        window.yudu_commonSettings.brandingFolderPath = constants.baseResourcesFolder;
        window.yudu_commonSettings.clickAction = config.clickAction;
        window.yudu_commonSettings.toolbarLoaded = false;
        window.yudu_commonSettings.orientation = config.orientation;
        window.yudu_commonSettings.hasIntroPage = config.hasIntroPage;
        window.yudu_commonSettings.hammerJSRecogniserPresets = hammerManager.createPresetsObject({});
        window.yudu_commonSettings.createjs = createjs;
        window.yudu_commonSettings.hammerjs = hammerjs;
        window.yudu_commonSettings.pixelDensity = config.pixelDensity;

        // helper functions
        window.yudu_commonFunctions.returnDynamicInput = tools.returnDynamicInput;
        window.yudu_commonFunctions.returnFunctionWithDynamicArgs = tools.returnFunctionWithDynamicArgs;
        // page loading utilities
        window.yudu_commonFunctions.decryptAllPages = decryptAllPages;
        // general getters
        window.yudu_commonFunctions.getLocalisedStringByCode = localisation.get;
        // toolbar functions
        window.yudu_commonFunctions.enableScrollingWithoutDocumentBouncing = uiTools.enableScrollingWithoutDocumentBouncing;
        window.yudu_commonFunctions.toolbarFinishedLoading = toolbarFinishedLoading;
        // interaction functions
        window.yudu_commonFunctions.createHammerJSManagerWithRecognisers = hammerManager.createManagerWithRecognisers;
        window.yudu_commonFunctions.createHammerJSManagerWithOptions = hammerManager.createManagerWithOptions;
        window.yudu_commonFunctions.createHammerJSTapManager = hammerManager.createTapManager;
        // reader API calls
        window.yudu_commonFunctions. goToPage = goToPage;
        // user preferences
        window.yudu_commonFunctions.updateUserPreferenceSetting = config.updateUserPreferenceSetting;

        events.subscribe(events.ALL, events.RESIZE, function() {
            yudu_commonSettings.width = config.width;
            yudu_commonSettings.height = config.height;
            yudu_commonSettings.pixelDensity = config.pixelDensity;
            events.emit(yudu_events.ALL, yudu_events.COMMON.RESIZE);
        });
        events.subscribe(events.ALL, events.TOUCH, function() {
            events.emit(yudu_events.ALL, yudu_events.COMMON.TOUCH);
        });
        events.subscribe('bookmarks', events.UGC_CHANGED, function() {
            events.emit(yudu_events.ALL, yudu_events.COMMON.UGC_BOOKMARKS_CHANGED)
        });
        events.subscribe('pageHighlights', events.UGC_CHANGED, function() {
            events.emit(yudu_events.ALL, yudu_events.COMMON.UGC_PAGE_HIGHLIGHTS_CHANGED)
        });
        events.subscribe('notes', events.UGC_CHANGED, function() {
            events.emit(yudu_events.ALL, yudu_events.COMMON.UGC_NOTES_CHANGED)
        });
        events.subscribe(events.ALL, events.PAGE_DECRYPTED, function() {
            // decrpytion key has been tested successfully
            events.emit(yudu_events.ALL, yudu_events.COMMON.LOGIN_APPROVED);
        });
    };

    return {
        init: init
    }
});
var LZString=function(){function o(o,r){if(!t[o]){t[o]={};for(var n=0;n<o.length;n++)t[o][o.charAt(n)]=n}return t[o][r]}var r=String.fromCharCode,n="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$",t={},i={compressToBase64:function(o){if(null==o)return"";var r=i._compress(o,6,function(o){return n.charAt(o)});switch(r.length%4){default:case 0:return r;case 1:return r+"===";case 2:return r+"==";case 3:return r+"="}},decompressFromBase64:function(r){return null==r?"":""==r?null:i._decompress(r.length,32,function(e){return o(n,r.charAt(e))})},compressToUTF16:function(o){return null==o?"":i._compress(o,15,function(o){return r(o+32)})+" "},decompressFromUTF16:function(o){return null==o?"":""==o?null:i._decompress(o.length,16384,function(r){return o.charCodeAt(r)-32})},compressToUint8Array:function(o){for(var r=i.compress(o),n=new Uint8Array(2*r.length),e=0,t=r.length;t>e;e++){var s=r.charCodeAt(e);n[2*e]=s>>>8,n[2*e+1]=s%256}return n},decompressFromUint8Array:function(o){if(null===o||void 0===o)return i.decompress(o);for(var n=new Array(o.length/2),e=0,t=n.length;t>e;e++)n[e]=256*o[2*e]+o[2*e+1];var s=[];return n.forEach(function(o){s.push(r(o))}),i.decompress(s.join(""))},compressToEncodedURIComponent:function(o){return null==o?"":i._compress(o,6,function(o){return e.charAt(o)})},decompressFromEncodedURIComponent:function(r){return null==r?"":""==r?null:(r=r.replace(/ /g,"+"),i._decompress(r.length,32,function(n){return o(e,r.charAt(n))}))},compress:function(o){return i._compress(o,16,function(o){return r(o)})},_compress:function(o,r,n){if(null==o)return"";var e,t,i,s={},p={},u="",c="",a="",l=2,f=3,h=2,d=[],m=0,v=0;for(i=0;i<o.length;i+=1)if(u=o.charAt(i),Object.prototype.hasOwnProperty.call(s,u)||(s[u]=f++,p[u]=!0),c=a+u,Object.prototype.hasOwnProperty.call(s,c))a=c;else{if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++),s[c]=f++,a=String(u)}if(""!==a){if(Object.prototype.hasOwnProperty.call(p,a)){if(a.charCodeAt(0)<256){for(e=0;h>e;e++)m<<=1,v==r-1?(v=0,d.push(n(m)),m=0):v++;for(t=a.charCodeAt(0),e=0;8>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}else{for(t=1,e=0;h>e;e++)m=m<<1|t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t=0;for(t=a.charCodeAt(0),e=0;16>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1}l--,0==l&&(l=Math.pow(2,h),h++),delete p[a]}else for(t=s[a],e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;l--,0==l&&(l=Math.pow(2,h),h++)}for(t=2,e=0;h>e;e++)m=m<<1|1&t,v==r-1?(v=0,d.push(n(m)),m=0):v++,t>>=1;for(;;){if(m<<=1,v==r-1){d.push(n(m));break}v++}return d.join("")},decompress:function(o){return null==o?"":""==o?null:i._decompress(o.length,32768,function(r){return o.charCodeAt(r)})},_decompress:function(o,n,e){var t,i,s,p,u,c,a,l,f=[],h=4,d=4,m=3,v="",w=[],A={val:e(0),position:n,index:1};for(i=0;3>i;i+=1)f[i]=i;for(p=0,c=Math.pow(2,2),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(t=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=r(p);break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;l=r(p);break;case 2:return""}for(f[3]=l,s=l,w.push(l);;){if(A.index>o)return"";for(p=0,c=Math.pow(2,m),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;switch(l=p){case 0:for(p=0,c=Math.pow(2,8),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=r(p),l=d-1,h--;break;case 1:for(p=0,c=Math.pow(2,16),a=1;a!=c;)u=A.val&A.position,A.position>>=1,0==A.position&&(A.position=n,A.val=e(A.index++)),p|=(u>0?1:0)*a,a<<=1;f[d++]=r(p),l=d-1,h--;break;case 2:return w.join("")}if(0==h&&(h=Math.pow(2,m),m++),f[l])v=f[l];else{if(l!==d)return null;v=s+s.charAt(0)}w.push(v),f[d++]=s+v.charAt(0),h--,s=v,0==h&&(h=Math.pow(2,m),m++)}}};return i}();"function"==typeof define&&define.amd?define('lzString',[],function(){return LZString}):"undefined"!=typeof module&&null!=module&&(module.exports=LZString);

define('utils/ugcUtils',['config', 'shared/storage', 'lzString'], function(config, storage, lzString) {
    //I chose to handle the compress keyword here, save us have to make changes in multiple changes in the future,
    // all we have to do is call the compress methods with the old key and data.
    var COMPRESSED = 'compressed';

    /**
     * Helper method to retrieve arbitrary UGC data given the key
     * @returns {*}
     */
    var retrieveUgcFromLocalStorage = function(key) {
        return JSON.parse(storage.getItem(key));
    };

    /**
     * Helper method to retrieve arbitrary UGC data given the key
     * This data has been compressed and we decompress it before parsing it to JSON
     * @returns {*}
     * */
    var retrieveCompressedUgcFromLocalStorage = function(key) {
        var pageHighlights = storage.getItem(getStorageKeyForCompressedData(key));

        //If String is already compressed then decompress, parse and return.
        if(pageHighlights) {
            //decompress the string
            var decompressedPageHighlights = lzString.decompressFromEncodedURIComponent(pageHighlights)
            var parsedPageHighlights = JSON.parse(decompressedPageHighlights);

            return parsedPageHighlights;
        } else {
            //If not compressed parse, replace the local storage data with a compressed version, returned the parsed string.
            var parsedPageHighlights = retrieveUgcFromLocalStorage(key);

            if(parsedPageHighlights) {
                //Delete the old entry in local storage
                storage.removeItem(key);

                //Create a compressed entry.
                compressAndSaveUgcToLocalStorage(key, parsedPageHighlights);
            }

            return parsedPageHighlights;
        }
    };

    /**
     * Compress and save Ugc to local storage
     * */
    var compressAndSaveUgcToLocalStorage = function (key, data) {
        var dataJSON = JSON.stringify(data);
        var dataJSONCompressed = lzString.compressToEncodedURIComponent(dataJSON);
        storage.setItem(getStorageKeyForCompressedData(key), dataJSONCompressed);
    };
    
    var getStorageKeyForCompressedData = function(key) {
        return key + '-' + COMPRESSED;
    };

    /**
     * Single method to combine all functionality required to prepare UGC for synchronisation
     * @param jsonObject ; the JSON object with the UGC data
     * @param keyedByPage ; whether the data is keyed by page ID (true: bookmarks/highlights) or UID (false: notes)
     * @returns {*} ; JSON object with UGC data appropriately prepared
     */
    var prepareUgcForSyncRequest = function(jsonObject, keyedByPage) {
        var newJson = {};
        for (var readerKey in jsonObject) {
            if (jsonObject.hasOwnProperty(readerKey)) {
                // the data is kept serialised in the local storage, so they need to be parsed
                var value = JSON.parse(jsonObject[readerKey]);
                // we only want to sync UGC that has been modified since the last sync
                if (value.lastModified > value.lastSynced) {
                    var compatibleKey = readerKey;
                    // the HTML reader works on 0-indexed page numbers, but Publisher assumes 1-indexing
                    //  as page number 0 is reserved for the intro page even when not present
                    // to keep UGC cross-platform compatible, when we do not have an intro page,
                    //  we need to add one to all the page numbers
                    if (!config.hasIntroPage) {
                        value.pageNumber += 1;
                        // similarly, we need to ensure the new hash key, when using the page number, is increased
                        if (keyedByPage) {
                            compatibleKey = (parseInt(readerKey, 10) + 1).toString();
                        }
                    }
                    // add the modified UGC to the new hash
                    newJson[compatibleKey] = value;
                }
            }
        }
        return newJson;
    };

    /**
     * Single method to reverse the prepare-for-sync method to receive synced data
     * @param jsonObject ; the JSON object with the UGC data
     * @param keyedByPage ; whether the data is keyed by page ID (true: bookmarks/highlights) or UID (false: notes)
     * @returns {*} ; JSON object with UGC data appropriately prepared
     */
    var prepareUgcFromSyncResponse = function(jsonObject, keyedByPage) {
        var newJson = {};
        for (var compatibleKey in jsonObject) {
            if (jsonObject.hasOwnProperty(compatibleKey)) {
                var readerKey = compatibleKey;
                var value = jsonObject[compatibleKey];
                if (!config.hasIntroPage) {
                    // no intro page, so there should be no UGC with a page number of 0
                    if (!value.pageNumber || value.pageNumber <= 0) {
                        if (keyedByPage || !value.isDeleted) {
                            console.log("Unexpected page number received from UGC sync response: ignoring element.");
                            continue;
                        }
                        // deleted notes from other platforms may not have a page number as the page number is
                        //  considered part of the note's "content", which is deleted on note-deletion
                    } else {
                        // reset page numbers to 0-indexing
                        value.pageNumber -= 1;
                        if (keyedByPage) {
                            readerKey = (parseInt(compatibleKey, 10) - 1).toString();
                        }
                    }
                }
                newJson[readerKey] = JSON.stringify(value);
            }
        }
        return newJson;
    };

    /**
     * change the page numbers of local UGC for editions whose intro page offset has changed since the last save
     * this solution does not require refactoring, but is inefficient: this is ok because it should happen rarely
     * @param localStorageKey ; key for JSON in local storage to apply offset to
     * @param keyedByPage ; whether the data is keyed by page ID (true: bookmarks/highlights) or UID (false: notes)
     */
    var applyIntroPageOffset = function(localStorageKey, keyedByPage) {
        var newJson = {};
        var jsonObject = JSON.parse(storage.getItem(localStorageKey));
        for (var key in jsonObject) {
            if (jsonObject.hasOwnProperty(key)) {
                // the data is kept serialised in the local storage, so they need to be parsed
                var value = JSON.parse(jsonObject[key]);
                if (!value.pageNumber || value.pageNumber < 0) {
                    // this is here to prevent exceptions thrown by remotely-deleted notes without pages that have
                    //  overwritten local data but has not yet deleted it
                    continue;
                }
                var newKey = key;
                if (config.hasIntroPage) {
                    // new intro page added: increase page numbers
                    value.pageNumber += 1;
                    if (keyedByPage) {
                        newKey = (parseInt(key, 10) + 1).toString();
                    }
                } else {
                    // no intro page now: decrease page numbers
                    if (value.pageNumber == 0) {
                        // there was UGC on the intro page: remove it
                        continue;
                    }
                    value.pageNumber -= 1;
                    if (keyedByPage) {
                        newKey = (parseInt(key, 10) - 1).toString();
                    }
                }
                // reserialise the data after offsetting
                newJson[newKey] = JSON.stringify(value);
            }
        }
        storage.setItem(localStorageKey, JSON.stringify(newJson));
    };

    /**
     * Helper method: determines if there is content in a json/object
     * @param json ; JSON to check for content
     * @returns {boolean}
     */
    var jsonHasContent = function(json) {
        for (var key in json) {
            if (json.hasOwnProperty(key)) {
                return true;
            }
        }
        return false;
    };

    /**
     * Helper method: determines if there is content in any json/object in an array
     * @param array ; array of JSONs
     * @returns {boolean}
     */
    var anyJsonHaveContent = function(array) {
        for (var i = 0, m = array.length; i < m; i += 1) {
            if (jsonHasContent(array[i])) {
                return true;
            }
        }
        return false;
    };

    return {
        retrieveUgcFromLocalStorage: retrieveUgcFromLocalStorage,
        retrieveCompressedUgcFromLocalStorage: retrieveCompressedUgcFromLocalStorage,
        compressAndSaveUgcToLocalStorage: compressAndSaveUgcToLocalStorage,
        prepareUgcForSyncRequest: prepareUgcForSyncRequest,
        prepareUgcFromSyncResponse: prepareUgcFromSyncResponse,
        applyIntroPageOffset: applyIntroPageOffset,
        jsonHasContent: jsonHasContent,
        anyJsonHaveContent: anyJsonHaveContent
    };
});

define('utils/timerUtils',['events'],
    function(events) {
        var TYPE_TIMEOUT = 'timeout';
        var TYPE_INTERVAL = 'interval';

        /**
         * wrapper object to handle state associated with `timeout`s and `interval`s
         * it is basically a generified way of keeping track of whether a countdown is running without needing two variables
         * @returns {Countdown}
         * @constructor
         */
        var Countdown = function() {
            this.init = function() {
                this.type = null;
                this.function = null;
                this.handle = null;
                this.running = false;
            };

            /**
             * check to see if this countdown is running or not
             * @returns {boolean}
             */
            this.isRunning = function() { return this.running; };

            /**
             * interface method for setting a timeout
             * @param timeoutFunction ; function to use as a callback
             * @param timeoutTimeout ; length of time to set for the timeout in ms
             */
            this.startTimeout = function(timeoutFunction, timeoutTimeout) {
                this.reset();
                this.type = TYPE_TIMEOUT;
                this.function = timeoutFunction;
                this.handle = setTimeout(events.callback(this, this.triggerTimeout), timeoutTimeout);
                this.running = true;
            };

            /**
             * internal wrapper to trigger a function and ensure the handle is updated
             */
            this.triggerTimeout = function() {
                this.stopCountdown();
                try {
                    this.function();
                } catch (e) {
                    console.log(e);
                }
                this.reset();
            };

            /**
             * interface method for setting an interval
             * @param intervalFunction ; function to use as a callback
             * @param intervalTimeout ; length of time to set for the timeout in ms
             */
            this.startInterval = function(intervalFunction, intervalTimeout) {
                this.reset();
                this.type = TYPE_INTERVAL;
                this.handle = setInterval(intervalFunction, intervalTimeout);
                this.running = true;
            };

            /**
             * stops a countdown, but does not ensure internal state is reset - use `reset` for that
             */
            this.stopCountdown = function() {
                if (this.type == TYPE_TIMEOUT) {
                    clearTimeout(this.handle);
                } else if (this.type == TYPE_INTERVAL) {
                    clearInterval(this.handle);
                }
                this.running = false;
            };

            /**
             * resets a counter to ensure any running countdown is stopped and that all variables are reinitialised
             */
            this.reset = function() {
                this.stopCountdown();
                this.init();
            };

            // make sure we create an initialised countdown
            this.init();
            return this;
        };

        return {
            Countdown: Countdown
        };
    });

define('ugc',['events', 'constants', 'config', 'resources', 'ui/login', 'shared/ui/messageBox',
            'utils/ugcUtils', 'utils/ugcApi', 'utils/timerUtils', 'shared/localisation', 'shared/storage', 'utils/rememberMeToken'],
    function(events, constants, config, resources, login, messageBox,
             ugcUtils, ugcApi, timerUtils, localisation, storage, rememberMeToken) {
        var BOOKMARKS = 'bookmarks';
        var PAGE_HIGHLIGHTS = 'pageHighlights';
        var NOTES = 'notes';
        var BOOKMARKS_CONTENT_BASE = 'bookmarks-';
        var PAGE_HIGHLIGHTS_CONTENT_BASE = 'pageHighlights-';
        var NOTES_CONTENT_BASE = 'notes-';
        var LAST_CONTENT_SYNC_BASE = 'synced-';
        var HAS_INTRO_PAGE_BASE = 'introPage-';
        var BOOKMARKS_CONTENT;
        var PAGE_HIGHLIGHTS_CONTENT;
        var NOTES_CONTENT;
        var LAST_CONTENT_SYNC;
        var HAS_INTRO_PAGE;

        var bookId = 0;

        /**
         * Initialisation content necessary for any other UGC module to be initialised
         */
        var init = function() {
            // make sure UGC is unique between editions
            bookId = resources.yuduBook.settings.id;
            BOOKMARKS_CONTENT_BASE += bookId;
            PAGE_HIGHLIGHTS_CONTENT_BASE += bookId;
            NOTES_CONTENT_BASE += bookId;
            LAST_CONTENT_SYNC_BASE += bookId;
            HAS_INTRO_PAGE_BASE += bookId;
            addSuffixToBaseIds('');
            checkForIntroPageStateChange();
            // subscribe to potentially ugc-changing events
            events.subscribe(BOOKMARKS, events.UGC_CHANGED, events.callback(this, saveBookmarks));
            events.subscribe(PAGE_HIGHLIGHTS, events.UGC_CHANGED, events.callback(this, savePageHighlights));
            events.subscribe(NOTES, events.UGC_CHANGED, events.callback(this, saveNotes));
        };

        /**
         * Helper method to ease repetition in changing values of local storage keys
         * @param suffix ; new suffix to add to the "base" key to create the "current" key
         */
        var addSuffixToBaseIds = function(suffix) {
            BOOKMARKS_CONTENT = BOOKMARKS_CONTENT_BASE + suffix;
            PAGE_HIGHLIGHTS_CONTENT = PAGE_HIGHLIGHTS_CONTENT_BASE + suffix;
            NOTES_CONTENT = NOTES_CONTENT_BASE + suffix;
            LAST_CONTENT_SYNC = LAST_CONTENT_SYNC_BASE + suffix;
            HAS_INTRO_PAGE = HAS_INTRO_PAGE_BASE + suffix;
        };

        /**
         * Handles the check for a change in the presence of an intro page for the edition
         * Such a change can cause UGC to appear on the wrong page without a check like this
         * It ensures that UGC is repositioned if a change is detected
         * If no previous intro page state is associated with an edition's UGC, the current state will be assumed
         */
        var checkForIntroPageStateChange = function() {
            var previousIntroPageState = storage.getItem(HAS_INTRO_PAGE);
            if (!!previousIntroPageState) {
                if (JSON.parse(previousIntroPageState) === config.hasIntroPage) {
                    // intro page state has not changed
                    return;
                }
                // we need to offset locally-stored UGC page numbers to account for a change in the presence of the intro page
                // remote UGC will already be offset
                ugcUtils.applyIntroPageOffset(BOOKMARKS_CONTENT, true);
                ugcUtils.applyIntroPageOffset(NOTES_CONTENT, false);
                ugcUtils.applyIntroPageOffset(PAGE_HIGHLIGHTS_CONTENT, true);
            }
            storage.setItem(HAS_INTRO_PAGE, JSON.stringify(config.hasIntroPage));
        };

        /**
         * Get the bookmarks from local storage
         * @returns {*}
         */
        var retrieveBookmarks = function() {
            return ugcUtils.retrieveUgcFromLocalStorage(BOOKMARKS_CONTENT);
        };

        /**
         * Get any bookmarks which have been modified since the last attempted sync
         * @returns {*}
         */
        var unsyncedBookmarks = function() {
            return ugcUtils.prepareUgcForSyncRequest(retrieveBookmarks(), true);
        };

        /**
         * Event handler callback for a change to any bookmark data
         * Will save the current state of the bookmarks to the local storage
         * @param event ; optional data passed by the event emitter
         */
        var saveBookmarks = function(event) {
            var bookmarks = event.data.bookmarks;
            var stringifiedBookmarks = {};
            for (var property in bookmarks) {
                if (bookmarks.hasOwnProperty(property)) {
                    stringifiedBookmarks[property] = JSON.stringify(bookmarks[property].getWriteableObject());
                }
            }
            storage.setItem(BOOKMARKS_CONTENT, JSON.stringify(stringifiedBookmarks));
            if (!event.data.fromSync) {
                ugcSync.syncUgc({});
            }
        };

        /**
         * Get the page highlights from local storage
         * @returns {*}
         */
        var retrievePageHighlights = function() {
            return ugcUtils.retrieveCompressedUgcFromLocalStorage(PAGE_HIGHLIGHTS_CONTENT);
        };

        /**
         * Get any page highlights which have been modified since the last attempted sync
         * @returns {*}
         */
        var unsyncedPageHighlights = function() {
            return ugcUtils.prepareUgcForSyncRequest(retrievePageHighlights(), true);
        };

        /**
         * Event handler callback for a change to any page highlights data
         * Will save the current state of the page highlights to the local storage
         * @param event ; optional data passed by the event emitter
         */
        var savePageHighlights = function(event) {
            var pageHighlights = event.data.pageHighlights;
            var stringifiedHighlights = {};
            for (var property in pageHighlights) {
                if (pageHighlights.hasOwnProperty(property)) {
                    stringifiedHighlights[property] = JSON.stringify(pageHighlights[property].getWriteableObject());
                }
            }
            try {
                ugcUtils.compressAndSaveUgcToLocalStorage(PAGE_HIGHLIGHTS_CONTENT, stringifiedHighlights);
            } catch (e) {
               alert("Local Storage is full, Please erase some highlights and try again");
            }
            if (!event.data.fromSync) {
                ugcSync.syncUgc({});
            }
        };

        /**
         * Get the notes from local storage
         * @returns {*}
         */
        var retrieveNotes = function() {
            return ugcUtils.retrieveUgcFromLocalStorage(NOTES_CONTENT);
        };

        /**
         * Get any notes which have been modified since the last attempted sync
         * @returns {*}
         */
        var unsyncedNotes = function() {
            return ugcUtils.prepareUgcForSyncRequest(retrieveNotes(), false);
        };

        /**
         * Event handler callback for a change to any notes' data
         * Will save the current state of the notes to the local storage
         * @param event ; optional data passed by the event emitter
         */
        var saveNotes = function(event) {
            var notes = event.data.notes;
            var stringifiedNotes = {};
            for (var property in notes) {
                if (notes.hasOwnProperty(property)) {
                    stringifiedNotes[property] = JSON.stringify(notes[property].getWriteableObject());
                }
            }
            storage.setItem(NOTES_CONTENT, JSON.stringify(stringifiedNotes));
            if (!event.data.fromSync) {
                ugcSync.syncUgc({});
            }
        };

        /**
         * Submodule that deals with the UGC sync process
         */
        var ugcSync = function() {
            var lastSynced = 0;
            var ugcSyncUrl = false;
            var syncInitialised = false;
            var ugcRequestedLogin = false;
            var attemptingSync = false;
            var hasSyncedSuccessfully = false;
            var ugcTimeout = new timerUtils.Countdown();
            var previousRequestFailed = false;

            /**
             * Initialisation content only necessary if at least one other UGC module has been initialised
             */
            var syncInit = function() {
                lastSynced = storage.getItem(LAST_CONTENT_SYNC) || 0;
                var syncUrl = resources.yuduBook.settings.ugcSyncBaseUrl;
                if (!!syncUrl) {
                    ugcSyncUrl = syncUrl + resources.yuduBook.settings.id;
                } else {
                    ugcSyncUrl = false;
                    return;
                }
                events.subscribe(events.ALL, events.LOGIN_SUCCESS, events.callback(this, getSubscriberInfo));
                events.subscribe(events.ALL, events.LOGIN_DETAILS_CHANGED, events.callback(this, getSubscriberInfo));
                getSubscriberInfo();
                syncInitialised = true;
            };

            var getSubscriberInfo = function(event) {
                //only attempt to get subscriber info if subscriber is logged in
                if(!config.isLoggedIn) return;

                if (event.data && event.data.credentials && event.data.credentials.ssoSubscriberId) {
                    syncUgc();
                    return;
                }

                if (login.getSubscriberId()) {
                    // if a subscriber ID is already known, either a response has already been processed,
                    // or a wrapper has supplied an ID; either way: use the stored ID
                    if (subscriberId.subscriberIdChanged(login.getSubscriberId())) {
                        syncUgc();
                        return;
                    }
                }
                // otherwise send an empty request to obtain a subscriber ID before syncing
                if (!ugcSyncUrl) {
                    return;
                }
                if (attemptingSync) {
                    functionQueue.queueSubscriberInfo();
                    return;
                }
                if (!(login.getHasCredentials() || rememberMeToken.hasTokenDetails())) {
                    if (syncInitialised && !ugcRequestedLogin) {
                        events.emit(events.ALL, events.SHOW_LOGIN, this, {ugcCredentialsRequested: true});
                        ugcRequestedLogin = true;
                    }
                    return;
                }
                attemptingSync = true;
                sendSyncAjax(serialiseSyncData(false), subscriberSuccess, subscriberError);
            };

            var subscriberSuccess = function(data, textStatus, jqXHR) {
                // handle remote errors or missing data
                if (jqXHR.status != 200 || !(data && data.authenticationResult && data.authenticationResult.userId)) {
                    subscriberError(jqXHR, textStatus, null);
                    return;
                }
                // manage any potential change in subscriber ID
                if (subscriberId.subscriberIdChanged(data.authenticationResult.userId)) {
                    // subscriber ID has changed: queue a sync request
                    functionQueue.queueSyncFromSubscriberInfo();
                } else {
                    setTimeout(syncUgc, 0);
                }
            };

            var subscriberError = function(jqXHR, textStatus, errorThrown) {
                // only display an error message if this is the first failed request
                if (!previousRequestFailed && resources.yuduBook.settings.ugcAllowAllPrompts) {
                    // this message might be displayed unnecessarily by, for example, 3rd party auth from an app
                    // since it is not strictly necessary (alerting users to sync failure should be sufficient)
                    //  we now hide it behind a setting (that still needs implementing)
                    if (jqXHR.responseText && jqXHR.responseText.error && console && console.log) {
                        console.log('Remote server error message from UGC subscriber ID attempt:\n' + jqXHR.responseText.error);
                    }
                    messageBox.displayByCode('ugc.sync.subscriberError');
                    previousRequestFailed = true;
                }
                // try again later
                ugcTimeout.startTimeout(getSubscriberInfo, constants.ugcSyncRetryTimer);
            };

            /**
             * Entry method to the sync process: determines if a sync is needed, and if it is, sends a request to Publisher
             * @param event ; optional data passed by the event emitter if triggered by an event
             */
            var syncUgc = function (event) {
                // Do not attempt to sync if a remote URL is not specified
                if (!ugcSyncUrl) {
                    return;
                }
                // If a sync is already in progress, queue another request
                if (attemptingSync) {
                    functionQueue.queueSync();
                    return;
                }
                // If there are no login credentials, we allow one request to display the login window
                //  except during initialisation, which may open the login window anyway, to avoid a potential conflict.
                // If we have already requested it, then we do not attempt to sync.
                if (!(login.getHasCredentials() || rememberMeToken.hasTokenDetails() || login.getSsoSubscriberId())) {
                    if (syncInitialised && !ugcRequestedLogin) {
                        events.emit(events.ALL, events.SHOW_LOGIN, this, {ugcCredentialsRequested: true});
                        ugcRequestedLogin = true;
                    }
                    return;
                }
                // if we have credentials but no subscriber ID, then try and obtain the ID first
                else if (!login.getSubscriberId() && !login.getSsoSubscriberId()) {
                    getSubscriberInfo();
                    return;
                }
                // we have credentials and a subscriber ID: but has the subscriber's UGC been loaded?
                else if (subscriberId.subscriberIdChanged(login.getSubscriberId()) && !login.getSsoSubscriberId()) {
                    functionQueue.queueSync();
                    return;
                }

                // only send one request at a time
                attemptingSync = true;
                // if the countdown is not running, either this has been triggered by the countdown or by a first-sync
                //  either way, we want to send a request regardless of the presence of changes to UGC
                var triggeredByTimeout = true;
                if (ugcTimeout.isRunning()) {
                    ugcTimeout.stopCountdown();
                    triggeredByTimeout = false;
                    // if the countdown is still running, this usually indicates a change in data
                }
                var data = serialiseSyncData(true);
                var hasUnsyncedData = ugcUtils.anyJsonHaveContent(
                        [data.ugc.bookmarks, data.ugc.pageHighlights, data.ugc.notes]);
                // in the rare event this has not come from an initial request, a timeout or a change in data, abort
                if (hasSyncedSuccessfully && !triggeredByTimeout && !hasUnsyncedData) {
                    finishSync();
                    return;
                }
                sendSyncAjax(data, handleSyncResponse, handleSyncError)
            };

            /**
             * Method to keep the serialised data for the sync separate from the decision mechanism
             * @returns {*} ; serialised data for the UGC request
             */
            var serialiseSyncData = function(withUgc) {
                var bookmarksData = withUgc ? unsyncedBookmarks() : {};
                var pageHighlightsData = withUgc ? unsyncedPageHighlights() : {};
                var notesData = withUgc ? unsyncedNotes() : {};
                var lastSyncedData = withUgc ? lastSynced : new Date().getTime();
                var credentials = login.getCurrentUserCredentials(true);
                if (!credentials.username) {
                    delete credentials.username;
                }

                if (!credentials.password) {
                    delete credentials.password;
                }

                if (!credentials.ssoSubscriberId) {
                    delete credentials.ssoSubscriberId;
                }

                return {
                    'requestedEditions': {
                        "bookId": resources.yuduBook.settings.id,
                        "lastSynced": lastSyncedData
                    },
                    'credentials': credentials,
                    'ugc': {
                        'bookmarks': bookmarksData,
                        'pageHighlights': pageHighlightsData,
                        'notes': notesData
                    }
                };
            };

            /**
             * Wrapper method to handle the actual AJAX request to the sync URL
             * @param data ; javascript hash to be serialised and sent as the request body
             * @param successCallback ; function to be called if the AJAX request successfully receives a response
             * @param errorCallback ; function to be called if not
             */
            var sendSyncAjax = function(data, successCallback, errorCallback) {
                $.ajax({
                    url: ugcSyncUrl,
                    type: 'POST',
                    dataType: "json",
                    contentType: "text/plain",
                    data: JSON.stringify(data),
                    success: events.callback(this, successCallback),
                    error: events.callback(this, errorCallback)
                });
            };

            /**
             * jQuery ajax callback to handle a successful ajax request - note that the sync request could still return
             *  an HTML error code if something went wrong with the sync itself
             * @param data
             * @param textStatus
             * @param jqXHR
             */
            var handleSyncResponse = function (data, textStatus, jqXHR) {
                // if there has been an error while syncing, handle the error
                // if we are missing any necessary data, act as if there has been an error
                if (jqXHR.status != 200 || !(data && data.authenticationResult && data.authenticationResult.userId &&
                        data.editions && data.editions[bookId] && data.editions[bookId].syncTime && data.ugc)) {
                    handleSyncError(jqXHR, textStatus, null);
                    return;
                }
                // look for a subscriber ID
                if (!subscriberId.needsChanging(data.authenticationResult.userId, data)) {
                    resolveSync(data);
                    finishSync();
                }
                // if it does need changing, then let the submodule trigger a delayed sync response after further processing
            };

            /**
             * Partial function to allow a delayed / asyncronous sync request to continue normally
             * @param data ; body from the sync request response
             */
            var delayedSyncResponse = function (data) {
                resolveSync(data);
                finishSync();
            };

            /**
             * The core of the sync response resolution, ensures UGC is updated according to the response
             * @param data ; body from the sync request response
             */
            var resolveSync = function (data) {
                // save the new last-synchronised time returned by the server
                lastSynced = data.editions[bookId].syncTime;
                storage.setItem(LAST_CONTENT_SYNC, lastSynced);
                // re-initialise the existing UGC data with that returned from the server
                //  merging behaviour is deferred to individual scripts
                if (data.ugc.bookmarks) {
                    ugcApi.bookmarksReinit(ugcUtils.prepareUgcFromSyncResponse(data.ugc.bookmarks, true), {});
                }
                if (data.ugc.notes) {
                    ugcApi.notesReinit(ugcUtils.prepareUgcFromSyncResponse(data.ugc.notes, false), {});
                }
                if (data.ugc.pageHighlights) {
                    ugcApi.highlightsReinit(ugcUtils.prepareUgcFromSyncResponse(data.ugc.pageHighlights, true), {});
                }
                hasSyncedSuccessfully = true;
            };

            /**
             * Finally-type method to tidy things up after a successful or aborted sync
             */
            var finishSync = function () {
                // indicate we are no longer attempting to sync
                attemptingSync = false;
                // if another event has been queued, start it
                if (functionQueue.hasNext()) {
                    functionQueue.next();
                } else {
                    // otherwise, queue a sync on a countdown to refresh content if we have already synced successfully
                    if (hasSyncedSuccessfully) {
                        ugcTimeout.startTimeout(syncUgc, constants.ugcSyncRefreshTimer);
                    }
                }
            };

            /**
             * Combined jQuery ajax callback for an unsuccessful ajax request and general error handler for any problems
             *  encountered during the UGC sync process
             * Ensures an interval is established to auto-retry connecting
             * Does not permit other sync requests while ticking over
             * @param jqXHR
             * @param textStatus
             * @param errorThrown
             */
            var handleSyncError = function (jqXHR, textStatus, errorThrown) {
                // only display an error message if this is the first failed request
                if (!previousRequestFailed) {
                    if (jqXHR.responseText && jqXHR.responseText.error && console && console.log) {
                        console.log('Remote server error message from UGC sync attempt:\n' + jqXHR.responseText.error);
                    }
                    messageBox.displayByCode('ugc.syncError');
                    previousRequestFailed = true;
                }
                // sync failed, try again later
                ugcTimeout.startTimeout(syncUgc, constants.ugcSyncRetryTimer);
            };

            var functionQueue = function() {
                var syncQueued = false;
                var syncQueuedFromSubscriberInfo = false;
                var subscriberInfoQueued = false;

                var queueSync = function() {
                    syncQueued = true;
                };

                var queueSyncFromSubscriberInfo = function() {
                    syncQueuedFromSubscriberInfo = true;
                };

                var queueSubscriberInfo = function() {
                    subscriberInfoQueued = true;
                };

                var next = function() {
                    setTimeout(doNext, 0);
                };

                var doNext = function() {
                    if (syncQueuedFromSubscriberInfo) {
                        attemptingSync = false;
                        setTimeout(syncUgc, 0);
                        syncQueuedFromSubscriberInfo = false;
                    } else if (subscriberInfoQueued) {
                        setTimeout(getSubscriberInfo, 0);
                        subscriberInfoQueued = false;
                    } else if (syncQueued) {
                        setTimeout(syncUgc, 0);
                        syncQueued = false;
                    }
                };

                var hasNext = function() {
                    return syncQueued || syncQueuedFromSubscriberInfo || subscriberInfoQueued;
                };

                return {
                    queueSync: queueSync,
                    queueSyncFromSubscriberInfo: queueSyncFromSubscriberInfo,
                    queueSubscriberInfo: queueSubscriberInfo,
                    hasNext: hasNext,
                    next: next
                }
            }();

            return {
                syncInit: syncInit,
                syncUgc: syncUgc,
                delayedSyncResponse: delayedSyncResponse,
                functionQueue: functionQueue
            }
        }();

        /**
         * Submodule to manage the multi-user problem, namely, what to do in the event that a second subscriber
         *  attempts to use the same browser on the same device
         * Has one interface method to handle the decision and start processing if necessary
         * Depends upon sync being initialised, but also will only be triggered by a sync response
         */
        var subscriberId = function() {
            var currentSubscriberId = false;
            var newSubscriberId = false;
            var responseData = false;
            var offlineBookmarks = {};
            var offlineNotes = {};
            var offlineHighlights = {};

            /**
             * Interface method to determine if the subscriber ID has changed and UGC needs to switch users
             * This method ensures that any sync in-progress is continued after this process
             * @param newSubId ; the subscriber ID to change to
             * @param data ; data from the sync response
             * @returns {boolean} ; does the subscriber need changing?
             */
            var handleSubscriberIdFromSync = function(newSubId, data) {
                responseData = data;
                var idHasChanged = handleSubscriberId(newSubId);
                if (!idHasChanged) {
                    responseData = false;
                }
                return idHasChanged;

            };

            /**
             * Interface method to determine if the subscriber ID has changed and UGC needs to switch users
             * @param newSubId ; the subscriber ID to change to
             * @returns {boolean} ; does the subscriber need changing:
             *  - yes (true) will trigger further processing asyncronously
             *  - no (false) expects the main thread to continue processing
             */
            var handleSubscriberId = function(newSubId) {
                if (currentSubscriberId == newSubId) {
                    // current subscriber receiving new sync data, nothing to change
                    return false;
                }
                // a new subscriber has logged in - may need to merge unclaimed data into their UGC
                newSubscriberId = newSubId;
                // check if there is any unclaimed data to merge
                checkMergeNecessity();
                return true;
            };

            /**
             * Given that the subscriber has changed, this decision method determines if the current dataset is
             *  associated with a subscriber, if not whether there is any data to merge, and if there is, prompts the
             *  user for what action to take
             * Further processing is triggered by callbacks tied to the dialog's buttons
             */
            var checkMergeNecessity = function() {
                var previousSubscriberId = currentSubscriberId;
                var previousSyncTimestampKey = LAST_CONTENT_SYNC;
                offlineBookmarks = retrieveBookmarks();
                offlineNotes = retrieveNotes();
                offlineHighlights = retrievePageHighlights();
                loadNewSubscribersData();
                if (!previousSubscriberId && previousSyncTimestampKey == LAST_CONTENT_SYNC_BASE &&
                        ugcUtils.anyJsonHaveContent([offlineBookmarks, offlineNotes, offlineHighlights])) {
                    var settings = {
                        leftLabel: localisation.get('ugc.syncMerge.discard'),
                        rightLabel: localisation.get('ugc.syncMerge.merge'),
                        leftCallback: events.callback(this, discardOfflineData),
                        rightCallback: events.callback(this, mergeOfflineData),
                        backgroundCallback: events.callback(this, finishMerge),
                        text: localisation.get('ugc.syncMerge.message')
                    };
                    messageBox.displayAdvancedTwoButtonPopup(settings);
                } else {
                    // switching subscribers or no unclaimed data found, no need to merge anything
                    finishMerge();
                }
            };

            /**
             * Callback method to handle merging unclaimed UGC data with any existing subscriber data
             */
            var mergeOfflineData = function() {
                if (ugcUtils.jsonHasContent(offlineBookmarks)) {
                    ugcApi.bookmarksReinit(offlineBookmarks, {});
                    offlineBookmarks = {};
                }
                if (ugcUtils.jsonHasContent(offlineNotes)) {
                    ugcApi.notesReinit(offlineNotes, {});
                    offlineNotes = {};
                }
                if (ugcUtils.jsonHasContent(offlineHighlights)) {
                    ugcApi.highlightsReinit(offlineHighlights, {merge: true});
                    offlineHighlights = {};
                }
                // data has been claimed by this subscriber: remove it from the unclaimed records
                discardOfflineData();
            };

            /**
             * Callback method to handle discarding unclaimed UGC data
             */
            var discardOfflineData = function() {
                storage.setItem((BOOKMARKS_CONTENT_BASE), JSON.stringify({}));
                storage.setItem((PAGE_HIGHLIGHTS_CONTENT_BASE), JSON.stringify({}));
                storage.setItem((NOTES_CONTENT_BASE), JSON.stringify({}));
                storage.setItem((LAST_CONTENT_SYNC_BASE), 0);
                finishMerge();
            };

            /**
             * Reload visible UGC using new subscriber's data to reinitialise
             */
            var loadNewSubscribersData = function() {
                addSuffixToBaseIds('-' + newSubscriberId);
                checkForIntroPageStateChange();
                var parameters = { reset: true };
                ugcApi.bookmarksReinit(retrieveBookmarks(), parameters);
                ugcApi.highlightsReinit(retrievePageHighlights(), parameters);
                ugcApi.notesReinit(retrieveNotes(), parameters);
            };

            /**
             * Finally-type method to be called when a new subscriber ID has been received
             */
            var finishMerge = function() {
                currentSubscriberId = newSubscriberId;
                login.setSubscriberId(newSubscriberId);
                if (responseData) {
                    ugcSync.delayedSyncResponse(responseData);
                    responseData = false;
                } else {
                    ugcSync.functionQueue.next();
                }
            };

            return {
                needsChanging: handleSubscriberIdFromSync,
                subscriberIdChanged: handleSubscriberId
            }
        }();

        return {
            init: init,
            syncInit: ugcSync.syncInit,
            initialSync: ugcSync.syncUgc,
            retrieveBookmarks: retrieveBookmarks,
            retrievePageHighlights: retrievePageHighlights,
            retrieveNotes: retrieveNotes
        };
    });

define('publicApi',['api', 'events'],
    function(api, events) {
        /*
         * Provides a public API for the reader available to on-page content
         * Note that JavaDoc-style comments should be included in public documentation for this class
         */
        var EMITTER_NAME = "publicApi";
        var EMPTY_DATA = {};

        /**
         * Registers a public API for the reader to the window's global variable `yudu_readerApi`
         * These functions can be accessed from on-page html content via the reference `window.parent.yudu_readerApi`
         * Note that if the edition has an intro page, it will be available as a "page 0",
         *  while all other pages are numbered from 1
         */
        var init = function() {
            listeners.init();
            window.yudu_readerApi = {
                getCredentials: getCredentials,
                nextPage: nextPage,
                previousPage: previousPage,
                goToPage: goToPage,
                triggerLightboxOnCurrentPage: triggerLightboxOnCurrentPage,
                triggerLightboxOnPage: triggerLightboxOnPage,
                closeLightbox: closeLightbox,
                getCurrentPageNumber: getCurrentPageNumber,
                getCurrentPageLabel: getCurrentPageLabel
            };
        };

        /**
         * Requests the credentials of the currently logged in user, if there is one.
         * Default response if no valid credentials are found is to return an empty object.
         * @returns Object that contains properties 'username' (likely be an email address) and 'password'
         */
        var getCredentials = function() {
            return state.subscriberCredentials;
        };

        /**
         * Requests the reader turn to the next page (or double page in two-page mode) if there is one to turn to
         */
        var nextPage = function() {
            emitEvent(events.GOTO_NEXT_PAGE, EMPTY_DATA);
        };

        /**
         * Requests the reader turn to the previous page (or double page in two-page mode) if there is one to turn to
         */
        var previousPage = function() {
            emitEvent(events.GOTO_PREVIOUS_PAGE, EMPTY_DATA);
        };

        /**
         * Requests the reader turn to the page number specified, starting from page 1
         * If the page given is not in the current range of pages, nothing will happen
         * @param pageNumber
         */
        var goToPage = function(pageNumber) {
            emitEvent(events.GOTO_PAGE, {pageNumber: pageNumber});
        };

        /**
         * Requests the reader open the lightbox associated with a lightbox overlay on the reader's current page
         * This will only work if there is exactly one lightbox overlay on the page
         * In two-page mode, this scans all currently visible pages starting with the left-hand page, triggering the
         *  lightbox of the first page with exactly one lightbox that it encounters. For precise control of which
         *  lightbox is opened, use `triggerLightboxOnPage`
         */
        var triggerLightboxOnCurrentPage = function() {
            var currentPages = api.getPagesInCurrentTray();
            for (var i = 0; i < currentPages.length; i++) {
                if (triggerLightbox(currentPages[i])) {
                    break;
                }
            }
            // TODO rtl: needs to be able to scan right to left
        };

        /**
         * Requests the reader open the lightbox associated with a lightbox overlay on the specified page
         * This will only work if there is exactly one lightbox overlay on the page
         * @param pageNumber
         */
        var triggerLightboxOnPage = function(pageNumber) {
            if (triggerLightbox(api.getPage(pageNumber))) {
                goToPage(pageNumber);
            }
        };

        /*
         * If there is exactly one lightbox on the specified page, it triggers the lightbox to show its content
         * @param page : PageController object for the page in question
         */
        var triggerLightbox = function(page) {
            if (page.encrypted) {return false;}
            var lOverlay = findSuitableLightboxOverlayOnPage(page);
            if (!!lOverlay) {
                lOverlay.showContent();
                return true;
            }
            return false;
        };

        /*
         * If there is exactly one lightbox on the specified page, returns the overlay, else returns false
         * @param page : PageController object for the page in question
         */
        var findSuitableLightboxOverlayOnPage = function(page) {
            if (page.overlayLevel && page.overlayLevel.launchableOverlays.length === 1) {
                return page.overlayLevel.launchableOverlays[0];
            } else {
                return false;
            }
        };

        /**
         * Closes the currently displaying lightbox
         */
        var closeLightbox = function() {
            emitEvent(events.CLOSE_LIGHTBOX, EMPTY_DATA);
        };

        /**
         * Returns the current page number
         */
        var getCurrentPageNumber = function() {
            return api.getCurrentPageNumber();
        };

        /**
         * Returns the current page label
         */
        var getCurrentPageLabel = function() {
            return api.getCurrentPageLabel();
        };

        /*
         * Helper function for emitting events from this module
         */
        var emitEvent = function(eventType, data) {
            events.emit(EMITTER_NAME, eventType, this, data);
        };

        /*
         * Helper submodule to track the state of variables known to the public API
         */
        var state = function() {
            var State = function() {
                this.subscriberCredentials = {};
            };

            return new State();
        }();

        /*
         * Helper submodule to listen for specific changes in the reader,
         *  without exposing the entire application
         */
        var listeners = function() {
            var init = function() {
                registerListeners();
                // now that the public api is listening, request a login details resend
                emitEvent(events.REQUEST_LOGIN_DETAILS, {});
            };

            /*
             * Callback for use during initialisation
             * Registers getters the public API may need
             */
            var registerListeners = function() {
                // login details retrieval is made async for added security
                events.subscribe(events.ALL, events.LOGIN_DETAILS_CHANGED, events.callback(this, newSubscriber), true);
                events.subscribe(events.ALL, events.CHANGE_FOR_LOGIN_DETAILS, events.callback(this, newSubscriber), true);
                events.subscribe(events.ALL, events.LOGIN_SUCCESS, events.callback(this, newSubscriber), true);
            };

            var newSubscriber = function(event) {
                var credentials = {};
                if (event && event.data && event.data.credentials) {
                    credentials = event.data.credentials;
                }
                state.subscriberCredentials = credentials;
                emitEvent(events.PUBLIC_API_LOGIN_STATE_CHANGED, credentials);
            };

            return {
                init: init
            }
        }();

        return {
            init: init
        };
    });

/**
 * Created by alg on 10/07/2017.
 * Responsible for handing the "PhoneView per-device defaults" settings,
 *  and redirecting to the article view if appropriate
*/
define('viewRedirect',['api', 'config', 'events', 'shared/utils/appUtils', 'shared/device', 'shared/utils/utils'],
function(api, config, events, appUtils, device, sharedUtils) {
    var HASH_REDIRECT_KEY = 'noRedirect';
    var QUERY_ORIGIN_KEY = 'origin';

    var views = {
        fixedLayout: 'fixedlayout',
        article: 'article'
    };

    var deviceKeys = {};
    deviceKeys[device.types.desktop] = 'deviceViewDesktop';
    deviceKeys[device.types.tablet] = 'deviceViewTablet';
    deviceKeys[device.types.phone] = 'deviceViewPhone';

    var ViewRedirect = function() {
        var preinit = function() {
            events.subscribe(events.ALL, events.QUERY_STRING_PARSED, hasQueryString, false);
        };

        var hasQueryString = function() {
            if (window.location.hash.indexOf(HASH_REDIRECT_KEY) < 0
                    && !wasInternalNavigation()
                    && !appUtils.deviceType.isAndroid()) {
                // only permit the redirect if this is not an Android app, and there was no previous internal navigation
                events.subscribe(events.ALL, events.YUDU_BOOK_LOADED, redirect, false);
            }
        };

        /**
         * Redirect to the article view if deemed appropriate
         * @param event {{}} data from the event
         */
        var redirect = function(event) {
            var settingKey = deviceKeys[device.classify()];
            var viewSetting = sharedUtils.getLeafOrUndefined(event.data, 'settings', 'phoneview', settingKey);
            if (viewSetting == views.article) {
                api.openArticleView();
            }
        };

        /**
         * Helper that encapsulates the check for whether the current page load was a result of an internal navigation
         * @returns {boolean}
         */
        var wasInternalNavigation = function() {
            return config.getFromQuery(QUERY_ORIGIN_KEY);
        };

        preinit();
    };

    return new ViewRedirect();
});

define('ui/dataCollection',['events', 'config', 'resources', 'interactions', 'utils/stats/yuduReporting', 'shared/storage', 'utils/tools',
    'jquery'],
    function(events, config, resources, interactions, yuduReporting, storage, tools,
             $) {

        var storageKeys = {};
        var dataCollectionUI = {
            "background": $("#yudu_dataCollectionBackground"),
            "prompt": $("#yudu_dataCollectionPrompt"),
            "greeting": $("#yudu_dataCollectionGreeting"),
            "explanation": $("#yudu_dataCollectionExplanation"),
            "infoLink": $("#yudu_dataCollectionInfoLink"),
            "emailInput": $("#yudu_dataCollectionEmail"),
            "validation": $("#yudu_dataCollectionValidation"),
            "form": $("#yudu_dataCollectionForm"),
            "dontShowAgain": $("#yudu_dataCollectionDontShowAgain"),
            "skip": $("#yudu_dataCollectionSkip"),
            "submit": $("#yudu_dataCollectionSubmit")
        };

        var tryDisplay = function() {
            initStorageKeys();
            if (!shouldDisplay()){
                return;
            }
            loadFromSettings();
            configureInteractions();
            show();
        };

        var initStorageKeys = function() {
            var bookId = resources.yuduBook.settings.id;
            storageKeys.DONT_SHOW_AGAIN = bookId + "-DONT_SHOW_AGAIN";
            storageKeys.EMAIL_COLLECTED = bookId + "-EMAIL_COLLECTED";
        };

        var shouldDisplay = function() {
            var isApp = tools.isThisAnApp();
            var dontShowAgain = storage.getItem(storageKeys.DONT_SHOW_AGAIN);
            var emailCollected = storage.getItem(storageKeys.EMAIL_COLLECTED);
            return !isApp && !dontShowAgain && !emailCollected;
        };

        var loadFromSettings = function() {
            var settings = resources.yuduBook.settings;
            dataCollectionUI.greeting.text(settings.dataCollectionGreeting);
            dataCollectionUI.explanation.text(settings.dataCollectionExplanation);
            dataCollectionUI.infoLink.prop("href", settings.dataCollectionInfoUrl);
        };

        var configureInteractions = function() {
            dataCollectionUI.form.submit(events.callback(this, function(event) {
                $("input").blur();
                event.stopPropagation();
                submit();
                return false;
            }));
            events.yuduOn(dataCollectionUI.skip, config.clickAction, events.callback(this, hide));
            events.yuduOn(dataCollectionUI.background, config.clickAction, events.callback(this, hide));
            events.yuduOn(dataCollectionUI.background, "touchmove", events.callback(this, function(event) {
                event.stopPropagation();
                return false;
            }));
        };

        var show = function() {
            interactions.setAllowKeyNavigation(false);
            events.subscribe(events.ALL, events.CLOSE_ACTIVE, hide);
            dataCollectionUI.background.show();
            dataCollectionUI.prompt.slideDown();
        };

        var hide = function() {
            events.unsubscribe(events.ALL, events.CLOSE_ACTIVE, hide);
            interactions.setAllowKeyNavigation(true);
            dataCollectionUI.background.hide();
            dataCollectionUI.prompt.hide();

            if (dataCollectionUI.dontShowAgain.prop("checked")) {
                dontShowAgain();
            }
        };

        var submit = function() {
            if (validateEmailAddress()){
                markEmailCollected();
                yuduReporting.email(dataCollectionUI.emailInput.val());
                hide();
            } else {
                dataCollectionUI.validation.show();
            }
        };

        var dontShowAgain = function() {
            storage.setItem(storageKeys.DONT_SHOW_AGAIN, true);
        };

        var markEmailCollected = function() {
            storage.setItem(storageKeys.EMAIL_COLLECTED, true);
        };

        var validateEmailAddress = function() {
            var email = dataCollectionUI.emailInput.val();
            // extremely basic email validation to match the flash reader
            var index = email.indexOf('@');
            return 0 <= index && index < email.lastIndexOf('.');
        };

        return {
            tryDisplay: tryDisplay
        };
    });
define('ui/gaTrackerConsent',['utils/statistics', 'shared/localisation', 'resources', 'jquery', 'shared/storage', 'shared/config', 'events'], function(statistics, localisation, resources, $, storage, config, events) {
    var banner = $('#yudu_gaTrackerConsent');
    var GA_CONSENT_PREFIX = "gaConsent-";
    var storageItemName = '';

    function hideBanner() {
        banner.removeClass('show');
    }

    function decline() {
        storage.setItem(storageItemName, false);
        hideBanner();
    }

    function accept() {
        storage.setItem(storageItemName, true);
        statistics.enableGoogleAnalytics();
        hideBanner();
    }

    function bindEvents() {
        events.subscribe(events.ALL, events.INIT_GA_CONSENT, events.callback(this, init), false);
    }

    function init() {
        storageItemName = GA_CONSENT_PREFIX + resources.yuduBook.settings.id;
        if (storage.getItem(storageItemName) == 'true') {
            statistics.enableGoogleAnalytics();
        }
        // Only initialise the banner if google analytics is enabled (there is a tracking ID set, or native android GA4 is enabled) for this edition and the user has not responded to the banner before
        if ((resources.yuduBook.settings.googleAnalyticsTrackerId || resources.yuduBook.settings.googleAnalyticsMeasurementId || (config.nativeAndroidGoogleAnalyticsEnabled && resources.yuduBook.settings.googleAnalyticsPrivacyPolicyUrl))
                && storage.getItem(storageItemName) == null) {
            banner.addClass('show');

            var messageText = resources.yuduBook.settings.googleAnalyticsConsentBannerText || localisation.get('gaTrackerConsent.message');
            var message = $('<div id="gaTrackerConsentMessage">' + messageText + '</div>');

            var url = resources.yuduBook.settings.googleAnalyticsPrivacyPolicyUrl;
            if (url) {
                var linkContainer = $('<div id="consentBannerPrivacyPolicyLink" />');
                var link = $('<a />', { "href": url, text: "Privacy Policy", target: "_blank" });
                linkContainer.append(link);
                message.append(linkContainer);
            }

            var buttonContainer = $('<div id="consentButtonContainer"></div>');
            var declineButton = $('<a id="consentButton" type="button">' + localisation.get('gaTrackerConsent.decline') + '</a>')
                .click(decline);
            var acceptButton = $('<a id="consentButton" type="button">' + localisation.get('gaTrackerConsent.accept') + '</a>')
                .click(accept);
    
            if (!config.isDesktop) {
                declineButton.addClass('touchControl');
                acceptButton.addClass('touchControl');
            }
    
            buttonContainer
                .append(declineButton)
                .append(acceptButton);
            banner
                .append(message)
                .append(buttonContainer);
        }
    }

    return {
        init: init,
        bindEvents, bindEvents
    }
});
define('ui/accessibleVersionLink',['api', 'jquery'],
    function(api, $) {
        var init = function() {
            $('#yudu_accessibleVersionLink').click(function () {
                api.openArticleView();
            });
        };

        return {
            init: init
        };
    });

define('ui/instantiation',['events', 'resources', 'ui/contents', 'ui/information', 'ui/login', 'shared/ui/messageBox', 'ui/rollover',
        'ui/sharing', 'ui/thumbnails', 'ui/toolbar', 'utils/userOptions', 'ui/loading', 'ui/search', 'ui/orderForm',
        'config', 'ui/uiTools', 'ui/drawingToolbars', 'utils/ugcApi', 'ui/highlightingCanvas', 'ui/notes',
        'ui/bookmarks', 'shared/commonFunctionsApi', 'brandableSubmodulesApi', 'ugc', 'publicApi', 'viewRedirect',
        'ui/dataCollection', 'ui/gaTrackerConsent', 'ui/downloadPdfTools', 'ui/accessibleVersionLink'],
    function(events, resources, contents, information, login, messageBox, rollover,
             sharing, thumbnails, toolbar, userOptions, loading, search, orderForm,
             config, uiTools, drawingToolbars, ugcApi, highlightingCanvas, notes,
             bookmarks, commonFunctionsApi, brandableSubmodulesApi, ugc, publicApi, viewRedirect,
             dataCollection, gaTrackerConsent, downloadPdfTools, accessibleVersionLink) {
        /**
         * Called before the reader is created and loaded.
         */
        var preLoad = function() {
            uiTools.setScrollbarWidth();
            information.init();
            login.init();
            sharing.bindEvents();
            accessibleVersionLink.init();
            gaTrackerConsent.bindEvents();
        };

        /**
         * Called after the reader has fully loaded but before the reader is started.
         * @param reader
         */
        var postLoad = function(reader) {
            var startPage = reader.getCurrentPage().getPageNumber();

            commonFunctionsApi.init();
            brandableSubmodulesApi.init();

            publicApi.init();

            loading.init(startPage, resources.yuduBook.pages.length);

            thumbnails.init(reader);

            var toc = new contents.Contents();
            toc.init(resources.yuduBook.contents);

            sharing.init();
            downloadPdfTools.init();

            toolbar.preInit();
            reader.updateReaderSize();
            toolbar.init();

            messageBox.init();

            // UGC initialisation is complex due to the interdependencies
            // the API should be initialised first, which will map methods from the various modules to one central, importable location
            ugcApi.init();
            ugc.init();
            if (config.bookmarksEnabled) {
                bookmarks.init(ugc.retrieveBookmarks());
                downloadPdfTools.initBookmarkedPageIndexes();
            }
            if (config.notesEnabled) {
                notes.init(ugc.retrieveNotes());
            }
            if (config.highlightsEnabled) {
                drawingToolbars.init();
                highlightingCanvas.init(ugc.retrievePageHighlights());
            }
            if (reader.isUgcEnabled()) {
                ugc.syncInit();
            }

            if (config.orderFormEnabled)
                orderForm.init();

            if ( (!userOptions.shouldShowInformationBox() || resources.yuduBook.settings.infoScreenDisabled)
                    && reader.isShowingEncryptedPage() ) {
                events.emit(events.ALL, events.SHOW_LOGIN, this, {});
            } else {
                ugc.initialSync();
            }

            if (config.emailCollectionEnabled && !reader.isShowingEncryptedPage()) {
                dataCollection.tryDisplay();
            }
        };


        return {
            preLoad: preLoad,
            postLoad: postLoad
        };

    }
);
define('main',['api', 'shared/localisation', "jquery", 'ui/instantiation', 'interactions', 'events', 'fetching/fetchHandler'],
    function(api, localisation, $, ui, interactions, events, fetchHandler) {
        //entry point for the program
        var init = function() {
            localisation.localiseHtml(document);

            ui.preLoad();

            //subscribe for the load completion of the reader, then finish init and start the reader!
            events.subscribe(events.ALL, events.READER_LOADED, readerLoadedCallback);

            fetchHandler.start();

            //create a new reader and load it
            api.createReader("yudu_reader");
        };

        var readerLoadedCallback = function(event) {
            var reader = event.target;

            ui.postLoad(reader);

            //create interactions layer
            interactions.init(reader);

            reader.start();
        };

        return {
            init: init
        };
    });

require.config({
    baseUrl: "src",
    map: {
        // '*' means all modules will get 'jquery-private'
        // for their 'jquery' dependency.
        '*': { 'jquery': 'jquery-private' },

        // 'jquery-private' wants the real jQuery module
        // though. If this line was not here, there would
        // be an unresolvable cyclic dependency.
        'jquery-private': { 'jquery': 'jquery' }
    },
    shim: {
        easel: {
            exports: 'createjs'
        },
        sound: {
            deps: ['easel'],
            exports: 'createjs.Sound'
        },
        tween: {
            deps: ['easel'],
            exports: 'createjs'
        },
        "jquery.mousewheel": ["jquery"],
        "jquery.hammer": ["jquery"],
        "fabric": ["jquery"],
        "crypto" : {
            exports: 'CryptoJS'
        },
        lzString: {
            exports: 'lzString'
        }
    },
    paths: {
        // changes to these imports should be copied to `readerBuild.js` (build) and `SpecRunner.js` (tests)
        "shared": "../shared",
        "environmentActive": "env-dev",
        "has": "../lib/has",
        "jquery": "../lib/jquery-3.4.1.min",
        "easel": "../lib/easeljs-0.7.1.min",
        "tween": "../lib/tweenjs-0.5.1.min",
        "sound": "../lib/soundjs-1.0.0.min",
        "hammer2": "../lib/hammer-2.0.8.noconflict",
        "jquery.hammer": "../lib/jquery.hammer.min",
        "jquery.mousewheel": "../lib/jquery.mousewheel",
        "fabric": "../lib/fabric.require.min",
        "bowser": "../lib/bowser.min",
        "crypto": "../lib/aes",
        "lzString": "../lib/lz-string.min"
    }
});

require(['jquery', 'easel', 'main', 'resources', 'constants', 'shared/localisation', 'shared/device', 'bowser',
        'shared/version', 'jquery.hammer', 'jquery.mousewheel'],
function($, createjs, main, resources, constants, localisation, device, bowser) {
    $(function() {
        // Make jquery (and hammer, and mousewheel) globally available
        window.$ = $;

        console = console || {log: function() {}};

        createjs.Alignment = {
            LEFT : 1,
            CENTRE : 2,
            RIGHT : 3
        };

        createjs.Container.prototype.resetPosition = function() {
            this.x = 0;
            this.y = 0;
        };

        device.setupLibraries(bowser);
        device.startDeviceDetectionAsyncChecks();
        localisation.loadResources(constants.customStringsPackURL, main.init);
    });
});

define("../app", function(){});

